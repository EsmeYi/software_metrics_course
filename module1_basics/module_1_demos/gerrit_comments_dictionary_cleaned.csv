line,class_value
"        apply_button_->setToolTip(tr(""Apply display filter""))_",1
"		proto_item_append_text(tree, "": %p"", (void *) tvb_get_guint64(tvb, offset, info->encoding))_",0
#define NEW_PROTO_TREE_API,0
 * Editor modelines  -  http://www.wireshark.org/tools/modelines.html,1
    offset += 4_,1
,1
            DISSECTOR_ASSERT(pos+chunk_size <= length)_,1
 * http://kafka.apache.org/protocol.html,1
"    { 3, ""Substract"" },",1
"            (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset+len, val), val)_",0
"            chunk_size = tvb_get_ntohl(tvb, offset+pos)_",0
"        length = (guint32)tvb_get_ntohl(tvb, offset)_",1
    if (api_version >= 7) {,0
    if (api_version >= 4 ) {,1
    if (api_version >= 2 ) {,1
    return result_,1
    LZ4F_decompressionContext_t lz4_ctxt_,1
"    col_append_fstr(pinfo->cinfo, COL_INFO, "" [zstd decompression failed]"")_",0
 * http://kafka.apache.org/0100/documentation/#messageformat,1
        proto_item_set_hidden(ti)_,0
"                NULL, HFILL }",0
    // null array ,0
    } ,1
"    { 82, ""Fenced Instance ID""},",1
"            { ""SASL Authentication Bytes"", ""kafka.header_value"",",0
"            { ""Default"", ""kafka.config_defualt"",",1
        ,1
    ,1
"        tvb_get_string_enc(wmem_packet_scope(), tvb, offset+len, val, ENC_UTF_8|ENC_NA))_",1
    if (p_string_length!=NULL) {,1
"    // proto_item_set_len(message_ti, offset - start_offset)_",0
    DISSECTOR_ASSERT(count>=-1)_,0
"decompress_lz4(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, int length, tvbuff_t **decompressed_tvb, int *decompressed_offset)",1
    LZ4F_freeDecompressionContext(lz4_ctxt)_,1
"                    wmem_free(pinfo->pool, decompressed_buffer)_",0
    if (api_version>=7) {,1
"                                    &global_kafka_tls_range, 65535)_",1
#if 0,1
    else if(2 == doi) {,1
      /* add GDOi specific changes here*/,0
	  /* GDOI */,0
      else  /* TODO: conflict with GAP payload PLOAD_IKE_SEQ already mapped to same variable*/,0
  if(PLOAD_IKE_SAT == next_payload),0
  proto_item            *idit_,0
  proto_tree            *idtree_,0
	    /* Error here*/,0
"      { ""Next Payload"", ""isakmp.sak.Nextpayload"",",0
"					proto_item_append_text(ti, "" on interface id: %u, name: %s"",",0
"              FT_BOOLEAN, 32, NULL, (0xFFE00000u), ""Must be zero"", HFILL }},",0
                if ((pinfo->num > req_frame_num) && (req_function_code == function_code) && ,0
This menu item stops the currently running capture and starts again with,1
More detail on this subject is provided in <<ChWorkDefineFilterSection>>,0
|menu:Apply as Column[]             ||,1
See the wiki page on link:{wireshark-wiki-url}SSL[SSL] for instructions,1
Open a dialog showing expert information in the capture.,0
"Displays a dialog box that allows you to create and edit display filters. You can name filters, and you can save them for future use. See <<ChWorkDefineFilterSection>>.",1
    void* buf_,1
#ifdef HAVE_ZLIB,0
"	slice_t* data_to_save = (slice_t *)wmem_alloc0(wmem_file_scope(), sizeof(slice_t))_",0
"	//		... and going to port 4984 for message type = MSG occurred in wireshark packet #12""",0
	// Adapted from sample code in https://raw.githubusercontent.com/wireshark/wireshark/master/doc/README.dissector,0
 * Editor modelines  -	http://www.wireshark.org/tools/modelines.html,0
"        dissect_dsmcc_un_session_nsap(tvb, offset, pinfo, sub_sub_tree)_",1
"        proto_tree_add_item(sub_tree, hf_dsmcc_adaptation_type, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
. btn:[Enable All]: Enable all protocols in the list.,0
"static void forge_and_dissect_socketcan(tvbuff_t *tvb, packet_info *pinfo,",0
            datalen -= processed_bytes_,0
"        if (dissector_try_payload_new(avb1722_acf_dissector_table, next_tvb, pinfo, tree_can, TRUE, &can_id) <= 0) {",0
"$Win32CurrentTag = ""2019-08-14""",0
    timeinfo = localtime(&rawtime)_,1
#define USBLL_ADDRESS_HOST_TO_DEV 0,0
        dst_addr->flags = USBLL_ADDRESS_HOST_,0
            /* SPLIT transactions are directed to the device without any particular endpoint */,1
#define USBLL_POISON 0xFE,1
"static int usbll_addr_to_str(const address* addr, gchar *buf, int buf_len _U_)",1
    pinfo->ptype = PT_NONE_,0
"    copy_address_shallow(&pinfo->dst, &pinfo->net_dst)_",0
	if (id_is_query) {,0
"		return dissect_obdii_query(tvb, &oinfo, obdii_tree)_",0
"        return g_strlcpy(buf, ""Broadcast"", buf_len) + 1_",0
        return 10_,0
    *buf = '\0'_ /* NULL terminate */,0
    return 11_,0
    return 2_,0
    if (isReply(op_code) || LSC_DONE),1
    const char **in_filenames = (const char **)g_malloc(sizeof(const char*) * local_files.size())_,1
	*filenamep = g_strdup(tmpname)_,0
"    proto_tree_add_item(sub_tree, hf_dsmcc_un_sess_rsrc_value_type, tvb, offset, 2, ENC_NA)_",0
"#define OTRXC_UDP_PORTS ""5701,5703,5800,5801,5803""",0
"	col_add_fstr(pinfo->cinfo, COL_INFO, ""Rx TS=%u, FN=%u, RSSI=%u, ToA=%d"", ts, fn, rssi, toa)_",0
"						""OsmoTRX Tx Burst (TS=%d, FN=%u, RSSI=%u, ToA=%d)"",",0
"		proto_tree_add_item(otrxb_tree, hf_otrxb_rssi, tvb, offset, 1, ENC_NA)_",0
"		proto_tree_add_item(otrxb_tree, hf_otrxb_soft_symbols, tvb, offset, 148, ENC_NA)_",0
/* Burst data in Transmit direction */,0
/* packet-osmo_trx_burst.c,1
 * This program is free software_ you can redistribute it and/or,1
"	proto_otrx_c = proto_register_protocol(""Osmocom TRX Control Protocol"", ""otrx_c"", ""otrx_c"")_",0
"	col_set_str(pinfo->cinfo, COL_INFO, (const gchar *) msg_str)_",0
"	dissector_add_uint_range_with_preference(""udp.port"", OTRXC_UDP_PORTS, otrxc_handle)_",0
"        &hf_usbll_crc5,",0
"dissect_usbll_split(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_, gint offset)",0
<<ChDisplayFilterMacrosSection>>,1
This file contains all the display filter macros that you have defined and saved.,1
static gboolean check_file_exists(const char * filename){,0
"    QList<int> rows = const_cast<ProfileModel *>(this)->findAllByNameAndVisibility(set_profile_, false, true)_",0
    if ((tokens[THREAD_URI_NAMESPACE_IDX] != NULL) && (tokens[THREAD_URI_COMMAND_IDX] != NULL)) {,0
#define THREAD_URI_COMMAND_IDX 2,1
"	DISSECTOR_ASSERT_HINT(element->data != NULL, ""Unable to allocate memory."")_",1
			DISSECTOR_ASSERT(pdata != NULL)_,1
				DISSECTOR_ASSERT(conv_data != NULL)_,1
} f5tls_keylog_format_t_,0
 *  As we come across the initial crypto data store it in a struct on the coversation.,1
 * @param ptr     Pointer to byte array that will be examined,1
	DISSECTOR_ASSERT_NOT_REACHED()_,1
	f5tls_packet_data_t *pdata = ((f5tls_data_t *)data)->pkt_,1
					if ((crnd_changed && conv_data->exporter_sec.len != 0)) {,0
				if (secret_len > 0) {,0
	/* Combine 2 byte TYPE with 2 btye VERSION into guint32 for the subdissector table lookup */,1
"					chs = tvb_get_ptr(tvb, o, secret_len)_",0
"        ui->checkSaveOnStart->setText(tr(""Save parameters on capture start""))_",0
"echo ""libnl is unavailable"" >&2",1
WS_DLL_PUBLIC GHashTable * allowed_profile_filenames(void)_,1
        if sys.byteorder == 'big':,0
			if (secret_len <= F5TLS_HASH_LEN) {,1
					o += F5TLS_HASH_LEN_,1
"	return(dissector_try_uint_new(tls_subdissector_table, pattern, tvb, pinfo, tree, FALSE, NULL))_",1
  image: debian:stable,0
    - apt-get update -qq,1
    - dpkg-buildpackage -b --no-sign -Jauto > /dev/null 2>&1 || dpkg-buildpackage -b --no-sign --no-pre-clean,1
"	lsb-release""",0
# https://about.gitlab.com/2016/10/12/automated-debian-package-build-with-gitlab-ci/,0
build-debian-deb:,0
    - apt-get install -y lsb-release libbrotli-dev,0
    - dpkg-buildpackage -b --no-sign -J$(nproc) > /dev/null 2>&1 || dpkg-buildpackage -b --no-sign -J$(nproc) --no-pre-clean ,0
"    g_printerr(""Temp dir for unzip: %s\n"", dir.path().toUtf8().constData())_",0
        ctx_menu_.addSeparator()_,1
            if ( ( parent && parent->status == PROF_STAT_NEW ) || ( ! parent && prof->status == PROF_STAT_NEW ) ),0
            else,1
    /* Changing this order requires changing filterTypes() as well! */,1
		DATA_INDEX_VALUE_IS_URL,1
"        pd_ui_->hintLabel->setText(tr(""%Ln profile(s) selected"", """", list.count()))_",0
		model_->disconnect()_,1
    if ( message.isEmpty() && ( name.startsWith('.') || name.endsWith('.') ) ),1
"        /* what to do, if only a single profile is selected and it is either global or default */",1
"        msg = """"_",1
        if ( index.data(ProfileModel::DATA_IS_DEFAULT).toBool() ),1
        {,1
"            msg = tr(""The default profile cannot be exported."")_",1
            enable_export = false_,1
        },1
        else if ( index.data(ProfileModel::DATA_IS_GLOBAL).toBool() ),1
"            msg = tr(""A global profile cannot be exported."")_",1
        export_selected_entry_->setToolTip(msg)_,1
        if ( skipped > 0 ),0
    if (wsApp && dir.length() > 0) wsApp->setLastOpenDir(dir.toUtf8().constData())_,1
"        if (! g_file_test(libname, G_FILE_TEST_EXISTS)) {",1
"            err = g_string_new(""Error loading PKCS #11 libraries:"")_",1
                /* TODO: should also affect LCID/SRB-3 ? */,1
      <string>Save parameters on capture start</string>,0
tar xaf wireshark-2.9.0.tar.xz,0
apt install wireshark,0
----,0
 defined in USB 2.0 Specificaiton. This function calculates the CRC,0
#endif /* crc5.h */,0
 crc5_usb_11bit_input@Base 3.1.0,0
"        } while (g_file_test(save_as_fullpath.toUtf8().constData(), G_FILE_TEST_EXISTS) && ++count < 1000)_",1
"            msg = tr(""One profile has been imported"")_",0
    packets = 0_,0
    QString path = gchar_free_to_qstring(isGlobal() ? get_global_profiles_dir() : get_profiles_dir())_,1
class Profile,1
"    Profile(QString name, bool isGlobal = false, bool isDefault = false) : name_(name), isGlobal_(isGlobal), isDefault_(isDefault) {}",0
"Q_LOGGING_CATEGORY(modelProfiles, ""wireshark.model.profiles"")_",0
#include <QDebug>,1
        return false_,0
"    qWarning() << ""Das ist ein Test""_",1
Q_DECLARE_LOGGING_CATEGORY(modelProfiles)_,0
#include <config.h>,0
#include <glib.h>,1
"            msg.append(tr("", %n profile(s) skipped"", """", skipped))_",0
        addSeparator()_,0
QAction * CopyFromProfileMenu::systemDefault(QString filename),1
    addActions(global)_,0
    if (global.count() > 0),0
  tag_len -= 4_,0
"     {""Load (pps)"", ""wlan.tag.symbol_proprietary.extreme.load_pps"",",0
"          tap_credential_t* auth = wmem_new0(wmem_packet_scope(), tap_credential_t)_",0
          if (!session_state->),0
"            session_state->username = wmem_strdup(wmem_packet_scope(), decrypt)_",0
"            decrypt = tvb_get_string_enc(wmem_file_scope(), tvb, loffset, linelen, ENC_ASCII)_",0
          session_state->username = decrypt_,0
            session_state->username = decrypt_,0
"          tap_credential_t* auth = wmem_new0(wmem_file_scope(), tap_credential_t)_",0
"          auth->info = wmem_strdup_printf(wmem_file_scope(), ""Username in packet %u"", auth->username_num)_",0
"        data_val->username = tvb_get_string_enc(wmem_file_scope(), tvb, offset, linelen, ENC_NA|ENC_ASCII)__",0
"          data_val->username = tvb_get_string_enc(wmem_file_scope(), tvb, offset, linelen, ENC_NA|ENC_ASCII)__",1
"            guint8* password = tvb_get_string_enc(wmem_file_scope(), tvb, password_offset + 1, password_tokenlen - 2, ENC_ASCII | ENC_NA)_",1
	libminizip-devel \,0
#endif,1
        minizip-dev \,0
        libminizip-dev \,0
        libminizip-devel \,0
"static const true_false_string tfs_exclude_include = { ""Exclude"", ""Include"" }_",0
	struct hf_tree tree = {0}_,0
 * executions.,0
"					if (wmem_array_try_index(obuf, out_start+out_off-match_off, &byte))",0
import re,1
"                         bytes.fromhex(re.sub('[^0-9A-Fa-f]','', proc.stdout_str)))",1
 *,1
 * Copyright (C) 2019  Aurélien Aptel,1
"		out = GUINT16_FROM_LE(*(const guint16*)BUF_POS(buf, ofs))_ \",1
					guint64 value = 0_,0
					if ((i*8) < length) {,0
					if (i < length) {,1
"					proto_tree_add_bitmask_list_value(tree, out_tvb, offset + MIN(i, length - 1), 1, section_named_bits, value)_",1
"dissect_zbee_zcl_elec_mes(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree , void* data)",0
    *err_info = NULL_,0
                if (p_ftp_conv && !p_ftp_conv->username && !p_ftp_conv->username_pkt_num) {,0
                if (p_ftp_conv) {,0
"			auth = wmem_new0(wmem_file_scope(), tap_credential_t)_",0
"	tap_credential_t* auth = wmem_new0(wmem_file_scope(), tap_credential_t)_",0
"    clone->info = auth->info = wmem_strdup(NULL, auth->info)_",0
"                    wmem_free(wmem_file_scope(), p_ftp_conv->username)_",0
    clone->username = g_strdup(auth->username)_,0
        g_free(*itr)_,0
        break_,1
"            connect(this, SIGNAL(bgColorizationProgress(int, int)),",1
"    { NCSI_TYPE_GLS,	""Get link status"" },",1
"			tap_queue_packet(credentials_tap, pinfo, auth)_",0
"	aad = tvb_get_ptr(tvb, offset_aad, aad_size)_",1
"		if ((err = gcry_cipher_ctl(cipher_hd, GCRYCTL_SET_CCM_LENGTHS, lengths, sizeof(lengths)))) {",1
"	data = (guint8 *)tvb_memdup(pinfo->pool, tvb, offset, sti->size)_",0
"		wmem_free(pinfo->pool, data)_",1
"			NULL, SMB2_CIPHER_AES_128_CCM, NULL, HFILL }",0
  ascendlex_destroy(&scanner)_,0
        return 0_,1
"dissect_omron_fins_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {",1
"        tvbuff_t *slice = tvb_new_subset_remaining(tvb, fins_pdu_offset)_",0
"        if (tvb_get_guint32(tvb, 0, ENC_BIG_ENDIAN) != OMRON_FINS_TCP_MAGIC_BYTES) {",1
    int margin = 2 * 6 + 1_,0
"    QVariant hf_id = idx.sibling(idx.row(), CredentialsModel::ColumnHFID).data(CredentialsModel::ColumnHFID)_",0
"    QVariant hf_id = idx.sibling(idx.row(), CredentialsModel::ColumnHFID).data(Qt::UserRole)_",0
        hf_id = qVariantFromValue(-1)_,0
    if ( ! hf_id.canConvert(QVariant::Int) ),0
                if ( auth->num != auth->username_num && auth->username_num > 0 ),0
        else if ( index.column() == COL_USERNAME && auth->username_num > 0 ),0
	if (idx.column() != 0),0
		return_,0
	qint32 packet_num = idx.data().toInt()_,0
	if (packet_num > 0) {,0
        packet_list_->goToPacket(packet_num)_,0
    if (role == Qt::DisplayRole) {,1
    if (role != Qt::DisplayRole),1
    ui->auths->setSortingEnabled(true)_,0
"column_prefs_add_custom_with_position(gint fmt, const gchar *title, const gchar *custom_fields, gint custom_occurrence, gint16 position)",0
    if (position < 0),0
                                      gint16 position)_,0
"            msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, smpp_sms_decode)_",0
"        msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ISO_8859_1)_",0
"    prefs_register_enum_preference(smpp_module, ""decode_sms_over_smpp"",",0
"                         ""Decode SMS when DCS is 0 (zero)"",",0
"        msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, smpp_sms_decode)_",0
"        dest = (unsigned char*)wmem_alloc(wmem_packet_scope(), length+1)_",0
"        msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_NA)_",0
"        msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ASCII)_",0
"                FT_STRING, BASE_NONE, NULL, 0x00,",0
"            {   ""Message bytes"", ""smpp.message_bytes"",",0
"void smpp_handle_dcs(proto_tree *tree, tvbuff_t *tvb, int *offset, guint32 *dataCoding)_",0
    case 0:,0
"    dataCoding = tvb_get_guint8(tvb, offset-1)_",0
"            {   ""Message"", ""smpp.message"",",0
"        { ""none"",        ""None"",       -1 },",0
 * -1 = DO_NOT_DECODE,0
 * 3  = DECODE_AS_ISO-8859-1,0
"        msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, smpp_decode_dcs_0_sms)_",0
"        { ""iso-8859-1"",  ""ISO-8859-1"",  3 },",0
"        msg = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_UCS_2|ENC_NA)_",0
      } else {,0
    lenE = (octet & 0x3) + 1_,0
      DISSECTOR_ASSERT_NOT_REACHED()_,1
"	<avp name=""PS-Previous-Information"" code=""1140"" mandatory=""must"" may-encrypt=""no"" protected=""mustnot"" vendor-bit=""must"" vendor-id=""TGPP"">",0
          offset +=4_,1
#define DIAM_APPID_3GPP_STA     16777250,0
"dissect_diameter_3gpp_mip6_feature_vector(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)",0
"int dissect_diameter_3gpp_mip6_feature_vector(tvbuff_t*, packet_info*, proto_tree*, void*)_",0
            return offset_,1
"                    tvb_composite_append(reassembled_tvb, tvb_new_subset_length(tvb, 0, offset))_",0
"                guint8 *setup_data = (guint8 *)wmem_tree_lookup32(usbpcap_setup_data, pinfo->num-1)_",0
"                    add_new_data_source(pinfo, reassembled_tvb, ""USBPcap reassembled setup"")_",0
        if ((bm_request_type & 0x80) == 0 && usb_conv_info->is_setup &&,0
                    //pinfo->srcport = NO_ENDPOINT_,0
"  nrppa_handle = find_dissector_add_dependency(""lppa"", proto_ngap)_",0
            key[2].key = &k_frame_number_,1
"                request_data = (request_data_t *)wmem_tree_lookup32_le(wmem_tree, pinfo->num)_",0
            info->direction = 1_,0
            inf.assoc_index = info->assoc_index_,0
            inf.direction = 2_,0
static int hf_babel_message_index = 0_,0
static char *subtype_to_str(int type),0
        if (subtype == MESSAGE_SUB_PADN){,0
"        proto_tree_add_debug_text(filter_rule_tree, ""-----------Display Filter Rule(s) in V3 Struct  Format------------"")_",0
"            &aeroscout_header,",0
/* Start the FUNCTION2s we need for the plugin stuff */,0
			offset += 4_,0
	switch (temp),0
	if ((opCode_action & 0xf000) == 0x0000),0
"    { &ei_ngap_number_pages_le15, { ""ngap.number_pages_le15"", PI_MALFORMED, PI_ERROR, ""Number of pages should be <=15"", EXPFILL }}",0
"    dissector_add_string(""ngap.n2.sm"", ""PduSessionResourceReleaseCommandTransfer"", create_dissector_handle(dissect_PDUSessionResourceReleaseCommandTransfer_PDU, proto_ngap))_",0
﻿/* packet_list.cpp,0
    qSort(selectedRows)_,0
 *   https://www.cablelabs.com/specs,0
"  dh = dissector_get_uint_handle(cl3_command_table, subprotocol_id)_",0
"    ssid_len = tvb_get_guint8(tvb, offset + 6)_ /* +6 = skip over mac address */",0
  if (cl3_tree) {,0
  if (tree) {,0
"    proto_tree_add_uint(cl3_tree, _hf_cl3_version,    tvb, 0, 1, version)_",0
"                                ""CL3 Payload (%u byte%s)"", payload_length,",0
static int           _hf_cl3dcw_type             = -1_,0
"  proto_tree_add_uint(tree, _hf_cl3dcw_datamacaddrcount, tvb, 0, 1, data_macaddr_count)_",0
  gint    bytes_consumed_,0
"    bond_item = proto_tree_add_string_format(tree, _hf_cl3dcw_dcbond, tvb, bytes_consumed, 6 + 1 + ssid_len,",0
#define CL3TYPE_DCW 0x00DC,0
"	proto_tree_add_item_ret_uint(batadv_iv_ogm_tree, hf_batadv_iv_ogm_seqno,",1
"	proto_tree_add_item(batadv_iv_ogm_tree, hf_batadv_iv_ogm_seqno, tvb,",1
"            proto_tree_add_item(main_tree, hf_setup_brequest, tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"            if (tvb_captured_length_remaining(tvb, offset) > 0)",0
"                proto_tree_add_expert(main_tree, pinfo, &ei_undecoded, tvb, offset, -1)_",0
"        bytes = tvb_captured_length_remaining(tvb, offset)_",0
"    usb_conv_info->deviceVersion = tvb_get_letohs(tvb, offset)_",1
	if (tree) {,0
"                ""iso7816.subdissector"",",1
            s = eval(input ('Query: ')),1
"	<application id=""16777257""	name=""Telefonica OCS Account Management application"" uri=""none""/>",0
 * Radiotap (type 6):,0
"            proto_tree_add_item(sub_tree, hf_btmesh_model_layer_parameters, tvb, offset, -1, ENC_NA)_",1
"            FT_UINT16, BASE_DEC, VALS(btmesh_model_vals), 0x0,",1
"/*        { &hf_btmesh_config_composition_data_status_data,",1
    static const int * pfcp_out_hdr_removal_flags[] = {,0
"        &hf_pfcp_gtpu_ext_hdr_del,",0
        NULL,0
    /* Octet 7 to (n+4) Application Identifier,0
    * The Application Identifier shall be encoded as an OctetString (see 3GPP TS 29.212),0
static const true_false_string pfcp_sess_cont_ext_hdr_to_del_tfs = {,0
"    ""PDU Session Container to be deleted"",",0
"    ""PDU Session Container not to be deleted""",0
                    padding = (4 - (psts % 4)) % 4_,0
"http_reset_hash_responses(gchar *key _U_, http_response_code_t *data, gpointer ptr _U_ )",0
"http_reset_hash_requests(gchar *key _U_, http_request_methode_t *data, gpointer ptr _U_ )",0
"    { 0x7801, ""zlib"" },",1
    return ((header >> 8) == 0x78) && ((header % 31) == 0)_,0
        if (captured_length < min_len),1
"            number = tvb_get_guint8(tvb, 10)_",1
"        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""GELF"")_",1
"        proto_tree_add_boolean(gelf_tree, hf_gelf_pdu_chunked, tvb, 0, 2, TRUE)_",1
                    return 0_,1
" * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.",1
    int len_,1
            goto handle_compressed_,0
"                col_set_str(pinfo->cinfo, COL_PROTOCOL, ""GELF"")_",0
"    proto_item *ti = proto_tree_add_item(tree, proto_gelf, tvb, 0, -1, ENC_NA)_",0
"    header = tvb_get_ntohs(tvb, 0)_",1
"    if (dissect_gelf_udp(tvb, pinfo, tree, data) > 0) {",0
"        { &hf_gelf_pdu_chunked,",0
"                ""Chunked messeage"", ""gelf.chunked"", FT_BOOLEAN,",1
                       HEURISTIC_ENABLE)_,1
/* packet-gelf.c,0
 * Routines for Graylog Extended Log Format (GELF) dissection,0
" * (c) Copyright 2019, Slava Bacherikov <slava@bacher09.org>",0
 * Wireshark - Network traffic analyzer,1
 * By Gerald Combs <gerald@wireshark.org>,1
 * Copyright 1998 Gerald Combs,1
 * modify it under the terms of the GNU General Public License,1
 * as published by the Free Software Foundation_ either version 2,1
" * of the License, or (at your option) any later version.",1
" * This program is distributed in the hope that it will be useful,",1
 * but WITHOUT ANY WARRANTY_ without even the implied warranty of,1
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the,1
 * GNU General Public License for more details.,1
 * You should have received a copy of the GNU General Public License,1
" * along with this program_ if not, write to the Free Software",1
 */,1
"#include ""config.h""",1
#include <epan/packet.h>,1
#include <epan/to_str.h>,1
#include <epan/reassemble.h>,0
#define HEADER_GZIP 0x1f8b,0
#define HEADER_ZLIB 0x789c,0
#define HEADER_CHUNKED 0x1e0f,0
// not sure if this really used,0
// seen this here: https://github.com/lusis/gelfd/blob/229cf5f1f913a35db648b195300d1aaae841d522/lib/gelfd.rb#L7,0
#define HEADER_UNCOMPRESSED 0x1f3c,0
"#define HEADER_UNCOMPRESSED_PLAIN 0x7b22 // {"", json payload without real header",0
// make 32 bit message id from 64 bit message id,0
#define BUILD_MESSAGE_ID(X) ((X[3] << 3 | X[2] << 2 | X[1] << 1 | X[0]) ^ \,0
                            (X[4] << 3 | X[5] << 2 | X[6] << 1 | X[7])),0
static dissector_handle_t json_handle_,0
static int proto_gelf = -1_,0
static dissector_handle_t gelf_udp_handle_,0
static gint ett_gelf = -1_,0
static gint hf_gelf_pdu_type = -1_,0
static gint hf_gelf_pdu_message_id = -1_,0
static gint hf_gelf_pdu_chunk_number = -1_,0
static gint hf_gelf_pdu_chunk_count = -1_,0
static gint hf_gelf_pdu_chunked = -1_,0
static const value_string gelf_udp_types[] = {,0
"    { HEADER_GZIP, ""gzip"" },",0
"    { HEADER_ZLIB, ""zlib"" },",0
"    { HEADER_CHUNKED, ""chunked"" },",0
"    { HEADER_UNCOMPRESSED, ""uncompressed"" },",0
"    { HEADER_UNCOMPRESSED_PLAIN, ""uncompressed plain json"" },",0
"    { 0, NULL }",1
}_,1
static reassembly_table gelf_udp_reassembly_table_,0
static gint ett_gelf_fragment = -1_,0
static gint ett_gelf_fragments = -1_,0
static int hf_gelf_fragments = -1_,0
static int hf_gelf_fragment = -1_,0
static int hf_gelf_fragment_overlap = -1_,0
static int hf_gelf_fragment_overlap_conflict = -1_,0
static int hf_gelf_fragment_multiple_tails = -1_,0
static int hf_gelf_fragment_too_long_fragment = -1_,0
static int hf_gelf_fragment_error = -1_,0
static int hf_gelf_fragment_count = -1_,0
static int hf_gelf_reassembled_in = -1_,0
static int hf_gelf_reassembled_length = -1_,0
static const fragment_items gelf_fragment_items = {,0
"    &ett_gelf_fragment,",0
"    &ett_gelf_fragments,",0
"    &hf_gelf_fragments,",0
"    &hf_gelf_fragment,",0
"    &hf_gelf_fragment_overlap,",0
"    &hf_gelf_fragment_overlap_conflict,",0
"    &hf_gelf_fragment_multiple_tails,",0
"    &hf_gelf_fragment_too_long_fragment,",0
"    &hf_gelf_fragment_error,",0
"    &hf_gelf_fragment_count,",0
"    &hf_gelf_reassembled_in,",0
"    &hf_gelf_reassembled_length,",0
"    NULL,",0
"    ""GELF fragments""",0
static int,1
"dissect_gelf_simple_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",0
"                        void *data _U_, guint16 header, gboolean set_name)",0
{,1
    tvbuff_t *next_tvb_,0
    char *packet_name_,0
    switch (header) {,0
        case HEADER_ZLIB:,0
"            packet_name = ""ZLIB""_",0
        case HEADER_GZIP:,0
"            packet_name = ""GZIP""_",0
        handle_compressed:,0
            if (set_name) {,0
"                col_set_str(pinfo->cinfo, COL_INFO, packet_name)_",0
            },1
            len = tvb_captured_length(tvb)_,0
"            next_tvb = tvb_uncompress(tvb, 0, len)_",0
            if (next_tvb) {,0
"                add_new_data_source(pinfo, next_tvb, ""compressed data"")_",0
"                call_dissector(json_handle, next_tvb, pinfo, tree)_",0
            return len_,0
        case HEADER_UNCOMPRESSED:,0
"                col_set_str(pinfo->cinfo, COL_INFO, ""uncompressed"")_",0
"            next_tvb = tvb_new_subset_remaining(tvb, 2)_",0
            return tvb_captured_length(tvb)_,0
        case HEADER_UNCOMPRESSED_PLAIN:,0
"            if (call_dissector(json_handle, tvb, pinfo, tree) == 0) {",0
                return 0_,0
            } else {,1
                if (set_name) {,0
"                    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""GELF"")_",0
"                    col_set_str(pinfo->cinfo, COL_INFO, ""uncompressed plain json"")_",0
                },1
                return tvb_captured_length(tvb)_,0
        default:,1
            return 0_,0
    },1
    return tvb_captured_length(tvb)_,1
},1
"dissect_gelf_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",0
    guint16 header_,0
    if (tvb_captured_length(tvb) < 2),0
"    proto_tree *gelf_tree = proto_item_add_subtree(ti, ett_gelf)_",0
"    proto_tree_add_item(gelf_tree, hf_gelf_pdu_type, tvb, 0, 2, ENC_BIG_ENDIAN)_",0
    if (header == HEADER_CHUNKED) {,0
"        guint32 number, count, short_id, data_len_",0
        GByteArray *bytes_,0
        char message_id[17]_,0
        gboolean more_frags_,0
        fragment_head *fd_head_,0
        message_id[0] = '\0'_,0
        bytes = g_byte_array_sized_new(8)_,0
"        col_clear(pinfo->cinfo, COL_INFO)_",1
"        proto_tree_add_bytes_item(gelf_tree, hf_gelf_pdu_message_id, tvb, 2, 8, ENC_BIG_ENDIAN,bytes,",0
"                                  NULL, NULL)_",0
"        proto_tree_add_item_ret_uint(gelf_tree, hf_gelf_pdu_chunk_number, tvb, 10, 1, ENC_BIG_ENDIAN,",0
                                     &number)_,0
"        proto_tree_add_item_ret_uint(gelf_tree, hf_gelf_pdu_chunk_count, tvb, 11, 1, ENC_BIG_ENDIAN,",0
                                     &count)_,0
"        bytes_to_hexstr(message_id, bytes->data, 8)_",0
        message_id[16] = '\0'_,0
        // HACK: convert 64 bit message id to 32 bit :),0
        short_id = BUILD_MESSAGE_ID(bytes->data)_,0
"        g_byte_array_free(bytes, TRUE)_",0
"        col_add_fstr(pinfo->cinfo, COL_INFO, ""Chunked packet: id: %s, number %u, count %u"", message_id,",0
"                     number, count)_",0
"        data_len = tvb_captured_length_remaining(tvb, 12)_",0
        more_frags = (count == number + 1) ? FALSE : TRUE_,0
        // reasembly,0
"        fd_head = fragment_add_seq_check(&gelf_udp_reassembly_table, tvb, 12, pinfo, short_id, NULL, number,",0
"                                         data_len, more_frags)_",0
        if (fd_head != NULL) {,0
            tvbuff_t *newtvb_,0
"            newtvb = process_reassembled_data(tvb, 12, pinfo, ""Reassembled GELF"", fd_head,",0
"                                              &gelf_fragment_items, NULL, gelf_tree)_",0
            if (newtvb != NULL) {,0
"                guint16 newheader = tvb_get_ntohs(newtvb, 0)_",0
"                dissect_gelf_simple_udp(newtvb, pinfo, tree, data, newheader, FALSE)_",0
           },0
        return tvb_captured_length(tvb)_,0
    } else {,1
"        proto_tree_add_boolean(gelf_tree, hf_gelf_pdu_chunked, tvb, 0, 2, FALSE)_",0
"        return dissect_gelf_simple_udp(tvb, pinfo, tree, data, header, TRUE)_",0
static gboolean,1
"dissect_gelf_heur_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)",0
        return TRUE_,1
        return FALSE_,1
void,1
proto_register_gelf(void),0
    static  hf_register_info hf[] = {,0
"        { &hf_gelf_pdu_type,",0
            {,1
"                ""GELF Type"", ""gelf.type"", FT_UINT16,",0
"                BASE_HEX, VALS(gelf_udp_types), 0x0,",0
"                NULL, HFILL",0
"        },",1
"        { &hf_gelf_pdu_message_id,",0
"                ""Message id"", ""gelf.chunk.msg_id"", FT_BYTES,",0
"                BASE_NONE, NULL, 0x0,",0
"        { &hf_gelf_pdu_chunk_number,",0
"                ""Chunk number"", ""gelf.chunk.number"", FT_UINT8,",0
"                BASE_DEC, NULL, 0x0,",0
"        { &hf_gelf_pdu_chunk_count,",0
"                ""Chunk count"", ""gelf.chunk.count"", FT_UINT8,",0
"        /* Fragmentation */,",0
"        { &hf_gelf_fragments,",0
"                ""GELF fragments"", ""gelf.fragments"", FT_NONE, BASE_NONE,",0
"                NULL, 0x00, NULL, HFILL",0
"        { &hf_gelf_fragment,",0
"                ""GELF fragment"", ""gelf.fragment"", FT_FRAMENUM, BASE_NONE,",0
"        { &hf_gelf_fragment_overlap,",0
"                ""GELF fragment overlap"", ""gelf.fragment.overlap"", FT_BOOLEAN,",0
"                BASE_NONE, NULL, 0x00, NULL, HFILL",0
"        { &hf_gelf_fragment_overlap_conflict,",0
"                ""GELF fragment overlapping with conflicting data"",",0
"                ""gelf.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE,",0
"        { &hf_gelf_fragment_multiple_tails,",0
"                ""GELF has multiple tail fragments"",",0
"                ""gelf.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE,",0
"        { &hf_gelf_fragment_too_long_fragment,",0
"                ""GELF fragment too long"", ""gelf.fragment.too_long_fragment"",",0
"                FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL",0
"        { &hf_gelf_fragment_error,",0
"                ""GELF defragmentation error"", ""gelf.fragment.error"", FT_FRAMENUM,",0
"        { &hf_gelf_fragment_count,",0
"                ""GELF fragment count"", ""gelf.fragment.count"", FT_UINT32, BASE_DEC,",0
"        { &hf_gelf_reassembled_in,",0
"                ""Reassembled GELF in frame"", ""gelf.reassembled.in"", FT_FRAMENUM, BASE_NONE,",0
"                NULL, 0x00, ""This GELF packet is reassembled in this frame"", HFILL",0
"        { &hf_gelf_reassembled_length,",0
"                ""Reassembled GELF length"", ""gelf.reassembled.length"", FT_UINT32, BASE_DEC,",0
"                NULL, 0x00, ""The total length of the reassembled payload"", HFILL",0
    }_,1
    static gint *ett[] = {,1
"        &ett_gelf,",0
"        &ett_gelf_fragment,",0
        &ett_gelf_fragments,0
"    proto_gelf = proto_register_protocol(""Graylog Extended Log Format"", ""GELF"", ""gelf"")_",0
"    gelf_udp_handle = register_dissector(""gelf-udp"", dissect_gelf_udp, proto_gelf)_",0
"    proto_register_field_array(proto_gelf, hf, array_length(hf))_",0
"    proto_register_subtree_array(ett, array_length(ett))_",1
"    reassembly_table_register(&gelf_udp_reassembly_table, &addresses_reassembly_table_functions)_",0
proto_reg_handoff_gelf(void),0
"    dissector_add_for_decode_as(""udp.port"", gelf_udp_handle)_",0
"    heur_dissector_add(""udp"", dissect_gelf_heur_udp,  ""GELF over UDP"", ""gelf_udp"", proto_gelf,",0
"    json_handle = find_dissector_add_dependency(""json"", proto_gelf)_",0
/*,1
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html,0
 * Local variables:,1
 * c-basic-offset: 4,1
 * tab-width: 8,1
 * indent-tabs-mode: nil,1
 * End:,1
 * vi: set shiftwidth=4 tabstop=8 expandtab:,1
 * :indentSize=4:tabSize=8:noTabs=true:,1
"	proto_gelf = proto_register_protocol(""Graylog Extended Log Format"", ""GELF"", ""gelf"")_",0
is amended. Using the same Change-Id on two complete different changes makes them,0
actually the same change. This is useful if you pushed a version of your patch,0
that for some reason needs to be completely re-worked. Instead of abandoning the,0
"first and pushing a new one, you can re-use the Change-Id, taking over the first",0
"version. This approach can sound a bit puzzling at the beginning, but it's just",0
"an alternative way: instead of making a review ""branch-centric"", Gerrit requires",0
"      tvb_memcpy(parameter_tvb, padded_nsap_bytes, 0, tvb_len)_",0
    }else{,0
				),0
        g_free(executable_path)_,0
        execname = rp_execname_,0
    xx_free(rp_execname)_,0
"        { 1, ""subType 1"" },",0
    guint8 subType_ ,0
"        proto_tree_add_item(tree, hf_ex_avaya_state, tvb, offset, 3, ENC_BIG_ENDIAN)_",0
    case OUI_AVAYA_EXTREME:,0
#define OUI_AVAYA_EXTREME   0x00040D    /* avaya extreme access point */,0
"        proto_tree_add_expert(tree, pinfo, &ei_usb_usbpcap_unknown_urb, tvb, 22, 1)_",0
        // when both the C run-time file descriptor (out_fd) and the extcap_control_out_h are closed.,0
            if (fi->value.value.uinteger),0
k4(uat_btmesh_record_t *key_set),0
label_uuid_hash(uat_btmesh_label_uuid_record_t *label_uuid_record),0
    return FALSE_,1
void extcap_free_toolbar_control(iface_toolbar_control *control)_,1
    sd.show()_,0
"        win:append("" with "" .. eyes .."" eyes and "" .. hair .. "" hair."")_",0
"    - if [ -f run/dumpcap ]_ then setcap ""CAP_NET_RAW+eip CAP_NET_ADMIN+eip"" run/dumpcap_ fi",0
    - cmake -GNinja -DCMAKE_CC=$CC -DCMAKE_CXX=$CXX $CMAKE_ADDITIONAL_OPTIONS ..,0
"    PCAP: ""OFF""",1
"		nds_prot_flags=tvb_get_letohs(tvb, 22)_",0
  column_info* cinfo = pinfo->cinfo_,1
"    proto_tree_add_uint_bits_format_value(p4_tree, hf_iso14443_cid,",0
         * we can reclaim them.,0
#define PNDCP_SUBOPTION_DHCP_CONTROL_FOR_ADDRESS_RES 255  ,0
        offset += 1_ //SuboptionDHCP ,0
        guint32 id = p_rlc_nr_info->direction + (sn<<1) + (p_rlc_nr_info->ueid<<19) + (p_rlc_nr_info->bearerId<<27)_,0
"        proto_tree_add_bitmask(tree, tvb, offset, hf_as_ep_gen_bmattributes, ett_as_ep_gen_attributes, v1_attributes, ENC_LITTLE_ENDIAN)_",1
"    return wmem_tree_lookup32_array(q_ctx->data_requests, cmd_key)_",1
    //struct tcpinfo *tcpinfo = (struct tcpinfo *) data_,0
            goto done_,1
"            ""Whether to validate the PDU data digest or not.  "",",0
            goto not_found_,1
"            val_to_str(offset_in_string, prop_offset_tbl, ""Unknown Property""))_",0
    data_key = tcpinfo->seq + offset_,0
        if (!cmd_ctx) {,1
    PROTO_ITEM_SET_GENERATED(cmd_ref_item)_,1
"        return val_to_str(opcode, aq_opc_tbl, ""Reserved"")_",1
"#define NVME_TCP_PORT_RANGE    ""4420"" /* IANA registered */",0
"    { 0xc,""Reserved"" },",0
	return ((opcode == NVME_IOQ_OPC_FLUSH) ||,0
	if (qid),0
"	net_id_len = tvb_get_guint8(tvb, curr_offset++)_",1
	guint an_type_,1
"		guint apn_len, ui_",1
"	proto_tree_add_item(tree, hf_gsup_an_type, tvb, offset, 1, ENC_NA)_",1
"		proto_tree_add_item(tree, hf_gsup_ie_payload, ss_tvb, 0, tvb_captured_length(ss_tvb), ENC_NA)_",1
"		wmem_free(wmem_packet_scope(), str)_",1
"			proto_tree_add_item(tree, hf_gsup_source_name_text, tvb, offset, ie_len, ENC_ASCII|ENC_NA)_",1
"			proto_tree_add_item(tree, hf_gsup_destination_name_text, tvb, offset, ie_len, ENC_ASCII|ENC_NA)_",1
/* Retry Packet dissection for draft -13 and newer. */,0
static const value_string protected_he_action_vals[] = {,0
              for (f = i_ f <  i + ((bitmap_size == 4 ? 4 : 8) * 8)_ f++) {,0
static const true_false_string ht_info_dual_cts_protection_flag = {,0
"  proto_tree_add_uint_format(tree, hf_he_qtp_control, tvb, offset, 1, control,",0
"  item = proto_tree_add_uint_format(tree, hf_ieee80211_ff_he_action, tvb, offset, 1, he_action,",0
%(DEFAULT_BODY)s,0
"                proto_item_append_text(item, "" not available in the old MME/SGSN/AMF"")_",0
            key[1] = pinfo->rec->rec_header.packet_header.interface_id_,0
"								 ""Try heuristic sub-dissectors first"",",0
  nr_drb_mapping_t *mapping = &nr_rrc_get_private_data(actx)->drb_mapping_,1
"	//{ FRR_ZAPI6_IPV4_ROUTE_IPV6_NEXTHOP_ADD,""Add IPv6 nexthop for IPv4 Route"" },",0
"		[CBSP_IEI_MSG_CONTENT] =		{ TLV_TYPE_TLV, 0 },",0
"	call_dissector(gsm_cbs_handle, next_tvb, pinfo, tree)_",0
			len_len = 0_,0
"			proto_tree_add_item(att_tree, hf_cbsp_dcs, tvb, offset, len, ENC_NA)_",0
"    { TUNNEL_TYPE_L2TP_OVER_IP, ""L2TP_OVER_IP"" },",1
"    { TUNNEL_TYPE_MPLS_IN_IP,   ""MPLS-in-IP tunnel with IPsec Transport Mode"" },",1
"    { TUNNEL_TYPE_IP_IN_IP,     ""IP_IN_IP"" },",1
"                               ""         %d: %s"", lastError, win32strerror(lastError))_",1
"                           pipename, lastError, win32strerror(lastError))_",1
"                   lastError, win32strerror(lastError))_",1
"  set_property(TARGET pcap::pcap APPEND PROPERTY IMPORTED_LOCATION ""${PCAP_LIBRARIES}"")",1
if(ENABLE_SPEEXDSP AND NOT SPEEXDSP_FOUND),1
"    g_string_append(str, "", without SpeexDSP (using built-in)"")_",0
* The build system now produces reproducible builds (wsbuglink:15163[]).,0
static gboolean docsis_didssect_encrypted_frames = FALSE_,0
"							 guint8 exthdr, guint16 mac_parm, guint16 len_sid, guint16 *payload_length, gboolean *is_encrypted)",0
"										 ENC_BIG_ENDIAN, is_encrypted)_",0
		if(is_encrypted && !docsis_didssect_encrypted_frames),0
		${WIN_WS2_32_LIBRARY},0
  mapping->rlcMode = RLC_UM_MODE_,1
  mapping->rlcMode = RLC_AM_MODE_,1
"                                  guint8 direction _U_,",1
"  memset(&drb_mapping, 0, sizeof(drb_mapping))_",0
  if (mapping != NULL) {,0
#.FN_BODY UL-UM-RLC,1
#.FN_BODY DL-UM-RLC,1
#.FN_BODY UL-AM-RLC,1
#.FN_BODY DL-AM-RLC,1
#.FN_BODY SN-FieldLengthUM  VAL_PTR=&value,0
#.FN_BODY SN-FieldLengthAM  VAL_PTR=&value,0
static nr_drb_mapping_t* private_data_get_drb_mapping(asn1_ctx_t *actx),0
                /* Set seqnum_length and rlc_ext_li_field */,1
        /* Set seqnum_length and rlc_ext_li_field */,1
"        set_rlc_seqnum_length(*rlc_bearer_type, direction, seqnum_length)_",0
            if ((lcid >= 2) && (lcid <= 32)) {,1
        if ((lcid < 3) || (lcid > 32)) {,1
    guint8     rlc_sn_length_        /* Part of RLC config - optional */,1
"	ret = p_pcap_findalldevs(a, errbuf)_",0
	ret = p_pcap_lookupdev(errbuf)_,0
	 * by pcap_geterr is atleast of size PCAP_ERRBUF_SIZE?,0
"	ret = p_pcap_lookupnet(a, b, c, errbuf)_",0
"	p = p_pcap_open_live(a, b, c, d, errbuf)_",1
"	ret = p_pcap_open(a, b, c, d, e, errbuf)_",0
"	ret = p_pcap_findalldevs_ex(a, b, c, errbuf)_",0
"	ret = p_pcap_createsrcstr(a, b, c, d, e, errbuf)_",0
"	p = p_pcap_create(a, errbuf)_",0
    if (p_pcap_statustostr != NULL) {,0
endif(),1
  find_program(PCAP_CONFIG pcap-config),0
    # It could also be empty if the default include dir is in use.,0
find_path(PCAP_INCLUDE_DIR,0
  set(PCAP_LIBRARIES ${PCAP_LIBRARY}),0
"    string(REGEX REPLACE ""-I"" """" PCAP_CONFIG_INCLUDE_DIRS ""${PCAP_CONFIG_OUTPUT}"")",1
# XXX this is not needed for Wireshark because of FindWSWinLibs,0
mark_as_advanced(PCAP_INCLUDE_DIRS PCAP_LIBRARIES),1
"			proto_tree_add_uint(nfl_tree, hf_nfs4_nfl_util_stripe_size, tvb, offset, 4, nfl_util&NFL4_UFLG_STRIPE_UNIT_SIZE_MASK)_",0
 /*,0
DIAG_OFF(frame - larger - than = ),0
DIAG_ON(frame - larger - than = ),0
    //menu_recent_file_write_all,0
"    connect(this, SIGNAL(filterAction(QString, FilterAction::Action, FilterAction::ActionType)),",0
"        main_ui_->statusBar, SLOT(pushFilterStatus(const QString&)))_",0
"    connect(funnel_statistics_, SIGNAL(openCaptureFile(QString, QString)),",0
"        main_ui_->statusBar, SLOT(pushTemporaryStatus(const QString&)))_",0
 /** @defgroup main_window_group Main window,0
 // Qt 5.5.0 + Visual C++ 2013,0
"	iec870_module = prefs_register_protocol(proto_iec870_asdu, NULL)_",0
void proto_register_iec104apci(void)_,0
/* IEC-104 comment: Fields are little endian. */,0
	/* Support both 16 and 24-bit IOA addresses */,0
	size_t Ind_,0
	/* 'ASDU Details': ROOT ITEM */,1
	/* Check that this is actually a IEC 101 packet. */,0
"#include ""tfs.h""",0
"      //proto_tree_add_item(subtree, hf_isakmp_auth_digital_sig_asn1_data, tvb, offset, asn1_len, ENC_BIG_ENDIAN)_",0
} digital_signature_algo_,0
"      ti = proto_tree_add_bytes_item(subtree, hf_isakmp_auth_digital_sig_asn1_data, tvb, offset, asn1_len, ENC_BIG_ENDIAN, asn1_data, NULL, NULL)_",0
  gchar     *strptr_,0
"      proto_tree_add_item(subtree, hf_isakmp_auth_digital_sig_value, tvb, offset, length, ENC_NA)_",0
typedef struct _digital_signature_algo {,0
  guint8    length_,0
    (void)source_,0
"WS_DLL_PUBLIC void prefs_set_custom_value(pref_t *pref, const char *value, pref_source_t source)_",0
    /* XXX - what to do with the changed flags or the source? */,0
"            prefs_set_custom_value(item->getPref(), value.toString().toStdString().c_str(), pref_stashed)_",0
"  wmem_free(wmem_packet_scope(), vendor_context)_",1
  vendor_context = (eap_vendor_context *)g_malloc(sizeof(eap_vendor_context))_,1
        // --arg= for an empty argument) and may indicate a bug.,0
        return WS_INVALID_PID_,0
        if (!*args[i]) {,0
    for (int i = 0_ i < argc_ i++) {,0
        // XXX remove this? The caller violated contract.,0
        if (!args[i]) {,0
        return tvb_reported_length(tvb)_,1
            pinfo->can_desegment++_,0
"          { ""Source Address"", ""proxy.v1.src_addr_ipv4"",",1
"            NULL, HFILL }",1
"    guint32 offset, guint len _U_,",0
"            memcpy(uncompr + (total_out - pass_out), strmbuf, pass_out)_",0
"echo ""libmaxminddb-dev is unavailable"" >&2",0
add_package ADDITIONAL_LIST brotli-devel || add_packages ADDITIONAL_LIST libbrotli-devel libbrotlidec1 ||,0
#define TVB_BROTLI_MAX_BUFSIZ 1048576 * 10,1
                return NULL_,1
            needs_more_output = 1_,0
            uncompr = new_data_,1
"        key_file = os.path.join(dirs.key_dir, 'http2-brotli.keys')",1
"$Win32CurrentTag = ""2019-04-01""",1
),1
  /usr/lib,1
        BrotliDecoderResult result = BrotliDecoderDecompressStream(,0
"                '-d', 'tcp.port==80,http',",0
"                '-d', 'tcp.port==443,tls',",1
    /* TODO: currently only draft status: draft-yeung-g-ikev2-15 */,0
#define TAG_FINE_TIME_MEASUREMENT_PARAM 206,0
"    - export PYTEST_ADDOPTS=--skip-missing-programs=dumpcap,rawshark",0
"            g_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_WARNING, ""Empty argument in arguments list"")_",0
        DWORD error = GetLastError()_,1
        g_free(argv[0])_,0
"        stdout_overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)_",1
"                    if (!ReadFile(child_stdout_rd, &stderr_buffer[0], BUFFER_SIZE, NULL, &stderr_overlapped))",1
"            HANDLE handles[] = { stdout_overlapped.hEvent, stderr_overlapped.hEvent, processInfo.hProcess }_",1
        for (__),1
"(Windows or Linux, x86 or x64).",1
that further data is available on request. Large files may annoy people on the,1
        item += (str(i) + ' sec').encode('utf-8'),1
"    def test_tshark_extcap_interfaces(self, cmd_tshark, program_path):",0
"                    proto_tree_add_string(tree, hf_isakmp_notify_data_3gpp_device_identity_imeisv, tvb, offset, length, imeisv_str)_",0
			/* Payload Octet 8-n - Identity value */,0
"                    proto_item_append_text(item, ""[%u Zero bits not present, but displayed]"", zero_bits_omitted)_",0
"            item = proto_tree_add_item(parent_tree, hf_id, tvb, offset, len, ENC_BIG_ENDIAN)_",0
"                        proto_item_append_text(item, ""[%u Zero bits not encoded, but displayed]"", zero_bits_omitted)_",0
"    return g_regex_match_simple(pattern, subject, (GRegexCompileFlags) (G_REGEX_CASELESS), (GRegexMatchFlags)0)_",0
"        g_regex_match(regex, s, (GRegexMatchFlags) 0, &match_info)_",0
"        g_regex_match_full(regex, s, -1, 0, (GRegexMatchFlags) 0, &match_info, &error)_",0
#!/usr/bin/env python3,0
        extcap_folder = program_path + '/extcap/',0
"        shutil.copy2('../test/' + extcap_tool, extcap_folder)",0
        os.remove(extcap_folder + extcap_tool),0
        extcap_folder = 'run/extcap/',0
            return,0
        extcap_tool = 'sampleif.py',1
            os.makedirs(target_dir),0
"        self.assertEqual(2, self.countOutput('extcap.sampleif'))",0
dissector_handle_t drbd_handle_,1
    return !!(value & (G_GINT64_CONSTANT(1) << bit))_,1
    if (tvb_reported_length(tvb) - offset >= DRBD_FRAME_HEADER_100_LEN && magic32 == DRBD_MAGIC_100),0
"                written += g_snprintf(s + written, ITEM_LABEL_LENGTH - written, ""%d - %d"", run_start, run_end - 1)_",1
  epan_dissect_cleanup(&edt)_,1
"    rescan_packets(cf, ""Reprocessing"", ""all packets"", redissect)_",0
" * de facto standard is 11344, we default to 0 */",0
"    ssl_dissector_add(icap_tls_port, icap_handle)_",0
"    if (help_url.scheme().compare(""file"") != 0) {",1
		QDesktopServices::openUrl(help_url)_,0
    offset += 4 + len_,1
"	printf(""dddddddddd %s\n"", help_url)_",0
"Unix-like, Windows and macOS operating systems. It uses Qt, a graphical",0
  data -= 0x05_ /* HACK */,0
  /* XXX - why must we only free this after dissecting the new frame? */,0
"	{ WIRESHARK_VT_PTR, ""VT_PTR""},",1
    PROTO_ITEM_SET_HIDDEN(item)_,0
"    dissect_per_constrained_integer(tvb, t_offset, actx, tree, hf_s1ap_ENB_UE_S1AP_ID_PDU,",0
    PROTO_ITEM_SET_GENERATED(actx->created_item)_,0
"    dissect_per_constrained_integer(tvb, t_offset, actx, tree, hf_s1ap_MME_UE_S1AP_ID_PDU,",0
    case 0x000FAC03:,0
  g_assert(bufptr < buf + bytes)_,0
      /* Check we have enough data in the line */,0
  buf[i > 0 ? i-1 : 0] = '\0'_,0
      if (buf[i] == 0x0A),0
	packaging/macosx/entitlements.plist,1
"        --entitlements ""@CMAKE_BINARY_DIR@/packaging/macosx/entitlements.plist"" \",0
		--timestamp \,1
"        toa = (gint16)tvb_get_ntohs(tvb, offset)_",0
			if (is_digest_line && !transfer_info->req) {,0
				if (!already_dissected) {,0
/.vs,0
"        &hf_nas_5gs_mm_type_id,",0
             * MNC digit 3     MCC digit 3,0
"					((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) {",0
"          sscanf (buf+78,",1
"            json_dumper_value_string(pdata->dumper, NULL)_",0
"            FT_UINT8, BASE_DEC, &units_octet_octets, 0x0,",0
"    proto_tree_add_item(tree, hf_bthci_cmd_antenna_switching_pattern_length, tvb, offset, 1, ENC_NA)_",0
"            item = proto_tree_add_item(tree, hf_bthci_cmd_rx_frequency, tvb, offset, 1, ENC_NA)_",0
"            item = proto_tree_add_item(tree, hf_bthci_cmd_tx_frequency, tvb, offset, 1, ENC_NA)_",0
"            item = proto_tree_add_item(tree, hf_bthci_cmd_cte_length, tvb, offset, 1, ENC_NA)_",0
#define BGP_LS_IGP_TE_METRIC_FLAG_A         0x80,1
/* From IEEE802.11-2016 Table 12-8—Integrity and key-wrap algorithms */,0
	# (the default) creates zlibd1.dll.,1
		# GTK+ required GObject and GIO. We probably don't.,0
"			CACHE FILEPATH ""GLib 2 PDB list""",1
#,1
    #  mark_as_advanced( ZLIB_DLL_DIR ZLIB_DLL ),0
"  if (tvb_get_ntohl(tvb, offset) == IPADDRESS_INVALID)",0
    guint32 oxm_hm_,0
"    proto_tree_add_item(tree, hf_openflow_v6_oxm_hm, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
"            FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }",0
"                        if (!nstrace_ensure_buflen(nstrace, nstrace_buf_offset, sizeof(nspr_abstime_v##ver##_t), err, err_info))\",0
      rb_data.io_buffer = (char *)g_malloc(buffsize)_,1
    * | guint32 SequenceSize                                          |,0
    * +---------------+---------------+---------------+---------------+,0
		  encapsulation_id == ENCAPSULATION_PL_CDR_LE ||,0
		  encapsulation_id == ENCAPSULATION_CDR2_LE ||,0
		  encapsulation_id == ENCAPSULATION_D_CDR2_LE ||,0
"	{ &hf_rtps_param_data_representation,{",0
"		""Data Representation Kind"", ""rtps.param.data_representation"",",0
"		FT_UINT16, BASE_DEC, VALS(data_representation_kind_vals), 0, NULL, HFILL }",0
		if (len > length) {,0
			return base_offs_,1
"			offset += dissect_gsup_tlvs(tvb, offset, len, pinfo, att_tree, gsup_ti, msg_type)_",0
#if GCRYPT_VERSION_NUMBER >= 0x010600 /* 1.6.0 */,0
"    proto_tree_add_item(sub_tree, hf_btmesh_proxy_sar, tvb, offset, 1, ENC_NA)_",1
    /* Proposed Provider Name */,0
    /* Proposed Provider Contact Details */,0
"    if (tvb_reported_length_remaining(tvb, *offset) <= 0) return_",0
"                    payload_tree = proto_tree_add_subtree(tree, tvb, offset, rem_len, ett_zbee_zcl_device_management, NULL, ""Payload"")_",0
"  if (ws_stat64(ringbuf_current_filename(), &statb) == 0) {",1
"        if (ws_stat64(capture_opts->save_file, &statb) == 0) {",0
"        g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_DEBUG, ""capture_loop_init_output: bufsize %""G_GUINT64_FORMAT, buffsize)_",0
#define IO_BUF_SIZE 64 * 1024,1
"    { 0x01, ""speech full rate or half rate version 1(GSM FR or GSM HR)""},",0
"    { 0x83, ""speech full rate or half rate version 6(OHR AMR )""},",0
"    if (!g_str_has_prefix(col_get_text(cinfo, el), g_strdup(str)))",0
"        col_set_str(cinfo, el, str)_",0
"    if (!g_strrstr(col_get_text(cinfo, el), g_strdup(str)))",0
    iface_timer_id_ = QFrame::startTimer(interval)_,0
    if (!added) {,0
				return -1_,0
"    return (bsearch(&key, bool_properties, (sizeof(bool_properties)/sizeof(guint16)), sizeof(guint16), compcp) != NULL)_",0
"    return (bsearch(&key, utf8_properties, (sizeof(utf8_properties)/sizeof(guint16)), sizeof(guint16), compcp) != NULL)_",0
"	proto_tree_add_item(tree, hf_smb2_error_context_length, tvb, offset, 4, ENC_LITTLE_ENDIAN)_",1
"	proto_tree_add_item(tree, hf_smb2_error_context_id, tvb, offset, 4, ENC_LITTLE_ENDIAN)_",1
"    proto_tree_add_item(tree, hf_zbee_zcl_tun_protocol_offset, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
        proto_tree *mu_chan1_rus = NULL_,0
"    { ETHERTYPE_EERO,                 ""EERO Broadcast Packet"" },",1
#define ETHERTYPE_EERO        0x9104    /* EERO: broadcast packets sent by EERO MESH AP's (not officially registered) */,1
"                field_tree = proto_tree_add_subtree_format(ieee802154_tree, tvb, offset, 2, ett_ieee802154_fcs, NULL,",0
"                proto_tree_add_item_ret_uint(tlvtree, hf_ieee802154_ch_page, tvb, offset+2, 1, ENC_LITTLE_ENDIAN, &page)_",1
        } /* switch (tlv_type) */,1
    wmem_tree_key_t             ieee802154_key[4]_,0
    (void) src_addr_,0
"            payload_tvb = tvb_new_subset_length(tvb, mhr_len, reported_len)_",0
"static void dissect_zcl_met_start_sampling_response(tvbuff_t *tvb, proto_tree *tree, guint *offset)",0
"    proto_tree_add_time(tree, hf_zbee_zcl_price_start_time, tvb, *offset, 4, &start_time)_",0
/**,0
" *This function decodes utc time, with peculiarity case for",0
 *@param s string to display,0
 *@param value value to decode,0
*/,1
static void,1
"decode_zcl_start_utc_time(gchar *s, guint32 value)",0
    if (value == ZBEE_ZCL_SE_UTC_INVALID_TIME),0
"        g_snprintf(s, ITEM_LABEL_LENGTH, ""Invalid UTC Time"")_",0
    else {,0
        gchar *utc_time_,0
        value += ZBEE_ZCL_NSTIME_UTC_OFFSET_,0
"        utc_time = abs_time_secs_to_str (NULL, value, ABSOLUTE_TIME_LOCAL, TRUE)_",0
"        g_snprintf(s, ITEM_LABEL_LENGTH, ""%s"", utc_time)_",0
"        wmem_free(NULL, utc_time)_",0
/* Notification Flags dissector */,0
"static void dissect_zcl_met_notification_flags              (tvbuff_t *tvb, proto_tree *tree, guint *offset, guint16 noti_flags_number)_",0
static int hf_zbee_zcl_met_schedule_snapshot_snapshot_schedule_payload_snapshot_schedule_id = -1_,0
static int hf_zbee_zcl_met_schedule_snapshot_snapshot_schedule_payload_snapshot_start_time = -1_,0
static int hf_zbee_zcl_met_schedule_snapshot_snapshot_schedule_payload_snapshot_schedule = -1_,0
static int hf_zbee_zcl_met_schedule_snapshot_snapshot_schedule_payload_shapshot_payload_type = -1_,0
"        { &hf_zbee_zcl_met_schedule_snapshot_snapshot_schedule_payload_shapshot_payload_type,",0
"            { ""Snapshot Payload Type"", ""zbee_zcl_se.met.schedule_snapshot.snapshot_schedule_payload.snapshot_payload_type"",",0
"                FT_UINT8, BASE_DEC, VALS(zbee_zcl_met_snapshot_payload_type),",0
"            0x00, NULL, HFILL } },",0
"        { &hf_zbee_zcl_met_schedule_snapshot_snapshot_schedule_payload_snapshot_cause,",0
"            { ""Snapshot Cause"", ""zbee_zcl_se.met.schedule_snapshot.snapshot_schedule_payload.snapshot_cause"",  FT_UINT32, BASE_HEX, NULL,",0
"    proto_tree_add_item(tree, hf_zbee_zcl_met_get_sampled_data_sample_id, tvb, *offset, 2, ENC_LITTLE_ENDIAN)_",0
        if (packet->src_addr_mode == IEEE802154_FCF_ADDR_SHORT) {,0
    IEEE802154_FCS_OK_BIT = 0  /* TI CC24xx CRC_OK bit */,0
"  privileges, and the fact that the Npcap driver is signed.",0
"  return de_sgsap_ecgi(parameter_tvb, subtree, actx->pinfo, 0, 0, 0, 0)_",1
"  return de_emm_trac_area_id(parameter_tvb, subtree, actx->pinfo, 0, 0, 0, 0)_",1
"  dissect_isup_calling_geodetic_location_parameter(parameter_tvb, actx->pinfo, subtree, 0)_",1
"void dissect_isup_calling_geodetic_location_parameter(tvbuff_t *parameter_tvb, packet_info *pinfo, proto_tree *parameter_tree, proto_item *parameter_item _U_)_",1
DiameterIdentity TYPE = FT_STRING  DISPLAY = BASE_NONE,0
	const gchar *field = NULL_,0
static const true_false_string available = {,1
            ,1
#define ECPRI_ETHERTYPE 						0xAEFE,1
static gboolean message_type_decoding	= TRUE_,0
	proto_item *ecpri_item = NULL_,1
"			ecpri_item = proto_tree_add_item(tree, proto_ecpri, tvb, offset, -1, ENC_NA)_",1
"		col_append_fstr(pinfo->cinfo, COL_INFO, ""[eCPRI Message Type: %s]"", try_rval_to_str(msg_type, ecpri_msg_types))_",1
"						data_length = tvb_get_guint16(tvb, offset, ENC_BIG_ENDIAN)_",1
"						proto_tree_add_item(payload_tree, hf_action_type, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
"						ti_sec = proto_tree_add_item(timestamp_tree, hf_timestamp_sec, tvb, offset, 6, ENC_BIG_ENDIAN)_",1
"						proto_item_append_text(ti_sec, "" s"")_",1
"						ti_nano_sec = proto_tree_add_item(timestamp_tree, hf_timestamp_nanosec, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"						proto_item_append_text(ti_nano_sec, "" ns"")_",1
"						event_type = tvb_get_guint8(tvb, offset)_",1
"						num_faults_notif = tvb_get_guint8(tvb, offset)_",1
"			{ &hf_action_type , 		{ ""Action Type"", 					""ecpri.actiontype"", 		FT_UINT8, 	BASE_RANGE_STRING, 	RVALS(action_type_coding), 		0x00, 	NULL, HFILL } },",1
"			{ &hf_reset_code, 			{ ""Reset Code Op"", 					""ecpri.resetcode"", 			FT_UINT8, 	BASE_RANGE_STRING, 	RVALS(reset_coding), 			0x00, 	NULL, HFILL } },",1
"			{ &hf_event_type, 			{ ""Event Type"", 					""ecpri.eventtype"", 			FT_UINT8, 	BASE_RANGE_STRING, 	RVALS(event_type_coding), 		0x00, 	NULL, HFILL } },",1
"			{ &hf_element_id2, 			{ ""Element ID"", 					""ecpri.elementid"", 			FT_UINT16, 	BASE_RANGE_STRING, 	RVALS(element_id_coding), 		0x00, 	NULL, HFILL } },",1
 * This program is free software_ you can redistribute it and/or modify,1
"		{ 0x00,	0x00,	""0x00 = Request""						},",1
"		{ 0x00,	0x00,	""0x00 = Reserved""						},",1
"		{ 0x00,	0x00,	""0x00 = Fault(s) Indication"" 				},",1
"		{ 0xFFFF,	0xFFFF,	""0xFFFF = Fault/Notification applicable for all Elements""	},",1
"		{ 0x000,	0x000,	""0x000 = General Userplane HW Fault"" 			},",1
	proto_item *ecpri_item 		= NULL_,0
"	col_add_fstr(pinfo->cinfo, COL_INFO, ""[eCPRI Message Type: %s]"", try_rval_to_str(msg_type, ecpri_msg_types))_",0
"				ecpri_item = proto_tree_add_item(tree, proto_ecpri, tvb, offset, -1, ENC_NA)_",1
"							time_stamp_s = tvb_get_guint64(tvb, offset, ENC_BIG_ENDIAN) & 0xFFFFFFFFFFFF0000_",1
"							ti_comp_val = proto_tree_add_item(payload_tree, hf_compensation_value, tvb, offset, 8, ENC_BIG_ENDIAN)_",1
"											ti_fault_notif = proto_tree_add_item(element_tree, hf_fault_notif, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"	prefs_register_bool_preference(module_message_decoding,",0
"        payload_size = tvb_get_guint16(tvb, offset + 2, tvb_get_ntohs(tvb, offset))_",0
"                        proto_tree_add_item(payload_tree, hf_rma_id, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
"        payload_size = tvb_get_guint16(tvb, offset + 2, ENC_NA)_",0
"        ti_payload_size = proto_tree_add_item(header_tree, hf_payload_size, tvb, offset, 2, ENC_NA)_",0
"		/* Report empty error frames to subdissectors, since data has already been parsed */",0
"        byte = tvb_get_guint8(tvb, offset + 2)_",0
"        rtree = proto_tree_add_subtree_format(ldac_tree, tvb, offset, 3 + frame_length,",0
static int hf_btavdtp_vendor_specific_ldac_sampling_frequency_44100        = -1_,0
"        { &hf_ldac_syncword,",0
"    proto_ldac = proto_register_protocol(""LDAC : Bluetooth A2DP Vendor Specific Codec"", ""LDAC"", ""ldac"")_",1
"		default:  str = ""hr""_",0
"            //if number of coils is 0, presume the response wasn't found and set number of coils based on byte count",0
"            //if number of registers is 0, presume the response wasn't found and set number of registers based on byte count",0
    for (int i = 0_ (host = hosts[i]) != NULL_ ++i) {,1
	/* Make room for the next tree item */,1
			switch (GetExceptionCode()) {,0
"		show_exception(tvb, pinfo, parent_tree, EXCEPT_CODE, GET_MESSAGE)_",0
				switch (GetExceptionCode()) {,0
"			show_exception(tvb, pinfo, parent_tree, EXCEPT_CODE, GET_MESSAGE)_",1
	if (color_filter) {,0
"					proto_tree_add_expert_format(tree, pinfo, &ei_incomplete, tvb, i, 1, ""Undecoded byte number: %u (0x%.4X+%u)"", i, i - i % 16, i % 16)_",0
"        proto_tree_add_uint(assoc_header_ptree, hf_dcm_assoc_version, tvb, offset, 2, assoc_ver)_",0
            pdv->data_len = pdv_body_len_,0
"            if (str[i] == '\\' || str[i] == '""') {",0
// PacketListModel [already moved] (or replace this with a wmem allocator).,1
    g_string_chunk_free(string_cache_pool_)_,1
// {,0
"        proto_tree_add_item(flow_data_tree, hf_sflow_enterprise_length, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"    WriteINIStr ""$PLUGINSDIR\NpcapPage.ini"" ""Field 5"" ""Text"" ""The currently installed $NPCAP_NAME will be uninstalled first.""",0
"dissect_zcl_met_request_fast_poll_response(tvbuff_t *tvb, proto_tree *tree, guint *offset)",0
"    proto_tree_add_item(tree, hf_zbee_zcl_met_request_fast_poll_response_applied_update_period, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
# Include the User Guide:,0
"        proto_tree_add_item(payload_tree, hf_zbee_zcl_met_schedule_snapshot_response_snapshot_schedule_id, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
"        proto_tree_add_item(payload_tree, hf_zbee_zcl_met_schedule_snapshot_response_snapshot_schedule_confirmation, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
"   Element usage), HI3CCLinkData, Intelligent Transport Systems (ITS) ",0
"		update_preauth_hash(si->conv->preauth_hash_current, tvb)_",0
"    proto_tree_add_item(tree, hf_zbee_zcl_met_get_profile_response_status, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
"    proto_tree_add_item(tree, hf_zbee_zcl_met_get_profile_response_profile_interval_period, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
"    proto_tree_add_item(tree, hf_zbee_zcl_met_get_profile_response_number_of_periods_delivered, tvb, *offset, 1, ENC_LITTLE_ENDIAN)_",0
    if ( command_str != NULL ) {,1
"        hf_pcombinary_command_item = proto_tree_add_item(pcombinary_tree, hf_pcombinary_command, tvb,",0
    static ei_register_info pcomtcp_ei[] = {,1
"    ""npcap-0.99-r8.exe"" = ""c8f996c430d7d6395edf94c0a85c849d034c324bd234b74a0f6ac62e4f0f04e0""_",0
"                tvb_get_string_enc(wmem_packet_scope(), tvb, offset, cc_len, ENC_ASCII),",1
            default:,1
    guint8       i = 0_,1
    guint32      cc = 0_,1
"        proto_item_set_text(ti, ""Command Code: %s (%s)"", cc_str,",1
            switch(cc),1
                    nvalues = tvb_captured_length(tvb)-3-offset_ // 1 char each,1
                    nvalues = (tvb_captured_length(tvb)-3-offset) / 4_ // 4 chars size,1
                    nvalues = (tvb_captured_length(tvb)-3-offset) / 8_ // 8 chars size,1
              switch(cc),1
                    nvalues = tvb_captured_length(tvb)-3-offset_ // 1 char size,0
              },1
    if (tvb_captured_length(tvb)-3-offset > 0){,1
        offset += (tvb_captured_length(tvb)-3-offset)_ //-3 from checksum and etx,1
"            { ""Length"", ""pcomascii.address"",",0
"    NoticesAndTraps_header_item = proto_tree_add_item(parentTree, hf_opa_Notice, tvb, local_offset, 96, ENC_NA)_",0
    for (sc_entry = sc->cache_list_ sc_entry != NULL_ sc_entry = g_list_next(sc_entry)) {,1
		 * Bay Nortel Networks has a mechanism in the Optivity,0
"    QString file = WiresharkFileDialog::getOpenFileName(this, tr(""Select PKCS #11 Provider Library""), """", filter)_",1
secrets_pkcs11_get_tokens(void)_,0
"secrets_pkcs11_verify_token(const char *token_uri, const char *pin)_",1
                        /* R R PCMAXC (6 bits) */,0
"              ""mac-nr.control.me-phr.ph"", FT_UINT8, BASE_DEC, NULL, 0x3f,",0
            if (ret == 2) {,0
        *offset += other_info_len_,0
        other_info_len -= other_info_len_,0
"            report_failure(""Lua: syntax error during precompilation:\n%s"",lua_tostring(L,-1))_",1
"""-n"" or ""--lines"" argument for the C<tail> command. Values prefixed",0
"                        report_failure(""Lua: Error during loading:\n%s"", lua_tostring(L, -1))_",0
"                        report_failure(""Lua: Error during loading: out of memory"")_",1
"            {""upplementary Originator Counter"", ""gbcs_message.grouping_header.supplementary_remote_party_originator_counter"",",1
"            {""KRP"", ""gbcs_message.grouping_header.supplementary_remote_party_ka_certificate"",",1
    proto_item *ti_,1
"    component_tree = proto_tree_add_subtree(tree, tvb, *offset, 1, ett_gbcs_gbz_components, &ti, ""Use Case Component"")_",1
"        proto_tree_add_item(component_tree, hf_gbcs_gbz_encrypted_payload, tvb, *offset, component_len, ENC_NA)_",1
"static void dissect_gbcs_gbz_component(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint *offset)",1
"    proto_tree_add_item(component_tree, hf_gbcs_gbz_extended_header_control, tvb, *offset, 1, ENC_BIG_ENDIAN)_",1
    *offset += 2_,1
    if (fromdatetime_present) {,1
"        proto_tree_add_item(component_tree, hf_gbcs_gbz_encrypted_payload, tvb, *offset, component_len, ENC_BIG_ENDIAN)_",1
    if (encryption_present == FALSE && zcl_handle) {,1
"        payload_tvb = tvb_new_subset_length(tvb, *offset - 3, component_len + 3)_",0
"    if (tvb_reported_length_remaining(tvb, offset) && tvb_get_guint8(tvb, offset) >= 0x80) { // Probably an alert",1
    *offset += 1_ // Transaction ID length,1
	channel = ssh_channel_new(sshs)_,0
	// better than nothing.,0
"        self.assertIn('unknown Response', proc.stdout_str)",1
"        self.assertEqual(tree+'\n', proc.stdout_str)",1
        )),0
"        self.assertIn(tree, proc.stdout_str)",0
"    def test_bad_key(self, cmd_tshark, dirs, capture_file, features, softhsm):",1
"        self.assertNotIn('Malformed', proc.stdout_str)",1
"        tvb, 0, 0, msp->first_frame_with_seq)_",0
            if(pinfo->num==msp->first_frame_with_seq) {,0
"            proto_tree_add_item(tree, hf_pfcp_network_instance, tvb, offset, length, ENC_ASCII | ENC_NA)_",1
"                len += g_snprintf(&buf[len], ITEM_LABEL_LENGTH - len, ""%d"", port)_",0
    return num_ports_,0
"			wmem_map_remove(si->session->tids, &tid_key)_",0
        /* ACK */,0
"        g_hash_table_replace(attr_table, node_name, attr_instances)_",0
"            attr_instances = g_slist_prepend(attr_instances, current_node)_",0
"    GHashTable *attr_table  = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (GDestroyNotify)g_slist_free)_",0
   * - Registration Request (REG-REQ-MP) MAC Management Message Frames_,0
              static const int *extra_flags[] = {,0
"                      &hf_force_meta,",0
"                      &hf_force_accept,",0
"                      &hf_regenerate_cas,",0
"                      &hf_skip_conflict,",0
"                      &hf_is_expiration,",0
                      NULL,0
              }_,0
"              proto_tree_add_bitmask(extras_tree, tvb, offset, hf_meta_options,",0
"                                     ett_extras_flags, extra_flags, ENC_BIG_ENDIAN)_",0
              offset += 4_,0
          } else /*CMD_SET_WITH_META*/ {,0
"                                 ett_extras_flags, extra_flags, ENC_BIG_ENDIAN)_",0
        GChecksum *hash  = g_checksum_new(G_CHECKSUM_SHA512)_,0
"        g_checksum_update(hash, (guchar*)buf, SMB2_PREAUTH_HASH_SIZE)_",0
	if (gcry_err_code(err)),0
"        ret = gnutls_privkey_decrypt_data(pk, 0, &epms, &pms)_",1
"		proto_item_append_text(item, "" Acct:%s"", ses->acct_name)_",0
"    ELEM_OPT_TLV_E(0x79, NAS_5GS_PDU_TYPE_MM, DE_NAS_5GS_MM_LADN_INF, NULL)_",0
"    ELEM_OPT_TLV_E(0x7F, NAS_5GS_PDU_TYPE_SM, DE_NAS_5GS_SM_MAPPED_EPS_B_CONT, NULL)_",0
"        hp_cipher = quic_get_1rtt_hp_cipher(pinfo, conn, from_server)_",0
#endif /* !HAVE_LIBGCRYPT_AEAD */,0
    if (!PINFO_FD_VISITED(pinfo) && !quic_packet->decryption.error) {,0
        if (!PINFO_FD_VISITED(pinfo) && !quic_packet->decryption.error) {,0
"      GlobalRANNodeID_enum ranmode_id = ngap_get_ranmode_id(&actx->pinfo->dst, actx->pinfo->destport, actx->pinfo)_",0
NAS-PDU	                                   N ngap.ies id-NASC,0
"            ""(Encrypted) payload of a packet"", HFILL }",0
"        proto_tree_add_uint(quic_tree, hf_quic_long_reserved, tvb, offset, 1, first_byte)_",0
        ATTRS_BLOCK \,0
"            {""req"":""load"",""file"":""../test/captures/http2-data-reassembly.pcap""},",0
                            {,0
"                                ""f"": ""frame.encap_type == 1"",",0
"                                ""l"": ""Encapsulation type: Ethernet (1)""",0
target_link_libraries(capchild PRIVATE wsutil),0
		wsutil,0
	${PCAP_LIBRARIES},0
	endif(),0
		set(QT_PACKAGELIST ${QT_PACKAGELIST} Qt5WinExtras),1
	foreach(_qt_package ${QT_PACKAGELIST}),1
	set(LIBXML2_LIBRARIES),1
		${GTHREAD2_INCLUDE_DIRS},1
		${Qt5Svg_INCLUDE_DIRS},0
        // Fallthtough,1
"               FT_UINT8, BASE_DEC, VALS(openflow_v6_oxs_basic_field_values), 0x0,",1
"               FT_UINT8, BASE_HEX, NULL, 0x0,",1
"            # XXX remove the first 0 element, it is not part of the interface.",1
	    va_list ap_,0
"	    va_start(ap, format)_",0
"	sharkd_json_value_anyf(NULL, ""null"")_",1
"	sharkd_json_value_anyf(NULL, ""0"")_",1
		json_dumper_finish(&dumper)_,0
	int *pi = (int *) userdata_,1
	for (i = 0_ i < len_ i++) {,0
"		json_dumper_write_base64(&dumper, &data[i], 1)_",0
"#define sharkd_json_value_anyf(key, format, ...) \",1
do { \,1
	if ((intptr_t)key != (intptr_t)NULL) \,1
"		json_dumper_set_member_name(&dumper, key)_ \",1
	if (format) \,1
"		json_dumper_value_anyf(&dumper, format, ##__VA_ARGS__)_ \",1
"sharkd_session_process_frame_cb_tree(epan_dissect_t *edt, proto_tree *tree, tvbuff_t **tvbs, gboolean display_hidden)",0
		sharkd_json_object_open()_,0
"		sharkd_session_process_frame_cb_tree(edt, tree, tvbs, display_hidden)_",0
			for (i = 0_ i < (int) sizeof(wav_hdr)_ i++),1
		for (i = 0_ i < write_bytes_ i++),1
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""VPP-Opaque"")_",0
"                         major_version, minor_version)_",1
"                         (int) protocol_hint,",0
"  proto_vpp = proto_register_protocol(""VPP Dispatch Trace"", ""VPP"", ""vpp"")_",1
#define WTAP_ENCAP_VPP				205,1
"	{ ""vpp"", ""Vector Packet Processing graph dispatch trace v1"", ""vpp"" },",0
"	{ ""VPP"", ""vpp"" },",0
"_(VLIB_NODE_PROTO_HINT_ETHERNET, eth_maybefcs)  \",1
        case IP6_VERSION:,0
"	{ 280, 		WTAP_ENCAP_VPP },",1
"	{ ""vpp"", ""Vector Packet Processing graph dispatch trace v1"" },",1
  DISSECTOR_ASSERT(prev_layer)_,0
    /* This is a CAN packet */,1
        if (compression_plugin_class_id < -1 || compression_plugin_class_id > 2) {,0
"          expert_add_info_format(pinfo, compression_class_name_item, &ei_rtps_parameter_value_invalid,",0
"            ""Unknown compression plugin class id value. Expected values are [-1,0,1,2]"")_",0
static const value_string isis_lsp_bier_alg_vals[] = {,0
"    proto_tree_add_item(tree, hf_isis_lsp_clv_bier_alg, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
  switch (global_he_trigger_bw) {,0
"                                  tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"=item --help, -h",1
  - perl tools/make-version.pl --set-release --untaggged-version-extra=%#-AppVeyor --taggged-version-extra=-AppVeyor,1
$ tools/make-version.pl --set-release --untaggged-version-extra=-{vcsinfo}-FooCorp --taggged-version-extra=-FooCorp,1
				$num_commits = $parts[-2]_,0
  # Write ASCII (not UTF-16). Cannot use cmd due to repeated '%' unescapes.,0
"  - ps: echo ""`r`nuntagged_version_extra=-%#-AppVeyor`r`ntagged_version_extra=-AppVeyor"" | Out-File -Append -Encoding ASCII version.conf",0
    --verbose		  Print diagnostic messages to STDERR.,1
tortoise_svn: 0,0
"        --expression=""s/^git_description *[=:].*$/git_descripton: $DESCRIPTION"" \",0
"#   version_extra - Like ""format"", but used for the local package version.",1
"		print ""We are tagged.\n""_",1
"    register_dissector(""bssap_imei"", dissect_bssap_imei_dissector, proto_bssap)_",1
"	OSMO_GSUP_MSGT_CHECK_IMEI_ERROR		= 0x31,",0
"        *) printf ""Unknown option %s"" ""$OPTCHAR\\n"" __",1
"        *) printf ""Unknown option %s"" ""$OPTCHAR""",1
"if [ ""$STASH_POP"" == ""True"" ] _ then",1
"string(ip.dst) matches ""^172\.(1[6-9]|2[0-9]|3[0-1])""",0
for odd frames,1
to match a group of stations,1
for all OIDs under a specific node.,1
"string() is useful to convert some fields (like integer, ip addresses or mac",1
"and ""matches"". For example:",1
* A new dfilter function string() has been added. It allows the convertion of,1
"            s = fvalue_to_string_repr(NULL, arg_fvalue, FTREPR_DFILTER, BASE_NONE)_",1
                switch (ftype),0
        checkDFilterFail(dfilter),0
     *  } PreferredAddress_,1
    case SSL_HND_ENCRYPTED_EXTENSIONS:,0
    /*,1
    * t to (t+2)   C-TAG,0
    * The C-TAG field shall be present if the Outer Header Creation Description requests the setting of the C-Tag in Ethernet packet,0
    */,0
    if (value & 0x4000) {,0
"        offset = decode_pfcp_c_tag(tvb, pinfo, tree, item, offset)_",0
    * u to (u+2)   S-TAG,0
    * The S-TAG field shall be present if the Outer Header Creation Description requests the setting of the S-Tag in Ethernet packet,0
    if (value & 0x8000) {,0
"        offset = decode_pfcp_s_tag(tvb, pinfo, tree, item, offset)_",0
	DISSECTOR_ASSERT(width > 1)_,0
		return p_,0
"            register_cb cb, void *client_data)_",0
"    const gint start, gint length, const guint encoding)_",1
"		return val_from_string(fv, s, err_msg)_",0
    - name: Windows (VS2017 x64),1
"    if [ ""$TRAVIS_OS_NAME"" == ""windows"" ]_ then",0
"        compression_plugin_class_id, class_id_enum_names[1 + compression_plugin_class_id])_",0
/* For len() checks that the parameter passed to it is an string or byte type */,0
done,0
    clang-check -analyze ../$FILE || exit_status=1,0
"  { 1, ""Primary"" }",1
    if (fontMetrics().width(text()) + cr.height() > cr.width() || cr.height() < sir.height()) {,1
        // No space to draw,1
        return_,1
    painter.setOpacity(0.25)_,1
"  atm_vpi_vci_table = register_dissector_table(""atm.vpi_vci"", ""ATM VPI VCI"", proto_atm, FT_UINT32, BASE_DEC)_",0
static dissector_table_t atm_vpi_vci_table_,0
  if (atm_info) {,0
"  dissect_atm_cell_payload(tvb, 0, pinfo, tree, AAL_OAMCELL,",0
"  dissect_atm_cell_payload(tvb, offset, pinfo, tree, aal, TRUE, atm_info)_",0
                           NULL)_,0
/BUILD,0
const gunichar2 charset_table_cp1251[0x80] = {	,0
"	UNREPL, 0x2122, 0x0459, 0x203a, 0x045A, 0x045C, 0x045B, 0x045F,        /*      - 0x9F */",0
#define ENC_CP866			0x00000042,0
"    /* Allocate the output now, we cannot create this data structure in threads. */",0
    QModelIndexList selIndeces = tree->selectionModel()->selectedIndexes()_,1
        desktop_show_in_folder(cf_path)_,0
You can get the Npcap Windows packet capture library at {npcap-main-url}.,0
"                json_dumper_value_string(pdata->dumper, fi->hfinfo->abbrev)_",0
"                json_dumper_set_member_name(dumper, field)_",0
        json_dumper_begin_object(dumper)_,0
                    },1
    timeinfo = localtime(&t)_,0
                      json_dumper* dumper),1
"            g_snprintf(str + i * 2, len, ""%02x"", pd[i])_",0
  callback_args.fh = fh_,0
    dumper->flags = JSON_DUMPER_FLAGS_PRETTY_PRINT_,0
WS_DLL_PUBLIC json_dumper* write_json_preamble(FILE *fh)_,1
static json_dumper dumper_,0
    dumper.flags = JSON_DUMPER_FLAGS_PRETTY_PRINT_,1
 * cli_main.h header to rename main to real_main.,1
    int num_rows = selIndeces.count() / tree->model()->columnCount()_,0
"            next_tvb = tvb_new_subset_length(tvb, offset, payload_len - rtp_header_len)_",1
        else,1
"            VALS(frg_names), 0x00C00000, ""Fragmentation bits"", HFILL }},",0
                        self.eth_type[nm]['attr']['DISPLAY'] = 'BASE_DEC|BASE_VAL64_STRING',1
"			#""${GLIB2_DLL_DIR}/libgcc_s_*.dll""",1
"    ""gnutls-*-*-win??ws""",1
#define WTAP_ENCAP_EBHSCR                       279,0
 json_dumper_value_va_list@Base 2.9.1,0
 * escaping occurs. Do not use with untrusted data.,0
WS_DLL_PUBLIC void,0
"    ""_index"": ""packets-2018-12-24"",",0
import unittest,0
        if decode_json:,1
            int(total_length % 256),0
"from inspect import getframeinfo, stack",1
        hex_string = ' '.join('{:02x}'.format(ele) for ele in self.flatten(byte_list)),1
"                ""{}"".format(field): expected_message",1
            self.test_case = request.instance,0
                return flattened_list,0
"#            # text2pcap -u <port>,<port> full.txt out.pcap",0
"            with open(text_file, 'w+') as f:",0
"def dissection_validator(cmd_tshark, cmd_text2pcap):",0
    class  dissection_validator_real:,1
            hex_string = ' '.join('{:02x}'.format(int(ele)) for ele in byte_list),0
            self.dissection_map[hex_string] = expected_result,1
"                self.test_case.assertIn(self.protocol, result) # requires python 3.1",1
        self.maxDiff = None,1
"            ""asterix.019_551_SP4_GOOD"": ""0"" } )",0
"void dissect_oer_not_decoded_yet(proto_tree* tree, packet_info* pinfo, tvbuff_t *tvb, const char* reason)",0
    gchar buf[(CHUNK_SIZE / 3 + 1) * 4 + 4 + 1]_,1
    prepare_token(dumper)_,1
"        fwrite(buf, 1, wrote, dumper->output_file)_",1
 json_dumper_write_base64@Base 2.9.1,0
#define JSON_DUMPER_TYPE(state)         ((enum json_dumper_element_type)((state) & 7)),0
void debug(void){},0
void fuck(void){},0
        dumper->flags |= JSON_DUMPER_FLAGS_ERROR_,0
                (prev_type == JSON_DUMPER_TYPE_NONE || prev_type == JSON_DUMPER_TYPE_OBJECT)_,0
"json_dumper_write_base64(json_dumper* dumper, const char *data, size_t len)",0
    gchar *buf = (gchar *)g_malloc0((len / 3 + 1) * 4 + 4 + 1)_,0
"    if (!json_dumper_check_state(dumper, JSON_DUMPER_END, JSON_DUMPER_TYPE_NONE)) {",0
                ok = TRUE_,1
                (prev_type == JSON_DUMPER_TYPE_BASE64 || prev_type == JSON_DUMPER_TYPE_OBJECT)_,0
    dumper->state[dumper->current_depth] = JSON_DUMPER_TYPE_BASE64_,0
    else,1
"			fprintf(stderr, ""WideCharToMultiByte failed: %d\n"",",0
"			fprintf(stderr,",0
"        <widget class=""QTextEdit"" name=""label_wireshark"">",0
#define JSON_DUMPER_MAX_DEPTH   200,0
"    { 0, """" },",0
"        { &ei_hdcp2_length_6, { ""hdcp2.length.lt6"", PI_PROTOCOL, PI_WARN, ""length must be at least 6"", EXPFILL }},",0
            PROTO_ITEM_SET_GENERATED(ti)_,1
if(ENABLE_SYSTEMD),0
"if (CMAKE_SYSTEM_NAME STREQUAL ""Linux"")",0
"    int start_offset = offset, i_",0
      _ At this point we're deep into the installation process and probably shouldn't abort.,1
"            mt_desc=""IPv4 unicast""_",0
"        proto_tree_add_uint_format ( tree, tree_id, tvb, offset, 2,",0
"static const true_false_string tfs_notsupported_supported = { ""Not Supported"", ""Supported"" }_",0
"        proto_tree_add_boolean(tree, hf_isis_lsp_prefix_attr_flags_x, tvb, offset, 1, flags)_",0
"        snprintf(ti_text, 64, ""Flags:%c%c%c"",",0
"        sc_tree = proto_tree_add_subtree(tree, tvb, offset, ue_add_sec_cap_len, ett_gtpv2_mm_context_sc, NULL, ""Security Capability"")_",0
"                g_queue_push_tail(tapinfo->graph_analysis->items, new_gai)_",0
  if ((v1->conversation == v2->conversation) &&,0
"      (!strcmp(v1->tag, v2->tag)))",0
    return 1_,0
  val = (guint)(wmem_str_hash(key->tag) * 37 + key->conversation * 765)_,0
       * Otherwise if a tag is present then extract tokens.,0
    return_,1
"        self.assertRun(tshark_cmd, shell=True)",0
E<lt>intf-nameE<gt>.,0
"        offset = decode_pfcp_source_interface(tvb, pinfo, tree, item, offset)_",0
#include <stdio.h>,1
#define ETHER_TYPE_GEONETWORKING 0x8947,0
    if (addrdata[0] & 0x80) ,0
    if (addr[0] & 0x80) ,1
"        l2 = g_strlcpy(rname, string, MAXNAMELEN-l1-3)_",1
    // XXX We could use ether_name_resolution_str: ,1
                     * 8  ,1
 * Intelligent Transport Systems (ITS)_ ,1
"    proto_tree_add_item(btpa_tree, hf_btpa_dstport, tvb, 0, 2, ENC_NA)_",1
"    proto_tree_add_item(btpb_tree, hf_btpb_dstport, tvb, 0, 2, ENC_NA)_",1
"    ti = proto_tree_add_item(geonw_bh_tree, hf_geonw_bh_reserved, tvb, offset, 1, ENC_NA)_",1
"        ti = proto_tree_add_item(geonw_ch_tree, hf_geonw_ch_payload_length, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
 * GeoNetworking_ ,0
"                tree_item = proto_tree_add_string(tree, hf_bacapp_present_value_octet_string, tvb, offset, lvt+tag_len, str)_",0
"                ""%sany"", label)_",0
"        proto_tree_add_string(subtree, hf_bacapp_present_value_time, tvb, offset, lvt+tag_len, wmem_strbuf_get_str(strbuf))_",0
"                wmem_strbuf_append_printf(strbuf, ""%s"", out)_",0
"        proto_tree_add_string(subtree, hf_bacapp_present_value_bit_string, tvb, offset, offs+lvt, wmem_strbuf_get_str(strbuf))_",1
"            FT_STRING, STR_UNICODE, NULL, 0, NULL, HFILL }",1
"        subtree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_bacapp_tag, NULL, ""present-value"")_",0
"        subtree = proto_tree_add_subtree(tree, tvb, offset, bool_len, ett_bacapp_tag, NULL, ""present-value"")_",0
        } else {,1
#define ETHER_TYPE_GEONETWORKING	0x8947	/* GeoNetworking as defined in ETSI EN 302 636-4-1. */,0
"          FT_UINT32, BASE_DEC, NULL, 0x7fffffff,",0
        msgtype = MSG_INVALID_,0
/* Prototypes */,0
    len = tvb_captured_length(tvb)_,1
    offset += len_,1
"		COMMAND chmod +x ""${_ai_appdir}/AppRun""",1
#!/bin/bash,0
"HERE=""$(dirname ""$(readlink -f ""${0}"")"")""",1
"    BINARY_NAME=$(basename ""$0"")",1
    guint32		homeplug_av_oui_,1
"          { ""Type"", ""homeplug_av.mmhdr.mmtype"",",0
"            FT_BYTES, SEP_COLON, NULL, 0x00, NULL, HFILL }",0
            case SAFNUM_MCAST_VPN:,0
"            { ""Sub-TLV Length"", ""isis.lsp.ext_is_reachability.subclvs_length"",",1
#include <inttypes.h>,0
         preq_info->connInfo->FwdOpenPathLenBytes = conn_path_size_,0
   /* Display originator to target actual packet interval */,1
"   memset(&conn_info, 0, sizeof(conn_info))_",0
   /* Save the connection info for the conversation filter */,0
* length.,0
                Added Fast Extension */,0
"   { BITTORRENT_MESSAGE_EXTENDED,       ""Extended"" },",0
"      ""Diplexer Upstream Upper Band Edge"", HFILL}",0
"  { 2, ""Majority and persist on master""},",0
    while (bytes_remaining > 0) {,0
    /* FrameInfo starts with a 'tag' byte which is formed from 2 nibbles */,0
"	set(ENABLE_RPATH_ORIGIN ${_enable_rpath_origin} CACHE BOOL ""Use $ORIGIN with RPATH"")",0
			),0
"	elseif(CMAKE_SYSTEM_NAME STREQUAL ""NetBSD"" OR",0
"		set(CMAKE_INSTALL_RPATH ""${DSO_RPATH_ORIGIN}"")",1
	SET(CMAKE_SKIP_BUILD_RPATH FALSE),0
	SET(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE),0
	SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE),0
"	add_definitions(""/DNPCAP_VERSION=${NPCAP_VERSION}"")",0
"	g_string_append(str, ""with WinPcap ("" G_STRINGIFY(NPCAP_VERSION) "")"")_",0
"Text=This text will be replaced, depending if NPcap is already installed",1
      offset += label_len_,0
      len -= label_len_,1
"          offset += awdl_add_tagged_field(pinfo, tagged_tree, tvb, offset, TAG_LENGTH_SHORT)_",0
		${ZLIB_LIBRARIES},1
target_link_libraries(caputils PUBLIC ${PCAP_LIBRARIES}) ,0
"     * Windows 7, http://go.microsoft.com/fwlink/p/?linkid=217865",0
" * Copyright 2018, Peter Wu <peter@lekensteyn.nl>",0
  guint        next_tap_block_num_,0
"    blocknum_item = proto_tree_add_uint(tftp_tree, hf_tftp_blocknum, tvb, offset, 2, blocknum)_",0
    if (!pinfo->fd->flags.visited) {,1
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", Block: %i%s"",",0
"    proto_tree_add_uint(tftp_tree, hf_tftp_blocknum, tvb, offset, 2,",0
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", Block: %i"",",0
    if (!frame_numbers.isEmpty()) {,0
    filter_str = filter_str.right(filter_str.length() - 3)_,0
"parse_ether_address_fast(const guint8 *cp, ether_t *eth, unsigned int *mask,",0
"        proto_tree_add_item(settings_tree, hf_http2_settings_identifier, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"            ""  -6 <srcip>,<destip>    prepend dummy IPv6 header with specified\n""",0
        }else if (i == 8) {,1
anonsvn			<anonsvn[AT]localhost>,0
"        // This dummy value exists to permit unconditionally adding ',' in the taps callback.",0
" *   (o) geoip	    - whether GeoIP information is available, boolean",0
	// XXX why is this 0? webshark.js ignores this first element while iterating.,1
get_f5info_platform_name(,0
"                    col_set_str(pinfo->cinfo, COL_INFO, (char *) tvb_get_string_enc(wmem_packet_scope(), tvb, eq_off, val_len, ENC_UTF_8))_",1
   {,0
"        g_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_DEBUG, ""spawn output: %s"", local_output)_",0
        quoted_arg = protect_arg(*tmp)_,0
"    gboolean spawned = g_spawn_async_with_pipes(NULL, (gchar **)args->pdata, NULL,",0
            check_vals[0]['idb_count'] = 11,0
"    {&hf_docsis_tlv_tcc_p_16hi,",0
	# compilers warn about it. Silence those older compilers. All versions,0
                if (tvb_reported_length(tvb) > 8) {,1
#include <epan/packet_info.h>,0
    if (global_capture_opts.ifaces->len == 1 && !global_ld.passthrough_shb) {,0
    pcap_src->cap_pipe_state = STATE_EXPECT_DATA_,1
"        memcpy(global_ld.passthrough_shb, pcap_src->cap_pipe_databuf, bh->block_total_length)_",1
"        memcpy(idb_source.idb, pcap_src->cap_pipe_databuf, bh->block_total_length)_",1
        if (idb_source.deleted) {,1
"        g_array_append_val(pcap_src->cap_pipe_info.pcapng.src_iface_to_global, iface_id)_",1
        if (idb_source.idb && idb_source.idb_len) {,0
        if (capture_opts->use_pcapng) {,0
                    if (queue_element->u.bh.block_type != BLOCK_TYPE_SHB) {,1
            /* Our input and output IDBs are the same. */,1
    if (ld->pcapng_passthrough) {,1
		    compression_type++) {,0
	    compression_type++) {,0
"            dissect_ssl3_alert(decrypted, pinfo, ssl_record_tree, 0, record_length, session)_",0
"            ti_lcaf_prefix = proto_tree_add_item(prefix_tree, hf_lisp_tcp_message_eid_lcaf, tvb, offset, addr_len, ENC_NA)_",0
"            ti_lcaf_prefix = proto_tree_add_item(lisp_mapping_tree, hf_lisp_mapping_eid_lcaf, tvb, offset, addr_len, ENC_NA)_",0
"            ti_lcaf_src_eid = proto_tree_add_item(lisp_tree, hf_lisp_mreq_srceid_lcaf, tvb, offset, addr_len, ENC_NA)_",0
     case PID_DOMAIN_TAG: {,0
"	   rtps_util_add_string(rtps_parameter_tree, tvb, offset, hf_rtps_domain_tag, encoding)_",0
"    { &hf_rtps_domain_tag,{",0
  - pytest -nauto -ra -v ../test,0
"        wtap_block_add_string_option_format(g_array_index(params.shb_hdrs, wtap_block_t, 0), OPT_SHB_USERAPPL, ""TShark (Wireshark) %s"", get_ws_vcs_version_info())_",0
"                                  &params, &err)_",0
"    	.snaplen = WTAP_MAX_PACKET_SIZE_STANDARD,",0
        /* XXX other blocks like NRB are now discarded. */,0
	wtap_dump_params params = WTAP_DUMP_PARAMS_INIT_,1
 * Initialize the per-file finformation based on an existing file. Its,0
	guint8 src_ip_d1_,0
    	 */,0
                    (unsigned long)(sizeof tlvh + sizeof private_state->time_format))_,0
        case FT_ACK_OLD:{,0
"		ssh_options_set(sshs, SSH_OPTIONS_LOG_VERBOSITY, &debug_level)_",0
	ssh_params->port = 22_,1
"			if (!ws_strtou32(optarg, NULL, &ssh_params->port) || ssh_params->port == 0) {",1
	if (!(*ssh_params)),1
	guint port_,0
	},1
"                                                       &params,",0
"    d = wtap_dump_open(filename, filetype, encap, 0, FALSE, &params, &err)_",0
"    extcap_dumper.dumper.wtap = wtap_dump_open(fifo, WTAP_FILE_TYPE_SUBTYPE_PCAP_NSEC, encap, PACKET_LENGTH, FALSE, &params, &err)_",0
"			&params, &err)_",0
"    import_info_.wdh = wtap_dump_open_tempfile(&tmpname, ""import"", WTAP_FILE_TYPE_SUBTYPE_PCAP, import_info_.encapsulation, import_info_.max_frame_length, FALSE, &params, &err)_",0
    wtapng_dump_params           ng_params = { .idb_inf = NULL }_,1
  wtapng_dump_params ng_params = { .idb_inf = NULL }_,1
/* packet-blip.c ,0
	decompress_stream->avail_in = length_,1
"	col_clear(pinfo->cinfo,COL_INFO)_",0
"	gchar* msg_num = g_strdup_printf(""#%"" G_GUINT64_FORMAT, value_message_num)_",0
	pool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE)_,0
    ${CMAKE_CURRENT_SOURCE_DIR}/packet-blip.c,0
//,0
static gboolean is_compressed(guint64)_,0
"    printf(""BLIP message number: %"" G_GUINT64_FORMAT ""\n"", value_message_num)_",0
get_message_type(guint64 value_frame_flags),0
    static const value_string flag_combos[] = {,0
			goto end_,0
"void set_pdcp_nr_proto_data(packet_info *pinfo, pdcp_nr_info *p_pdcp_nr_info)_",0
	if (!sshs) {,0
"    def test_http2_data_reassembly(self, cmd_tshark, features, dirs, test_env):",0
# http://public.kitware.com/Bug/view.php?id=13818,0
"PS$>$Env:Path += ""_C:\Python37\Scripts""",1
"        length = (gint)tvb_captured_length_remaining(tvb, offset)_",0
* Add Secure Reliable Transport dissector,0
TPM 2.0 protocol,0
WireGuard protocol,0
/* c-basic-offset: 4_ tab-width: 8_ indent-tabs-mode: nil,0
/* WireShark headers go here */,0
#include <epan/packet.h>   /* Should be first Wireshark include (other than config.h) */,0
/* (Required to prevent [-Wmissing-prototypes] warnings */,0
/* Copied from common.h file: */,0
static const value_string srt_packet_types[] = {,0
"            FT_UINT32, BASE_DEC,",0
"#define KITEM(name) {SRT_KM_S_##name, #name}",0
"            VALS(srt_ctrlmsg_exttypes), 0xffff, NULL, HFILL}},",0
sudo: required,0
    - name: OSX clang PCAP,0
    - name: OSX clang NOPCAP,0
    - name: OSX xcode10.1 NOPCAP,0
"  - if [ ""$PCAP"" == ""ON"" ]_ then ninja test-programs && ctest -j_ fi",0
    - os: linux,0
    - os: osx,0
"			*err_info = g_strdup(""NO PROXY OMMAND"")_",0
      udp_p_info->ts_del = NULL_,0
  udp_per_packet_data->heur_dtbl_entry = NULL_,1
  if (!pinfo->flags.in_error_pkt) {,0
"  ""Time delta from previous frame in this UDP stream"", HFILL }_",0
  /* Do we need to calculate timestamps relative to the udp-stream? */,0
  /* Different boolean preferences have to be checked. */,0
  /* If the protocol is UDP then the UDP preference */,0
  if ((ip_proto == IP_PROTO_UDP && udp_calculate_ts),0
      /* Otherwise the UDP-Lite preference */,0
      || (ip_proto != IP_PROTO_UDP && udplite_calculate_ts)) {,0
"      udp_handle_timestamps(pinfo, tvb, udp_tree, udpd, ip_proto)_",0
  },1
  udpd->ts_first.secs=pinfo->abs_ts.secs_,1
"udp_calculate_timestamps(packet_info *pinfo, struct udp_analysis *udpd, int proto)",0
"  udp_p_info_t *udppd = (udp_p_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto, pinfo->curr_layer_num)__",1
  if( !udppd ) {,1
  if (!udpd),0
  if (ip_proto == IP_PROTO_UDP ? udp_calculate_ts : udplite_calculate_ts) {,0
    if (name && strlen(name) > 0) {,0
"                    proto_item_append_text(item, "" (%""G_GINT64_MODIFIER""f)"", tvb_get_letohieee_float(tvb, *offset))_",0
        if (pipedata && pipedata->stdout_fd > 0),0
            ws_pipe_close((ws_pipe_t *) interface_opts->extcap_pipedata)_,0
"        proto_tree_add_item(ts2_tree, hf_ts2_channel_name, tvb, offset, string_len , ENC_ASCII|ENC_NA)_",0
"        proto_tree_add_item(ts2_tree, hf_ts2_channel_topic, tvb, offset, string_len ,ENC_ASCII|ENC_NA)_",0
"        proto_tree_add_item(ts2_tree, hf_ts2_channel_description, tvb, offset, string_len , ENC_ASCII|ENC_NA)_",0
"          { ""HV1 may be used"",        ""bthci_cmd.sco_packet_type.hv1"",",0
"	SEP_NONE     = 18,  /**< hexadecimal bytes with no separator between each byte */",0
"        printf(""Expert tap error (%s)!\n"", error_string->str)_",1
"                proto_item_append_text(parameter_tree, "" %u"", tvb_get_guint8(tvb, offset))_",0
            case SSL_HND_QUIC_TP_MAX_ACK_DELAY:,0
            pseudoh6.dst_addr6  = HDR_IPv6.ip6_dst_,0
"        if ( line.contains(""Acknowledgements"") )",1
"        super(case_text2pcap_headers, self).__init__(proc_args, *args, **kwargs)",1
            pseudoh.length      = g_htons(length - header_length + sizeof(HDR_UDP))_,0
"                                    proto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_sampling_frequency_16000, tvb, offset + 6, 1, ENC_NA)_",0
                                } else {,0
"        dfilter = ""icmp.resptime == 492.205""",0
"		(guint8)rootdispersion, ""%8.6f seconds"", rootdispersion)_",0
"			""Root Dispersion"", ""ntp.rootdispersion"", FT_UINT8, BASE_NONE|BASE_UNIT_STRING,",0
static header_field_info* hfi_rootdispersion_,0
	PROTO_ITEM_SET_GENERATED(ti)_,0
	hfi_rootdispersion = proto_registrar_get_nth(hf_ntp_rootdispersion)_,1
"	proto_tree_add_double_format_value(ntp_tree, hf_ntp_rootdispersion, tvb, 8, 4,",0
"	proto_tree_add_double_format_value(ntp_tree, hf_ntp_rootdelay, tvb, 4, 4,",0
"	rootdelay = tvb_get_ntohl(tvb, 8)_",0
"		(guint32)rootdelay, ""%8.6f seconds"", rootdelay_double)_",1
"		(guint32)rootdispersion, ""%8.6f seconds"", rootdispersion_double)_",1
"			&units_second_seconds, 0, ""Total round-trip delay to the reference clock"", HFILL }},",1
"    ti = proto_tree_add_uint(context_tree, hf_mac_nr_context_harqid,",0
    guint8 isprint_,0
    for ( i = 0_ i < len_ i++){,0
        if (!g_ascii_isprint(ptr[i])){,0
            isprint = 0_,0
            break_,1
    /* (p+1) to q   Header Field Value */,1
 * Routines for DICOM dissection,1
 * script from the following sources:,0
""""""" + ""\n\n"".join(""\n"".join(f'#define {uid_define_name(uid)} ""{uid[0]}""' ",0
#define TSDNS_PORT  41144,0
  PROTO_ITEM_SET_HIDDEN(hidden_item)_,0
"   {WNSRP_RESPONSE_HEADER, ""WNSRP response""},",0
# AppVeyor prevents to store artifacts exceeding 50000 Mb. Commenting out ,0
  lineno = *plineno_,0
	list(APPEND fuzzshark_LIBS FuzzingEngine),1
  gboolean          ret = TRUE_,0
        ret = TRUE_,0
    ret = FALSE_,0
    WSLUA_RETURN(1)_,0
static int Address_eth(lua_State *L),0
"        g_warning(""invalid eth addr"")_",1
"    addMatchFields(ether_match_fields, Address.ether('1:2:3:4:5:6'))",1
"                r.strptr = g_strdup(lua_tostring(L,-1))_",1
            if (key_count >= 3) {,0
"                luaL_argerror(L, inner_idx, ""Inner tables of a range string cannot contain more than three elements"")_",0
----------------------------------------,0
        ws_close(pipedata->stderr_fd)_,1
#ifdef _MSC_VER,1
#pragma warning(4:)     // max warning level,0
#pragma warning(error:) // warnings as errors,0
#include <epan/tvbuff.h>,0
  if( !nonce ),0
  {,0
"    memset( p_result, 0, KNX_KEY_LENGTH )_",0
  else,0
"    memcpy( p_result, nonce, nonce_length )_",0
    while( nonce_length < KNX_KEY_LENGTH ),0
    {,1
      p_result[ nonce_length++ ] = 0x00_,0
  return result_,0
"void read_knx_keyring_xml_file( const gchar* path_name, const gchar* password )",0
  gint additionalInfoLength = cemi_telegram[ 1 ]_,0
          innerTelegram[ additionalInfoLength + 8 ] = (guint8) (size2 - 1)_,0
"            const guint8* encrypted = tvb_get_ptr( tvb, offset, -1 )_",1
"          const guint8* a_data = tvb_get_ptr( tvb, offset, -1 ) - a_length_",1
			my $license1 = $1_,0
"              ""mac-nr.control.me-phr.ph.type1-pcell"", FT_UINT8, BASE_DEC, NULL, 0x3f,",0
    /* Will these be include in the ME PHR report? */,0
				// vesion == 0,0
    ether_t eth_,0
"[{extcap-base,randpktdump,ssh-base,sshdump,udpdump}.[ch]]",1
#include <wsutil/unicode-utils.h>,0
                            /* Show BSR values.  TODO: report in expert info that Long BSR case is truncated... */,0
                            /* TODO: check change in offset against PDU_length */,0
"	offset = dcom_tvb_get_nwstringz0(tvb, offset, u32ArraySize*2, pszStr, u32MaxStr, &isPrintable)_",1
"    self.assertRun((config.cmd_text2pcap,) + args + (testin_file, testout_file))",1
"        self.assertEqual({'encapsulation': u'Ethernet', 'packets': 1,",1
"gboolean file_has_text_entries(const char *fname, int comment)",0
        gquic_info->version = 0x34_,0
        if (version != 0) {,0
"                ti = proto_tree_add_item(subheader_tree, hf_mac_nr_ulsch_sdu,",0
"    { CCCH_LCID,                            ""CCCH (64 bits)""},",0
VALUE	3GPP-RAT-Type			Virtual			7,0
ATTRIBUTE	3GPP-Negotiated-DSCP			26	byte,0
            sel_ret = 1_,1
            if (!pcap_src->from_cap_socket) {,0
                if (pcap_src->cap_pipe_fd == -1) {,0
        if (pcap_src->from_cap_socket) {,0
    /* For now only dissect complete PDUs */,1
"        &global_rlc_nr_call_pdcp_for_drb, pdcp_drb_col_vals, FALSE)_",1
/* Routines for NR RLC disassembly,1
 * Pascal Quantin,1
 * SPDX-License-Identifier: GPL-2.0-or-later,1
#include <epan/exceptions.h>,1
#include <epan/expert.h>,1
#include <epan/prefs.h>,1
#include <epan/proto_data.h>,1
"#include ""packet-rlc-nr.h""",1
"#include ""packet-pdcp-nr.h""",1
/* Described in:,1
 * 3GPP TS 38.322 NR_ Radio Link Control (RLC) protocol specification v15.0.0,1
/* TODO:,1
- add sequence analysis,1
- add reassembly,1
- add tap info,1
- call more upper layer dissectors once they appear,1
void proto_register_rlc_nr(void)_,1
void proto_reg_handoff_rlc_nr(void)_,1
/********************************/,1
/* Preference settings          */,1
/* By default do call PDCP/RRC dissectors for SDU data */,1
static gboolean global_rlc_nr_call_pdcp_for_srb = TRUE_,1
"enum pdcp_for_drb { PDCP_drb_off, PDCP_drb_SN_12, PDCP_drb_SN_18}_",1
static const enum_val_t pdcp_drb_col_vals[] = {,1
"    {""pdcp-drb-off"",           ""Off"",                 PDCP_drb_off},",1
"    {""pdcp-drb-sn-12"",         ""12-bit SN"",           PDCP_drb_SN_12},",1
"    {""pdcp-drb-sn-18"",         ""18-bit SN"",           PDCP_drb_SN_18},",1
"    {NULL, NULL, -1}",1
static gint global_rlc_nr_call_pdcp_for_drb = (gint)PDCP_drb_off_,1
static gboolean global_rlc_nr_call_rrc_for_ccch = TRUE_,1
/* Preference to expect RLC headers without payloads */,1
static gboolean global_rlc_nr_headers_expected = FALSE_,1
/**************************************************/,1
/* Initialize the protocol and registered fields. */,1
int proto_rlc_nr = -1_,1
extern int proto_pdcp_nr_,1
static dissector_handle_t pdcp_nr_handle_,1
static dissector_handle_t nr_rrc_bcch_bch_,1
/* Decoding context */,1
static int hf_rlc_nr_context = -1_,1
static int hf_rlc_nr_context_mode = -1_,1
static int hf_rlc_nr_context_direction = -1_,1
static int hf_rlc_nr_context_ueid = -1_,1
static int hf_rlc_nr_context_bearer_type = -1_,1
static int hf_rlc_nr_context_bearer_id = -1_,1
static int hf_rlc_nr_context_pdu_length = -1_,1
static int hf_rlc_nr_context_sn_length = -1_,1
/* Transparent mode fields */,1
static int hf_rlc_nr_tm = -1_,1
static int hf_rlc_nr_tm_data = -1_,1
/* Unacknowledged mode fields */,1
static int hf_rlc_nr_um = -1_,1
static int hf_rlc_nr_um_header = -1_,1
static int hf_rlc_nr_um_si = -1_,1
static int hf_rlc_nr_um_reserved = -1_,1
static int hf_rlc_nr_um_sn6 = -1_,1
static int hf_rlc_nr_um_sn12 = -1_,1
static int hf_rlc_nr_um_so = -1_,1
static int hf_rlc_nr_um_data = -1_,1
/* Acknowledged mode fields */,1
static int hf_rlc_nr_am = -1_,1
static int hf_rlc_nr_am_header = -1_,1
static int hf_rlc_nr_am_data_control = -1_,1
static int hf_rlc_nr_am_p = -1_,1
static int hf_rlc_nr_am_si = -1_,1
static int hf_rlc_nr_am_sn12 = -1_,1
static int hf_rlc_nr_am_sn18 = -1_,1
static int hf_rlc_nr_am_reserved = -1_,1
static int hf_rlc_nr_am_so = -1_,1
static int hf_rlc_nr_am_data = -1_,1
/* Control fields */,1
static int hf_rlc_nr_am_cpt = -1_,1
static int hf_rlc_nr_am_ack_sn = -1_,1
static int hf_rlc_nr_am_e1 = -1_,1
static int hf_rlc_nr_am_e2 = -1_,1
static int hf_rlc_nr_am_e3 = -1_,1
static int hf_rlc_nr_am_nack_sn = -1_,1
static int hf_rlc_nr_am_so_start = -1_,1
static int hf_rlc_nr_am_so_end = -1_,1
static int hf_rlc_nr_am_nack_range = -1_,1
static int hf_rlc_nr_am_nacks = -1_,1
static int hf_rlc_nr_header_only = -1_,1
/* Subtrees. */,1
static int ett_rlc_nr = -1_,1
static int ett_rlc_nr_context = -1_,1
static int ett_rlc_nr_um_header = -1_,1
static int ett_rlc_nr_am_header = -1_,1
static expert_field ei_rlc_nr_context_mode = EI_INIT_,1
static expert_field ei_rlc_nr_am_nack_sn = EI_INIT_,1
static expert_field ei_rlc_nr_am_nack_sn_ahead_ack = EI_INIT_,1
static expert_field ei_rlc_nr_am_nack_sn_ack_same = EI_INIT_,1
static expert_field ei_rlc_nr_am_nack_range = EI_INIT_,1
static expert_field ei_rlc_nr_am_cpt = EI_INIT_,1
static expert_field ei_rlc_nr_um_data_no_data = EI_INIT_,1
static expert_field ei_rlc_nr_am_data_no_data = EI_INIT_,1
static expert_field ei_rlc_nr_am_nack_sn_partial = EI_INIT_,1
static expert_field ei_rlc_nr_bytes_after_status_pdu_complete = EI_INIT_,1
static expert_field ei_rlc_nr_um_sn = EI_INIT_,1
static expert_field ei_rlc_nr_am_sn = EI_INIT_,1
static expert_field ei_rlc_nr_header_only = EI_INIT_,1
static expert_field ei_rlc_nr_reserved_bits_not_zero = EI_INIT_,1
static expert_field ei_rlc_nr_no_per_frame_info = EI_INIT_,1
static expert_field ei_rlc_nr_unknown_udp_framing_tag = EI_INIT_,1
/* Value-strings */,1
static const value_string direction_vals[] =,1
"    { DIRECTION_UPLINK,   ""Uplink"" },",1
"    { DIRECTION_DOWNLINK, ""Downlink"" },",1
static const value_string rlc_mode_short_vals[] =,1
"    { RLC_TM_MODE, ""TM"" },",1
"    { RLC_UM_MODE, ""UM"" },",1
"    { RLC_AM_MODE, ""AM"" },",1
static const value_string rlc_mode_vals[] =,1
"    { RLC_TM_MODE, ""Transparent Mode"" },",1
"    { RLC_UM_MODE, ""Unacknowledged Mode"" },",1
"    { RLC_AM_MODE, ""Acknowledged Mode"" },",1
static const value_string rlc_bearer_type_vals[] =,1
"    { BEARER_TYPE_CCCH,        ""CCCH"" },",1
"    { BEARER_TYPE_BCCH_BCH,    ""BCCH BCH"" },",1
"    { BEARER_TYPE_PCCH,        ""PCCH"" },",1
"    { BEARER_TYPE_SRB,         ""SRB"" },",1
"    { BEARER_TYPE_DRB,         ""DRB"" },",1
"    { BEARER_TYPE_BCCH_DL_SCH, ""BCCH DL-SCH"" },",1
static const value_string seg_info_vals[] =,1
"    { 0, ""Data field contains all bytes of an RLC SDU"" },",1
"    { 1, ""Data field contains the first segment of an RLC SDU"" },",1
"    { 2, ""Data field contains the last segment of an RLC SDU"" },",1
"    { 3, ""Data field contains neither the first nor last segment of an RLC SDU"" },",1
static const true_false_string data_or_control_vals =,1
"    ""Data PDU"",",1
"    ""Control PDU""",1
static const true_false_string polling_bit_vals =,1
"    ""Status report is requested"",",1
"    ""Status report not requested""",1
static const value_string control_pdu_type_vals[] =,1
"    { 0, ""STATUS PDU"" },",1
static const true_false_string am_e1_vals =,1
"    ""A set of NACK_SN, E1, E2 and E3 follows"",",1
"    ""A set of NACK_SN, E1, E2 and E3 does not follow""",1
static const true_false_string am_e2_vals =,1
"    ""A set of SOstart and SOend follows for this NACK_SN"",",1
"    ""A set of SOstart and SOend does not follow for this NACK_SN""",1
static const true_false_string am_e3_vals =,1
"    ""NACK range field follows for this NACK_SN"",",1
"    ""NACK range field does not follow for this NACK_SN""",1
static const true_false_string header_only_vals =,1
"    ""RLC PDU Headers only"",",1
"    ""RLC PDU Headers and body present""",1
/********************************************************/,1
/* Forward declarations & functions                     */,1
"static void dissect_rlc_nr_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean is_udp_framing)_",1
/* Write the given formatted text to:,1
   - the info column,1
   - the top-level RLC PDU item,1
   - another subtree item (if supplied) */,1
"static void write_pdu_label_and_info(proto_item *pdu_ti, proto_item *sub_ti,",1
"                                     packet_info *pinfo, const char *format, ...)",1
    #define MAX_INFO_BUFFER 256,1
    static char info_buffer[MAX_INFO_BUFFER]_,1
    va_list ap_,1
"    va_start(ap, format)_",1
"    g_vsnprintf(info_buffer, MAX_INFO_BUFFER, format, ap)_",1
    va_end(ap)_,1
    /* Add to indicated places */,1
"    col_append_str(pinfo->cinfo, COL_INFO, info_buffer)_",1
"    proto_item_append_text(pdu_ti, ""%s"", info_buffer)_",1
    if (sub_ti != NULL) {,1
"        proto_item_append_text(sub_ti, ""%s"", info_buffer)_",1
"/* Version of function above, where no g_vsnprintf() call needed",1
"static void write_pdu_label_and_info_literal(proto_item *pdu_ti, proto_item *sub_ti,",1
"                                             packet_info *pinfo, const char *info_buffer)",1
"/* Show in the info column how many bytes are in the UM/AM PDU, and indicate",1
   whether or not the beginning and end are included in this packet */,1
"static void show_PDU_in_info(packet_info *pinfo,",1
"                             proto_item *top_ti,",1
"                             gint32 length,",1
                             guint8 seg_info),1
    /* Reflect this PDU in the info column */,1
    if (length > 0) {,1
"        write_pdu_label_and_info(top_ti, NULL, pinfo,",1
"                                 ""  %s%u-byte%s%s"",",1
"                                 (seg_info & 0x02) ? "".."" : ""["",",1
"                                 length,",1
"                                 (length > 1) ? ""s"" : """",",1
"                                 (seg_info & 0x01) ? "".."" : ""]"")_",1
"                                 ""  %sunknown-bytes%s"",",1
"/* Show an SDU. If configured, pass to PDCP/RRC dissector */",1
"static void show_PDU_in_tree(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, gint offset, gint length,",1
"                             rlc_nr_info *rlc_info, guint32 seg_info _U_)",1
    /* Add raw data (according to mode) */,1
"    proto_tree_add_item(tree, (rlc_info->rlcMode == RLC_AM_MODE) ?",1
"                        hf_rlc_nr_am_data : hf_rlc_nr_um_data,",1
"                        tvb, offset, length, ENC_NA)_",1
    /* TODO: handle reassembled PDCP PDUs. */,1
    if (seg_info == 0) {  /* i.e. contains whole SDU */,1
        if ((global_rlc_nr_call_pdcp_for_srb && (rlc_info->bearerType == BEARER_TYPE_SRB)) ||,1
           ((global_rlc_nr_call_pdcp_for_drb != PDCP_drb_off) && (rlc_info->bearerType == BEARER_TYPE_DRB))) {,1
            /* Get whole PDU into tvb */,1
"            tvbuff_t *pdcp_tvb = tvb_new_subset_length(tvb, offset, length)_",1
            /* Reuse or allocate struct */,1
            struct pdcp_nr_info *p_pdcp_nr_info_,1
"            p_pdcp_nr_info = (pdcp_nr_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_pdcp_nr, 0)_",1
            if (p_pdcp_nr_info == NULL) {,1
"                p_pdcp_nr_info = wmem_new0(wmem_file_scope(), pdcp_nr_info)_",1
                /* Store info in packet */,1
"                p_add_proto_data(wmem_file_scope(), pinfo, proto_pdcp_nr, 0, p_pdcp_nr_info)_",1
            /* Fill in struct params. */,1
            p_pdcp_nr_info->direction = rlc_info->direction_,1
            p_pdcp_nr_info->ueid = rlc_info->ueid_,1
            switch (rlc_info->bearerType) {,1
                case BEARER_TYPE_SRB:,1
                    p_pdcp_nr_info->plane = NR_SIGNALING_PLANE_,1
                    p_pdcp_nr_info->bearerType = Bearer_DCCH_,1
                    p_pdcp_nr_info->seqnum_length = 12_,1
                    break_,1
                case BEARER_TYPE_DRB:,1
                    p_pdcp_nr_info->plane = NR_USER_PLANE_,1
                    switch (global_rlc_nr_call_pdcp_for_drb) {,1
                        case PDCP_drb_SN_12:,1
                            p_pdcp_nr_info->seqnum_length = 12_,1
                            break_,1
                        case PDCP_drb_SN_18:,1
                            p_pdcp_nr_info->seqnum_length = 18_,1
                default:,1
                    /* Shouldn't get here */,1
                    return_,1
            p_pdcp_nr_info->bearerId = rlc_info->bearerId_,1
            /* Assume no SDAP present */,1
            p_pdcp_nr_info->sdap_header = 0_,1
            p_pdcp_nr_info->rohc.rohc_compression = FALSE_,1
            p_pdcp_nr_info->is_retx = FALSE_,1
            p_pdcp_nr_info->pdu_length = length_,1
            TRY {,1
"                call_dissector_only(pdcp_nr_handle, pdcp_tvb, pinfo, tree, NULL)_",1
            CATCH_ALL {,1
            ENDTRY,1
/***************************************************/,1
/* Transparent mode PDU. Call RRC if configured to */,1
"static void dissect_rlc_nr_tm(tvbuff_t *tvb, packet_info *pinfo,",1
"                              proto_tree *tree,",1
"                              int offset,",1
"                              rlc_nr_info *p_rlc_nr_info,",1
                              proto_item *top_ti),1
    proto_item *raw_tm_ti_,1
    proto_item *tm_ti_,1
    /* Create hidden TM root */,1
"    tm_ti = proto_tree_add_string_format(tree, hf_rlc_nr_tm,",1
"                                         tvb, offset, 0, """", ""TM"")_",1
    PROTO_ITEM_SET_HIDDEN(tm_ti)_,1
    /* Remaining bytes are all data */,1
"    raw_tm_ti = proto_tree_add_item(tree, hf_rlc_nr_tm_data, tvb, offset, -1, ENC_NA)_",1
    if (!global_rlc_nr_call_rrc_for_ccch) {,1
"                                 ""                               [%u-bytes]"", tvb_reported_length_remaining(tvb, offset))_",1
    if (global_rlc_nr_call_rrc_for_ccch) {,1
"        tvbuff_t *rrc_tvb = tvb_new_subset_remaining(tvb, offset)_",1
        dissector_handle_t protocol_handle_,1
        switch (p_rlc_nr_info->bearerType) {,1
        case BEARER_TYPE_BCCH_BCH:,1
                protocol_handle = nr_rrc_bcch_bch_,1
                break_,1
        case BEARER_TYPE_BCCH_DL_SCH:,1
        case BEARER_TYPE_PCCH:,1
        case BEARER_TYPE_CCCH:,1
        case BEARER_TYPE_SRB:,1
        case BEARER_TYPE_DRB:,1
"                /* Shouldn't happen, just return... */",1
                return_,1
        /* Hide raw view of bytes */,1
        PROTO_ITEM_SET_HIDDEN(raw_tm_ti)_,1
        /* Call it (catch exceptions) */,1
        TRY {,1
"            call_dissector_only(protocol_handle, rrc_tvb, pinfo, tree, NULL)_",1
        CATCH_ALL {,1
        ENDTRY,1
/* Unacknowledged mode PDU                         */,1
"static void dissect_rlc_nr_um(tvbuff_t *tvb, packet_info *pinfo,",1
"                               proto_tree *tree,",1
"                               int offset,",1
"                               rlc_nr_info *p_rlc_nr_info,",1
                               proto_item *top_ti),1
"    guint32 seg_info, sn_",1
    guint64 reserved_,1
    proto_item *um_ti_,1
    proto_tree *um_header_tree_,1
    proto_item *um_header_ti_,1
    gboolean is_truncated = FALSE_,1
    proto_item *truncated_ti_,1
    proto_item *reserved_ti_,1
    int start_offset = offset_,1
    /* Hidden UM root */,1
"    um_ti = proto_tree_add_string_format(tree, hf_rlc_nr_um,",1
"                                         tvb, offset, 0, """", ""UM"")_",1
    PROTO_ITEM_SET_HIDDEN(um_ti)_,1
    /* Add UM header subtree */,1
"    um_header_ti = proto_tree_add_string_format(tree, hf_rlc_nr_um_header,",1
"                                                tvb, offset, 0,",1
"                                                """", ""UM header"")_",1
"    um_header_tree = proto_item_add_subtree(um_header_ti,",1
                                            ett_rlc_nr_um_header)_,1
"    proto_tree_add_item_ret_uint(um_header_tree, hf_rlc_nr_um_si, tvb, offset, 1, ENC_BIG_ENDIAN, &seg_info)_",1
    if (seg_info == 0) {,1
"        reserved_ti = proto_tree_add_bits_ret_val(um_header_tree, hf_rlc_nr_um_reserved,",1
"                                                  tvb, (offset<<3)+2, 6, &reserved, ENC_BIG_ENDIAN)_",1
        offset++_,1
        if (reserved) {,1
"            expert_add_info(pinfo, reserved_ti, &ei_rlc_nr_reserved_bits_not_zero)_",1
"        write_pdu_label_and_info(top_ti, um_header_ti, pinfo, ""                             "")_",1
        if (p_rlc_nr_info->sequenceNumberLength == UM_SN_LENGTH_6_BITS) {,1
"            proto_tree_add_item_ret_uint(um_header_tree, hf_rlc_nr_um_sn6, tvb, offset, 1, ENC_BIG_ENDIAN, &sn)_",1
            offset++_,1
        } else if (p_rlc_nr_info->sequenceNumberLength == UM_SN_LENGTH_12_BITS) {,1
"            reserved_ti = proto_tree_add_bits_ret_val(um_header_tree, hf_rlc_nr_um_reserved, tvb,",1
"                                                      (offset<<3)+2, 2, &reserved, ENC_BIG_ENDIAN)_",1
            if (reserved) {,1
"                expert_add_info(pinfo, reserved_ti, &ei_rlc_nr_reserved_bits_not_zero)_",1
"            proto_tree_add_item_ret_uint(um_header_tree, hf_rlc_nr_um_sn12, tvb, offset, 2, ENC_BIG_ENDIAN, &sn)_",1
            offset += 2_,1
            /* Invalid length of sequence number */,1
"            proto_tree_add_expert_format(um_header_tree, pinfo, &ei_rlc_nr_um_sn, tvb, 0, 0,",1
"                                         ""Invalid sequence number length (%u bits)"",",1
                                         p_rlc_nr_info->sequenceNumberLength)_,1
            return_,1
        if (seg_info >= 2) {,1
            guint32 so_,1
"            proto_tree_add_item_ret_uint(um_header_tree, hf_rlc_nr_um_so, tvb, offset, 2, ENC_BIG_ENDIAN, &so)_",1
"            write_pdu_label_and_info(top_ti, um_header_ti, pinfo, ""            SN=%-6u SO=%-4u"", sn, so)_",1
"            write_pdu_label_and_info(top_ti, um_header_ti, pinfo, ""            SN=%-6u        "", sn)_",1
"    proto_item_set_len(um_header_ti, offset-start_offset)_",1
    if (global_rlc_nr_headers_expected) {,1
"        /* There might not be any data, if only headers (plus control data) were logged */",1
"        is_truncated = (tvb_captured_length_remaining(tvb, offset) == 0)_",1
"        truncated_ti = proto_tree_add_boolean(tree, hf_rlc_nr_header_only, tvb, 0, 0,",1
                                              is_truncated)_,1
        if (is_truncated) {,1
            PROTO_ITEM_SET_GENERATED(truncated_ti)_,1
"            expert_add_info(pinfo, truncated_ti, &ei_rlc_nr_header_only)_",1
"            show_PDU_in_info(pinfo, top_ti, p_rlc_nr_info->pduLength - offset, seg_info)_",1
            PROTO_ITEM_SET_HIDDEN(truncated_ti)_,1
"    if (tvb_reported_length_remaining(tvb, offset) > 0) {",1
"        show_PDU_in_tree(pinfo, tree, tvb, offset, tvb_reported_length_remaining(tvb, offset),",1
"                         p_rlc_nr_info, seg_info)_",1
"        show_PDU_in_info(pinfo, top_ti, tvb_reported_length_remaining(tvb, offset), seg_info)_",1
    } else if (!global_rlc_nr_headers_expected) {,1
        /* Report that expected data was missing (unless we know it might happen) */,1
"        expert_add_info(pinfo, um_header_ti, &ei_rlc_nr_um_data_no_data)_",1
/* Dissect an AM STATUS PDU */,1
"static void dissect_rlc_nr_am_status_pdu(tvbuff_t *tvb,",1
"                                         packet_info *pinfo,",1
"                                         proto_tree *tree,",1
"                                         proto_item *status_ti,",1
"                                         int offset,",1
"                                         proto_item *top_ti,",1
                                         rlc_nr_info *p_rlc_nr_info),1
"    guint8     sn_size, reserved_bits1, reserved_bits2_",1
"    guint32    cpt, sn_limit, nack_count = 0_",1
"    guint64    ack_sn, nack_sn_",1
"    guint64    e1, e2, e3, reserved_",1
"    guint32    so_start, so_end, nack_range_",1
    int        bit_offset = offset << 3_,1
    /****************************************************************/,1
    /* Part of RLC control PDU header                               */,1
    /* Control PDU Type (CPT) */,1
"    ti = proto_tree_add_item_ret_uint(tree, hf_rlc_nr_am_cpt, tvb, offset, 1, ENC_BIG_ENDIAN, &cpt)_",1
    if (cpt != 0) {,1
        /* Protest and stop - only know about STATUS PDUs */,1
"        expert_add_info_format(pinfo, ti, &ei_rlc_nr_am_cpt,",1
"                               ""RLC Control frame type %u not handled"", cpt)_",1
    if (p_rlc_nr_info->sequenceNumberLength == AM_SN_LENGTH_12_BITS) {,1
        sn_size = 12_,1
        sn_limit = 4096_,1
        reserved_bits1 = 7_,1
        reserved_bits2 = 1_,1
    } else if (p_rlc_nr_info->sequenceNumberLength == AM_SN_LENGTH_18_BITS) {,1
        sn_size = 18_,1
        sn_limit = 262044_,1
        reserved_bits1 = 1_,1
        reserved_bits2 = 3_,1
"        proto_tree_add_expert_format(tree, pinfo, &ei_rlc_nr_am_sn, tvb, 0, 0,",1
"                                     ""Invalid sequence number length (%u bits)"",",1
                                     p_rlc_nr_info->sequenceNumberLength)_,1
    /* The Status PDU itself starts 4 bits into the byte */,1
    bit_offset += 4_,1
    /* ACK SN */,1
"    proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_ack_sn, tvb,",1
"                                bit_offset, sn_size, &ack_sn, ENC_BIG_ENDIAN)_",1
    bit_offset += sn_size_,1
"    write_pdu_label_and_info(top_ti, status_ti, pinfo, ""  ACK_SN=%-6u"", (guint32)ack_sn)_",1
    /* E1 */,1
"    proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_e1, tvb,",1
"                                bit_offset, 1, &e1, ENC_BIG_ENDIAN)_",1
    bit_offset++_,1
    /* Reserved bits */,1
"    ti = proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_reserved, tvb, bit_offset,",1
"                                     reserved_bits1, &reserved, ENC_BIG_ENDIAN)_",1
    bit_offset += reserved_bits1_,1
    if (reserved) {,1
"        expert_add_info(pinfo, ti, &ei_rlc_nr_reserved_bits_not_zero)_",1
"    /* Optional, extra fields */",1
    while (e1) {,1
        proto_item *nack_ti_,1
        /****************************/,1
"        /* Read NACK_SN, E1, E2, E3 */",1
        /* NACK_SN */,1
"        nack_ti = proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_nack_sn, tvb,",1
"                                              bit_offset, sn_size, &nack_sn, ENC_BIG_ENDIAN)_",1
        bit_offset += sn_size_,1
"        write_pdu_label_and_info(top_ti, NULL, pinfo, ""  NACK_SN=%-6u"", (guint32)nack_sn)_",1
        /* We shouldn't NACK the ACK_SN! */,1
        if (nack_sn == ack_sn) {,1
"            expert_add_info_format(pinfo, nack_ti, &ei_rlc_nr_am_nack_sn_ack_same,",1
"                                   ""Status PDU shouldn't ACK and NACK the same sequence number (%"" G_GINT64_MODIFIER ""u)"",",1
                                   ack_sn)_,1
        /* NACK should always be 'behind' the ACK */,1
        if ((sn_limit + ack_sn - nack_sn) % sn_limit > (sn_limit>>1)) {,1
"            expert_add_info(pinfo, nack_ti, &ei_rlc_nr_am_nack_sn_ahead_ack)_",1
        nack_count++_,1
        /* E1 */,1
"        proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_e1, tvb,",1
"                                    bit_offset, 1, &e1, ENC_BIG_ENDIAN)_",1
        bit_offset++_,1
        /* E2 */,1
"        proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_e2, tvb,",1
"                                    bit_offset, 1, &e2, ENC_BIG_ENDIAN)_",1
        /* Report as expert info */,1
        if (e2) {,1
"            expert_add_info_format(pinfo, nack_ti, &ei_rlc_nr_am_nack_sn_partial,",1
"                                   ""Status PDU reports NACK (partial) on %s for UE %u"",",1
"                                   val_to_str_const(p_rlc_nr_info->direction, direction_vals, ""Unknown""),",1
                                   p_rlc_nr_info->ueid)_,1
"            expert_add_info_format(pinfo, nack_ti, &ei_rlc_nr_am_nack_sn,",1
"                                   ""Status PDU reports NACK on %s for UE %u"",",1
        /* E3 */,1
"        proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_e3, tvb,",1
"                                    bit_offset, 1, &e3, ENC_BIG_ENDIAN)_",1
        /* Reserved bits */,1
"        ti = proto_tree_add_bits_ret_val(tree, hf_rlc_nr_am_reserved, tvb, bit_offset,",1
"                                         reserved_bits2, &reserved, ENC_BIG_ENDIAN)_",1
        bit_offset += reserved_bits2_,1
"            expert_add_info(pinfo, ti, &ei_rlc_nr_reserved_bits_not_zero)_",1
"            /* Read SOstart, SOend */",1
"            proto_tree_add_item_ret_uint(tree, hf_rlc_nr_am_so_start, tvb,",1
"                                         bit_offset>>3, 2, ENC_BIG_ENDIAN, &so_start)_",1
            bit_offset += 16_,1
"            proto_tree_add_item_ret_uint(tree, hf_rlc_nr_am_so_end, tvb,",1
"                                         bit_offset>>3, 2, ENC_BIG_ENDIAN, &so_end)_",1
            if (so_end == 0xffff) {,1
"                write_pdu_label_and_info(top_ti, NULL, pinfo,",1
"                                         "" (SOstart=%u SOend=<END-OF_SDU>)"",",1
                                         so_start)_,1
"                                         "" (SOstart=%u SOend=%u)"",",1
"                                         so_start, so_end)_",1
        if (e3) {,1
            proto_item *nack_range_ti_,1
            /* Read NACK range */,1
"            nack_range_ti = proto_tree_add_item_ret_uint(tree, hf_rlc_nr_am_nack_range, tvb,",1
"                                                         bit_offset>>3, 1, ENC_BIG_ENDIAN, &nack_range)_",1
            bit_offset += 8_,1
            if (nack_range == 0) {,1
"                expert_add_info(pinfo, nack_range_ti, &ei_rlc_nr_am_nack_range)_",1
                nack_count += nack_range-1_,1
"            write_pdu_label_and_info(top_ti, NULL, pinfo,"" NACK range=%u"", nack_range)_",1
    if (nack_count > 0) {,1
"        proto_item *count_ti = proto_tree_add_uint(tree, hf_rlc_nr_am_nacks, tvb, 0, 1, nack_count)_",1
        PROTO_ITEM_SET_GENERATED(count_ti)_,1
"        proto_item_append_text(status_ti, ""  (%u NACKs)"", nack_count)_",1
"    /* Check that we've reached the end of the PDU. If not, show malformed */",1
    offset = (bit_offset+7) / 8_,1
"        expert_add_info_format(pinfo, status_ti, &ei_rlc_nr_bytes_after_status_pdu_complete,",1
"                               ""%cL %u bytes remaining after Status PDU complete"",",1
"                               (p_rlc_nr_info->direction == DIRECTION_UPLINK) ? 'U' : 'D',",1
"                               tvb_reported_length_remaining(tvb, offset))_",1
    /* Set selected length of control tree */,1
"    proto_item_set_len(status_ti, offset)_",1
/* Acknowledged mode PDU                           */,1
"static void dissect_rlc_nr_am(tvbuff_t *tvb, packet_info *pinfo,",1
"    gboolean dc, polling_",1
    proto_item *am_ti_,1
    proto_tree *am_header_tree_,1
    proto_item *am_header_ti_,1
    gint   start_offset = offset_,1
    /* Hidden AM root */,1
"    am_ti = proto_tree_add_string_format(tree, hf_rlc_nr_am,",1
"                                         tvb, offset, 0, """", ""AM"")_",1
    PROTO_ITEM_SET_HIDDEN(am_ti)_,1
    /* Add AM header subtree */,1
"    am_header_ti = proto_tree_add_string_format(tree, hf_rlc_nr_am_header,",1
"                                                """", ""AM Header "")_",1
"    am_header_tree = proto_item_add_subtree(am_header_ti,",1
                                            ett_rlc_nr_am_header)_,1
    /* First bit is Data/Control flag */,1
"    proto_tree_add_item_ret_boolean(am_header_tree, hf_rlc_nr_am_data_control,",1
"                                    tvb, offset, 1, ENC_BIG_ENDIAN, &dc)_",1
    if (dc == 0) {,1
        /**********************/,1
        /* Status PDU         */,1
"        write_pdu_label_and_info_literal(top_ti, NULL, pinfo, "" [CONTROL]"")_",1
        /* Control PDUs are a completely separate format  */,1
"        dissect_rlc_nr_am_status_pdu(tvb, pinfo, am_header_tree, am_header_ti,",1
"                                     offset, top_ti, p_rlc_nr_info)_",1
    /**********************/,1
    /* Data PDU           */,1
"    write_pdu_label_and_info_literal(top_ti, NULL, pinfo, "" [DATA]"")_",1
    /* Polling bit */,1
"    proto_tree_add_item_ret_boolean(am_header_tree, hf_rlc_nr_am_p, tvb,",1
"                                    offset, 1, ENC_BIG_ENDIAN, &polling)_",1
"    write_pdu_label_and_info_literal(top_ti, NULL, pinfo, (polling) ? "" (P) "" : ""     "")_",1
    if (polling) {,1
"        proto_item_append_text(am_header_ti, "" (P) "")_",1
    /* Segmentation Info */,1
"    proto_tree_add_item_ret_uint(am_header_tree, hf_rlc_nr_am_si, tvb,",1
"                                 offset, 1, ENC_BIG_ENDIAN, &seg_info)_",1
    /* Sequence Number */,1
"        proto_tree_add_item_ret_uint(am_header_tree, hf_rlc_nr_am_sn12, tvb,",1
"                                     offset, 2, ENC_BIG_ENDIAN, &sn)_",1
        offset += 2_,1
"        reserved_ti = proto_tree_add_bits_ret_val(am_header_tree, hf_rlc_nr_am_reserved, tvb,",1
"                                                  (offset<<3)+4, 2, &reserved, ENC_BIG_ENDIAN)_",1
"        proto_tree_add_item_ret_uint(am_header_tree, hf_rlc_nr_am_sn18, tvb,",1
"                                     offset, 3, ENC_BIG_ENDIAN, &sn)_",1
        offset += 3_,1
        /* Invalid length of sequence number */,1
"        proto_tree_add_expert_format(am_header_tree, pinfo, &ei_rlc_nr_am_sn, tvb, 0, 0,",1
    /* Segmentation Information */,1
    if (seg_info >= 2) {,1
        guint32 so_,1
"        proto_tree_add_item_ret_uint(am_header_tree, hf_rlc_nr_am_so, tvb,",1
"                                     offset, 2, ENC_BIG_ENDIAN, &so)_",1
"        write_pdu_label_and_info(top_ti, am_header_ti, pinfo, ""SN=%-6u SO=%-4u"",sn, so)_",1
"        write_pdu_label_and_info(top_ti, am_header_ti, pinfo, ""SN=%-6u        "", sn)_",1
    /* Header is now complete */,1
"    proto_item_set_len(am_header_ti, offset-start_offset)_",1
"    /* There might not be any data, if only headers (plus control data) were logged */",1
    /* Data */,1
"        expert_add_info(pinfo, am_header_ti, &ei_rlc_nr_am_data_no_data)_",1
/* Heuristic dissector looks for supported framing protocol (see header file for details) */,1
"static gboolean dissect_rlc_nr_heur(tvbuff_t *tvb, packet_info *pinfo,",1
"                                    proto_tree *tree, void *data _U_)",1
    gint        offset = 0_,1
    rlc_nr_info *p_rlc_nr_info_,1
    tvbuff_t    *rlc_tvb_,1
    guint8      tag_,1
    /* Do this again on re-dissection to re-discover offset of actual PDU */,1
    /* Needs to be at least as long as:,1
       - the signature string,1
       - fixed header bytes,1
       - tag for data,1
       - at least one byte of RLC PDU payload */,1
"    if (tvb_captured_length_remaining(tvb, offset) < (gint)(strlen(RLC_NR_START_STRING)+2+2)) {",1
"    /* OK, compare with signature string */",1
"    if (tvb_strneql(tvb, offset, RLC_NR_START_STRING, (gint)strlen(RLC_NR_START_STRING)) != 0) {",1
    offset += (gint)strlen(RLC_NR_START_STRING)_,1
"    /* If redissecting, use previous info struct (if available) */",1
"    p_rlc_nr_info = (rlc_nr_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc_nr, 0)_",1
    if (p_rlc_nr_info == NULL) {,1
        /* Allocate new info struct for this frame */,1
"        p_rlc_nr_info = wmem_new0(wmem_file_scope(), struct rlc_nr_info)_",1
        /* Read fixed fields */,1
"        p_rlc_nr_info->rlcMode = tvb_get_guint8(tvb, offset++)_",1
"        p_rlc_nr_info->sequenceNumberLength = tvb_get_guint8(tvb, offset++)_",1
        /* Read optional fields */,1
        do {,1
            /* Process next tag */,1
"            tag = tvb_get_guint8(tvb, offset++)_",1
            switch (tag) {,1
                case RLC_NR_DIRECTION_TAG:,1
"                    p_rlc_nr_info->direction = tvb_get_guint8(tvb, offset)_",1
                    offset++_,1
                case RLC_NR_UEID_TAG:,1
"                    p_rlc_nr_info->ueid = tvb_get_ntohs(tvb, offset)_",1
                    offset += 2_,1
                case RLC_NR_BEARER_TYPE_TAG:,1
"                    p_rlc_nr_info->bearerType = tvb_get_guint8(tvb, offset)_",1
                case RLC_NR_BEARER_ID_TAG:,1
"                    p_rlc_nr_info->bearerId = tvb_get_guint8(tvb, offset)_",1
                case RLC_NR_PAYLOAD_TAG:,1
"                    /* Have reached data, so set payload length and get out of loop */",1
"                    p_rlc_nr_info->pduLength = tvb_reported_length_remaining(tvb, offset)_",1
                    /* It must be a recognised tag */,1
                    {,1
                        proto_item *ti_,1
                        proto_tree *subtree_,1
"                        col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RLC-NR"")_",1
"                        col_clear(pinfo->cinfo, COL_INFO)_",1
"                        ti = proto_tree_add_item(tree, proto_rlc_nr, tvb, offset, tvb_reported_length(tvb), ENC_NA)_",1
"                        subtree = proto_item_add_subtree(ti, ett_rlc_nr)_",1
"                        proto_tree_add_expert(subtree, pinfo, &ei_rlc_nr_unknown_udp_framing_tag,",1
"                                              tvb, offset-1, 1)_",1
"                    wmem_free(wmem_file_scope(), p_rlc_nr_info)_",1
                    return TRUE_,1
        } while (tag != RLC_NR_PAYLOAD_TAG)_,1
        /* Store info in packet */,1
"        p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc_nr, 0, p_rlc_nr_info)_",1
        offset = tvb_reported_length(tvb) - p_rlc_nr_info->pduLength_,1
    /**************************************/,1
"    /* OK, now dissect as RLC NR          */",1
    /* Create tvb that starts at actual RLC PDU */,1
"    rlc_tvb = tvb_new_subset_remaining(tvb, offset)_",1
"    dissect_rlc_nr_common(rlc_tvb, pinfo, tree, TRUE)_",1
    return TRUE_,1
/*****************************/,1
/* Main dissection function. */,1
"static int dissect_rlc_nr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)",1
"    dissect_rlc_nr_common(tvb, pinfo, tree, FALSE)_",1
"static void dissect_rlc_nr_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean is_udp_framing)",1
    proto_tree             *rlc_nr_tree_,1
    proto_tree             *context_tree_,1
    proto_item             *top_ti_,1
    proto_item             *context_ti_,1
    proto_item             *ti_,1
    proto_item             *mode_ti_,1
    gint                   offset = 0_,1
    struct rlc_nr_info     *p_rlc_nr_info = NULL_,1
    /* Set protocol name */,1
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RLC-NR"")_",1
    /* Create protocol tree. */,1
"    top_ti = proto_tree_add_item(tree, proto_rlc_nr, tvb, offset, -1, ENC_NA)_",1
"    rlc_nr_tree = proto_item_add_subtree(top_ti, ett_rlc_nr)_",1
    /* Look for packet info! */,1
    /* Can't dissect anything without it... */,1
"        proto_tree_add_expert(rlc_nr_tree, pinfo, &ei_rlc_nr_no_per_frame_info, tvb, offset, -1)_",1
    /* Clear info column when using UDP framing */,1
    if (is_udp_framing) {,1
    /*****************************************/,1
    /* Show context information              */,1
    /* Create context root */,1
"    context_ti = proto_tree_add_string_format(rlc_nr_tree, hf_rlc_nr_context,",1
"                                              tvb, offset, 0, """", ""Context"")_",1
"    context_tree = proto_item_add_subtree(context_ti, ett_rlc_nr_context)_",1
    PROTO_ITEM_SET_GENERATED(context_ti)_,1
"    ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_direction,",1
"                             tvb, 0, 0, p_rlc_nr_info->direction)_",1
    PROTO_ITEM_SET_GENERATED(ti)_,1
"    mode_ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_mode,",1
"                                  tvb, 0, 0, p_rlc_nr_info->rlcMode)_",1
    PROTO_ITEM_SET_GENERATED(mode_ti)_,1
    if (p_rlc_nr_info->ueid != 0) {,1
"        ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_ueid,",1
"                                 tvb, 0, 0, p_rlc_nr_info->ueid)_",1
        PROTO_ITEM_SET_GENERATED(ti)_,1
"    ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_bearer_type,",1
"                             tvb, 0, 0, p_rlc_nr_info->bearerType)_",1
    if ((p_rlc_nr_info->bearerType == BEARER_TYPE_SRB) ||,1
        (p_rlc_nr_info->bearerType == BEARER_TYPE_DRB)) {,1
"        ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_bearer_id,",1
"                                 tvb, 0, 0, p_rlc_nr_info->bearerId)_",1
"    ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_pdu_length,",1
"                             tvb, 0, 0, p_rlc_nr_info->pduLength)_",1
    if (p_rlc_nr_info->rlcMode != RLC_TM_MODE) {,1
"        ti = proto_tree_add_uint(context_tree, hf_rlc_nr_context_sn_length,",1
"                                 tvb, 0, 0, p_rlc_nr_info->sequenceNumberLength)_",1
    /* Append highlights to top-level item */,1
"        proto_item_append_text(top_ti, ""   UEId=%u"", p_rlc_nr_info->ueid)_",1
"        col_append_fstr(pinfo->cinfo, COL_INFO, ""UEId=%-4u "", p_rlc_nr_info->ueid)_",1
    /* Append context highlights to info column */,1
"    write_pdu_label_and_info(top_ti, NULL, pinfo,",1
"                             "" [%s] [%s] "",",1
"                             (p_rlc_nr_info->direction == 0) ? ""UL"" : ""DL"",",1
"                             val_to_str_const(p_rlc_nr_info->rlcMode, rlc_mode_short_vals, ""Unknown""))_",1
    if (p_rlc_nr_info->bearerId == 0) {,1
"        write_pdu_label_and_info(top_ti, NULL, pinfo, ""%s   "",",1
"                                 val_to_str_const(p_rlc_nr_info->bearerType, rlc_bearer_type_vals, ""Unknown""))_",1
"        write_pdu_label_and_info(top_ti, NULL, pinfo, ""%s:%-2u"",",1
"                                 val_to_str_const(p_rlc_nr_info->bearerType, rlc_bearer_type_vals, ""Unknown""),",1
                                 p_rlc_nr_info->bearerId)_,1
    /* Dissect the RLC PDU itself. Format depends upon mode... */,1
    switch (p_rlc_nr_info->rlcMode) {,1
        case RLC_TM_MODE:,1
"            dissect_rlc_nr_tm(tvb, pinfo, rlc_nr_tree, offset, p_rlc_nr_info, top_ti)_",1
        case RLC_UM_MODE:,1
"            dissect_rlc_nr_um(tvb, pinfo, rlc_nr_tree, offset, p_rlc_nr_info, top_ti)_",1
        case RLC_AM_MODE:,1
"            dissect_rlc_nr_am(tvb, pinfo, rlc_nr_tree, offset, p_rlc_nr_info, top_ti)_",1
            /* Error - unrecognised mode */,1
"            expert_add_info_format(pinfo, mode_ti, &ei_rlc_nr_context_mode,",1
"                                   ""Unrecognised RLC Mode set (%u)"", p_rlc_nr_info->rlcMode)_",1
void proto_register_rlc_nr(void),1
    static hf_register_info hf[] =,1
        /**********************************/,1
        /* Items for decoding context     */,1
"        { &hf_rlc_nr_context,",1
"            { ""Context"",",1
"              ""rlc-nr.context"", FT_STRING, BASE_NONE, NULL, 0x0,",1
"              NULL, HFILL",1
"        { &hf_rlc_nr_context_mode,",1
"            { ""RLC Mode"",",1
"              ""rlc-nr.mode"", FT_UINT8, BASE_DEC, VALS(rlc_mode_vals), 0x0,",1
"        { &hf_rlc_nr_context_direction,",1
"            { ""Direction"",",1
"              ""rlc-nr.direction"", FT_UINT8, BASE_DEC, VALS(direction_vals), 0x0,",1
"              ""Direction of message"", HFILL",1
"        { &hf_rlc_nr_context_ueid,",1
"            { ""UEId"",",1
"              ""rlc-nr.ueid"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"              ""User Equipment Identifier associated with message"", HFILL",1
"        { &hf_rlc_nr_context_bearer_type,",1
"            { ""Bearer Type"",",1
"              ""rlc-nr.bearer-type"", FT_UINT16, BASE_DEC, VALS(rlc_bearer_type_vals), 0x0,",1
"              ""Bearer Type associated with message"", HFILL",1
"        { &hf_rlc_nr_context_bearer_id,",1
"            { ""Bearer Id"",",1
"              ""rlc-nr.bearer-id"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"              ""Bearer ID associated with message"", HFILL",1
"        { &hf_rlc_nr_context_pdu_length,",1
"            { ""PDU Length"",",1
"              ""rlc-nr.pdu-length"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"              ""Length of PDU (in bytes)"", HFILL",1
"        { &hf_rlc_nr_context_sn_length,",1
"            { ""Sequence Number length"",",1
"              ""rlc-nr.seqnum-length"", FT_UINT8, BASE_DEC, 0, 0x0,",1
"              ""Length of sequence number in bits"", HFILL",1
        /* Transparent mode fields */,1
"        { &hf_rlc_nr_tm,",1
"            { ""TM"",",1
"              ""rlc-nr.tm"", FT_STRING, BASE_NONE, NULL, 0x0,",1
"              ""Transparent Mode"", HFILL",1
"        { &hf_rlc_nr_tm_data,",1
"            { ""TM Data"",",1
"              ""rlc-nr.tm.data"", FT_BYTES, BASE_NONE, 0, 0x0,",1
"              ""Transparent Mode Data"", HFILL",1
        /* Unacknowledged mode fields */,1
"        { &hf_rlc_nr_um,",1
"            { ""UM"",",1
"              ""rlc-nr.um"", FT_STRING, BASE_NONE, NULL, 0x0,",1
"              ""Unacknowledged Mode"", HFILL",1
"        { &hf_rlc_nr_um_header,",1
"            { ""UM Header"",",1
"              ""rlc-nr.um.header"", FT_STRING, BASE_NONE, NULL, 0x0,",1
"              ""Unacknowledged Mode Header"", HFILL",1
"        { &hf_rlc_nr_um_si,",1
"            { ""Segmentation Info"",",1
"              ""rlc-nr.um.si"", FT_UINT8, BASE_HEX, VALS(seg_info_vals), 0xc0,",1
"        { &hf_rlc_nr_um_reserved,",1
"            { ""Reserved"",",1
"              ""rlc-nr.um.reserved"", FT_UINT8, BASE_HEX, 0, 0x0,",1
"        { &hf_rlc_nr_um_sn6,",1
"            { ""Sequence Number"",",1
"              ""rlc-nr.um.sn"", FT_UINT8, BASE_DEC, 0, 0x3f,",1
"        { &hf_rlc_nr_um_sn12,",1
"              ""rlc-nr.um.sn"", FT_UINT16, BASE_DEC, 0, 0x0fff,",1
"        { &hf_rlc_nr_um_so,",1
"            { ""Segment Offset"",",1
"              ""rlc-nr.um.so"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"        { &hf_rlc_nr_um_data,",1
"            { ""UM Data"",",1
"              ""rlc-nr.um.data"", FT_BYTES, BASE_NONE, 0, 0x0,",1
"              ""Unacknowledged Mode Data"", HFILL",1
        /* Acknowledged mode fields */,1
"        { &hf_rlc_nr_am,",1
"            { ""AM"",",1
"              ""rlc-nr.am"", FT_STRING, BASE_NONE, NULL, 0x0,",1
"              ""Acknowledged Mode"", HFILL",1
"        { &hf_rlc_nr_am_header,",1
"            { ""AM Header"",",1
"              ""rlc-nr.am.header"", FT_STRING, BASE_NONE, NULL, 0x0,",1
"              ""Acknowledged Mode Header"", HFILL",1
"        { &hf_rlc_nr_am_data_control,",1
"            { ""Data/Control"",",1
"              ""rlc-nr.am.dc"", FT_BOOLEAN, 8, TFS(&data_or_control_vals), 0x80,",1
"        { &hf_rlc_nr_am_p,",1
"            { ""Polling Bit"",",1
"              ""rlc-nr.am.p"", FT_BOOLEAN, 8, TFS(&polling_bit_vals), 0x40,",1
"        { &hf_rlc_nr_am_si,",1
"              ""rlc-nr.am.si"", FT_UINT8, BASE_HEX, VALS(seg_info_vals), 0x30,",1
"        { &hf_rlc_nr_am_sn12,",1
"              ""rlc-nr.am.sn"", FT_UINT16, BASE_DEC, 0, 0x0fff,",1
"        { &hf_rlc_nr_am_sn18,",1
"              ""rlc-nr.am.sn"", FT_UINT24, BASE_DEC, 0, 0x03ffff,",1
"        { &hf_rlc_nr_am_reserved,",1
"              ""rlc-nr.am.reserved"", FT_UINT8, BASE_HEX, 0, 0x0,",1
"        { &hf_rlc_nr_am_so,",1
"              ""rlc-nr.am.so"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"        { &hf_rlc_nr_am_data,",1
"            { ""AM Data"",",1
"              ""rlc-nr.am.data"", FT_BYTES, BASE_NONE, 0, 0x0,",1
"              ""Acknowledged Mode Data"", HFILL",1
"        { &hf_rlc_nr_am_cpt,",1
"            { ""Control PDU Type"",",1
"              ""rlc-nr.am.cpt"", FT_UINT8, BASE_HEX, VALS(control_pdu_type_vals), 0x70,",1
"              ""AM Control PDU Type"", HFILL",1
"        { &hf_rlc_nr_am_ack_sn,",1
"            { ""ACK Sequence Number"",",1
"              ""rlc-nr.am.ack-sn"", FT_UINT24, BASE_DEC, 0, 0x0,",1
"              ""Sequence Number we expect to receive next"", HFILL",1
"        { &hf_rlc_nr_am_e1,",1
"            { ""Extension bit 1"",",1
"              ""rlc-nr.am.e1"", FT_BOOLEAN, BASE_NONE, TFS(&am_e1_vals), 0x0,",1
"        { &hf_rlc_nr_am_e2,",1
"            { ""Extension bit 2"",",1
"              ""rlc-nr.am.e2"", FT_BOOLEAN, BASE_NONE, TFS(&am_e2_vals), 0x0,",1
"        { &hf_rlc_nr_am_e3,",1
"            { ""Extension bit 3"",",1
"              ""rlc-nr.am.e3"", FT_BOOLEAN, BASE_NONE, TFS(&am_e3_vals), 0x0,",1
"        { &hf_rlc_nr_am_nacks,",1
"            { ""Number of NACKs"",",1
"              ""rlc-nr.am.nacks"", FT_UINT32, BASE_DEC, 0, 0x0,",1
"              ""Number of NACKs in this status PDU"", HFILL",1
"        { &hf_rlc_nr_am_nack_sn,",1
"            { ""NACK Sequence Number"",",1
"              ""rlc-nr.am.nack-sn"", FT_UINT24, BASE_DEC, 0, 0x0,",1
"              ""Negative Acknowledgement Sequence Number"", HFILL",1
"        { &hf_rlc_nr_am_so_start,",1
"            { ""SO start"",",1
"              ""rlc-nr.am.so-start"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"              ""Segment Offset Start byte index"", HFILL",1
"        { &hf_rlc_nr_am_so_end,",1
"            { ""SO end"",",1
"              ""rlc-nr.am.so-end"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"              ""Segment Offset End byte index"", HFILL",1
"        { &hf_rlc_nr_am_nack_range,",1
"            { ""NACK range"",",1
"              ""rlc-nr.am.nack-range"", FT_UINT16, BASE_DEC, 0, 0x0,",1
"              ""Number of consecutively lost RLC SDUs starting from and including NACK_SN"", HFILL",1
"        { &hf_rlc_nr_header_only,",1
"            { ""RLC PDU Header only"",",1
"              ""rlc-nr.header-only"", FT_BOOLEAN, BASE_NONE, TFS(&header_only_vals), 0x0,",1
    static gint *ett[] =,1
"        &ett_rlc_nr,",1
"        &ett_rlc_nr_context,",1
"        &ett_rlc_nr_um_header,",1
        &ett_rlc_nr_am_header,1
    static ei_register_info ei[] = {,1
"        { &ei_rlc_nr_reserved_bits_not_zero, { ""rlc-nr.reserved-bits-not-zero"", PI_MALFORMED, PI_ERROR, ""Reserved bits not zero"", EXPFILL }},",1
"        { &ei_rlc_nr_um_sn, { ""rlc-nr.um.sn.invalid"", PI_MALFORMED, PI_ERROR, ""Invalid sequence number length"", EXPFILL }},",1
"        { &ei_rlc_nr_am_sn, { ""rlc-nr.am.sn.invalid"", PI_MALFORMED, PI_ERROR, ""Invalid sequence number length"", EXPFILL }},",1
"        { &ei_rlc_nr_header_only, { ""rlc-nr.header-only.expert"", PI_SEQUENCE, PI_NOTE, ""RLC PDU SDUs have been omitted"", EXPFILL }},",1
"        { &ei_rlc_nr_am_cpt, { ""rlc-nr.am.cpt.invalid"", PI_MALFORMED, PI_ERROR, ""RLC Control frame type not handled"", EXPFILL }},",1
"        { &ei_rlc_nr_am_nack_sn_ack_same, { ""rlc-nr.am.nack-sn.ack-same"", PI_MALFORMED, PI_ERROR, ""Status PDU shouldn't ACK and NACK the same sequence number"", EXPFILL }},",1
"        { &ei_rlc_nr_am_nack_range, { ""rlc-nr.am.nack-sn.nack-range"", PI_MALFORMED, PI_ERROR, ""Status PDU shouldnot contain a NACK range vith value 0"", EXPFILL }},",1
"        { &ei_rlc_nr_am_nack_sn_ahead_ack, { ""rlc-nr.am.nack-sn.ahead-ack"", PI_MALFORMED, PI_ERROR, ""NACK must not be ahead of ACK in status PDU"", EXPFILL }},",1
"        { &ei_rlc_nr_am_nack_sn_partial, { ""rlc-nr.am.nack-sn.partial"", PI_SEQUENCE, PI_WARN, ""Status PDU reports NACK (partial)"", EXPFILL }},",1
"        { &ei_rlc_nr_am_nack_sn, { ""rlc-nr.am.nack-sn.expert"", PI_SEQUENCE, PI_WARN, ""Status PDU reports NACK"", EXPFILL }},",1
"        { &ei_rlc_nr_bytes_after_status_pdu_complete, { ""rlc-nr.bytes-after-status-pdu-complete"", PI_MALFORMED, PI_ERROR, ""bytes remaining after Status PDU complete"", EXPFILL }},",1
"        { &ei_rlc_nr_um_data_no_data, { ""rlc-nr.um-data.no-data"", PI_MALFORMED, PI_ERROR, ""UM data PDU doesn't contain any data"", EXPFILL }},",1
"        { &ei_rlc_nr_am_data_no_data, { ""rlc-nr.am-data.no-data"", PI_MALFORMED, PI_ERROR, ""AM data PDU doesn't contain any data"", EXPFILL }},",1
"        { &ei_rlc_nr_context_mode, { ""rlc-nr.mode.invalid"", PI_MALFORMED, PI_ERROR, ""Unrecognised RLC Mode set"", EXPFILL }},",1
"        { &ei_rlc_nr_no_per_frame_info, { ""rlc-nr.no-per-frame-info"", PI_UNDECODED, PI_ERROR, ""Can't dissect NR RLC frame because no per-frame info was attached!"", EXPFILL }},",1
"        { &ei_rlc_nr_unknown_udp_framing_tag, { ""rlc-nr.unknown-udp-framing-tag"", PI_UNDECODED, PI_WARN, ""Unknown UDP framing tag, aborting dissection"", EXPFILL }}",1
    module_t *rlc_nr_module_,1
    expert_module_t* expert_rlc_nr_,1
    /* Register protocol. */,1
"    proto_rlc_nr = proto_register_protocol(""RLC-NR"", ""RLC-NR"", ""rlc-nr"")_",1
"    proto_register_field_array(proto_rlc_nr, hf, array_length(hf))_",1
    expert_rlc_nr = expert_register_protocol(proto_rlc_nr)_,1
"    expert_register_field_array(expert_rlc_nr, ei, array_length(ei))_",1
    /* Allow other dissectors to find this one by name. */,1
"    register_dissector(""rlc-nr"", dissect_rlc_nr, proto_rlc_nr)_",1
    /* Preferences */,1
"    rlc_nr_module = prefs_register_protocol(proto_rlc_nr, NULL)_",1
"    prefs_register_bool_preference(rlc_nr_module, ""call_pdcp_for_srb"",",1
"        ""Call PDCP dissector for SRB PDUs"",",1
"        ""Call PDCP dissector for signalling PDUs.  Note that without reassembly, it can""",1
"        ""only be called for complete PDUs (i.e. not segmented over RLC)"",",1
        &global_rlc_nr_call_pdcp_for_srb)_,1
"    prefs_register_enum_preference(rlc_nr_module, ""call_pdcp_for_drb"",",1
"        ""Call PDCP dissector for DRB PDUs"",",1
"        ""Call PDCP dissector for user-plane PDUs.  Note that without reassembly, it can""",1
"    prefs_register_bool_preference(rlc_nr_module, ""call_rrc_for_ccch"",",1
"        ""Call RRC dissector for CCCH PDUs"",",1
        &global_rlc_nr_call_rrc_for_ccch)_,1
"    prefs_register_bool_preference(rlc_nr_module, ""header_only_mode"",",1
"        ""May see RLC headers only"",",1
"        ""When enabled, if data is not present, don't report as an error, but instead """,1
"        ""add expert info to indicate that headers were omitted"",",1
        &global_rlc_nr_headers_expected)_,1
void proto_reg_handoff_rlc_nr(void),1
    /* Add as a heuristic UDP dissector */,1
"    heur_dissector_add(""udp"", dissect_rlc_nr_heur, ""RLC-NR over UDP"", ""rlc_nr_udp"", proto_rlc_nr, HEURISTIC_DISABLE)_",1
"    nr_rrc_bcch_bch = find_dissector_add_dependency(""nr-rrc.bcch.bch"", proto_rlc_nr)_",1
        gint hs_ext_record_size_limit_,0
"    { 0x00000009,  ""systemd journal entry"" },",0
%if %{with libxml2},0
	sd_journal_close(jnl)_,1
Requires:	systemd,0
elseif (BUILD_sdjournal),0
"		memcpy (entry_buff+data_end, &total_len, 4)_",0
	// XXX Do we need to call sd_journal_add_conjunction here?,1
"	//sd_journal_set_data_threshold(jnl, 8192)_",0
				return EXIT_FAILURE_,1
	// XXX Not needed?,0
#ifdef _WIN32,0
	WSADATA wsaData_,0
	attach_parent_console()_,0
	// XXX,1
"	// We don't have an SDJOURNAL DLT, so just use EN10MB (1) for now.",1
  -DBUILD_sdjournal=ON \,1
 * Network (MCN) dissection as per RFC RFC 5718 .,1
    guint       pid_,1
"    next_tvb     = tvb_new_subset_remaining(tvb, 2)_",1
#define PW_ACH_MCC_TYPE_IPV4          0x0021,1
#define PW_ACH_MCC_TYPE_IPV6          0x0057,1
   Network (MCN) dissection as per RFC RFC 5718 .,1
"    p_add_proto_data(pinfo->pool, pinfo, proto_pw_ach_mcc, 0, GUINT_TO_POINTER(pid))_",1
 * PW Associated Channel Header  Management Communication,0
"    pid = tvb_get_ntohs(tvb, 0)_",0
    if(tree){,0
"        proto_tree_add_item(mpls_pw_ach_mcc_tree, hf_mpls_pw_ach_mcc_proto,",0
"    proto_pw_ach_mcc = proto_register_protocol(""Managment Communication Channel (MCC)"",",0
 * FF: PW Associated Channel Header  Management Communication,0
		/* Generic/Preferred PW MPLS MCC Control Word fields */,0
"		&ett_mpls_pw_ach_mcc,",0
"    ws_buffer_init(&buf_, 1500)_",1
    wtap_rec rec_ /* Record metadata */,1
"    memset(&rec, 0, sizeof(rec))_",1
            ws_buffer_free(&buf)_,1
    /* TODO: Add Certificate Decrompression following algo... (Need to implement brolti too)*/,0
    return h2session->current_stream_id_,1
    case WFA_SUBTYPE_OWE_TRANSITION_MODE:,0
#if 0 // IDBs are optional.,0
    if (!global_commandline_info.cf_name),0
#.FN_BODY RATRestrictionInformation VAL_PTR=&parameter_tvb,0
"    { 0x00000000, ""Version Negotiation"" },",0
"    },",1
"                          QString(tr(""Should the directory %1 be created."").arg(urlText)) ) == QMessageBox::Yes )",1
version of zlib to be able to use zlib to read gzipped files_ version 1.1.3,1
        scheme_length = (int)strlen(previous_hop)+1_,0
"        proto_tree_add_item_ret_string(payload_block_tree, hf_bundle_payload_data, tvb, offset,",0
"    {0xD1, ""HMAC_SHA384""},",0
"    {0xD2, ""ECDSA_SHA256""},",0
"    {0xD3, ""ECDSA_SHA384""},",0
"    {0xD4, ""SHA256_AES128""},",0
"            col_append_fstr(pinfo->cinfo, COL_INFO, "", RS"")_",0
"                        printf ""%5d  %-40.40s\n"", $APIs{$apiGroup}{function_counts}{$api}, $api_",1
#ifdef HAVE_LIBGCRYPT_AEAD,0
                    new_param[np_len] = '\0'_,0
            offset += len_frametype_,0
"            g_array_append_val(wanted_fields, hf_of_interest[i].hf)_",0
"    { TLS_HANDSHAKE_FAILED, ""TLS_HANDSHAKE_FAILED (The TLS handshake failed)"" },",0
"    { TLS_FATAL_ALERT_GENERATED, ""TLS_FATAL_ALERT_GENERATED (A TLS fatal alert was sent causing the TLS connection to end prematurely)"" },",0
"        proto_tree_add_item_ret_uint(quic_tree, hf_quic_odcil, tvb, offset, 1, ENC_NA, &odcil)_",0
        if (odcil) {,0
            odcil += 3_,0
"          { ""Original Destination Connection ID Length"", ""quic.odcil"",",0
"    if (!quic_derive_handshake_secrets(cid, client_secret, server_secret, quic_info, error)) {",1
        if (success) {,0
"                col_set_writable(pinfo->cinfo, -1, FALSE)_",1
"    { SSL_HND_QUIC_TP_PA_IPV6, ""IPv6"" },",0
static int hf_quic_frame_type_crypt_offset = -1_,1
"            { ""RTT Message"", ""aeron.sm"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } },",0
"            ),",0
"      { &hf_ssl_pct_client_version, { ""Client Version"", ""tls.pct.client_version"", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},",1
"      { &ei_ssl_pct_client_version, { ""tls.pct.client_version.invalid"", PI_PROTOCOL, PI_WARN, ""Client Version invalid"", EXPFILL }},",1
"      { &ei_ssl_pct_ch_offset, { ""tls.pct.ch_offset.invalid"", PI_PROTOCOL, PI_WARN, ""CH_OFFSET invalid"", EXPFILL }},",1
 * TLS version 2 dissectors,1
     * Detect TLS 2.0 compatible Client Hello as used in SSLv3 and TLS.,1
 * TLS version 2 Dissectors,1
"    ti = proto_tree_add_item(tree, hf_tls_pct_client_version, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"                '-o', 'tls.desegment_ssl_application_data: FALSE',",1
"        { &hf_quic_token_length,",0
     * https://tools.ietf.org/html/draft-ietf-quic-tls-14#section-5.1.1,0
    // https://tools.ietf.org/html/draft-ietf-quic-tls-13#section-5.3,0
        // TODO separate field for encrypted and decrypted PKN?,0
"        {""Message fragments"", ""msg.fragments"",",1
static void ,1
        curr_len -= curr_offset - offset_ ,0
"    // Best-effort guess: if no connection is known, assume newer draft version.",0
                guint compressed_size = tvb_reported_length(raw)_,0
#else,1
                LZ4F_decompressionContext_t lz4_ctxt_,0
"            expert_add_info(pinfo, decrypt_item, &ei_kafka_message_decompress)_",0
"                g_warning(""Unable to save Display expressions: %s"", err)_",1
	display_filter_macro_uat->changed = TRUE_,0
#ifdef HAVE_LZ4FRAME_H,0
#if LZ4_VERSION_NUMBER >= 10401,0
#ifdef HAVE_PCAP_REMOTE,1
static GHashTable *wg_static_keys = NULL_,0
#define UUID_CONTEXT_MS_ADMIN              9,0
                                break_,1
"            { ""Context ID"", ""mbim.control.ms_provisioned_context_info_v2.context_id"",",0
"            { ""Context ID"", ""mbim.control.mbim_ms_network_blacklist_info.blacklist_state"",",0
"            { ""Context ID"", ""mbim.control.mbim_ms_network_blacklist_info.context_id"",",0
/* ,0
#define DATA_TYPE_UNSIGNED_INTEGER 3,0
"    g_snprintf(buf, ITEM_LABEL_LENGTH, ""%u BPM"", value)_",0
"  g_base64_decode_inplace(data, &len)_",1
    if (dfcode) {,1
"      if (dfilter_apply_edt(dfcode, &edt)) {",1
        passed_bits |= (1 << (framenum % 8))_,1
        prev_dis_num = framenum_,1
      },1
      passed_bits |= (1 << (framenum % 8))_,1
      prev_dis_num = framenum_,1
      fdata->flags.passed_dfilter = 1_,1
"              procedure_num = tvb_get_ntohs(tvb, *offset)_",0
    if (err_prob >= 0.0) {,0
            seed = (unsigned int) (time(NULL) + ws_getpid())_,0
"    {0x15, 0x3F, ""[Reserved]""},",0
"    {0x41, 0x7F, ""[Reserved]""},",0
"    {0x88, 0x8B, ""[Reserved]""},",0
"                                                    "" (UE=%u C-RNTI=%u), SF=%u"",",0
"                                                    "" (UE=%u C-RNTI=%u)"",",0
static epan_t *,0
static const value_string control_word[] = {,0
"    &hf_ieee80211_tag_twt_neg_type,",1
"  proto_item_append_text(item, "" Interval between individual TWT SPs %"" G_GUINT64_FORMAT,",0
static const true_false_string twt_implicit = {,0
			 (guint64) twt_wake_interval_mantissa << twt_wake_int_exp)_,0
  offset += 1_,0
    // NOTE: the FIELDABBREV here is shared between the TWT IE and the TWT,0
			 twt_wake_interval_mantissa * (1UL << twt_wake_int_exp))_,0
"  ""NDP Paging field is present"",",0
#define ACCEPT_TWT   4,0
  _twt_wake_int_exp = _twt_wake_interval_mantissa * (1ULL << _twt_wake_int_exp)_,0
  return tvb_captured_length(tvb)_,0
"     {""NDP Paging Indicator"", ""wlan.twt.ndp_paging"",",0
      // TODO: There are more tests needed here,0
    // but not at the same offset. Should I reuse the same FIELDABBREV ?,0
"  offset += add_ff_dialog_token(tree, tvb, pinfo, offset)_",0
"    expert_add_info_format(pinfo, field_data->item_tag_length, &ei_ieee80211_tag_length, ""Tag Length %u wrong, must be >= 1"", tag_len)_",0
"  // TODO: TWT field isn't always present, not clear when it isn't Check again the length",0
        if (!assoc) return_,1
"        QMessageBox::warning(this, tr(""Warning""),tr(""Could not find SCTP Association with id: %1"")",1
    selected_assoc = NULL_,0
version: 0.0.{build},1
"		""${VCINSTALLDIR}/Redist/MSVC/14.*.*"")",0
  static const enum_val_t ib_sg_enc_vals[] = {,1
					1 << ppoll)_,0
		ENC_NA)_,1
				flags)_,0
wireshark-win64-libs/,0
#define UDS_TD_SEQUENCE_COUNTER_OFFSET             (UDS_DATA_OFFSET + 0),0
    case UDS_SERVICES_TD: {,0
        guint32 sequence_no_,0
"        subtree = proto_tree_add_subtree(uds_tree, tvb, 0, -1, ett_uds_td, NULL, service_name)_",0
"        proto_tree_add_item_ret_uint(subtree, hf_uds_td_sequence_counter, tvb,",0
"                                     UDS_TD_SEQUENCE_COUNTER_OFFSET, UDS_TD_SEQUENCE_COUNTER_LEN, ENC_NA, &sequence_no)_",0
"        col_append_fstr(pinfo->cinfo, COL_INFO, ""   Block Sequence Counter %d"", sequence_no)_",0
"                            proto_item_set_len(ti_metric_nsa_object, 2)_",0
"        ""pdcp_keys"",                    /* filename */",0
"        ""Preconfigured PDCP keys"",",0
	exp_pdu_data->tlv_buffer = (guint8 *)g_malloc0(tag_buf_size)_,1
static int hf_ieee80211_ucast_twt_flow_id = -1_,0
"        ""Bad Negociation type for S1G TWT Flow field"", EXPFILL }},",0
"  {0x3, ""Broadcast TWT""},",0
      guint negociation_type = twt_flow_id & 0x60 >> 5_,0
"        // TODO: This is an error, what to do here?",0
	guint8   upgrade_,0
                                guint length = c ? (SDU_length-2) / 2 + 2: SDU_length_,1
                                while (offset - start_offset < length) {,0
    try { $stream = [IO.File]::OpenRead($filepath) } catch { throw },0
"    # may throw due to permission error, I/O error, etc.",0
"    { 0x3, ""IPv4v6"" },",0
 *                  v - field is hidden,0
"		/* XXX, for now always skip hidden */",1
"		if (FI_GET_FLAG(finfo, FI_GENERATED))",0
		{,0
"			printf("",\""generated\"":true"")_",0
		},1
"		if (FI_GET_FLAG(finfo, FI_HIDDEN))",0
"			printf("",\""hidden\"":true"")_",0
"    { 0x01, ""Handshake Initiation"" },",0
"    proto_tree_add_string(tree, hf_id, tvb, offset, 32, key_str)_",0
"        &hf_nas_5gs_mm_serv_type,",0
"  end_offset = tvb_skip_until_guint8(tvb, offset, tvb_captured_length_remaining(tvb, offset), ' ')_",0
"  proto_tree_add_time_item(tree, hf_syslog_timestamp, tvb, offset, end_offset - offset, ENC_UTF_8|ENC_ISO_8601_DATE_TIME,",0
"  dissect_syslog_info(tree, tvb, &offset, hf_syslog_version)_",0
  if (end_offset == -1),0
"    NULL, &offset, NULL)_",0
  *offset = end_offset + 1_,0
"      { ""Syslog timestamp"",    ""syslog.timestamp"",",1
    &ett_syslog_msg,0
"                wmem_map_remove(pfcp_info->unmatched, pcrp)_",1
"    proto_tree_add_item_ret_uint(sub_tree, hf_pfcp_seqno, tvb, offset, 3, ENC_BIG_ENDIAN, &seq_no)_",1
"        call_dissector_with_data(find_dissector(""btgatt.uuid0x2aae""), tvb_new_subset_length_caplen(tvb, offset, 4, 4), pinfo, tree, att_data)_",1
"    fprintf(output, ""  -p                     ignore radiotap header when checking for packet duplicates.\n"")_",0
"            { ""MPEG4 AAC Scalable"",             ""btavdtp.codec.mpeg24.object_type.mpeg4_aac_scalable"",",0
"    ""libgcrypt-1.8.3-win64ws.zip"" = """"_",0
"    ""libgcrypt-1.8.3-win??ws""_",0
$Global:proxy = $null,1
static const value_string gsm_a_rr_apdu_flags_cr_vals[] = {,1
static const value_string gsm_a_rr_apdu_flags_fs_vals[] = {,0
static const value_string gsm_a_rr_apdu_flags_ls_vals[] = {,0
"                FT_UINT8, BASE_DEC, VALS(gsm_a_rr_apdu_flags_cr_vals), 0x10,",0
"                FT_UINT8, BASE_DEC, VALS(gsm_a_rr_apdu_flags_fs_vals), 0x20,",0
"                FT_UINT8, BASE_DEC, VALS(gsm_a_rr_apdu_flags_ls_vals), 0x40,",0
  create_proto_tree = (dissect_color && color_filters_used()) || (dissect_tree) || (cinfo && have_custom_cols(cinfo))_,1
"    RSVP_CLASS_LSP_REQUIRED_ATTRIBUTES	= 67,",1
"    { RSVP_CLASS_LSP_REQUIRED_ATTRIBUTES,	""LSP REQUIRED ATTRIBUTES object""},",1
"    {  14,  14, ""Ethernet Line(EPL Type 2)"" },",1
static const value_string rsvp_rro_sobj_dbit_vals[] = {,0
    guint16 	m_,1
    case 8:	/* SSON FOWSPEC (RFC7762)*/ ,1
"        proto_tree_add_item(rsvp_object_tree, hf_rsvp_flowspec_m, tvb, offset2, 2, ENC_BIG_ENDIAN)_",0
		/* DWDM grid: Frequency (THz) = 193.1 THz + n * channel spacing (THz) */,1
"        //proto_tree_add_item(rsvp_object_tree, hf_rsvp_session_attribute_name_length, tvb, offset2+3, 1, ENC_BIG_ENDIAN)_",1
    guint8 signal_type_,1
"    proto_item_set_text(grid_tree,""Grid: %s (%u)"",val_to_str_const(grid, lambda_grid_vals, ""Unknown""),grid)_",1
"        proto_item_set_text(cs_tree, ""Channel Spacing: %s (%u)"",val_to_str_const(cs, grid1_cs_vals, ""Unknown""),cs)_",1
"        proto_tree_add_uint_format_value(wavelength_tree, hf_rsvp_wavelength_n, tvb, offset+2, 2, n, ""%d"", n)_",0
"        proto_item_set_text(cs_tree, ""Channel Spacing: %s (%u)"",val_to_str_const(cs, grid2_cs_vals, ""Unknown""),cs)_",1
"        proto_item_set_text(cs_tree, ""Channel Spacing: %s (%u)"",val_to_str_const(cs, grid3_cs_vals, ""Unknown""),cs)_",1
"    int         i, type,lbit,dbit,path_key, l,flags_",1
        /*  0                   1                   2                   3    */,0
"			proto_item_append_text(map_subtree, "" %s"", *value)_",0
"	dissect_msgpack_object(tvb, pinfo, tree, data, &offset, &value)_",0
"	msg=$(echo ""$msg"" | awk '",0
"	/* [IEEE80211_RADIOTAP_HE_MU_USER = 25 notdef */        { 0, 0 },",0
        /* IEEE80211_RADIOTAP_HE_MU_USER not implemented yet */,0
"        /* [IEEE80211_RADIOTAP_HE_MU_USER = 25 notdef */        { 0, 0 },",0
"                        proto_tree_add_item(present_word_tree,",0
"                {&hf_radiotap_present_0_length_psdu,",0
"            tvb, cur + 1, cursorname_len, tds_get_char_encoding(tds_info)|ENC_NA,",0
"                                proto_item_set_text(cs_tree, ""Channel Spacing: %s (%d)"",val_to_str_const((tvb_get_guint8(tvb, stlv_offset + 12) & 0x1E) >> 1, grid1_cs_vals, ""Unknown""),",1
"                        proto_item_set_text(cs_tree, ""Channel Spacing: %s (%d)"",val_to_str_const((tvb_get_guint8(tvb, stlv_offset + 52) & 0xF0) >> 4, grid3_cs_vals, ""Unknown""),",0
 * Added support for optical spectrum occupation for fixed grid WDM links (RFC 7579),0
 * Added support for optical spectrum occupation for flexi grid WDM links (RFC 7579),0
"                    /*   flexi-grid_lsc, see draft-ietf-ccamp-flexible-grid-ospf-ext-09 */",1
"                        if(tvb_get_ntohs(tvb, stlv_offset+2) > 36){",0
"                            proto_tree_add_item(sstlv_tree, hf_ospf_mpls_bandwidth_type, tvb, sstlv_offset, 2, ENC_NA)_",1
"                            proto_item_set_text(action_tree, ""Action: %d"",(tvb_get_guint8(tvb, sstlv_offset + 8) & 0xF0) >> 4 )_",0
                            if(grid == 1){,1
"    proto_tree *cs_tree, *no_eff_bits_tree, *starting_tree_ ",0
"		printf ""\n\nERROR: First line in the commit message must not exceed 80 characters\n\n""",0
                            p_mac_lte_info->number_of_srs = no_entries_,1
       if(dl_flush == 1){,0
       if(dl_disc_blk == 1){,0
          count = dl_disc_num_blks_,0
       if(lost_packet_report == 1){,0
          count = lost_NR_U_SN_range_,0
       if(high_del_nr_pdcp_sn_ind == 1),0
       if(high_tx_nr_pdcp_sn_ind == 1),0
       if(cause_rpt == 1),0
       if(high_del_retx_nr_pdcp_sn_ind == 1),0
       {,0
                           pdcp_length = tvb_reported_length(tvb) - offset_,0
                        else if(nr_pdu_type == 1){,0
//static dissector_handle_t pdcp_handle_,0
       PROTO_ITEM_SET_GENERATED(ti)_,0
          PROTO_ITEM_SET_GENERATED(ti)_,0
             PROTO_ITEM_SET_GENERATED(ti)_,0
       high_tx_nr_pdcp_sn_ind = (high_tx_nr_pdcp_sn_ind  & 0x08)>>3_,0
       high_del_nr_pdcp_sn_ind  = (high_del_nr_pdcp_sn_ind   & 0x04)>>2_,0
       lost_packet_report = lost_packet_report & 0x01_,0
       high_retx_nr_pdcp_sn_ind = (high_retx_nr_pdcp_sn_ind & 0x04) >> 2_,0
       high_del_retx_nr_pdcp_sn_ind = (high_del_retx_nr_pdcp_sn_ind & 0x04) >> 2_,0
       cause_rpt = cause_rpt & 0x01_,0
"                                        """",""NR RAN Container"")_",0
                            PROTO_ITEM_SET_GENERATED(ran_cont_tree)_,0
                            * payload as per 3GPP TS 38.323*/,0
"           FT_UINT32, BASE_DEC, NULL, 0xffffffff,",0
"           FT_UINT24, BASE_DEC, NULL, 0xffffff,",0
"    zbee_nwk_green_power_packet *packet _U_, guint offset)",0
                if(packet != NULL),0
            if(packet != NULL),0
# We don't necessarily want to depend on building our executables before,1
    gIsSackChunkPresent = false_,0
"            phtole32(enc_buffer_withA, packet->source_id)_ /* enc_buffer_withA = CCM* a (srcID) | enc_buffer */",0
    nonce[11] = (guint8)((packet->security_frame_counter) >> 24 & 0xff)_,0
"            memcpy(enc_buffer_withA, &(packet->source_id), 4)_",0
"    proto_tree_add_item (fp_tree, hf_ftag, tvb, offset, FP_FTAG_LEN, ENC_BIG_ENDIAN)_",1
Not yet written. See https://wiki.wireshark.org/Development/SubmittingPatches,0
"// COMMENTED OUT, not yet implemented in QT UI",0
Statistics for HTTP request types and response codes,0
HTTP statistics based on the host and URI,0
HTTP request and response statistics based on the server address and host,0
The Wireless menu provides access to statistics related to wireless traffic,0
Dylan Ulis <daulis0@gmail.com>,0
WSUG: Update docs for 'Export Object',1
Change-Id: Ifab1a0d76d3ba81585d557a8a8b49351cdc6a002,1
Reviewed-on: https://code.wireshark.org/review/28734,1
Reviewed-by: Graham Bloice <graham.bloice@trihedral.com>,1
   list.,1
"	type = tvb_get_guint16(tvb, offset, ENC_BIG_ENDIAN) >> 9 & 0x3F_",1
		&ett_h265_sprop_parametes,0
	/* Dissect the H265,0
"The extcap utility is then called again with all filled out arguments and the additional parameter ""--extcap-reload-option <option_name>"". It is expected to return a value section for this option, as it would during normal configuration. The provided option list is then presented as the selection, a previous selected option will be reselected if applicable.",1
"Arguments may be set with ""{required=true}"" which enforces a value being provided, before",1
"+Valid Commands: Set value, Enable, Disable.",1
:toclevels: 4,0
      // TODO: Handle more dimensions.,0
      if (dimension == 0 || dimension == 1),0
      {,0
"         parsed_len = dissect_cip_attribute(pinfo, attr_tree, attr_item, tvb, pattribute, offset, attribute_size)_",0
           cip_simple_request_info_t motion_path_,0
           motion_path.iClass = 0x42_,0
           motion_path.iInstance = 1_,0
"           parsed_len = dissect_cip_set_attribute_list_req(tvb, pinfo, header_tree, item, offset + 4, &motion_path)_",0
       int parsed_len = 0_,0
       switch (service_code),0
       case SC_GET_AXIS_ATTRIBUTE_LIST:,0
"           dissect_get_axis_attr_list_response(pinfo, tvb, header_tree, offset + 4, size - 4)_",0
           parsed_len = size - 4_,0
           break_,0
       case SC_SET_AXIS_ATTRIBUTE_LIST:,0
"           dissect_set_axis_attr_list_response(tvb, header_tree, offset + 4, size - 4)_",0
       case SC_GROUP_SYNC:,0
"           dissect_group_sync_response(tvb, header_tree, offset + 4, size - 4)_",0
       case SC_SET_ATT_LIST:,0
          cip_simple_request_info_t motion_path_,0
          motion_path.iClass = 0x42_,0
          motion_path.iInstance = 1_,0
"          parsed_len = dissect_cip_set_attribute_list_rsp(tvb, pinfo, header_tree, item, offset + 4, &motion_path)_",0
          break_,0
       },0
       default:,0
       /* Display the remainder of the service channel data */,0
       if (size - 4 - parsed_len > 0),0
"              print_len = g_snprintf(np, maxname + 1, ""\\[x"")_",0
"                                       tvb_get_guint8(tvb, offset))_",0
"              print_len = g_snprintf(np, maxname + 1, ""/%d]"", bit_count)_",0
"  - if [ ""$TRAVIS_OS_NAME"" == ""linux"" ]_ then if [ ""$CXX"" == ""g++"" ]_ then export CXX=""g++-8"" CC=""gcc-8""_ fi _ fi",0
        // XXX the dummy replacement could be larger than the actual missing bytes.,0
    for (cur = g_list_last(follow_info->payload)_ cur_ cur = g_list_previous(cur)) {,1
     */,1
            /* Domain name*/,0
    return (guint16)*((const guint8 *)(p)+6)<<8|,0
    return (guint32)*((const guint8 *)(p)+5)<<16|,0
    return (guint32)*((const guint8 *)(p)+4)<<24|,0
    return (guint64)*((const guint8 *)(p)+3)<<32|,0
    return (guint64)*((const guint8 *)(p)+2)<<40|,0
    return (guint64)*((const guint8 *)(p)+1)<<48|,0
"static inline void phton16(gchar *p, guint16 v)",0
"static inline void phton32(gchar *p, guint32 v)",0
static const value_string h265_profile_idc_values[] = {,0
static const value_string h265_level_bitrate_values[] = {,0
"		{ ""F bit"",           ""h265.f"",",1
/* packet-h265.h,0
"                                        ""Type=%d Len=%d"", type, 2+len)_",0
    /* MCC digit 2	MCC digit 1 Octet 2*/,0
    *(nonce++) = (guint8)((packet->src64)>>56)_,1
          maxname--_,0
          if (maxname > 0) {,0
"    { 0xC0AF, ""TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8"" },",0
	gulong packet_delay_ms = 0_,1
"static const true_false_string tfs_desired_not_desired = { ""Desired"", ""Not Desired"" }_",0
"			col_append_fstr(pinfo->cinfo, COL_INFO, ""SysName = %s "", strPtr)_",1
"			col_append_fstr(pinfo->cinfo, COL_INFO, ""SysDesc = %s "", strPtr)_",1
TCP protocol preference “Whether subdissector can request TCP streams to be,1
        guint16         mdp_type_,0
                if(mdp_type == 0x0712 || mdp_type == 0x0713){,0
proto_reg_handoff_mdp(void),0
#define HW_ADDR       1,0
"    { 1, ""MAC Address"" },",0
    if (preamble != 518){,0
"            proto_tree_add_item(tlv_tree, hf_ubdp_mac, ubdp_tvb, offset, ubdp_length, ENC_NA)_",0
            if(ubdp_length == 0){,0
"        proto_item_set_len(tlv_tree, ubdp_length + 3)_",0
#define UBDP_PORT 10001,0
"    proto_tree_add_item(ubdp_tree, hf_ubdp_size, ubdp_tvb, offset + 2, 2, ENC_NA)_",0
"        ubdp_item_tlv = proto_tree_add_item_ret_uint(ubdp_tree, hf_ubdp_type, ubdp_tvb, offset + TLV_TYPE, 1, ENC_BIG_ENDIAN, &ubdp_type)_",0
"            proto_tree_add_item(tlv_tree, hf_ubdp_system_id, ubdp_tvb, offset, ubdp_length, ENC_NA)_",0
        offset += ubdp_length_,0
    offset+=4_,1
static QStringList export_extensions = QStringList(),1
	 * See,1
	/*,1
	 * They should also note that you need an OSVERSIONINFOEX structure,1
"	HMODULE ntdll_module = LoadLibrary(_T(""ntdll.dll""))_",1
"						""Possible encoding error open type length less than dissectoed bits. Open type length %u, decoded %u"", length, length - (difference>>3))_",1
if(ASCIIDOCTOR_EXECUTABLE),0
$ tar xaf wireshark-2.9.0.tar.xz,0
    return tvb_reported_length(tvb)_,0
"  { PROTO_CHECKSUM_E_BAD,        ""Bad""  },",0
    gchar *payload_str_,0
    guint32 expected_,0
    gboolean problem_,0
"int printf(const char*, ...)_",0
"        proto_tree_add_item(subtree, hf_auth_algorithm, tvb, off+1, 1, ENC_BIG_ENDIAN)_",0
            if (optlen-11-20 < (int)sizeof(realm)) {,0
			,1
"					ReqRespDissector *reqresp_dissector, http_conv_t *conv_data)_",0
http_type_t get_http_type_from_method(http_method_t http_method),0
            return HTTP_REQUEST_,1
"http_method_t parse_http_method(const gchar *data, int data_len)",1
    switch (data_len) {,1
            http_method = HTTP_METHOD_NONE_,1
typedef enum _http_method {,0
#define MIN_DNAME_LEN    2              /* minimum domain name length */,1
#define CHANGE_TYPE_IS_MONOTONIC_INCR 0,0
"                            int pad_len = tvb_reported_length_remaining(tvb, offset)_",0
"                /* Bit 8 of Octet 1 is set, this indicates that the IE is defined by a vendor and the Enterprise ID is present */",0
    /*Octet 8		Spare Spare Spare Spare INAPRA APRA OPRA IPRA */,0
    guint16 cluster_id_,0
"    output = add_prototypes(output, protos)",0
    infiles = sys.argv[3:],0
          ${CMAKE_SOURCE_DIR}/tools/make-taps.py ${_outputfile} ${_sources},0
	COMMAND ${CMAKE_SOURCE_DIR}/tools/make-dissectors.py dissectors.c @dissectors.in.txt,0
# could invoke  )../tools/pre-commit HEAD ) to check for changes to staged files.,1
LUPDATE_FILES=$(find ui/qt -name '*.cpp' -o -name '*.h' -o -name '*.ui'),0
        return,0
"            ""In order to capture packets, WinPcap must be installed_ see\n""",0
"            ""\n""",0
"            ""        https://www.winpcap.org/\n""",0
"            ""for a downloadable version of WinPcap and for instructions on how to install\n""",0
BuildRequires:	cmake3 >= 3.5,0
cmake3 \,0
id-AMFConfigurationUpdate					ProcedureCode,0
id-AMFStatusIndication						ProcedureCode,0
id-CellTrafficTrace							ProcedureCode,0
id-DeactivateTrace							ProcedureCode,0
	id-AllowedNSSAI											ProtocolIE-ID,0
	id-AMFName 												ProtocolIE-ID,0
	id-AMFSetID												ProtocolIE-ID,0
AllowedNSSAI										N ngap.ies id-AllowedNSSAI,0
AMFName												N ngap.ies id-AMFName,0
AMFSetID											N ngap.ies id-AMFSetID,0
TNLAssociationList									N ngap.ies id-AMF-TNLAssociationFailedToSetupList,0
AMF-TNLAssociationSetupItem							N ngap.ies id-AMF-TNLAssociationSetupItem,0
"    proto_tree_add_item(field_tree, hf_zbee_zdp_profile, tvb, *offset, 2, ENC_LITTLE_ENDIAN)_",0
    gIsNRSackChunkPresent(false),0
"         <property name=""sizePolicy"">",0
"          <sizepolicy hsizetype=""Minimum"" vsizetype=""Preferred"">",0
           <horstretch>0</horstretch>,0
           <verstretch>0</verstretch>,0
          </sizepolicy>,0
         </property>,0
"         <property name=""minimumSize"">",0
          <size>,0
           <width>300</width>,0
           <height>0</height>,0
          </size>,0
"         <property name=""maximumSize"">",0
           <width>600</width>,0
           <height>16777215</height>,0
"         <property name=""layoutDirection"">",0
          <enum>Qt::LeftToRight</enum>,0
		#-Wshadow,0
        ${CMAKE_CURRENT_SOURCE_DIR}/packet-glow.c,0
        packet-glow.h,0
        ${CMAKE_CURRENT_SOURCE_DIR}/packet-s101.c,0
        proto_item      *glow_item = NULL_,0
 ,0
/* packet-snmp.h,0
 * Routines for snmp packet dissection,0
#endif  /* PACKET_SNMP_H */,0
 * Routines for PROTONAME dissection,0
frameFormatString(guint8 format) {,0
flagsString(guint flags) {,0
    /*** HEURISTICS ***/,0
"        proto_tree_add_uint_format_value(S101_tree, hf_S101_message_type, tvb, current_offset++,1, message, ""%s"", messageTypeString(message))_",0
"        {&hf_msg_fragments,",0
"        { &hf_ua3g_ip_device_routing_freeseating_parameter_ipv6, { ""Value"", ""ua3g.ip.freeseating.parameter.ip"", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL }},",0
if(GIT_EXECUTABLE),0
	set(GIT_BIN_PARAM --git-bin ${GIT_EXECUTABLE}),0
		add_custom_command(OUTPUT ${CMAKE_BINARY_DIR}/${_text_file}.txt,0
BuildRequires:	cmake >= 3.5 or cmake3 >= 3.5,1
# End:,1
"	{ ""Ruby Marshal Object"", FALSE, ""dat"" }",0
	# -external-sources requires 0.4.0 or later.,0
		COMMAND shellcheck -external-sources,0
"	stcsig_tvb = tvb_new_child_real_data(tvb,real_stcsig,bytes,bytes)_",0
	guint16 mfr_code_,1
    while (offset < tvb_len)  //TODO not secure with malformed packets,0
"    { PDCP_NR_DIRECTION_UPLINK,      ""Uplink""},",1
#define PDCP_NR_UL_SDAP_HEADER_PRESENT 1,0
    guint8             sdap_header_,0
  - sudo gem install asciidoctor --no-ri --no-rdoc,1
# Add distro-specific packages,1
	FreeBSD),1
# Setup development environment on Debian and derivatives such as Ubuntu,0
"    register_ber_oid_dissector(""1.2.826.0.1249.58.1.0"",dissect_NokiaMAP_ext_ExtensionType,proto_gsm_map,""Nokia ExtensionType Extension"")_",0
"            header_name_key = wmem_ascii_strdown(NULL, dynamic_hf[i].hfinfo.name, -1)_",0
"            wmem_map_remove(sip_custom_header_fields_hash, header_name_key)_",0
"            wmem_free(NULL, header_name_key)_",0
"        wmem_map_insert(user_data_fields_hash_ett, key, ett_id)_",1
	proto_cleanup()_,0
	packet_cleanup()_,0
"        sip_custom_header_fields_hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free)_",0
"                gint *hf_ptr = (gint*)g_hash_table_lookup(sip_custom_header_fields_hash, header_name)_",0
"    if ((cp = strtok(NULL, ""\t"")) != NULL)",0
"				g_snprintf(buf, ITEM_LABEL_LENGTH, ""%02x:%02x:%02x (%s)"", p_oui[0], p_oui[1], p_oui[2], manuf_name)_",0
"    proto_tree_add_item(pcp_label_tree, hf_pcp_label_nsets, tvb, offset, 4, ENC_NA)_",0
"                                     tvb, offset, -1)_",0
    if (offset > next_offset) {,0
"        proto_tree_add_expert(proxy_tree, pinfo, &ei_proxy_header_length_too_small,",0
        return offset_,1
        // expert info that header length is too small,0
"    if(tvb_memeql(tvb, 0, MAGIC_V2, 12) == 0){",0
"    proto_tree_add_item(proxy_tree, hf_proxy2_len, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
            offset += 108_,0
"            offset += tvb_reported_length_remaining(tvb, offset)_",0
"    offset = dissect_proxy_v2_tlv(tvb, pinfo, proxy_tree, offset)_",0
"    if(tvb_memeql(tvb, 0, MAGIC_V2, 12)){",0
"            FT_UINT8, BASE_HEX, NULL, 0xF0,",0
                    hf[i].hfinfo.display = BASE_NONE_,1
"                ""HTTP2 bytes range which server may use for partial data transfer"", HFILL}",1
    packet-http2-static-headers.h   \,1
"/* checkhf.pl checks that every hf_ has a proto_*add* function, but we have a hash table of pointers to hf_ and one */",0
"                ""HTTP2 Request-URI Path"", HFILL}",0
"                ""HTTP2 MIME type which client is able to understand"", HFILL}",1
"                ""HTTP2 Charset which client is able to understand"", HFILL}",1
"                ""HTTP2 content encoding(compression) which client is able to understand"", HFILL}",1
"                ""HTTP2 language and locale which client is prefer"", HFILL}",1
"        /* specifies named fields, so affects dissection",1
        // rfc static headers,1
"            proto_tree_add_string(tree, hf_http2_headers_host, tvb, offset, in->length, header_value)_",1
    register_cleanup_routine(&http2_cleanup_protocol)_,0
		packet-http2-static-headers.h,0
"                ""HTTP2 content encoding(compression) which is used to encode data"", HFILL}",1
"                ""Preferred natural languages for the user agent"", HFILL}",1
"        { val_uint64,   ""usigned 64bit integer"" },",1
  if (rec->encryption_key_string) {,1
"                    tsn_s = g_new0(struct tsn_sort, 1)_",1
                g_free(sack)_,0
    prefs.gui_active_style           = COLOR_STYLE_DEFAULT_,0
    ui->inactiveSampleLineEdit->setStyleSheet(sample_text_ex_ss.arg(,0
        goto end_of_wlan_ /* heuristics dissector handled it. */,1
      encap_type = ENCAP_802_2_,0
"      if (tvb_bytes_exist(next_tvb, 0, 2)) {",0
"        octet1 = tvb_get_guint8(next_tvb, 0)_",0
"        octet2 = tvb_get_guint8(next_tvb, 1)_",0
        if ((octet1 != 0xaa) || (octet2 != 0xaa)) {,0
"          if ((tvb_memeql(next_tvb, 6, (const guint8 *)pinfo->dl_src.data, 6) == 0) ||",0
"              (tvb_memeql(next_tvb, 0, (const guint8 *)pinfo->dl_dst.data, 6) == 0))",0
            encap_type = ENCAP_ETHERNET_,0
          else if ((octet1 == 0xff) && (octet2 == 0xff)),0
            encap_type = ENCAP_IPX_,0
          else if (((octet1 == 0x00) && (octet2 == 0x00)) ||,0
                   (((octet2 << 8) | octet1) == seq_control)) {,0
"            proto_tree_add_item(tree, hf_ieee80211_mysterious_olpc_stuff, next_tvb, 0, 2, ENC_NA)_",0
"            next_tvb = tvb_new_subset_remaining(next_tvb, 2)_",0
          },0
      switch (encap_type) {,0
      case ENCAP_802_2:,0
"        call_dissector(llc_handle, next_tvb, pinfo, tree)_",0
      case ENCAP_ETHERNET:,0
"        call_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree)_",0
      case ENCAP_IPX:,0
"        call_dissector(ipx_handle, next_tvb, pinfo, tree)_",0
            /***************************/,1
"   Preemption Protocol, ISO 13400-2 Diagnostic communication over",0
                        break_,1
static const true_false_string code_rate_7_8 = {,0
  /* TODO: 8 - 255 Reserved: how to represent?*/,0
  if (tag_len != 22),0
"     {""STA Beam Tracking Time Limit(us)"", ""wlan.dmg_capa.beam_track"",",0
#include <wsutil/netlink.h>,0
	nelink.h,0
#include <caputils/ws80211_utils.h>,0
    g_regex_unref(priv->re_post_eb)_,0
   enip_tree = NULL_,1
"  - if [ ""$PCAP"" == ""ON"" ]_ then ninja test-programs_ ninja test_ fi",1
	list(APPEND,0
        /* XXX should it check for SUCCESS_POWER_SAVE_MODE (85) as well? */,0
add_package ADDITIONAL_LIST nghttp2 ||,0
set(WIRESHARK_QT_QRC_SRC ${WIRESHARK_QT_QRC}),0
  # macos,0
static void exit_from_loop(int signo _U_),0
	run_loop = FALSE_,0
	int *ret = (int*)arg_,1
nla_put_failure:,1
		if (pcap_fp) ,1
"		printf(""group %s\n"", (char*)nla_data(tb_mcgrp[CTRL_ATTR_MCAST_GRP_NAME]))_",1
"void hexdump(void *mem, unsigned length)",1
	char  line[80]_,1
	char *src = (char*)mem_,1
"	unsigned i,j_",1
	printf(,1
"		""     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F    0123456789ABCDEF\r\n""",1
		)_,1
"	for (i=0_ i<length_ i+=16, src+=16) {",1
		char *t = line_,1
"		t += sprintf(t, ""%02x:  "", i)_",1
		for (j=0_ j<16_ j++) {,1
			if (i+j < length),1
"				t += sprintf(t, ""%02X"", src[j] & 0xff)_",1
			else,1
"				t += sprintf(t, ""  "")_",1
"			t += sprintf(t, "" "")_",1
"		t += sprintf(t, ""  "")_",1
			if (i+j < length) {,1
				if (isprint((unsigned char)src[j])),1
"					t += sprintf(t, ""%c"", src[j])_",1
				else,1
"					t += sprintf(t, ""."")_",1
			} else {,1
"				t += sprintf(t, "" "")_",1
			},1
"		t += sprintf(t, ""\r\n"")_",1
"		printf(""%s"", line)_",1
"		nl_cli_fatal(NLE_NOMEM, ""Unable to allocate netlink message"")_",0
"		nl_cli_fatal(ENOMEM, ""Unable to write genl header"")_",0
	return 0_,1
	(void)arg_,1
    dpauxmon --extcap-interface cisco --fifo=/tmp/cisco.pcap --capture --interface_id 0,1
	(void)nla_,1
	(void)msg_,1
"#include ""randpkt_core/randpkt_core.h""",1
	(void)unused_,1
	(void)cmd_,1
"	nla_for_each_nested(mcgrp, tb[CTRL_ATTR_MCAST_GROUPS], rem_mcgrp) {",0
	set(HAVE_SYS_STAT_H TRUE),0
	set(HAVE_STDDEF_H TRUE),0
  if (cf->cd_t == WTAP_FILE_TYPE_SUBTYPE_BER,1
"	{ ""ASN.1 BER (PEM-like encoding)"",          OPEN_INFO_MAGIC,     pem_open,                 ""pem_crt"",  NULL, NULL },",0
"	{ ""ASN.1 BER (PEM-like encoding)"", ""pem"", NULL, NULL,",0
"    } while (g_regex_match(priv->re_blank_line, line, (GRegexMatchFlags)0, NULL))_",0
"                *err_info = g_strdup(""missing post-encapsulation boundary"")_",0
"#define RE_LABEL ""([!-,.-~]([-\\s]?[!-,.-~])*)?""",1
    offset = value_guard(shoff + (guint32)shndx * (guint32)shentsize)_,0
    t += (guint32)days * (24*60*60)_,0
    t += (guint32)(days * (24*60*60))_,0
"  proto_tree_add_item(mcs_tree, hf_ieee80211_vht_mcsset_ext_nss_bw_cap, tvb, offset, 2, ENC_LITTLE_ENDIAN)_",0
"      NULL, HFILL }},",0
brew install c-ares glib libgcrypt gnutls lua cmake nghttp2 snappy lz4 libxml2 json-glib ninja libmaxminddb doxygen lua libsmi,0
"        ret = json_parser_load_from_data(parser, buf, len, &error)_",1
" * Copyright 2015, Dario Lombardo <lomato@gmail.com>",1
"#define __HF_MAIN(_reg, _text) \",1
"    { &hf_##_reg,\",1
"        { #_text, ""dpaux."" #_reg, FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } }",1
"#define __HF_BOOL(_reg, _text, _mask) \",1
"    { &hf_##_reg##_##_text,\",1
"        { #_text, ""dpaux."" #_reg ""_"" #_text, FT_BOOLEAN, 8, NULL, _mask, NULL, HFILL } }",1
"#define __HF_UINT(_reg, _text, _base, _convert, _mask)\",1
	/* DisplayPort AUX channel monitor */,1
	 * To repeat:,1
	 *,1
"	 * If you need a new encapsulation type for libpcap files, do",1
"	 * *N*O*T* use *ANY* of the values listed here!  I.e., do *NOT*",1
	 * add a new encapsulation type by changing an existing entry_,1
	 * leave the existing entries alone.,1
"	 * Instead, send mail to tcpdump-workers@lists.tcpdump.org, asking",1
"	 * for a new DLT_ value, and specifying the purpose of the new value.",1
"	 * When you get the new DLT_ value, use that numerical value in",1
                if (res > 0) {,0
                    k += res_,0
                } else {,1
                    k++_,0
"#define __HF_MAIN(_reg, _text) { &hf_##_reg, { #_text, ""dpaux."" #_reg, FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } }",0
"#define __HF_BOOL(_reg, _text, _mask) { &hf_##_reg##_##_text, { #_text, ""dpaux."" #_reg ""_"" #_text, FT_BOOLEAN, 8, NULL, _mask, NULL, HFILL } }",0
"	{ 275,		WTAP_ENCAP_DPAUXMON },",0
    buffer_size--_,0
        goto cleanup_exit_,0
        buffer[0] = '\0'_,1
            goto cleanup_exit_,1
        buffer_bytes_remaining = buffer_size - total_bytes_read_,1
                buffer[STDERR_BUFFER_SIZE] = '\0'_,0
		exp_pdu_tags_len += 4 + (exported_pdu_info->proto_col_str ? (int)strlen(exported_pdu_info->proto_col_str) : 0)_,0
    int offset_end = offset + len_,0
"    len = tvb_reported_length_remaining(tvb, offset)_",0
        // XXX Style the protocol tree as well? ,0
    pref_t *pref_toolbar_main_style__,0
	if (hdr->sb0 || hdr->sb1 || hdr->sb2),0
	if (chunk[1] != 1),0
		if (chunk[1]),0
		return FALSE_,0
"	/* Read in the number that should be at the start of a ""libpcap"" file */",0
  ,1
    if (G_UNLIKELY(allocator->count == allocator->size)) {,0
    if (G_UNLIKELY(x == 0)),0
                /* TA (12 bits) */,0
* Devel/bison (or install Win flex-bison -- see Chocolatey below),1
	,1
"	FILE(READ ""${CMAKE_CURRENT_BINARY_DIR}/version.h"" VERSION_H_FILE_CONTENT)",0
"	string(REPLACE ""-"" ""_"" RPM_VERSION ""${_git_description}"")",0
"    col_add_str(pinfo->cinfo, COL_INFO,",0
"			if (!g_ascii_strcasecmp(g_strstrip(typval[0]), ""NLR""))",0
        if (p_pdcp_info->bearerType == Bearer_DCCH) {,0
			/* Include new-line in line */,0
	filter_expression_t expression_,0
" *  Copyright 2015, Michail Koreshkov <michail.koreshkov [at] bk.ru",0
    guint32	curr_offset_,0
"    cause_item = proto_tree_add_item(sub_tree, hf_gsm_r_chpc_cause, tvb, curr_offset, 1, ENC_NA)_",0
	/usr/bin/ctest --force-new-ctest-process -j3 --verbose,1
	true,1
                os.unlink(filename),1
        self.commands.append(cmd),0
"        ('( cat ""{0}"" _ sleep 1 _ tail -c +25 ""{0}"" ) > {1}'.format(capture_file, fifo_file)),",1
            env = os.environ,0
"static void add_item(proto_tree *tree, int hf, tvbuff_t *tvb,",1
#define TPM_ALG_NULL 0x0010,1
	df->owns_memory[to_reg] = TRUE_,0
|_ss7pcs_|SS7 points code resolution.,0
==== SS7 point codes resolution,0
"    proto_tree_add_debug_text(ctree, ""Client CID: %s"", cid_to_string(&conn->client_cids.data))_",0
"          { ""Connection Number"", ""quic.connection.number"",",0
        if (ARISTA_TIMESTAMP_V1 == version) {,0
#define ETHERTYPE_AVSP          0xD28B /* Ethernet type for Arista vendor specific packet frames */,0
void proto_register_avsp(void),1
               }else,1
named <code>wireshark_wireshark</code> or <code>wireshark-qt</code>.  Find it and,1
"		//att_tree = proto_item_add_subtree(ti, ett_gsup_ie)_",0
"		//proto_tree_add_uint(att_tree, hf_gsup_ie_len, tvb, offset, 1, len)_",1
"		col_append_fstr(pinfo->cinfo, COL_INFO, ""%s "", str)_",1
"					       ""Attribute length is too small (%d bytes)"", length)_",1
			offset = offset + length - 2_,1
		if ((length+pad_len) < (offset - attr_start_offset)){,0
 * Copyright 2018 Peter Wu <peter@lekensteyn.nl>,1
"    offset += tvb_reported_length_remaining(tvb, offset)_",0
 * https://tools.ietf.org/html/draft-ietf-quic-transport-10,0
"        col_append_fstr(pinfo->cinfo, COL_INFO, "", DST=%s"", cid_to_string(dcid))_",0
"        col_append_fstr(pinfo->cinfo, COL_INFO, "", SRC=%s"", cid_to_string(scid))_",0
"    col_set_str(pinfo->cinfo, COL_INFO, val_to_str(long_packet_type, quic_long_packet_type_vals, ""Long Packet""))_",0
"    col_set_str(pinfo->cinfo, COL_INFO, ""Version Negotiation"")_",1
"          { ""Destination Connection ID"", ""quic.dst_cid"",",0
"          { ""Source Connection ID"", ""quic.src_cid"",",0
"          { ""Destination Connection ID Length"", ""quic.dst_cid_len"",",1
    QModelIndex packetIndex = ui->expertInfoTreeView->indexAt(pos)_,1
    if (!packetIndex.isValid()) {,1
"    unsigned int flow_index = select_http2_flow_index(pinfo, session)_",1
      elastic_mapping_filter = optarg_,0
  const gchar*         elastic_fields = NULL_,1
=item --elastic-mapping-fields,1
					found = TRUE_,1
      elastic_fields = g_strdup(optarg)_,1
        proto_registrar_dump_elastic(argv[2])_,0
* The autotools build system has been removed.,1
"        expert_add_info_format(pinfo, ti, &ei_quic_protocol_violation,",1
	set(LIBEPAN_LIBS ${LIBEPAN_LIBS} ${JSONGLIB_LIBRARY}),0
		target_include_directories(tshark PUBLIC ${JSONGLIB_INCLUDE_DIR}),1
      libjson-glib-1.0,1
gchar* dot_to_underscore(gchar* str),0
	json_builder_end_object(builder)_ // 8.properties,1
	json_builder_end_object(builder)_ // 5.layers,1
	json_builder_begin_object(builder)_ // 6.layers,1
				json_builder_end_object(builder)_ // 8.parent_hfinfo->abbrev,0
B<elastic>  Dumps the ElasticSearch mapping file to stdout.,1
"* tshark has now ""-G elastic"" option to generate an ElasticSearch mapping file.",1
	json_builder_end_object(builder)_,0
	g_free(data)_,0
			break_,0
"			json_builder_set_member_name(builder, hfinfo->abbrev)_",0
"	ws_debug_printf(""%s\n"", json_generator_to_data(generator, &length))_",0
"  fprintf(output, ""  -G elastic               dump ElasticSearch mapping file\n"")_",0
  	PATH_SUFFIXES,0
        file_name_ = cfi.fileName()_,1
  if (cf->count != 0),1
                capture_option_specified = TRUE_,0
		# XXX Add an option to git-export-release.sh to write to a,0
		# specific directory so that we can get rid of `ln` below.,0
"		DEPENDS ""${CMAKE_SOURCE_DIR}/${_export_tarball}""",1
"      { ""WDC"", ""mscldap.netlogon.flags.writabledc"", FT_BOOLEAN, 32,",0
        case FT_ACK:{,0
        offset = tvb_reported_length(tvb) - p_pdcp_nr_info->pdu_length_,0
                /* RoHC IP version field is now 1 byte only_ let's skip mosty significant byte,0
"                p_pdcp_lte_info->rohc.rohc_ip_version = tvb_get_guint8(tvb, offset+1)_",0
"        tag = tvb_get_guint8(tvb, offset++)_",1
                /* It must be a recognised tag */,0
"	{ ""Address family"", ""netlink-route.rt.family"", FT_UINT8, BASE_DEC | BASE_EXT_STRING,",0
#define PFCP_CREATED_TRAFFIC_ENDPOINT 	      128,0
"    { 131, ""Traffic Endpoint ID""},                                  /* Extendable / Subclause 8.2.92*/",0
    return _,0
"/*    127 */	{ dissect_pfcp_create_traffic_endpoint }, 			/* Create Traffic Endpoint   			   Extendable / Table 7.5.2.7 */",0
"                mantissa = (gint64)lbmpdm_fetch_uint64_encoded(tvb, offset + 1, encoding)_",0
"                proto_tree_add_item(main_tree, hf_rssi_threshold, tvb, offset, 2, ENC_LITTLE_ENDIAN)_",0
"	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint8))_",0
"	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32))_",0
"	ptr = fast_ensure_contiguous(tvb, offset, sizeof(guint64))_",0
    /* Obsolete preferences */,1
        mac_offset = tvb_reported_length(tvb)-4_,1
            /* DROPPING OUT HERE IF NOT DOING ROHC! */,1
#include <QMessageBox>,0
                if ( !prefval && (*iter).isDefault() ),0
                    selected = counter_,0
                else if ( prefval && stored.compare((*iter).call()) == 0 ),0
"    XXX(BS_INIT		, 0)                  \",0
    /*     __u32	lgbd_status_ */,0
    /*     __u64		gl_flags_ /\* see LQUOTA_FL* below *\/ */,0
    /*     __u32	lvb_status_ */,0
"          { ""Type"", ""lustre.ldlm_res_id.name"", FT_UINT32, BASE_HEX, VALS(mgs_config_body_type_vals), 0, NULL, HFILL }},",0
"          { ""LGBD Status"", ""lustre.ldlm_gl_barrier_desc.status"", FT_UINT32, BASE_HEX, VALS(lustre_barrier_status_vals), 0, NULL, HFILL }},",1
"static void dissect_zcl_write_attr_resp (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint *offset, guint16 cluster_id, guint16 mfr_code, gboolean direction)_",0
"static void  dissect_zcl_attr_data_type_val (tvbuff_t *tvb, proto_tree *tree, guint *offset, guint16 cmd_id, guint16 cluster_id, guint16 mfr_code, gboolean client)_",1
 *Register the specific cluster.,0
    int         hf_attr_id_,1
    int         hf_attr_clnt_id_,1
"static void dissect_ulsch_or_dlsch(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,",0
                        guint32 start_offset = offset_,0
                    case TCI_STATES_ACT_DEACT_FOR_UE_SPEC_PDSCH_LCID:,0
                            static const int * aper_csi_trigger_state_subselect_flags[] = {,0
"                        decode_wccp_encoded_address(tvb, offset, pinfo, info_tree, addr_table))_",0
/* Skip clan analyzer for the whole file. */,0
	offset++_,0
"gchar* determine_http_location_target(const gchar *base_url, const gchar * location_url)",0
	if (strlen(location_url) == 0) {,0
			if (strlen(scheme_end) == 0) {,0
"			final_target = wmem_strdup_printf(wmem_packet_scope(), ""%s%s"", base_through_netloc, location_url)_",0
				g_free(base_through_path)_,0
"		gchar *absolute_target = determine_http_location_target(v->location_base_uri, v->location_target)_",0
"		set(CMAKE_C_FLAGS ""-std=gnu99 ${CMAKE_C_FLAGS}"")",0
"    heur_dissector_add(""udp"", dissect_nano_heur_udp, ""Nano"", ""nano"", proto_nano, HEURISTIC_ENABLE)_",1
    if(CMAKE_VERSION LESS 3.1),0
"	<type type-name=""Enumerated""/>",0
"	<avp name=""Charging-Gateway-Function-Host""vendor-id=""VerizonWireless"" code=""6068"" >",0
"	<!ENTITY Verizon		SYSTEM ""Verizon.xml"">",0
	&Verizon_,0
"	<!ENTITY VerizonWireless			SYSTEM ""VerizonWireless.xml"">",0
the string is guaranteed to have a terminating NUL. If the string was truncated,0
"    if (tvb_get_guint8(tvb, offset) == 0xff)",0
"          { ""TX Power (dBm)"", ""bthci_evt.tx_power"",",0
gboolean rpcrdma_is_reduced(void)_,0
	packet-rpcrdma.h	\,0
     proto_item          *sub_item_,0
"	{ &hf_pn_io_am_location_beginslotnum,",0
"    guint8 packet_type = tvb_get_guint8(tvb, offset) & 0x7f_",0
 * PROTECTED PAYLOAD DECRYPTION (done in first pass),0
/* LTE RRC message types */,0
			sub_handle = GSMTAP_SUB_LTE_NAS_CIPHERED_,1
	case GSMTAP_TYPE_LTE_NAS:,1
		if(sub_type){,1
		else{,1
			sub_handle = GSMTAP_SUB_LTE_NAS_PLAIN_,1
                    case SHORT_TRUNCATED_BSR_LCID:,0
	if (version == 1) {,0
    // XXX remove this?,0
    expandParents(index)_,0
            protocol_handle = NULL_,0
        /* Preferences */,0
"					coap_trans = wmem_new(wmem_file_scope(), coap_transaction)_",0
"						coap_trans->oscore_info->kid = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len)_",0
    if (text) {,0
    if (bytes){,0
 * SPDX-License-Identifier: GPL-2.0+,0
"    memcpy(&buffer[ret], bytes, bytes_len)_",0
"int dissect_mac_nr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void*)_",1
#define	DUPLICATION_ACTIVATION_DEACTIVATION_LCID   0x38,1
        offset += tvb_reported_length(tvb) - (offset + p_mac_nr_info->length)_,0
        volatile dissector_handle_t protocol_handle_,0
"    write_pdu_label_and_info(top_ti, am_header_ti, pinfo, ""SN=%-5u"", sn)_",0
	${CMAKE_CURRENT_SOURCE_DIR}/packet-rlc-nr.c,0
    /* TODO: add reassembly and call upper layer dissector */,0
"                                 ""                     [%u-bytes]"", tvb_reported_length_remaining(tvb, offset))_",0
/* Heuristic dissector looks for supported framing protocol (see wiki page)  */,0
/* Several people have asked about dissecting RLC by framing     */,0
/* A heuristic dissecter (enabled by a preference) will          */,0
  col_data_changed_ = FALSE_,0
    if (type == AT_IPv4),0
    type = sctp_info->ip_dst.type_,0
"            alloc_address_wmem(NULL, &info->src, tmp_info.src.type, tmp_info.src.len, tmp_info.src.data)_",1
                sack->src.type = tmp_info.src.type_,0
"                alloc_address_wmem(NULL, &tsn->src, tmp_info.src.type, tmp_info.src.len, tmp_info.src.data)_",1
                sack->dst.type = tmp_info.dst.type_,0
"                alloc_address_wmem(NULL, &tsn->dst, tmp_info.dst.type, tmp_info.dst.len, tmp_info.dst.data)_",1
"                alloc_address_wmem(NULL, store, tmp_info.src.type, tmp_info.src.len, tmp_info.src.data)_",1
"                alloc_address_wmem(NULL, store, tmp_info.dst.type, tmp_info.dst.len, tmp_info.dst.data)_",0
            sack->src.type = tmp_info.src.type_,0
"            alloc_address_wmem(NULL, &tsn->src, tmp_info.src.type, tmp_info.src.len, tmp_info.src.data)_",0
            sack->dst.type = tmp_info.dst.type_,0
"            alloc_address_wmem(NULL, &tsn->dst, tmp_info.dst.type, tmp_info.dst.len, tmp_info.dst.data)_",1
"        alloc_address_wmem(NULL, store, tmp_info.src.type, tmp_info.src.len, tmp_info.src.data)_",0
"        alloc_address_wmem(NULL, store, tmp_info.dst.type, tmp_info.dst.len, tmp_info.dst.data)_",0
    if (type == AT_IPv4 || type == AT_IPv6),0
"    alloc_address_wmem(NULL, &tmp_info.src, tmp_info.src.type, tmp_info.src.len, sctp_info->ip_src.data)_",0
"    alloc_address_wmem(NULL, &tmp_info.dst, tmp_info.dst.type, tmp_info.dst.len, sctp_info->ip_dst.data)_",0
                sack = (tsn_t *)g_malloc(sizeof(tsn_t))_,0
"                copy_address(&tsn->src, &tmp_info.src)_",0
"                copy_address(&tsn->dst, &tmp_info.dst)_",1
            tsn  = (tsn_t *)g_malloc(sizeof(tsn_t))_,0
     * this is only required for early data decryption. */,0
 * Requires Libgcrypt 1.6 or newer for verifying that decryption is successful.,1
"    {GTPV2_IE_SECONDARY_RAT_USAGE_DATA_REPORT, dissect_gtpv2_secondary_rat_usage_data_report}, /* 199, 8.132 Secondary RAT Usage Data Report */",0
"check_struct_has_member(""struct stat""     st_flags       sys/stat.h   HAVE_STRUCT_STAT_ST_FLAGS) # GTK+ only",1
    /* If you will be fetching any data from the packet before filling in,0
   /* An ENIP packet is at least 4 bytes long. */,0
"            wmem_free(pinfo->pool, text)_",1
            return NULL_,0
# SPDX-License-Identifier: BSD-2-Clause,1
"        proto_tree_add_uint_format_value(pt, hf_gryphon_eventnum, tvb, offset, 1, 0, ""All Events."")_",0
"            proto_tree_add_string(pt, hf_gryphon_ldf_schedule_name, tvb, offset, 32, string)_",0
"                proto_tree_add_uint_format_value(pt, hf_gryphon_ldf_ioctl_setflags_flags, tvb, offset, 1, flags, ""0x%x %s"",i,flags==0 ? ""Classic checksum"" : (flags==0x80?""Enhanced checksum"":(flags==0x40?""Event"":""UNKNOWN"")))_",0
"                proto_tree_add_uint_format_value(pt, hf_gryphon_ldf_ioctl_setflags_flags, tvb, offset, 1, pid, ""0x%x "",pid)_",0
"            proto_tree_add_uint_format_value(pt, hf_gryphon_ldf_ioctl_setflags_flags, tvb, offset, 1, pid, ""0x%02x "",pid)_",0
"    /*proto_tree_add_debug_text(pt, ""cmd_ioctl() debug offset=%d msglen=%d padding=%d"",offset,msglen,padding)_*/",0
        if(dest_chan == CH_BROADCAST) {,0
"        /* proto_tree_add_debug_text(gryphon_tree, ""dissect_gryphon_message_with_offset() debug offset=%d msglen=%d msgend=%d"", offset, msglen, msgend)_ */",0
    if(msglen > 0) {,0
"    /*proto_tree_add_debug_text(pt, ""decode_response() debug offset=%d msglen=%d index i=%d"",offset,msglen,i)_*/",0
"    /* 20171012 always display mode bits, not just conditionally */",0
"        nbytes = tvb_get_letohl(tvb, offset)_",0
"            pid = tvb_get_guint8(tvb, offset)_",0
    int             save_offset_,0
            /* int */,0
    /* tx options */,0
            delete ag_,0
SPDX-License-Identifier: X11,0
                enum_bg = new QButtonGroup(vb)_,1
            if (ev->description),0
                enum_rb->setStyleSheet(QString(,1
"                                      ""QRadioButton {""",1
"                                      ""  margin-left: %1px_""",1
"                                      ""}""",1
                                      ),1
            while (ev->description) {,0
            enum_bg = new QButtonGroup(vb)_,1
    // If our parent window is a modal dialog we'll hang on macOS,0
"EditorFileDialog::EditorFileDialog(const QModelIndex& index, enum FileMode mode, QWidget* parent, const QString& caption, const QString& directory, const QString& filter)",1
    : QLineEdit(parent),1
"    , file_dialog_button_(new QPushButton(this))",1
"    , index_(index)",1
"    , mode_(mode)",1
"    , caption_(caption)",1
"    , directory_(directory)",1
"    , filter_(filter)",1
"    , options_(0)",1
    if (mode_ == Directory),1
        options_ = QFileDialog::ShowDirsOnly_,1
    file_dialog_button_->setText(UTF8_HORIZONTAL_ELLIPSIS)_,1
    setText(directory)_,1
"    connect(file_dialog_button_, SIGNAL(clicked()), this, SLOT(applyFilename()))_",1
"      { ""802.11ac"",     ""peekremote.extflags.11ac"", FT_BOOLEAN, 32, TFS(&tfs_yes_no),",0
"            { ""Transition Time"", ""zbee_zcl_general.scenes.enh_transit_time"", FT_UINT16, BASE_CUSTOM, CF_FUNC(decode_zcl_time_in_100ms),",0
"dissect_quic_initial(tvbuff_t *tvb, packet_info *pinfo, proto_tree *quic_tree, guint offset, quic_info_data_t *quic_info _U_, guint32 pkn _U_, guint64 cid _U_){",0
                                /* For each byte... */,0
"        proto_tree_add_item(tree, hf_pfcp_remote_gtp_u_peer_ipv4, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
    if((flags & 0x80) == 0) {,0
static void rrc_free_value(gpointer value ){,0
 * A real BGP speaker would rely on the BGP Additional Path in the BGP Open messages.,0
"    //proto_tree_add_item(nas_5gs_tree, hf_nas_5gs_mm_msg_type, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
static int hf_bootp_option_rdnss_reserved = -1_			/* 146 */,0
static int hf_bootp_option_bulk_lease_status_code = -1_		/* 151 */,0
"/* 145 */ { ""Forcerenew Nonce Capable"",		special, NULL },",0
"		    ""Option 142: ANDSF Server"", HFILL }},",0
"		  ""RF signal power at the antenna from a fixed,""",0
"		  ""RF signal power at the antenna from a fixed, arbitrary value in decibels"", HFILL}},",0
"		  ""RF noise power at the antenna from a fixed, arbitrary value""",0
"		  ""Transmit power expressed as unitless distance from max power""",0
"		  ""Transmit power expressed as decibels from max power""",0
"		  ""Transmit power in decibels per one milliwatt (dBm)"", HFILL}},",0
  if (eth_deduplicate_dmac && tvb_captured_length(tvb) > 20 &&,1
"      !memcmp(tvb_get_ptr(tvb,0,6),tvb_get_ptr(tvb,6,6), 6)) {",0
    guint8 sec_cat_count = 0_,0
"    new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table)_",0
            for (e_off = 0_ e_off < e_len_ e_off++),0
		jmps[i] = NULL_,1
"	wmem_map_insert(refstats_node_id_to_parent_node_id_hash, &st_node_requests_by_referer, parent_node_id_p)_",0
"			*referer_node_id_p = tick_stat_node(st, v->referer_uri, *parent_node_id_p, TRUE)_",0
		} else{,0
"			wmem_map_insert(full_uris_str_hash, wmem_strdup(wmem_epan_scope(), v->full_uri), uri_node_id_p)_",0
"        memcpy(d_a, (const guint8 *)pinfo->src.data, pinfo->src.len)_",1
        ws_close(sync_pipe_read_fd)_,0
"                                 fork_child, msg, update_cb)_",0
"        free_argv(argv, argc)_",0
"                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len)_",0
" * Copyright 201x, Jan Holthuis <jan.holthuis@ruhr-uni-bochum.de>",0
" * (A short description of the protocol including links to specifications, detailed documentation, etc.)",0
/* Initialize the protocol and registered fields */,0
#define PROTOBUF_WIRETYPE_VARINT          0,0
"            steamdiscover_dissect_body_unknown(tvb, pinfo, steam_ihs_discovery_tree, offset, body_length)_",0
    Qt::ItemFlags flags(const QModelIndex &index) const_,0
"    QVariant data(const QModelIndex &index, int role) const_",0
"    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole)_",0
"    QVariant headerData(int section, Qt::Orientation orientation,",0
                        int role = Qt::DisplayRole) const_,0
"    QModelIndex index(int row, int column,",0
                      const QModelIndex & = QModelIndex()) const_,0
    ui->coloringRulesTreeView->setDragEnabled(true)_,0
    ui->coloringRulesTreeView->viewport()->setAcceptDrops(true)_,0
    ui->coloringRulesTreeView->setDropIndicatorShown(true)_,0
"    connect(&colorRuleModel_, SIGNAL(dragDropComplete()),",0
"        mb.setText(tr(""Your coloring rules file contains unknown rules""))_",0
"        mb.setInformativeText(tr(""Wireshark doesn't recognize one or more of your coloring rules. """,0
    bool disabled__,0
    QString name__,0
    QString filter__,0
    QColor foreground__,0
    for (int row = 0_ row < colorRules_.count()_ row++),0
        delete VariantPointer<ColoringRuleItem>::asPtr(colorRules_.value(row))_,0
"        ColoringRuleItem* item = new ColoringRuleItem(colorf->disabled, colorf->filter_name, colorf->filter_text,",0
"                        ColorUtils::fromColorT(colorf->fg_color),",0
"        //drag and drop operation in place, just clear the list",1
        dragDropRows_.clear()_,1
"    ColoringRuleItem* dst_item = new ColoringRuleItem(src_item->disabled_, src_item->name_, src_item->filter_, src_item->foreground_, src_item->background_)_",0
    if (dst_item == NULL),0
        case colName:,0
            return rule->name__,0
        case colFilter:,0
            return rule->filter__,0
    case Qt::CheckStateRole:,0
        switch(index.column()),0
            return rule->disabled_ ? Qt::Unchecked : Qt::Checked_,0
    case Qt::BackgroundRole:,1
        return rule->background__,0
    case Qt::ForegroundRole:,1
        return rule->foreground__,0
            rule->name_ = value.toString()_,0
        rule->background_ = QColor(value.toString())_,1
        rule->foreground_ = QColor(value.toString())_,1
"    QDataStream stream(&encodedData, QIODevice::WriteOnly)_",0
"    foreach (const QModelIndex &index, indexes) {",0
"        //use first column as ""filter""",0
        if (index.column() == 0) {,0
            //just save the row that needs to be moved,0
            stream << index.row()_,0
    if (action == Qt::IgnoreAction),0
"    QByteArray encodedData = data->data(""application/octet-stream"")_",1
"    QDataStream stream(&encodedData, QIODevice::ReadOnly)_",1
    int readRow_,1
    while (!stream.atEnd()) {,1
        stream >> readRow_,1
        dragDropRows_ << readRow_,1
    int numRows = dragDropRows_.count()_,1
    if (numRows > 0) {,1
        //sort the list to make data notification easier,1
"        qSort(dragDropRows_.begin(), dragDropRows_.end())_",1
"        int startRow = (beginRow < dragDropRows_[0]) ? beginRow : dragDropRows_[0], ",1
            endRow = (beginRow+numRows < dragDropRows_[numRows-1]) ? dragDropRows_[numRows-1] : beginRow+numRows_,1
"        QModelIndex topLeft = index(startRow, colName),",1
"                    bottomRight = index(endRow, colFilter)_",1
        int rowIncrement = beginRow_,1
"        foreach (int moveRow, dragDropRows_) {",1
"            colorRules_.move(moveRow, rowIncrement)_",1
            rowIncrement++_,1
        //notify that data has changed in the model,1
"#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)",1
        QVector<int> roles_,1
        roles << Qt::DisplayRole << Qt::CheckStateRole << Qt::BackgroundRole << Qt::ForegroundRole_,1
"        emit dataChanged(topLeft, bottomRight",1
"                             , roles",1
        )_,1
    // there are no children,0
    if (parent.isValid()) {,0
    void addColor(color_filter_t* colorf)_,1
"    connect(wsApp->mainWindow(), SIGNAL(captureActive(int)), this, SLOT(captureActive(int)))_",0
"    {&hf_he_reserved_bit_25,",0
"    snprintf(str, 32, ""%d"", escaped_val)_",0
"      snprintf(str, 32, ""%luus"", decoded_micros)_",0
"    { &hf_flex_keylength, { ""Key Length"", ""couchbase.key.length"", FT_UINT8, BASE_DEC, NULL, 0x0, ""Length in bytes of the text key that follows the command extras"", HFILL } },",0
"                               ""Unknown flexible ID"")_",0
    for (guint32 src_indx = 0_ src_indx < sources_count_ src_indx++) {,0
      nbap_ib_segment = (nbap_ib_segment_t*)(wmem_list_frame_data(curr_frame))_,0
      source = nbap_ib_segment->data_,0
      bit_length = nbap_ib_segment->bit_length_,0
      byte_off = 0_,0
      bit_off = 0x80_,0
      for (guint32 i=0_i<bit_length_i++) {,0
        if (((*(source+byte_off)) & bit_off) == bit_off) {,0
          final_arr[final_byte_off] |= final_bit_off_,0
        bit_off >>= 1_,0
        if ( bit_off == 0x00 ) {,0
          byte_off += 1_,0
          bit_off = 0x80_,0
        final_bit_off >>= 1_,0
        if ( final_bit_off == 0x00 ) {,0
          final_byte_off += 1_,0
          final_bit_off = 0x80_,0
      curr_frame = wmem_list_frame_next(curr_frame)_,0
    const char     *label_prefix_,0
"hkdf_expand(int hashalgo, const guint8 *prk, guint prk_len, const guint8 *info, guint info_len,",1
AC_MSG_CHECKING([for an HTML to text processor]),1
"AS_IF([lynx -version >&AS_MESSAGE_LOG_FD 2>&1], [have_lynx=lynx],",1
"	[w3m -version >&AS_MESSAGE_LOG_FD 2>&1], [have_lynx=w3m],",1
	[have_lynx=no]),1
AC_MSG_RESULT([$have_lynx]),1
"AM_CONDITIONAL(HAVE_LYNX, [test ""x$have_lynx"" != xno])",1
"AS_IF([test $have_lynx = lynx], [LYNX=""$have_lynx""])",1
"	/* Try modes exact, NO_ADDR_B, NO_PORT_B and finally NO_ADDR_B|NO_PORT_B */",0
#define IEEE80211_RADIOTAP_AMPDU_EOF                    0x0040,0
   SPDX-License-Identifier: LGPL-2.0-or-later   */,0
gboolean,1
"wmem_map_contains(wmem_map_t *map, const void *key)",0
    wmem_map_item_t *item_,0
    /* Make sure we have a table */,0
    if (map->table == NULL) {,0
    /* find correct slot */,0
"    item = map->table[HASH(map, key)]_",0
    /* scan list of items in this slot for the correct value */,0
    while (item) {,0
"        if (map->eql_func(key, item->key)) {",0
            return TRUE_,0
        item = item->next_,0
/** Check if a value is in the map.,1
 * @param map The map to search in.,1
 * @param key The key to lookup.,1
" * @return true if the key is in the map, otherwise false.",1
WS_DLL_PUBLIC,1
/** Lookup a value in the map.,0
"  {0x01, ""Datatype""},",0
"     ""Common Industrial Protocol, Motion - Rev 3"",",0
"      { &hf_32bitheader_coo, { ""COO"", ""cip.32bitheader.coo"", FT_UINT32, BASE_HEX, NULL, 0x2, ""Claim Output Ownership"", HFILL } },",0
"       ""CIP Motion - Rev 3"",    /* Short name of protocol       */",0
"        wmem_free(NULL, *client_cleartext_secret)_",1
"    wmem_free(NULL, server_secret.data)_",0
        case TDS_PROTOCOL_NOT_SPECIFIED:,0
 * https://msdn.microsoft.com/en-us/library/cc219643.aspx,0
 * https://msdn.microsoft.com/en-us/library/dd304523.aspx,0
    he_mac_headers[8] = &hf_he_reserved_bits_15_16_,0
"     {""STBC Rx <= 80 MHz"", ""wlan.ext_tag.he_phy_cap.nbytes.stbc_rx_lt_80hz"",",0
"  { ETAG_HE_CAPABILITIES,                     ""HE Capabilities (IEEE Std 802.11ax/D2.0"" },",0
"dissect_he_capabilities(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,",0
static const int *he_phy_channel_width_set_headers[] _U_ = {,0
"                        offset, 1, bss_trans_thresh, "" (%ddBm)"",",0
"     {""DCM Max NSS Tx"", ""wlan.ext_tag.he_phy_cap.nbytes.dcm_max_nss_tx"",",0
    if (htc & (HTC_VHT | HTC_HE)) {,0
  /* Change some header fields depending on HE_HTC_HE_SUPPORT and FRAGMENTATION */,0
  int ext_tag_len_,0
"        item = proto_tree_add_item_ret_uint( pkt_chunk_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_chunk, tvb, offset, 2, ENC_BIG_ENDIAN, (guint32 *)&chunk )_",0
            int length = chunk & 0x1FFF_,1
            i += length_,0
"            item = proto_tree_add_item_ret_uint( recv_delte_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_1_byte, tvb, offset, 1, ENC_BIG_ENDIAN, (guint32 *)&delta )_",0
"            item = proto_tree_add_item_ret_uint( recv_delte_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_2_bytes, tvb, offset, 2, ENC_BIG_ENDIAN, (guint32 *)&delta )_",0
    if ( pkt_seq_array ),1
"                ""rtcp.rtpfb.transportcc.recv_delta"",",0
"    proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_base_seq, tvb, offset, 2, ENC_BIG_ENDIAN )_",0
    delta_array = (int *)g_malloc( pkt_count * sizeof(int) )_,0
        if ( Qt::ForegroundRole ),0
	if (load_wiretap_plugins) {,0
        if (!(nl_data->columns[i])) {,0
        if (!(nl_data->columns[col])) {,1
        if (nl_data->columns[col]->name) {,0
        if (timestamp_length < 7) {,1
	packet-caneth.c	\,1
"    /* Check that we have enough length for the Magic, Version, and Length */",1
"    can_subdissector_table = find_dissector_table(""can.subdissector"")_",1
#define OFPOSF_RX_PWR    1<<4,0
"	for (offset = 0_ tvb_offset_exists(tvb, offset)_ offset = next_offset)",0
		    (hfinfo->type == FT_FRAMENUM) )) {,0
	set(WARNINGS_CFLAGS /w34295 /w34189 /wd4200),0
        /*offset++_*/,0
		sc->sp = sp_,0
    if (presence_flags & 0x40) {,0
"          { ""Estimated Service Parameters Flags"", ""ieee1905.ap_metrics.flags"",",0
        return result_,0
        case PT_TXTMOD_BOOL:,0
								offset)_,1
"    GF_HNDSK_GET_VOLUME_INFO,",1
	if(ENABLE_APPLICATION_BUNDLE),1
    proxyModel.setSourceModel(&sourceModel)_,0
    infoModel.setSourceModel(&proxyModel)_,0
    InterfaceTreeModel * sourceModel_,1
    if ( prefs.capture_no_extcap ),0
#include <ui/qt/models/info_proxy_model.h>,0
	static proto_plugin plugin_foo_,0
	plugin_foo.register_protoinfo = proto_register_foo_,0
"    ti = proto_tree_add_item(tree, hf_bgp_open_myas, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"        { ""Bad Peer AS"", ""bgp.notify.error_open.bad_peear_as"", FT_UINT32, BASE_DEC,",0
"  fprintf(output, ""Note that this can make your system less secure!\n"")_",0
"    fprintf(output, ""Dumpcap can benefit from an enabled BPF JIT compiler if available.\n"")_",0
void wtap_init(gboolean load_wiretap_plugins)_,0
"    prefs_register_bool_preference(capture_module, ""no_extcap"", ""Don't load extcap interfaces"",",1
    /*         struct { */,0
"    lustre_handle = create_dissector_handle(dissect_lustre, proto_lustre)_",0
"        { &hf_lustre_lustre_msg_v1_lm_magic,",0
    } else if ((protocol_type == PROTO_TYPE_IEEE_802_2) && (protocol_length == 8)) {,0
/* Bitmask of flags for how a preference could affect changes in Wireshark */,1
#define PREF_EFFECT_DISSECTION        (1u << 0),1
#define PREF_EFFECT_CAPTURE           (1u << 1),1
#define PREF_EFFECT_GUI               (1u << 2),1
#define PREF_EFFECT_FONT              (1u << 3),1
"dissect_associated_sta_link_metrics(tvbuff_t *tvb, packet_info *pinfo _U_,",0
        pref = indexToPref(index)_,1
        switch(pref->getPrefType()),1
        case PREF_DECODE_AS_UINT:,1
        case PREF_UINT:,1
            QLineEdit* editor = new QLineEdit(parent)_,1
"//          editor->setInputMask(""0000000009_"")_",1
            return editor_,1
        case PREF_BOOL:,1
            //Setting any non-NULL value will invert boolean value,1
"            ((QAbstractItemModel*)index.model())->setData(index, QString(""BOOL""), Qt::EditRole)_",1
        case PREF_ENUM:,1
            QComboBox* editor = new QComboBox(parent)_,1
        case PREF_STRING:,1
            //Separated from UINT in case formatting needs to be applied to UINT,1
        case PREF_DECODE_AS_RANGE:,1
        case PREF_RANGE:,1
            RangeSyntaxLineEdit *editor = new RangeSyntaxLineEdit(parent)_,1
        case PREF_UAT:,1
        if (pref->getPrefGUIType() == GUI_ALL || pref->getPrefGUIType() == GUI_QT) {,1
"            UatDialog uat_dlg(parent, prefs_get_uat_value(pref->getPref()))_",1
            uat_dlg.exec()_,1
        case PREF_SAVE_FILENAME:,1
"            filename = QFileDialog::getSaveFileName(parent, wsApp->windowTitleString(prefs_get_title(pref->getPref())),",1
"                                                        index.model()->data(index, Qt::DisplayRole).toString())_",1
            if (!filename.isEmpty()) {,1
"                ((QAbstractItemModel*)index.model())->setData(index, QDir::toNativeSeparators(filename), Qt::EditRole)_",1
        case PREF_OPEN_FILENAME:,1
"            filename = QFileDialog::getOpenFileName(parent, wsApp->windowTitleString(prefs_get_title(pref->getPref())),",1
"                                                    index.model()->data(index, Qt::DisplayRole).toString())_",1
        case PREF_DIRNAME:,1
"            filename = QFileDialog::getExistingDirectory(parent, wsApp->windowTitleString(prefs_get_title(pref->getPref())),",1
        case PREF_COLOR:,1
            QColorDialog color_dlg_,1
"            color_t color = *prefs_get_color_value(pref->getPref(), pref_stashed)_",1
            color_dlg.setCurrentColor(QColor(,1
"                                          color.red >> 8,",1
"                                          color.green >> 8,",1
                                          color.blue >> 8,1
                                          ))_,1
            if (color_dlg.exec() == QDialog::Accepted) {,1
"                ((QAbstractItemModel*)index.model())->setData(index, color_dlg.currentColor().name(), Qt::EditRole)_",1
    //Look through appearance children,0
    if (!newIndex.isValid()) {,0
        for (row = 0_ row < model()->rowCount(appearanceIndex)_ row++),0
"            modelIndex = model()->index(row, ModulePrefsModel::colName, appearanceIndex)_",0
"            modelTreeName = model()->data(modelIndex, Qt::DisplayRole).toString()_",0
            if (modelTreeName.compare(pane_name) == 0) {,0
                newIndex = modelIndex_,0
    //Look through protocol children,0
        for (row = 0_ row < model()->rowCount(protocolIndex)_ row++),0
"            modelIndex = model()->index(row, ModulePrefsModel::colName, protocolIndex)_",0
"            PrefsItem* proto_pref = VariantPointer<PrefsItem>::asPtr(model()->data(modelIndex, Qt::UserRole))_",0
            if (proto_pref != NULL) {,0
                if (pane_name.compare(proto_pref->getModuleName()) == 0) {,0
                    newIndex = modelIndex_,0
    //Look through stat children,0
"            PrefsItem* stat_pref = VariantPointer<PrefsItem>::asPtr(model()->data(modelIndex, Qt::UserRole))_",0
            if (stat_pref != NULL) {,0
                if (pane_name.compare(stat_pref->getModuleName()) == 0) {,0
	} else {,0
	value_name = NULL_,0
"		hf_printerdata_value, TRUE, NULL)_",0
		if(!dcv->se_data){,0
/* enum { */,0
enum MSG_type {,0
static const value_string lnet_msg_type[] = {,0
"        ptr = wmem_map_insert(conv_info->pdus, GUINT_TO_POINTER(info->match_bits), info)_",0
"          { ""Ack"", ""lnet.ksm_zc_ack_cookie"", FT_UINT64, BASE_HEX|BASE_SPECIAL_VALS, VALS(unique_not_ack), 0x0, NULL, HFILL }},",0
				value = (guint32)value64_,1
	if (encoding & ENC_VARINT_PROTOBUF) {,1
"		*value = tvb_get_guint8(tvb, offset)_",1
		switch(((*value) >> 6){,1
"                    proto_tree_add_item_ret_varint(ft_tree, hf_quic_stream_offset, tvb, offset, -1, ENC_VARINT_QUIC, NULL, &lenvar)_",0
    offset += sizeof(guint8)_,0
//    return tvb_reported_length(tvb)_,0
"            ti_ipv6_plen = proto_tree_add_item(ipv6_tree, hf_ipv6_plen, tvb,",0
"                                offset + IP6H_CTL_PLEN, 2, ENC_BIG_ENDIAN)_",0
            if (ipv6_pinfo->ip6_plen == 0 && ip6_nxt != IP_PROTO_HOPOPTS) {,0
"                expert_add_info(pinfo, ti_ipv6_plen, &ei_ipv6_plen_zero)_",0
static const value_string,0
"    { 23, ""faults-listed""},",0
 * http://www.bacnet.org/VendorID/BACnet Vendor IDs.htm,0
static guint,0
"        {&hf_cflow_mib_index_indicator,",0
"          {""Max Fragments Pendig Reassembly"", ""cflow.max_fragments_pending_reassembly"",",0
"          {""Addresspool High Treshold"", ""cflow.addresspool_highthreshold"",",0
"		length[i] = evaluate_sdnv_64(tvb,frame_offset+1,&length_size[i])_",0
"#if !GLIB_CHECK_VERSION(2,24,0)",1
	if (!g_thread_get_initialized()),1
"         {""RADIUS Accounting Input Packets"", ""cflow.pie.ntop.radus_acct_in_pkts"",",0
#define IEEE80211_RADIOTAP_HE_PPDU_FORMAT_MASK                0x0003,0
static int hf_he_info_data_1 = -1_,0
	offset += 2_,0
"         * If we're not trying to do UN*X-style non-blocking I/O,",0
         * where we don't block if there isn't data available to,0
    /* Get the protocol version */,0
"        { &hf_tds_capability_req_lang,",1
static int hf_coap_opt_object_security_non_compressed	= -1_,0
static expert_field ei_coap_option_object_security_bad	= EI_INIT_,0
#define COAP_VERSION_MASK					0xC0,0
"#pragma GCC diagnostic ignored ""-Wunused-function""",0
" * Much room for optimization in the creation process of the array,",0
" * but we assume this to be an infrequent operation, with space utilization and",0
	wmem_interval_tree.h		\,0
	data->high = data->low = where_,0
	if (a < b) return -1_,0
	if (a > b) return +1_,0
	len = iarr->arr->len_,0
 * Finding speed is what matters,0
    if (format_subtype == IEEE_1722_CVF_FORMAT_SUBTYPE_MJPEG),0
"get_desc_by_code(const value_string *delim_desc, guint8 code) {",1
"              case AL_OBJ_AOC_32EVTT:   /* 32-bit Analog Command Event with time (Obj:43, Var:03) */",0
"     {""Reserved"", ""wlan.extcap.b1"",",0
"     {""Reserved"", ""wlan.extcap.b3"",",0
    proxyModel_->sort(DissectorTablesModel::colTableName)_,0
    ui->tableTree->resizeColumnToContents(DissectorTablesModel::colTableName)_,0
        /* ip_cm.req is 36 in length */,0
    ui->protocol_tree_->setModel(proxyModel_)_,0
        writeChanges()_,0
bool EnabledProtocolItem::applyValue(),0
    if (enabledInit_ != enabled_) {,0
        applyValuePrivate(enabled_)_,0
        return true_,0
    return false_,0
   EnabledProtocolItem *parent_item_,0
    if (parent.column() > 0),0
    if (!parent.isValid()),0
        parent_item = root__,0
        parent_item = static_cast<EnabledProtocolItem*>(parent.internalPointer())_,0
    if (parent_item == NULL),0
        case colProtocol:,1
        if (proto_can_toggle_protocol(i)),0
            protocol = find_protocol_by_id(i)_,0
"            ProtocolTreeItem* protocol_row = new ProtocolTreeItem(protocol, root_)_",0
            root_->appendChild(protocol_row)_,0
"            proto_heuristic_dissector_foreach(protocol, addHeuristicItem, protocol_row)_",0
    for (int proto_index = 0_ proto_index < root_->childCount()_ proto_index++) {,0
        EnabledProtocolItem* proto = root_->child(proto_index)_,0
        redissect |= proto->applyValue()_,0
        for (int heur_index = 0_ heur_index < proto->childCount()_ heur_index++) {,0
            EnabledProtocolItem* heur = proto->child(heur_index)_,0
            redissect |= heur->applyValue()_,0
    if (redissect) {,0
        saveChanges(writeChanges)_,0
"    ProtocolTreeItem disabled_proto(protocol, NULL)_",0
    disabled_proto.setEnabled(false)_,0
    if (disabled_proto.applyValue()) {,0
        saveChanges()_,0
const char *FieldInformation::moduleName(),1
    if (isValid()) {,1
        if (headerInfo().parent == -1) {,1
            return fi_->hfinfo->abbrev_,1
            return proto_registrar_get_abbrev(headerInfo().parent)_,1
    return NULL_,1
    field_info *fi = PNODE_FINFO(index_node)_,0
    /* dissection with an invisible proto tree? */,0
        /* was a free format label produced? */,1
        if (fi->rep) {,1
            label = fi->rep->representation_,1
"        else { /* no, make a generic label */",1
            gchar label_str[ITEM_LABEL_LENGTH]_,1
"            proto_item_fill_label(fi, label_str)_",1
            label = label_str_,1
        // Generated takes precedence.,1
        if (PROTO_ITEM_IS_GENERATED(index_node)) {,1
"            label.prepend(""["").append(""]"")_",1
        if (PROTO_ITEM_IS_HIDDEN(index_node)) {,1
"            label.prepend(""<"").append("">"")_",1
"        if(FI_GET_FLAG(fi, PI_SEVERITY_MASK)) {",1
"            switch(FI_GET_FLAG(fi, PI_SEVERITY_MASK)) {",1
            case(PI_COMMENT):,1
                return ColorUtils::expert_color_comment_,1
            case(PI_CHAT):,1
                return ColorUtils::expert_color_chat_,1
            case(PI_NOTE):,1
                return ColorUtils::expert_color_note_,1
            case(PI_WARN):,1
                return ColorUtils::expert_color_warn_,1
            case(PI_ERROR):,1
                return ColorUtils::expert_color_error_,1
                g_assert_not_reached()_,1
        if(fi->hfinfo->type == FT_PROTOCOL) {,1
            return QApplication::palette().window()_,1
        return QApplication::palette().base()_,1
            return ColorUtils::expert_color_foreground_,1
            return QApplication::palette().windowText()_,1
        return QApplication::palette().text()_,1
    proto_node *index_node = nodeFromIndex(index)_,0
    if (!index_node) return NULL_,0
struct find_hfid_ {,1
    int hfid_,1
    proto_node *node_,1
"void ProtoTree::foreachFindHfid(proto_node *node, gpointer find_hfid_ptr)",1
    struct find_hfid_ *find_hfid = (struct find_hfid_ *) find_hfid_ptr_,1
    if (PNODE_FINFO(node)->hfinfo->id == find_hfid->hfid) {,1
        find_hfid->node = node_,1
"    proto_tree_children_foreach(node, foreachFindHfid, find_hfid)_",1
"// XXX We select the first match, which might not be the desired item.",1
void ProtoTree::goToField(int hf_id),1
    if (hf_id < 0) return_,1
    proto_node *root_node = proto_tree_model_->rootNode()_,1
"    struct find_hfid_ find_hfid = { hf_id, NULL }_",1
"    proto_tree_children_foreach(root_node, foreachFindHfid, &find_hfid)_",1
    if (find_hfid.node) {,1
        QModelIndex index = proto_tree_model_->indexFromNode(find_hfid.node)_,1
        scrollTo(index)_,1
"        selectionModel()->select(index, QItemSelectionModel::ClearAndSelect)_",1
const QString ProtoTree::toString(const QModelIndex &index) const,0
"    QModelIndex cur_idx = index.isValid() ? index : proto_tree_model_->index(0, 0)_",0
    QString tree_string_,0
    int indent_level = 0_,0
    do {,1
"        tree_string.append(QString(""    "").repeated(indent_level))_",0
        tree_string.append(cur_idx.data().toString())_,0
"        tree_string.append(""\n"")_",0
        // Next child,0
        if (isExpanded(cur_idx)) {,0
"            cur_idx = proto_tree_model_->index(0, 0, cur_idx)_",0
            indent_level++_,0
            continue_,0
        // Next sibling,0
"        QModelIndex sibling = proto_tree_model_->index(cur_idx.row() + 1, 0, cur_idx.parent())_",0
        if (sibling.isValid()) {,0
            cur_idx = sibling_,0
        // Next parent,0
"        cur_idx = proto_tree_model_->index(cur_idx.parent().row() + 1, 0, cur_idx.parent().parent())_",0
        indent_level--_,0
    } while (cur_idx.isValid() && cur_idx != index && indent_level >= 0)_,0
    return tree_string_,0
          while(offset < offset_end) {,0
"            proto_tree_add_item(tree, hf_isakmp_notify_data_signature_hash_algorithms, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
    emit model->beginResetModel()_,0
	models/fileset_entry_model.h	models/html_text_delegate.h,1
	models/fileset_entry_model.cpp	models/html_text_delegate.cpp,1
	models/expert_info_model.cpp		\,1
	models/expert_info_proxy_model.cpp	\,1
"    if (!registerTapListener(""expert"",",1
"                             expert_info_model_,",1
"                             ui->limitCheckBox->isChecked() ? display_filter_.toUtf8().constData(): NULL,",1
"                             TL_REQUIRES_COLUMNS,",1
"                             ExpertInfoModel::tapReset,",1
"                             ExpertInfoModel::tapPacket,",1
                             ExpertInfoModel::tapDraw)) {,1
"                    .arg(expert_info_model_->data(modelIndex.sibling(modelIndex.row(), ExpertInfoModel::colProtocol), Qt::DisplayRole).toString())",1
"    packet_num_(expert_info.packet_num),",1
"    group_(expert_info.group),",1
"    severity_(expert_info.severity),",1
"    hf_id_(expert_info.hf_index),",1
"    protocol_(expert_info.protocol),",1
"    summary_(expert_info.summary),",1
#if FIX,0
"    setTextAlignment(severity_col_, Qt::AlignRight)_",0
    error_events_ = 0_,0
    warn_events_ = 0_,0
    note_events_ = 0_,0
    chat_events_ = 0_,0
    emit beginResetModel()_,1
"#include ""expert_info_proxy_model.h""",1
    switch (source_left.column()),1
    case colProxySeverity:,1
        if (source_left.parent().isValid() && source_right.parent().isValid()) {,1
            left_item = static_cast<ExpertPacketItem*>(source_left.parent().internalPointer())_,1
            right_item = static_cast<ExpertPacketItem*>(source_right.parent().internalPointer())_,1
        if (!source_left.parent().isValid() && !source_right.parent().isValid()) {,1
            left_item = static_cast<ExpertPacketItem*>(source_left.internalPointer())_,1
            right_item = static_cast<ExpertPacketItem*>(source_right.internalPointer())_,1
        if ((left_item != NULL) && (right_item != NULL)) {,1
            if (left_item->severity() != right_item->severity()) {,1
                return (left_item->severity() < right_item->severity())_,1
    //XXX - Is there a way to do with without changing whole tree?,1
    case severity_col_:,0
    severity_actions_ = QList<QAction *>() << ui->actionShowError << ui->actionShowWarning,0
                                           << ui->actionShowNote << ui->actionShowChat,0
                                           << ui->actionShowComment_,0
    QList<int> severities = QList<int>() << PI_ERROR << PI_WARN << PI_NOTE << PI_CHAT << PI_COMMENT_,0
    QMenu *severity_menu = new QMenu()_,0
    // It might be nice to color each menu item to match each severity. It,0
    // might also be nice if Qt supported that...,0
"    foreach (QAction *sa, severity_actions_) {",0
        severity_menu->addAction(sa)_,0
        sa->setData(QVariant(severities.takeFirst()))_,0
        sa->setChecked(true)_,0
"        connect(sa, SIGNAL(toggled(bool)), this, SLOT(actionShowToggled()))_",0
    ui->severitiesPushButton->setMenu(severity_menu)_,0
    ui->expertInfoTreeView->setContextMenuPolicy(Qt::CustomContextMenu)_,0
"    connect(ui->expertInfoTreeView, SIGNAL(customContextMenuRequested(QPoint)),",0
    /* XXX - Shouldn't tap draw function handle all of this? */,0
    addPacketTreeItems()_,0
    for (int i = 0_ i < ui->expertInfoTreeView->topLevelItemCount()_ i++) {,0
        QTreeWidgetItem *group_ti = ui->expertInfoTreeView->topLevelItem(i)_,0
        if (group_ti->childCount() <= auto_expand_threshold_) {,0
            group_ti->setExpanded(true)_,0
    setUpdatesEnabled(false)_,0
    // Adding a list of ExpertPacketTreeWidgetItems is much faster than,0
    // adding them individually. We still add ExpertGroupTreeWidgetItems,0
    // individually since that gives us a nice progress indicator.,0
#if REMOVE /* XXX - handled by model*/,0
        if (gti_packets_.contains(group_ti)) {,0
            group_ti->addChildren(gti_packets_[group_ti])_,0
            gti_packets_[group_ti].clear()_,0
    ui->actionShowError->setEnabled(expert_info_model_->numErrorEvents() > 0)_,0
    ui->actionShowWarning->setEnabled(expert_info_model_->numWarnEvents() > 0)_,0
    ui->actionShowNote->setEnabled(expert_info_model_->numNoteEvents() > 0)_,0
    ui->actionShowChat->setEnabled(expert_info_model_->numChatEvents() > 0)_,0
/*  XXX - handled in model???,0
    if (need_show_hide_) {,0
        for (int i = 0_ i < ui->expertInfoTreeView->topLevelItemCount()_ i++) {,0
            QTreeWidgetItem *group_ti = ui->expertInfoTreeView->topLevelItem(i)_,0
"            switch (group_ti->data(severity_col_, Qt::UserRole).value<int>()) {",0
            case PI_ERROR:,0
                group_ti->setHidden(! ui->actionShowError->isChecked())_,0
            case PI_WARN:,0
                group_ti->setHidden(! ui->actionShowWarning->isChecked())_,0
            case PI_NOTE:,0
                group_ti->setHidden(! ui->actionShowNote->isChecked())_,0
            case PI_CHAT:,0
                group_ti->setHidden(! ui->actionShowChat->isChecked())_,0
            case PI_COMMENT:,0
                group_ti->setHidden(! ui->actionShowComment->isChecked())_,0
    bool enable = true_,0
    ExpertPacketTreeWidgetItem *packet_ti = dynamic_cast<ExpertPacketTreeWidgetItem *>(ui->expertInfoTreeView->currentItem())_,0
    if (!packet_ti || packet_ti->hfId() < 0) {,0
        enable = false_,0
    FilterAction *fa = qobject_cast<FilterAction *>(QObject::sender())_,0
    if (!fa || !packet_ti) {,0
"    ui->expertInfoTreeView->headerItem()->setText(severity_col_, first_col_title)_",0
    ExpertPacketTreeWidgetItem *packet_ti = dynamic_cast<ExpertPacketTreeWidgetItem *>(current)_,0
    QList<QTreeWidgetItem *> pending_items_,0
    QList<QTreeWidgetItem *> group_items = ui->expertInfoTreeView->invisibleRootItem()->takeChildren()_,0
"    foreach (QList<QTreeWidgetItem *> gti_list, gti_packets_.values()) {",0
        pending_items.append(gti_list)_,0
    gti_packets_.clear()_,0
    ei_to_ti_.clear()_,0
"    foreach (QTreeWidgetItem *ti, pending_items) {",0
        ExpertPacketTreeWidgetItem *packet_ti = dynamic_cast<ExpertPacketTreeWidgetItem *>(ti)_,0
        addExpertInfo(packet_ti)_,0
"    foreach (QTreeWidgetItem *gti, group_items) {",0
        QList<QTreeWidgetItem *> packet_items = gti->takeChildren()_,0
"        foreach (QTreeWidgetItem *ti, packet_items) {",0
            ExpertPacketTreeWidgetItem *packet_ti = dynamic_cast<ExpertPacketTreeWidgetItem *>(ti)_,0
            addExpertInfo(packet_ti)_,0
        delete gti_,0
        addPacketTreeItems()_,0
    retapFinished()_ // Expands tree items.,0
"    QTreeWidgetItemIterator it(ui->expertInfoTreeView,",0
                               ui->groupBySummaryCheckBox->isChecked(),0
                               ? QTreeWidgetItemIterator::HasChildren,0
                               : QTreeWidgetItemIterator::NoChildren)_,0
"    QRegExp regex(search_re, Qt::CaseInsensitive)_",0
    while (*it) {,0
        bool hidden = true_,0
        // XXX Check other columns as well?,0
        if (search_re.isEmpty() || (*it)->text(summary_col_).contains(regex)) {,0
            hidden = false_,0
        (*it)->setHidden(hidden)_,0
        ++it_,0
enum {,0
"    severity_col_ = 0,",0
"    summary_col_,",0
"    group_col_,",0
"    protocol_col_,",0
    count_col_,0
    guint32 packetNum() const { return packet_num__ },0
    int group() const { return group__ },0
    int severity() const { return severity__ },0
    int hfId() const { return hf_id__ },0
    QString protocol() const { return protocol__ },0
"    static QString groupKey(bool group_by_summary, int severity, int group, QString protocol, QString summary = """")_",0
/* XXX - NEEDED?????,0
    bool operator< (const QTreeWidgetItem &other) const,0
        // Probably not needed.,0
        if (other.type() != packet_type_) return QTreeWidgetItem::operator< (other)_,0
        const ExpertPacketTreeWidgetItem *other_expert = static_cast<const ExpertPacketTreeWidgetItem *>(&other)_,0
        // Force ascending.,0
        if (treeWidget()->header()->sortIndicatorOrder() == Qt::DescendingOrder) {,0
            return packet_num_ > other_expert->packetNum()_,0
            return packet_num_ < other_expert->packetNum()_,0
    void appendChild(ExpertPacketItem *child)_,0
    ExpertPacketItem *child(int row)_,0
    int childCount() const_,0
    guint32 packet_num__,0
    int group__,0
    int severity__,0
    int hf_id__,0
"    // Half-hearted attempt at conserving memory. If this isn't sufficient,",0
    // PacketListRecord interns column strings in a GStringChunk.,0
    QByteArray protocol__,0
    QByteArray summary__,0
    ExpertPacketItem* groupParent__,0
    ExpertPacketItem* summaryParent__,0
    int numCommentEvents() {return comment_events__},0
    int numChatEvents() {return chat_events__},0
    int numNoteEvents() {return note_events__},0
    int numWarnEvents() {return warn_events__},0
    // Called from tapPacket,0
    int comment_events__,0
    int chat_events__,0
    int note_events__,0
    int warn_events__,0
proto_register_artemis(void),0
"dissect_artemis(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void *data _U_)",0
"        ei = proto_tree_add_item(tree, hf_ieee1905_extra_tlv_data, tvb, offset,",0
               if ((timestamp != 0) && (timestamp < safety_info->eip_conn_info->safety.running_timestamp_value)),0
"        expert_add_info_format(pinfo, ti, &ei_mongo_unsupported_compression, ""Error uncompressing snappy data"")_",1
"		tf = proto_tree_add_item(tree, hf_ieee_802_1br_aec, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
int ByteViewText::hexChars(),1
    int chars_per_byte = recent.gui_bytes_view == BYTES_HEX ? 3 : 9_,1
    return (row_width_ * chars_per_byte) + ((row_width_ - 1) / separator_interval_)_,1
/* frame_set.c,0
 * fdfdkfslf_ajkdf,0
#include <epan/frame_set.h>,0
const char *,0
"frame_set_get_interface_name(frame_set *fs, guint32 interface_id)",0
  wtapng_iface_descriptions_t *idb_info_,0
  wtap_block_t wtapng_if_descr = NULL_,0
  char* interface_name_,0
  idb_info = wtap_file_get_idb_info(fs->wth)_,0
  if (interface_id < idb_info->interface_data->len),0
"    wtapng_if_descr = g_array_index(idb_info->interface_data, wtap_block_t, interface_id)_",0
  g_free(idb_info)_,0
  if (wtapng_if_descr) {,0
"    if (wtap_block_get_string_option_value(wtapng_if_descr, OPT_IDB_NAME, &interface_name) == WTAP_OPTTYPE_SUCCESS)",0
      return interface_name_,0
"    if (wtap_block_get_string_option_value(wtapng_if_descr, OPT_IDB_DESCR, &interface_name) == WTAP_OPTTYPE_SUCCESS)",0
"  return ""unknown""_",0
"frame_set_get_interface_description(frame_set *fs, guint32 interface_id)",0
  return NULL_,0
    sctp_error_info_t *error = NULL_,1
"                local_profiles = g_list_append(local_profiles, g_strdup(name))_",0
"			if ((length == 1) && (value == 0xFF)) { /* Invalid Zigbee length, set to 0 */",1
"			if ((length == 2) && (value == 0xFFFF)) { /* Invalid Zigbee length, set to 0 */",0
#define ENC_ZIGBEE				0x0000003A,0
                {,1
    Q_UNUSED(parent)_,0
void AddressEditorFrame::keyPressEvent(QKeyEvent *event),0
    if (event->modifiers() == Qt::NoModifier) {,0
        if (event->key() == Qt::Key_Escape) {,0
            on_buttonBox_rejected()_,0
        } else if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {,0
            if (ui->buttonBox->button(QDialogButtonBox::Ok)->isEnabled()) {,0
                on_buttonBox_accepted()_,0
"    calendar_name = tvb_get_string_enc(wmem_packet_scope(), tvb, *offset, calendar_name_len, ENC_LITTLE_ENDIAN)_",0
        /* Season Start Date */,0
        /* Special Day Date */,0
"        { &hf_zbee_zcl_calendar_type,",0
"    dissect_zcl_octet_string(tvb, tree, offset,",0
"static void dissect_zcl_date(tvbuff_t *tvb, proto_tree *tree, guint *offset,",0
"    subtree = proto_tree_add_subtree(tree, tvb, *offset, 0, idx, NULL, proto_registrar_get_name(hfindex_date))_",0
"        { &hf_zbee_zcl_calendar_special_day_date,",0
"            { ""Season Start Date"", ""zbee_zcl_se.calendar.season_start_date"", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL,",0
"            { ""Year"", ""zbee_zcl_se.calendar.date.year"", FT_UINT32, BASE_DEC, NULL,",0
"        /* This is a request retransmission, create a ""fake"" pana_trans structure*/",0
"    /* create a ""fake"" pana_trans structure */",0
    - wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add -,0
"  { RC_SUCCESS,                                ""Success"" },",1
"  { RC_NORMAL_DISCONNECTION,                   ""Normal disconnection"" },",1
	../wiretap/libwiretap.la	\,0
	pkg_search_module(GEOIP geoip),0
		COMMAND ${th_command} -h > ${th_file},0
    if (offset < length) {,0
"        proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1)_",0
static const true_false_string pfcp_v4_tfs = {,0
"    byte_view_text->setProperty(tvb_data_property, VariantPointer<tvbuff_t>::asQVariant(tvb))_",0
"    proto_tree_add_item(ietree, hf_ieee80211_aironet_ie_dtpc, tvb, offset, 2, ENC_NA)_",0
  case AIRONET_IE_DTPC:,0
TWAMP,0
"            {""Key ID"", ""twamp.control.iv"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}",0
"            {""Server Start Time"", ""twamp.control.server_uptime"", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0, NULL, HFILL}",0
"                        data += QString(""|%1"").arg(filter).toUtf8()_",1
gboolean prefs_loaded = FALSE_,0
  prefs_loaded = TRUE_,0
  if ((log_level & G_LOG_LEVEL_MASK & prefs.console_log_level) == 0 &&,0
	packet-btmesh.c,0
"    proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ra, tvb, 4, 6, ENC_NA)_",0
"        FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x0f, NULL, HFILL }},",0
"    &hf_multi_ap_teardown_bsses,",0
  return 2_,0
  //ieee80211_tagged_field_data_t* field_data = (ieee80211_tagged_field_data_t*)data_,0
  /* The tage len can be 1 or more if there are sub-elements */,0
"    out = tvb_memdup(wmem_packet_scope(), tvb, 0, tvb_captured_length(tvb))_",0
"        { &hf_infiniband_ClassPortInfo_Reserved2, {",0
            local_offset += 40_ *offset = local_offset_,0
"    proto_tree_add_item(ClassPortInfo_header_tree, hf_infiniband_ClassPortInfo_BaseVersion,       tvb, local_offset, 1, ENC_BIG_ENDIAN)_ local_offset += 1_",0
    local_offset += 1_ /* reserved */,0
	% export CMAKE_PREFIX_PATH=~/Qt5.8.0/5.8/clang_64,0
"    { 1, "" (Transmission Sequence) "" },",0
/* Parse NoticesAndTraps Attribute,0
  for(i=3_ i < len_ i+=4) {,0
} /*dissect_zcl_events_clear_event_log_request*/,0
    field_info *fi       = NULL_,0
    // Hex dump -x,0
"    {0, """"},",0
             break_,0
"            { ""Device EUI64"", ""zbee_zcl_se.mdu_pairing.device_eui64"", FT_UINT64, BASE_HEX, NULL,",0
"            { ""EUI64 of Requesting Device"", ""zbee_zcl_se.mdu_pairing.requesting_device_eui64"", FT_UINT64, BASE_HEX, NULL,",0
    guint8 funcgroup_,1
                case S7COMM_UD_FUNCGROUP_CPU:,1
    DISSECTOR_ASSERT(FALSE)_,0
#if defined(__GNUC__),1
"      else if (strcmp(argv[2], ""?"") == 0)",0
"      else if (strcmp(argv[2], ""help"") == 0)",0
"         col_append_str(pinfo->cinfo, COL_INFO, "", Modulation: "")_",0
"    t_size = tvb_get_guint8(tvb, offset)_",1
    switch (area) {,1
"        proto_item_append_text(tree, "" %d)"", a_address)_",0
"      { ""11ac MCS index"",         ""peekremote.mcs_index"", FT_UINT16,  BASE_DEC|BASE_EXT_STRING, &peekremote_mcs_index_vals_ext_ac,",0
"      //extflags = tvb_get_ntohl(tvb, offset)_",0
"                                                            ""Type 1 (metric is specified in the same units as interface cost)"" }_",0
/* OSPF Extended Link Opauqe LSA */,0
/* OSPF Extended Prefix Opauqe LSA */,0
    &hf_ospf_ls_epfx_flag_n,1
"            proto_tree_add_item(tlv_tree, hf_ospf_ls_range_size, tvb, offset + 4, 3, ENC_BIG_ENDIAN)_",0
"                proto_item_append_text(ti, "" [incorrect, should be 0]"")_",0
                    if (stlv_length == 3) {,0
"                        proto_item_append_text(ti, "" [Invalid length - %u]"", stlv_length)_",0
"			mirrors_item = proto_tree_add_uint_format(newtree, hf_nfs4_nfl_mirrors,",0
"						ett_nfs4_layoutseg_sub, NULL,",0
"		ss_fitem = proto_tree_add_uint(subtree,",0
				mirror_start_offset = offset_,0
					ds_start_offset = offset_,0
	packet-ieee1905.c	\,0
" * Copyright 2017, The Wi-Fi Alliance.",0
" * (A short description of the protocol including links to specifications,",0
static const true_false_string tfs_last_fragment = {,0
static const true_false_string tfs_he_support_80plus_mhz = {,0
"    beginRemoveRows(QModelIndex(), 0, rowCount())_",0
    uat_clear(uat_)_,0
    record_errors.clear()_,0
    dirty_records.clear()_,0
    uat_->changed = TRUE_,0
"                           ett_mqtt_hdr_flags, publish_fields, ENC_BIG_ENDIAN)_",0
"                { &hf_iana_subtype,",0
"		        { ""IANA Subtype"",      ""lldp.iana.subtype"", FT_UINT8, BASE_HEX,",0
"    { OUI_IANA,             ""Internet Assigned Numbers Authority"" },",0
"	other_array = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, offset, 12)_",0
		case NFS4_OP_CLOSE:,0
SET(CMAKE_AUTORCC TRUE),0
"if(NOT CMAKE_VERSION VERSION_LESS ""3.0"")",0
	# Add .qrc files to library dependencies for AUTORCC.,0
	set(WIRESHARK_QT_QRC_SRC ${WIRESHARK_QT_QRC}),0
if (QT_VERSION EQUAL 5),0
	QT5_ADD_TRANSLATION(WIRESHARK_QT_QM ${WIRESHARK_QT_TS}),0
"	if(CMAKE_VERSION VERSION_LESS ""3.0"")",0
		QT5_ADD_RESOURCES(WIRESHARK_QT_QRC_SRC ${WIRESHARK_QT_QRC}),0
		QT5_WRAP_UI(WIRESHARK_QT_UI_SRC ${WIRESHARK_QT_UI}),0
else(),0
	QT4_ADD_TRANSLATION(WIRESHARK_QT_QM ${WIRESHARK_QT_TS}),0
		QT4_ADD_RESOURCES(WIRESHARK_QT_QRC_SRC ${WIRESHARK_QT_QRC}),0
		QT4_WRAP_UI(WIRESHARK_QT_UI_SRC ${WIRESHARK_QT_UI}),0
	packet-fp_hint.c	\,0
	packet-fp_mux.c	\,0
    /* Add subtree */,1
"    proto_tree_add_item(subtree, hfindex_data, tvb, *offset, octet_len, ENC_NA)_",0
                else {,1
"	ptvcursor_add_text_with_subtree(ptvc, SUBTREE_UNDEFINED_LENGTH, ett_nfapi_message_tree, ""%s"", message_str)_",0
"	dissector_add_uint(""udp.port"", 41700, nfapi_handle)_",0
// 1 - Add range validation using expert info,0
"	value_u16 = tvb_get_ntohs(ptvcursor_tvbuff(ptvc), ptvcursor_current_offset(ptvc))_",1
"	{ 0x200F, ""Initial Transmission Paramters Release 8"", dissect_ul_config_init_tx_params_rel8_value },",1
"			{ ""Group assigment"", ""nfapi.group.assignment"",",0
"	{ NMM_IN_CONFIGURED_AND_RUNNING_STATE, ""NMM_IN_CONFIGURED_AND_RUNNING_STAT"" },",1
	guint16 i = 0_,0
"				lengths[i - 1] = tvb_get_guint16(ptvcursor_tvbuff(ptvc), ptvcursor_current_offset(ptvc), ENC_BIG_ENDIAN)_",0
	{,1
"		g_strlcat(text, ""8"", ITEM_LABEL_LENGTH)_",0
"			""type of the primary cell is used to determine if this is valid with size 2 bits.""",1
"			""The frequency hopping bits"", HFILL }",0
"			""Defines the periodicity and subframe location of the SRS. SRS Configuration Index.This value is fixed for a UE and allocated in RRC connection setup."", HFILL }",0
"			""Number of HI PDUs included in this messagee"", HFILL }",0
// Macros to wrap the ptvcursor_add function to map better to the specification which ,0
	packet-nfapi.c,1
/* packet-nfapi.c,0
"#include ""config.h"" ",1
#include <windows.h>,1
"typedef int(*Decode_operation)(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)_",1
static const true_false_string true_false_strname = {,1
"												{ 0x81, ""UL_CONFIG.request""},",1
"typedef int(*tlv_decode)(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data, guint* offset, guint* end)_",1
"static guint8 proto_tree_add_uint8(proto_tree *tree, int hfindex, tvbuff_t *tvb, guint* offset, char* units)",1
"static guint8 proto_tree_add_uint8_with_conversion(proto_tree *tree, int hfindex, tvbuff_t *tvb, guint* offset, uint8_value_conversion conversion)",0
"static int dissect_tdd_channel_measuerment_value(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data, guint* offset, guint* end)",1
	for (i = 0_ i < num_tags_ i++),0
	guint16* lengths = malloc(count * 2)_,1
	guint8 save_fragmented = pinfo->fragmented_,1
			// this is a segement skip the body,1
		}_,1
		case 0x85:,0
			// todo : is this vendor extention?,1
    expert_nfapi = expert_register_protocol(proto_nfapi)_,1
#define ZBEE_ZCL_ON_OFF_ONOFF_CONTROL_MASK_ACCEPT_ONLY_WHEN_ON   0x01,0
    static gint *ett[ZBEE_ZCL_ON_OFF_NUM_ETT]_,0
    ett[0] = &ett_zbee_zcl_on_off_,0
                    switch (effect_identifier) {,1
"            { ""Command"", ""zbee_zcl_general.onoff.effect_identifier"", FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(zbee_zcl_on_off_effect_variant_delayed_all_off_names),",0
"            { ""Command"", ""zbee_zcl_general.onoff.effect_identifier"", FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(zbee_zcl_on_off_effect_variant_dying_light_names),",0
"            { ""Command"", ""zbee_zcl_general.onoff.effect_identifier"", FT_UINT8, BASE_HEX | BASE_RANGE_STRING, RVALS(zbee_zcl_on_off_effect_variant_reserved_names),",0
  if (!print_summary && !print_details && !print_hex),0
            offset += 1_,1
" * @param value  if parsing succeeds, parsed varint will store here.",0
"tvb_get_varint(tvbuff_t *tvb, guint offset, guint maxlen, guint64 *value)",0
			/* end successfully becauseof last byte's msb(most significant bit) is zero */,0
"static void dissect_general_extension_information (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,",0
"          default: proto_tree_add_item (ecm_tree, hf_docsis_vsif_tlv_unknown, tvb, pos, length, ENC_NA)_",0
"          default: proto_tree_add_item (sav_spr_tree, hf_docsis_vsif_tlv_unknown, tvb, pos, length, ENC_NA)_",0
"        default: proto_tree_add_item (sav_tree, hf_docsis_vsif_tlv_unknown, tvb, pos, length, ENC_NA)_",0
"                                   ""Restore current filter after following a stream?"",",0
"    { & name .hf.hs_ext_cert_status_request_list_len,                   \",0
"  proto_tree_add_item (ip6clsfr_tc_tree, hf_docsis_tlv_ip6clsfr_tc_low, tvb, start, 1, ENC_BIG_ENDIAN)_",0
#include <wiretap/wtap.h>,0
#define SOLAREDGE_POST_HEADER_LENGTH		8,0
#define SOLAREDGE_COMMAND_DISPLAY_BOARD_LED_SET 				0x1701,0
	switch(device_header.type) {,0
"				/* Timezone offset, then end time*/",0
	)_,0
static,0
"	device_header.type = tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN)_",1
	/* Validate CRC */,1
	/* Have we seen this conversation before? */,1
	if (!dissected_http && tvb_captured_length(tvb)) {,0
	if (add_proto_name &&,0
		/* XXX Should we decrement curr_layer_num as well? */,1
"        guint32 end_bytes = tvb_get_guint24(next_tvb, length - 3, ENC_BIG_ENDIAN)_",0
"    event_data_len = tvb_get_guint8(tvb, *offset)_",0
#define BRCM_TAG_OPCODE_MASK		0x7,0
#define BRCM_TAG_LEN			4,0
"      ti = ptvcursor_add_no_advance(cursor, hf_brcm_tag_opcode, 1, ENC_NA)_",0
   void,0
"            FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }",0
"	{ ETHERTYPE_BRCM_TYPE,		  ""Broadcom tag"" },",0
"                proto_tree* sub_tree = proto_tree_add_subtree_format(tree, tvb, *offset, 4, ett_zbee_zcl_met_func_noti_flags, NULL, ""Functional Notification Flags: 0x%08x"", flags)_",0
"                guint32 flags = tvb_get_guint32(tvb, *offset, ENC_LITTLE_ENDIAN)_",0
"DESCRIPTION=$(git describe --match ""v[1-9]*"" --tags ${COMMIT})",1
VERSION=${DESCRIPTION/#v/},0
STASH_POP=False,0
            rt_val -= ts_offset__,0
        <string>RTT By Sequence Number</string>,0
    if (sai) {,0
 *                  (o) p  - protocol,0
  } else {,0
"    proto_tree_add_expert(tree, pinfo, &ei_ws_decompression_failed, tvb, 0, -1)_",0
"    wmem_free(wmem_file_scope(), decompr_payload)_",0
"    if (ws_strtou8(str, NULL, &wbits)) {",0
"void *websocket_zalloc(void *opaque _U_, unsigned int items, unsigned int size)",0
"void websocket_zfree(void *opaque _U_, void *addr)",0
"    pmc = !!(tvb_get_guint8(tvb, 0) & MASK_WS_RSV1)_",0
    if (analysis != NULL),1
            /* g_assert(selector_type == FT_NONE)_ */,0
"    dissector_table_t dt = register_dissector_table(table_name, ui_name, proto, FT_NONE, BASE_NONE)_",0
///XXX - Is this really needed (constructor should be enough)?,0
// - Add DCERPC support (or make DCERPC use a regular dissector table?),0
    //XXX - doesn't work with model/view implementation,0
                        item->default_proto_ = dissector_handle_get_short_name(dissector)_,0
"    connect(wsApp, SIGNAL(preferencesChanged()), this, SLOT(fillTable()))_",0
     </column>,0
"        NULL, HFILL }},",0
"        proto_item_append_text(item, ""MB"")_",1
    if (!is_subsequent_fragment(pinfo)) {,1
"        convo = wmem_new0(wmem_file_scope(), struct tibia_convo)_",1
"        struct rsakey *entry = g_new(struct rsakey, 1)_",0
    if (convo->has.adler32) {,1
"        guint32 accnum = tvb_get_letohl(tvb_decrypted, offset)_",0
    int rsa1_end = 0_ /* End of first RSA block */,1
    /* if announced length != real length it's not a tibia packet */,1
        int off = offset + 2_,1
"        guint32 a32 = tvb_get_letohl(tvb, off)_",0
        rsa1_end = offset + 128_,1
"        /* OTServs I tested against use join ""$acc\n$pacc"" as session key */",1
        if (offset + acclen > plen) return -1_,1
"        convo->acc = wmem_strdup_printf(wmem_file_scope(), ""%lu"", (unsigned long)accnum)_",1
    s->tree = *s->tree.next_,1
"G_INLINE_FUNC void dissect_string(struct state *s, gint hfid) {",1
"    char *acc, *pass, *char_name, *session_key_",0
"        if (!(payload_len = rsa_decrypt_inplace(128, payload, privkey, FALSE, &err))) {",1
"        len = tvb_get_guint16(tvb_decrypted, offset, ENC_LITTLE_ENDIAN)_",1
"        convo->char_name = (char*)tvb_memdup_nul(wmem_file_scope(), tvb_decrypted, offset + 2, len)_",0
                            /* TODO Mark all communication with the IP/Port pair above,0
                             * as Tibia communication.,0
    /* TODO best way to store this in source? */,0
    const char sexp[] =,0
"        ""(private-key (rsa""",0
"        ""(n #9b646903b45b07ac956568d87353bd7165139dd7940703b03e6dd079399661b4a837aa60561d7ccb9452fa0080594909882ab5bca58a1a1b35f8b1059b72b1212611c6152ad3dbb3cfbee7adc142a75d3d75971509c321c5c24a5bd51fd460f01b4e15beb0de1930528a5d3f15c1e3cbf5c401d6777e10acaab33dbe8d5b7ff5#)""",0
"        ""(e #010001#)""",0
"        ""(d #428bd3b5346daf71a761106f71a43102f8c857d6549c54660bb6378b52b0261399de8ce648bac410e2ea4e0a1ced1fac2756331220ca6db7ad7b5d440b7828865856e7aa6d8f45837feee9b4a3a0aa21322a1e2ab75b1825e786cf81a28a8a09a1e28519db64ff9baf311e850c2bfa1fb7b08a056cc337f7df443761aefe8d81#)""",0
"        ""(p #91b37307abe12c05a1b78754746cda444177a784b035cbb96c945affdc022d21da4bd25a4eae259638153e9d73c97c89092096a459e5d16bcadd07fa9d504885#)""",0
"        ""(q #0111071b206bafb9c7a2287d7c8d17a42e32abee88dfe9520692b5439d9675817ff4f8c94a4abcd4b5f88e220f3a8658e39247a46c6983d85618fd891001a0acb1#)""",0
"        ""(u #6b21cd5e373fe462a22061b44a41fd01738a3892e0bd8728dbb5b5d86e7675235a469fea3266412fe9a659f486144c1e593d56eb3f6cfc7b2edb83ba8e95403a#)""",0
"    report_failure(""Can't load private key files, GnuTLS support is not compiled in."")_",0
    (void)p_ (void)r_,1
static gint hf_len                     = -1_,1
"                    ptvcursor_add(ptvc, cmd == LOGINSERV_DLG_MOTD ? hf_motd : hf_dlg_error, 2, ENC_LITTLE_ENDIAN | convo->has.string_enc)_",1
                dstblock += 2*sizeof(guint32)_,1
static gint hf_coords_x = -1_,1
static gint hf_item            = -1_,1
    if (convo->has.rsa) {,1
"    proto_tree_add_item_ret_uint (map_tree, hf_docsis_map_numie, tvb, 2, 1, ENC_BIG_ENDIAN, &numie)_",0
		offset += length_,1
"  { 0,0,  ""Reserved"" },",0
    proto_tree	*mac_phy_flags = NULL_,0
"        mac_phy_flags = proto_item_add_subtree(tf, ett_802_1_aggregation)_",0
        /* TODO: mark this TLV as deprecated*/,0
#endif /* PACKET_NETMON_H */,0
  /* Want to preserve existing protocol name and show that it is carrying IMF */,0
    case CM_STATUS_EVENT_ENABLE_FOR_DOCSIS_3_1_EVENTS:,0
"     { ""Downstream OFDM Profile Failure"", ""docsis_mdd.cm_status_event_d31_ofdm_prof_fail"",",0
                if((*pfcp_ies[type].decode)){,0
    case 1: /* IPv4 */,0
"        proto_tree_add_item(rsvp_object_tree, hf_rsvp_ctype_s2l_sub_lsp, tvb, offset+3, 1, ENC_BIG_ENDIAN)_",0
"         {""Transaction Latency (us)"", ""cflow.pie.ixia.transact-latency-us"",",0
"          ""Names in the Query section of a DNS message (comma seperated list)"", HFILL}",0
	packet-netmon.c	\,0
"		g_array_free(postdissectors, FALSE)_",0
hsdsch_macdflow_ids[private_data_get_num_items(actx)-1] = private_data_get_hsdsch_macdflow_id(actx)_,1
    nbap_dch_chnl_info[private_data_get_dch_id(actx)].num_ul_chans = 0_,0
    nbap_dch_chnl_info[private_data_get_dch_id(actx)].num_dl_chans = 0_,0
    nbap_dch_chnl_info[private_data_get_common_transport_channel_id(actx)].num_ul_chans = 0_,0
    if(private_data_get_num_items(actx)>0){,1
"                                                                      interface_opts->cfilter,     /* IDB_FILTER       11 */",0
"                                                                          interface_opts->name,        /* IDB_NAME          2 */",0
            capture_opts_free_interface_t(device)_,0
"    rrc_scrambling_code_urnti = g_tree_new_full(rrc_key_cmp,",0
x90	Source Cell ID,0
x9e	MME Query,0
"	{ GSMTAP_RRC_SUB_TargetRNC_ToSourceRNC_Container,	""RRC Target RNC To Source RNC Container"" },",0
"From the Start Menu (or Start Screen), navigate to the `Visual Studio 2015 ->",0
> rem Set the library download directory using WIRESHARK_LIB_DIR...,0
> set WIRESHARK_LIB_DIR=c:\wireshark-win64-libs,0
> rem ...or by using WIRESHARK_BASE_DIR,0
	set(INSTALL_FILES README.md ${INSTALL_FILES}),1
"set(CPACK_PACKAGE_DESCRIPTION_FILE ""${CMAKE_CURRENT_SOURCE_DIR}/README.md"")",0
"				       ""Whether to interpret 241-246 as extended attributes according to RFC 6929"",",0
"    { &hf_subdoc_doc_flags_reserved, {""Reserved fields"", ""couchbase.extras.subdoc.doc_flags.reserved"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0xF8, ""A reserved field"", HFILL} },",0
"  &hf_subdoc_flags_expandmacros,",0
"  &hf_subdoc_doc_flags_accessdeleted,",0
"    { &hf_subdoc_doc_flags_mkdoc, { ""MKDOC"", ""couchbase.extras.subdoc.doc_flags.mkdoc"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x01, ""Create document if it does not exist, implies mkdir_p"", HFILL} },",0
"    { &hf_subdoc_flags_xattrpath, { ""XATTR_PATH"", ""couchbase.extras.subdoc.flags.xattr_path"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x04, ""If set path refers to extended attribute (XATTR)"", HFILL} },",0
"    { &hf_subdoc_doc_flags_accessdeleted, { ""ACCESS_DELETED"", ""couchbase.extras.subdoc.doc_flags.access_deleted"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x04, ""Allow access to XATTRs for deleted documents"", HFILL} },",0
"    { &hf_subdoc_flags_expandmacros, { ""EXPAND_MACROS"", ""couchbase.extras.subdoc.flags.expand_macros"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x10, ""Expand macro values inside XATTRs"", HFILL} },",0
"    { &hf_subdoc_doc_flags, { ""Subdoc Doc flags"", ""couchbase.extras.subdoc.doc_flags"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL} },",0
	packet-wifi-dpp.c	\,0
"          *subtype |= (tvb_get_guint8(tvb, offset) << 8)_ //Hack Alert!",0
"        dissect_wifi_dpp(pinfo, tree, tvb, offset + 1, request)_",0
      /* FALL THROUGH */,0
"      offset = dissect_wifi_dpp_action(tree, tvb, offset)_",0
"  fprintf(stderr, ""%s called with offset: %d, request: %d\n"", __func__,",0
"  fprintf(stderr, ""Dissecting IE offset: %d size: %d\n"", offset, size)_",0
"    proto_tree_add_uint(attr_hdr, hf_wifi_dpp_ie_attr_id, tvb, offset, 2, attribute_id)_",0
    offset +=2_,0
"			       tvbuff_t *tvb, int offset)",0
"		  val_to_str(subtype, dpp_public_action_subtypes,",0
"							dpp_public_action_subtypes,",0
"				ett_wifi_dpp_attributes, NULL, ""DPP Attributes"")_",0
  return offset_,0
"WS_DLL_PUBLIC void decrypt_xtea_ecb(guint32 *plaintext, const guchar *ciphertext, const guint32 *key, guint num_rounds)_",1
#define SSL_HND_HELLO_EXT_QUIC_TRANSPORT_PARAMETERS     26,0
#define SSL_HND_QUIC_TP_MAX_PACKET_SIZE                 5,0
"      { ""Type"", prefix "".quic.paremeter.type"",                          \",0
"    { QUIC_INTERNAL_ERROR, ""INTERNAL_ERROR(The endpoint encountered an internal error and cannot continue with the connection)"" },",0
"            FT_UINT8, BASE_DEC, NULL, 0x80,",1
"          { ""(Long) Packet Type"", ""quic.long.packet_type"",",0
"          { ""Short (Packet Type)"", ""quic.short.packet_type"",",0
"            FT_UINT32, BASE_DEC, NULL, 0x0,",1
"    dissector_add_uint_with_preference(""udp.port"", 4444, quic_handle)_",0
use Getopt::Long_,0
+    /* for assemblers that don't support xgetbv yet */,0
"    if [ -e ""$PROGRAM"" ]_ then",0
 The libwsutil library provides utility functions for libwireshark0.,1
#define HASH_SHA2_224_LENGTH 28,0
"	[SNMP_USM_AUTH_MD5] = HASH_MD5_LENGTH,",0
"	snmp_usm_password_to_key(n->user.authModel,",0
"		snmp_usm_password_to_key(n->user.authModel,",0
"			snmp_usm_password_to_key(n->user.authModel,",0
"        p_ftp_conv->current_working_directory = ""/""_  /* Start at root of file system */",0
    if (conv->current_working_directory[strlen(conv->current_working_directory)-1] == '/') {,0
        output[output_offset] = '\0'_,0
"void store_directory_in_packet(packet_info *pinfo, ftp_conversation_t *p_ftp_conv)",1
                                                            strlen(p_ftp_conv->current_working_directory))_,0
// static const value_string ip_version_vals[] = {,0
#define T_XPF        65422              /* XPF draft-bellis-dnsop-xpf */,0
"        proto_tree_add_uint_format(rr_tree, hf_dns_xpf_protocol, tvb, cur_offset, 1, proto, ""Protocol: %s (%u)"", proto_name, proto)_",1
        if (afamily == AFNUM_INET && afdpart_len <= 4) {,0
	ip_version.c	\,1
	ip_version.h	\,1
"                ""Missing outgoing frame counter"", EXPFILL }}                ",0
static int hf_rtps_flag_reserved00001000						= -1_,0
static int hf_rtps_flag_secure_publication_writer				= -1_,0
static int hf_rtps_flag_secure_service_request_writer			= -1_,0
"  &hf_rtps_flag_secure_participant_volatile_message_reader,		/* Bit 25 */",0
"    { &hf_rtps_flag_reserved00001000, {",0
                              .arg(cap_file_->current_frame->num))_,0
"        packets_str.append(QString(tr(""Packets: %1""))",0
"	proto_tree_add_item(epl_feat_tree, hf_epl_asnd_identresponse_feat_bit21, tvb, offset, 4, ENC_LITTLE_ENDIAN)_",0
" * If ""accept_mask"" is TRUE, parse an up-to-6-byte sequence with an optional",0
"                /* Entries with masks are allowed only in the ""manuf"" files. */",0
                if (!accept_mask) {,0
"                   If we're reading one of the ""manuf"" files, indicate that",0
    write_pdml_data data_,0
    const color_filter_t *cfp = edt->pi.fd->color_filter_,0
"        dissected = dissector_try_string(media_type_dissector_table, content_type, ",0
"    g_snprintf(buffer, buffer_length, ADB_HEX4_FORMAT, adb_service_length)_",0
"static const true_false_string tfs_open_closed = { ""Open"", ""Closed"" }_",0
"          FT_BOOLEAN, 8, TFS(&tfs_open_closed), 0x01,",1
    proto_tree *assoc_item_unknown_tree = NULL_  /* Tree for item details */,0
		udt_conv->is_dtls = is_dtls_,1
	packet-zbee-zcl-touchlink.c \,0
"    /* The endpoints should either both be zero, or both non-zero. */",0
WS_DLL_PUBLIC const true_false_string tfs_s2c_c2s_,0
"  be enabled via the ""802.11 radio information"" preferences.",0
* Added TLS 1.3 (draft 21) dissection and decryption support (ws-buglink:12779[]).,0
  via the Decode As dialog.,0
  addition to the Key File.,0
   if(tree) {,0
    iog->setValueUnitField(item->text(yfield_col_))_,0
            filter_ = full_filter_,0
    for (guint i = 0_ i < global_capture_opts.all_ifaces->len_ i++),0
void proto_register_vsock(void)_,0
"    { 607, ""Unwanted""},",0
"			memcpy(out_key, key, MIN(id_size, outkey_size))_",0
"		UAT_FLD_CSTRING(seskey_list, key, ""Session Key"", ""The secret session key buffer, coded as hex digits as it appears on the wire (LE).""),",0
		| grep UDT > /dev/null,0
"		conversation_add_proto_data(conv, proto_udt, udt_conv)_",1
"    length = tvb_reported_length_remaining(tvb, offset)_",0
static const true_false_string bit_O_RPL = {,0
static const true_false_string bit_R_RPL = {,0
static const true_false_string bit_F_RPL = {,0
"          { ""Packet direction: UP false, DOWN true. bit O"",   ""6lowpan.5.bitO"",",0
"          { ""Error detected, bit R"",                 ""6lowpan.5.bitR"",",0
                                case 0: /* IPv6 address compressed to 1 byte */ ,1
                        if (loRHE_type >= 15) {,0
                                case 0:,0
                                case 2:,0
                                case 3:,0
                                case 4:,0
        } /* while (condition > 0)*/,0
#define LOWPAN_PATTERN_FRAG_BITS        5 ,0
        if (tree) {,0
/*FUNCTION:------------------------------------------------------,0
                        }   ,0
                        break_ /* case LOWPAN_PATTERN_6LORHE */ ,0
"                                    proto_tree_add_uint             (loRH_tree, hf_6lowpan_rpl_instance, tvb, offset, 1, rpl_instance)_",0
                                ,0
                        break_ /* case LOWPAN_PATTERN_6LORHC */ ,0
                    }  /* switch loRHE_class */                ,0
#define LOWPAN_PATTERN_FRAGN            0x1c,0
>>>>>>> fb5ab4120b... Squash me,0
"    else if (tvb_get_bits8(next, 0, LOWPAN_PATTERN_PAGING_DISPATCH_BITS) == LOWPAN_PATTERN_PAGING_DISPATCH) {",0
        // if (tree) {,0
        // },0
"        next = tvb_new_subset_remaining(tvb, 1)_",0
"        next = dissect_6lowpan_6loRH(next,/* pinfo,*/ lowpan_tree/*, -1, src_iid, dst_iid*/)_",0
            if (tree) {,1
                            for (int i=0_ i<loRHE_unitnums_ i++) {,0
"                        memset(&ipv6.ip6h_src, 0, sizeof(ipv6.ip6h_src))_",1
                    if (loRHE_type == 5){,0
                        offset += 2_,0
	DISSECTOR_ASSERT(format)_,0
"						expert_add_info_format(pinfo, ti, bad_checksum_expert, ""Bad checksum"", len*2, computed_checksum)_",0
#define UDT_HANDSHAKE_TYPE_STREAM	1,0
"        { ""Payload IE, IETF IE"",             ""wpan.payload_ie.ietf"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},",0
"        { ""Payload IE, IETF IE"",                         ""wpan.payload_ie.ietf"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},",0
" 	  vendor_unique_protocol_id_string = wmem_strdup_printf(wmem_packet_scope(), ""%012"" G_GUINT64_MODIFIER ""x"", vendor_unique_protocol_id)_",0
" 	  vendor_unique_protocol_id_string = wmem_strdup_printf(wmem_packet_scope(), ""%04x%08x"", vendor_unique_protocol_id >> 32, (vendor_unique_protocol_id & 0xFFFFFFFF))_",0
	wlan_statistics_dialog.h		\,1
	wireshark_dialog.cpp		\,1
"	void actionMoved(QAction * action, int oldPos, int newPos)_",1
#endif // ENDPOINT_DIALOG_H,1
    const struct dlt_encap lookup[] = {,0
"        { EXTCAP_ENCAP_LINUX_SLL, ""LINUX_SLL"" },",0
"        { EXTCAP_ENCAP_ETHERNET, ""EN10MB"" },",0
   preference files will be written without the old fields.,0
	for (i = 0_ i < num_display_filter_macros_ i++),0
		g_free(rec->expression)_,0
"			""filter_buttons"",           /* filename */",0
"    //handle frames that don't have their own OK/Cancel ""buttons""",0
    ui->deleteToolButton->setEnabled(false)_,0
"#include ""geometry_state_dialog.h""",0
"#include ""uat_model.h""",0
 *       instead of generating this file.,0
		$name =~ s/ \((formerly .*)\)/\t# $1/_,0
"    enterprises_hashtable = g_hash_table_new_full(g_int_hash, g_int_equal, g_free, g_free)_",0
"    return ""<Unknown>""_",0
"WS_DLL_PUBLIC gchar *enterprises_lookup_format(wmem_allocator_t *allocator, guint32 value, const char *fmt)_",1
    dt = find_dissector_table(table_name)_,1
        case NVME_IOQ_OPC_READ:,0
    uat_(uat),0
    setUat(uat)_,0
        ((field->mode == PT_TXTMOD_BOOL) && (role != Qt::CheckStateRole))),0
"    PT_TXTMOD_DISPLAY_FILTER,",0
//    case PT_TXTMOD_BOOL:,0
     * pass of a packet so this needs to be taken into account when this is used as an identifier.,1
"    gint datalen = tvb_reported_length_remaining(tvb, 0)_",1
    if (IS_HTTP2_END_STREAM(flags) && datalen == 0) {,0
    if(IS_HTTP2_END_STREAM(flags) && reassembly_info->stream_has_data_to_reassemble) {,1
"    fragment_head *head = fragment_add_seq_next(&http2_body_reassembly_table, tvb, offset, pinfo, reassembly_id, NULL,",0
    if (reassembly->last_fragment) {,0
            head->reassembled_in = get_fd_num_from_http2_frame_num(reassembly_info->last_data_frame)_,0
            reassembly_info->last_fragment = head_,0
    http2_header_stream_info_t header_stream_info[2]_,1
"        wmem_map_insert(stream_map, &stream_info->stream_id, stream_info)_",0
    http2_header_stream_info_t *stream_info = get_header_stream_info(pinfo)_,1
    if (stream_info->header_start_in != 0 && stream_info->header_end_in == 0 && flags & HTTP2_FLAGS_END_HEADERS) {,1
        stream_info->header_end_in = pinfo->fd->num_,1
    http2_session->current_stream_id = streamid_,1
"        nwritten += ws_write(fd, ""\n"", 1)_",0
    ws_close(fd)_,0
    wireless_timeline_->setPacketList(packet_list_)_,0
"                *length_size = dissect_amqp_1_0_map(tvb, pinfo, offset-1, item, hf_amqp_type, name)-1_",0
   tvbuff_t   *new_tvb_,0
"set(_all_manifest_wix_contents ""${_all_manifest_wix_contents}<Include>\n\n"")",0
          tvbuff_t           *msdu_tvb_,0
"dissect_zcl_gp_proxy_sink_table_request(proto_tree *tree, tvbuff_t *tvb, guint *offset)",0
"dissect_zcl_gp_proxy_sink_table_response(proto_tree *tree, tvbuff_t *tvb, guint *offset, guint16 attr_id)",0
"dissect_zcl_gp_sink_comm_mode(proto_tree *tree, tvbuff_t *tvb, guint *offset)",0
"dissect_zbee_zcl_gp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)",0
  proto_item *li_item_,0
  if (use_extended_sequence_numbers) {,0
                    /* Decode as ENC_UTF_16 instead of UCS2 because of Bug: 13808 */,1
    /* 802.15.4-2015 TSCH mode with frame counter suppression is not supported yet */,1
"    proto_tree_add_item(RETH_header_tree, hf_infiniband_virtual_address,                tvb, local_offset, 8, ENC_BIG_ENDIAN)_ local_offset += 8_",0
"    proto_tree_add_item(RETH_header_tree, hf_infiniband_remote_key,                     tvb, local_offset, 4, ENC_BIG_ENDIAN)_ local_offset += 4_",0
        switch(key_activation_code),1
"            proto_item_append_text(ti, "": "")_",0
                case 0:,1
"            /*font_colour = tvb_get_guint8(tvb, offset)_*/",1
/* packet-canopen.c,1
    struct can_identifier can_id_,0
    static guint seqnr = 0_,1
    /* put source address in source field */,1
        /* put destination addess in address field */,1
"            number_of_packets_can_be_sent = tvb_get_guint8(tvb, data_offset)_",1
"            total_size = tvb_get_guint16(tvb, data_offset, ENC_LITTLE_ENDIAN)_",1
    //cleanup address identifier table,1
static guint32,0
	gcry_cipher_hd_t cipher_,1
	if (encryption_keys) {,1
"	{ &hf_lorawan_mac_command_down_new_channel_req_drrange_max_type,",1
"	{ &hf_lorawan_mac_command_down_new_channel_req_drrange_min_type,",1
"		UAT_FLD_CSTRING(device_encryption_keys, dev_addr_string, ""Device Address"", ""LoRaWAN Device Addres""),",0
	packet-lorawan.c,0
"print_color_escape(FILE *fh, const color_t *fg, const color_t *bg)",0
#ifndef _WIN32,0
"print_line_color_text(print_stream_t *self, int indent, const char *line, const color_t *fg, const color_t *bg)",0
"	#echo ""command: ""$1"" opt1: ""$2"" opt2: ""$3"" opt3: ""$4"" opt4: ""$5"" opt5: ""$6",0
"	test_step_add ""Valid TShark parameter --color, exit status must be $EXIT_OK"" ""test_long_options $TSHARK color $EXIT_OK""",0
#define LONGOPT_COLOR (65536+1000),1
"    { BGPTYPE_BGP_PREFIX_SID,      ""BGP Prefix SID"" },",0
"                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_length, tvb, q + 1, 2, ENC_BIG_ENDIAN)_",0
"        { &ei_bgp_attr_as_path_as_len_err, { ""bgp.attr.as_path.as_len"", PI_UNDECODED, PI_ERROR, ""unable to determine 4 or 2 bytes ASN"", EXPFILL}},",0
/* BGP_PREFIX_SID TLV lenghts   */,0
                            if (prefix_sid_sublen != BGP_PREFIX_SID_TLV_LEN_LABEL_INDEX){,0
"                  v16 = tvb_get_guint16(tvb, 2 + length_field_size, byte_order)_",1
                   * The offset is changed to skip those four bytes in the,1
            if (plen == 0) {,0
	wireless_timeline.h,1
	wireless_timeline.cpp,1
"			(int) (255*(red * fraction + base)),",0
	if (fd->flags.passed_dfilter),0
"	printf(""wlan_radio_id %d\n"", wlan_radio_proto_id)_",1
    guint num = find_packet(event->pos().x())_,0
guint64 WirelessTimeline::current_frame_center(),0
    struct wlan_radio *wr = get_wlan_radio(cfile.current_frame->num)_,0
    return (wr->start_tsf + wr->end_tsf) /2_,0
"    cf_goto_frame(&cfile, num)_",0
"    connect(packet_list->packetListModel(), SIGNAL(dissectionProgress(int,int)),",0
"void WirelessTimeline::doToolTip(struct wlan_radio *wr, QPoint pos, int x)",0
"    dissectionProgress(first, idle_dissection_row_)_",0
        if (ri == NULL) continue_,0
"        FT_UINT8, BASE_HEX, NULL, 0,",0
          mne_local_offset+=2_,0
        if (sub_type == 0) {,0
"dissect_pn_uint32(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,",0
"WS_DLL_PUBLIC int rsa_pkcs1_decrypt_inplace(const guint len, guchar* data, gcry_sexp_t pk, gboolean pkcs1_padding, char **err)_",1
"        *err = g_strdup(""swapping p and q parameters and recomputing u"")_",1
            *err = NULL_,1
"        ssl_debug_printf(""%s"", err)_",1
"    /*ssl_debug_printf(""%d bytes read\n"", data.size)_*/",1
        g_free(*err)_,1
"            /*ssl_debug_printf( ""Bag %d/%d: %s\n"", i, j, BAGTYPE(bag_type))_*/",1
"		*err = g_strdup_printf(""pcry_private_decrypt: can't convert data to mpi (size %d):%s\n"",",1
				/*rc = (gint) i+1_*/,0
"                                            &next_line_start_offset, FALSE)_",1
"        {&hf_pie_ntop_src_to_dst_max_throuthput,",0
"        {&hf_pie_ntop_flow_proto_port,",0
"        {&hf_pie_ntop_upstream_tunnel_id,",0
"        {&hf_pie_ntop_downstram_tunnel_id,",0
"        {&hf_pie_ntop_client_nw_latency_ms,",0
"        {&hf_pie_ntop_server_nw_latency_ms,",0
"        {&hf_pie_ntop_oracle_query_duration,",0
"        {&hf_pie_ntop_src_proc_actual_memory,",0
"        {&hf_pie_ntop_src_proc_peak_memory,",0
"          ""(e.g. 1=A, 2=NS..)"", HFILL}",0
"          ""(e.g. 0=no error)"", HFILL}",0
"    MODE_POLY1305,  /* AEAD_CHACHA20_POLY1305 with 16 byte auth tag (RFC 7905) */",1
"                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN)_",0
                tag_len -= tag_len_,0
                       &g_fb_zero_debug)_,0
"    { AEAD_CC12, ""Salsa20 with Poly1305"" },",0
                    /*TODO FIX: 24 Length + Pubs key?.. ! */,1
		if (pinfo->dst.type != AT_NONE),0
		 */,1
         (key1->tid == key2->tid) ),0
"       p_add_proto_data(wmem_file_scope(), pinfo, proto, 0, pi)_",0
    guint32 destport_,1
    guint32 srcport = 0_,1
"			memset(&subobj, 0, sizeof subobj)_",0
/* XXX hopefully temporary till -Wmissing-field-initializers and -Wmissing-braces are ignored */,0
"	{ ""Domain"",         &hf_epl_od_domain, ENC_NA  },",0
"	{ ""Time_of_Day"",    &hf_epl_od_time,    ENC_NA },",0
"	{ 0, 0, 0, 0 }",0
	struct object_mapping map = OBJECT_MAPPING_INITIALIZER_,0
"        proto_tree_add_item(ie_tree, hf_rsl_paging_group_cs, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
/* Paging Package Number dissection. REF: EP2192796B1,0
"            FT_UINT8, BASE_DEC, VALS(rsl_emlpp_prio_vals), 0x05, /* in 3GPP TS 48.058 eMLPP Priority takes bits 1-3 not 1-2 */",0
#define epl_debug(...) g_warning(__VA_ARGS__),1
#define epl_debug(...),1
epl_ishex(const char *num),1
"	if (g_str_has_prefix(num, ""0x""))",1
		return TRUE_,1
	for (_ g_ascii_isxdigit(*num)_ num++),1
		_,1
	if (g_ascii_tolower(*num) == 'h'),1
	return FALSE_,1
static guint16,1
"epl_g_key_file_get_uint16(GKeyFile *gkf, const gchar *group_name, const gchar *key, GError **error)",1
	guint16 ret = 0_,1
	const char *endptr_,1
"	char *val = g_key_file_get_string(gkf, group_name, key, error)_",1
	if (!val),1
		return 0_,1
"	if (epl_ishex(val)) /* We need to support XXh, but no octals (is that right?) */",1
"		ws_hexstrtou16(val, &endptr, &ret)_",1
	else,1
"		ws_strtou16(val, &endptr, &ret)_",1
	g_free(val)_,1
	return ret_,1
static char *,1
"epl_strchrnul(const char *s, int c)",1
	const char *end_,1
	if (!s) return NULL_,1
	for (end = s_ *end && *end != c_ end++),1
	return (char*)end_,1
"epl_wmem_strdup_till(wmem_allocator_t *allocator, const char *str, char ch)",1
	if (!str) return NULL_,1
"	return (char*)wmem_strndup(allocator, str, epl_strchrnul(str, ch) - str)_",1
#if defined HAVE_LIBXML2,1
#include <libxml/xmlversion.h>,1
#if defined LIBXML_XPATH_ENABLED \,1
&&  defined LIBXML_SAX1_ENABLED  \,1
&&  defined LIBXML_TREE_ENABLED,1
"#include ""packet-epl.h""",1
#include <epan/wmem/wmem_interval_array.h>,1
#include <string.h>,1
#include <libxml/tree.h>,1
#include <libxml/parser.h>,1
#include <libxml/xpath.h>,1
struct dataType {,1
	guint16 id_,1
	const struct epl_datatype *ptr_,1
"			/*else if (g_str_equal(""PDOmapping"", key)) {",1
"			  obj.PDOmapping = get_index(ObjectPDOmapping_tostr, val)_",1
			  assert(obj.PDOmapping >= 0)_,1
		value = actualValue ? actualValue,1
		      : defaultValue ? defaultValue,1
"					if (subobj.info.value && epl_profile_object_mapping_add(profile, obj->info.idx, (guint8)subobj.info.idx, subobj.info.value))",1
static gint hf_epl_od_integer8        = -1_,0
static gint hf_epl_od_integer16       = -1_,0
static gint hf_epl_od_integer24       = -1_,0
static gint hf_epl_od_integer32       = -1_,0
static gint hf_epl_od_integer40       = -1_,0
static gint hf_epl_od_integer48       = -1_,0
static gint hf_epl_od_integer56       = -1_,0
/*static gint hf_epl_od_time_of_day     = -1_*/,1
#define EPL_PDO_TYPE_COUNT 8,1
static gint hf_epl_od_unsigned[EPL_PDO_TYPE_COUNT],1
"	= {  -1, -1, -1, -1, -1, -1, -1, -1 }_",1
#define SIZE_TO_UNSIGNED_HF(size) ((0 < (size) && (size) <= EPL_PDO_TYPE_COUNT) \,1
"	/*{ ""Time_of_Day"",    &hf_epl_od_time_of_day,     ENC_NA},*/",1
struct read_req {,1
	guint16 idx_,1
	guint8 subindex_,1
	guint8 sendsequence_,1
	const char *index_name_,1
	struct od_entry *info_,1
struct epl_convo {,1
	guint8 CN_,1
	guint16 DeviceType_,1
	guint32 ResponseTime_,1
	guint32 VendorId_,1
	guint32 ProductCode_,1
	guint generation_ /* FIXME remove */,1
	wmem_array_t *TPDO_ /* CN->MN */,1
	wmem_array_t *RPDO_ /* MN->CN */,1
	struct profile *profile_,1
	guint32 last_frame_,1
	guint8 next_read_req_,1
	guint8 seq_send_,1
	struct read_req read_reqs[4]_,1
"	/* In lieu of allocating an unknown number of read requests, we'll keep a ring",1
	 * buff of the 4 most recent ones and when a response comes we add them as packet,1
	 * data,1
	 */,1
"			ti = proto_tree_add_string_format(pdo_tree, hf_epl_asnd_identresponse_profile_path, tvb, 0, 0,",1
"					"""", ""Mapping set by %04X:%02X, Life time: Frame #%u-#%u, Offset: 0x%04x, Length %u bits"",",1
"					map->param.idx, map->param.subindex, map->frame.first, map->frame.last, map->bit_offset, map->no_of_bits",1
		dissect_epl_payload(,1
"				pdo_tree,",1
"				tvb_new_octet_aligned(payload_tvb, map->bit_offset, map->no_of_bits),",1
"				pinfo, 0, map->no_of_bits / 8, map->info ? map->info->type : NULL, msgType",1
static address epl_placeholder_mac_,1
#define CONVO_FOR_RESPONSE  1,1
#define CONVO_FOR_REQUEST   2,1
"				/* We don't know the type, so let's use appropriate unsignedX */",1
				gint *hf = SIZE_TO_UNSIGNED_HF(len)_,1
"			&& dissector_try_uint(epl_asnd_dissector_table, svid, next_tvb, pinfo,",0
/* User Access Table Checkers */,1
"static gboolean epl_profile_uat_fld_fileopen_check_cb(void *, const char *, unsigned, const void *, const void *, char **)_",1
"static gboolean epl_uat_fld_cn_check_cb(void *, const char *, unsigned, const void *, const void *, char **)_",1
"static gboolean epl_uat_fld_uint16dec_check_cb(void *, const char *, unsigned, const void *, const void *, char **)_",1
"static gboolean epl_uat_fld_uint32hex_check_cb(void *, const char *, unsigned, const void *, const void *, char **)_",1
/* DeviceType:Path User Access Table */,1
struct device_profile_uat_assoc {,1
	char *path_,1
	guint DeviceType_,1
	guint VendorId_,1
	guint ProductCode_,1
static uat_t *device_profile_uat = NULL_,1
static struct device_profile_uat_assoc *device_profile_list_uats = NULL_,1
static guint ndevice_profile_uat = 0_,1
"static void *device_profile_uat_copy_cb(void *, const void *, size_t)_",1
static void device_profile_uat_free_cb(void *)_,1
"static gboolean device_profile_uat_update_record(void *, char **)_",1
static void device_profile_parse_uat(void)_,1
"UAT_DEC_CB_DEF(device_profile_list_uats, DeviceType, struct device_profile_uat_assoc)",1
"UAT_HEX_CB_DEF(device_profile_list_uats, VendorId, struct device_profile_uat_assoc)",1
"UAT_HEX_CB_DEF(device_profile_list_uats, ProductCode, struct device_profile_uat_assoc)",1
"UAT_FILENAME_CB_DEF(device_profile_list_uats, path, struct device_profile_uat_assoc)",1
static uat_field_t device_profile_list_uats_flds[] = {,1
"	UAT_FLD_CSTRING_OTHER(device_profile_list_uats, DeviceType, ""DeviceType"", epl_uat_fld_uint16dec_check_cb, ""e.g. 401""),",1
"	UAT_FLD_CSTRING_OTHER(device_profile_list_uats, VendorId, ""VendorId"", epl_uat_fld_uint32hex_check_cb, ""e.g. DEADBEEF""),",1
"	UAT_FLD_CSTRING_OTHER(device_profile_list_uats, ProductCode, ""ProductCode"", epl_uat_fld_uint32hex_check_cb, ""e.g. 8BADFOOD""),",1
"	UAT_FLD_FILENAME_OTHER(device_profile_list_uats, path, ""Profile Path"", epl_profile_uat_fld_fileopen_check_cb, ""Path to the EDS"" IF_LIBXML(""/XDD/XDC"")),",1
	UAT_END_FIELDS,1
/* NodeID:Path User Access Table */,1
struct nodeid_profile_uat_assoc {,1
	guint8 is_nodeid:1_,1
	union {,1
		guint8 id_,1
		address addr_,1
	} node_,1
	char *id_str_,1
static uat_t *nodeid_profile_uat = NULL_,1
static struct nodeid_profile_uat_assoc *nodeid_profile_list_uats = NULL_,1
static guint nnodeid_profile_uat = 0_,1
"static void nodeid_profile_list_uats_nodeid_set_cb(void *, const char *, unsigned, const void*, const void*)_",1
"static void nodeid_profile_list_uats_nodeid_tostr_cb(void *, char **, unsigned *, const void*, const void*)_",1
"static void *nodeid_profile_uat_copy_cb(void *, const void *, size_t)_",1
static void nodeid_profile_uat_free_cb(void *)_,1
"static gboolean nodeid_profile_uat_update_record(void *, char **)_",1
static void nodeid_profile_parse_uat(void)_,1
"UAT_FILENAME_CB_DEF(nodeid_profile_list_uats, path, struct nodeid_profile_uat_assoc)",1
static uat_field_t nodeid_profile_list_uats_flds[] = {,1
"	UAT_FLD_CSTRING_OTHER(nodeid_profile_list_uats, nodeid, ""Node ID"", epl_uat_fld_cn_check_cb, ""e.g. 1 or 00-00-5E-00-53-00""),",1
"	UAT_FLD_FILENAME_OTHER(nodeid_profile_list_uats, path, ""Profile Path"", epl_profile_uat_fld_fileopen_check_cb, ""Path to the EDS"" IF_LIBXML(""/XDD/XDC"")),",1
"epl_strtou16(const char * str, char **endptr, int base)",0
"		wmem_map_insert(dataTypeMap, &entry->id, (void*)type)_",0
"	wmem_free(wmem_epan_scope(), dataTypeMap)_",0
	xmlInitParser()_,0
"	profile->data = typemap = (GHashTable*)g_hash_table_new_full(epl_g_int16_hash, epl_g_int16_equal, NULL, g_free)_",0
"	wmem_array_append(arr, mapping, 1)_",0
"	unsigned long val = strtoul(str, &endptr, 10)_",0
"epl_g_int16_equal(gconstpointer v1, gconstpointer v2)",0
	guint32 cid_,0
	const struct osmux_stream_key *v1 = (const struct osmux_stream_key *)v_,0
"        //fprintf(stderr, ""%s %u\t->\t%u"", stream_name, stream->stats.last_seq, osmuxh->seq)_",0
"            proto_tree_add_bytes_format(tree, hf_ipp_octetstring_value, tvb, valoffset, value_length, NULL, ""%s value: ??? %d bytes ???"", tag_desc, value_length)_",0
  expert_acn = expert_register_protocol(proto_magic)_,0
"    progfile_dir = g_strdup_printf(""%s_%s"", get_progfile_dir(), g_getenv(""PATH""))_",1
            if (status && exit_status == 0) {,0
"                keep_going = cb(extcap, command_output, cb_data, err_str)_",0
	rm -r -f libssh-0.7.2,0
"	<!ENTITY Inovar		SYSTEM ""Inovar.xml"">",0
            fp_rach_channel_info = NULL_,0
        /* Some information was missing in the conversation struct and the FP info isn't complete */,0
"        p_remove_proto_data(wmem_file_scope(), pinfo, proto_fp, 0)_",0
 #define MQ_MQMEDIMGSCHED_MANUAL           0,0
                    if (device.active_dlt >= DLT_USER0 && device.active_dlt <= DLT_USER15) {,0
    guint8 data[16]_,0
    cql_uuid_t  uuid_,0
    return uuid_,0
"			uuid = get_uuid(tvb, offset)_",0
			if (bytes_length == 16 || bytes_length == 20) { ,0
"				sub_item = proto_tree_add_item(columns_subtree, hf_cql_port, tvb, offset, 4, ENC_NA)_",0
			offset += 2_,0
				offset += 2_,0
"			my_double = tvb_get_ntohieee_double(tvb, offset)_",0
		case CQL_RESULT_ROW_TYPE_FLOAT:,0
		case CQL_RESULT_ROW_TYPE_INT:,0
			switch (bytes_length) {,0
"				port_number = tvb_get_ntohl(tvb, offset)_",0
			*offset_metadata += 2_,0
			/* UDT name */,0
				/* UDT field name */,0
			/* ksname and tablename */,0
			shadow_offset += string_length_,0
		shadow_offset += 2_,0
	../plugins/docsis/packet-bpkmrsp.c \,0
"		printf(""{\""errmsg\"":\""%s\"" specifies unknown preference}\n"", pref)_",0
	g_free(errmsg)_,0
} radius_attr_type_t_,0
#define zbee_zcl_events_attr_names_VALUE_STRING_LIST(XXX) \,0
"        proto_tree_add_item(tree, hf_zbee_zcl_events_srv_tx_cmd_id, tvb, offset, 1, cmd_id)_",0
"            algorithm = ""hmac-sha1""_",0
"    { ""Key ID"", ""isis.clv.key_id"", FT_UINT16, BASE_DEC, NULL,",0
static const true_false_string tfs_local_true_false =,0
"          ssl_calculate_handshake_hash(ssl, sub_tvb, 0, length)_",0
"                                guint16 val = tvb_get_ntohs(tvb, off)_",1
      if (pinfo->fd->num > 1) {,1
gboolean last_has_tsf_timestamp_,0
guint64 last_tsf_timestamp_,0
guint last_phy_,0
struct wlan_radio *last_,0
struct aggregate *aggregate_,0
"        col_add_fstr(pinfo->cinfo, COL_TX_RATE, ""%.1f"", data_rate)_",0
	if (duration && !pinfo->fd->flags.visited && phdr->has_tsf_timestamp) {,0
				  wlan_radio_info->aggregate->duration)_,0
"	{&hf_wlan_radio_aggregate,",0
"/* previous frame details, for aggregate detection */",0
"    proto_tree_add_bitmask(timeslot_tree, tvb, *offset, hf_ieee802154_payload_ie_tlv, ett_ieee802154_psie_short_bitmap, fields_short, ENC_LITTLE_ENDIAN)_",0
  if (phdr->has_data_rate && data_rate > 0) {,0
                guint decompressed_buffer_size = LZ4_compressBound(compressed_size)_,0
				       &aim_desegment)_,1
"  /* If blob exists, call function to dissect blob*/",0
"		col_append_fstr(pinfo->cinfo, COL_INFO, ""Response %s[%d]:"",",0
"				val_to_str_ext(EPL_ASND_SDO_COMMAND_READ_MULTIPLE_PARAMETER_BY_INDEX,",0
"				&epl_sdo_asnd_commands_short_ext, ""Command(%02X)""),",0
"				proto_item_append_text(psf_od_tree, "" Idx: 0x%04X"", idx)_",0
				/* get subindex offset */,0
"				subindex = tvb_get_guint8(tvb, dataoffset)_",0
"		col_append_fstr(pinfo->cinfo, COL_INFO, ""%s[%d]:"",",0
/* packet-netgear.c,0
"dissect_nge_esemble(tvbuff_t *tvb,proto_tree *tree _U_, int offset)",0
"    guint32 length = tvb_get_guint32(tvb, offset,ENC_BIG_ENDIAN)_",1
"    nge_handle = create_dissector_handle(dissect_nge, proto_nge)_",1
 * Routines for Netgear AP Ensemble Protocol,0
 * Charlie Lenahan <clenahan@sonicbison.com>,0
" * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.",0
#define NETGEAR_ENSEMBLE_PORT 4554,0
static int proto_nge = -1_,0
static int hf_nge_version = -1_,0
static int hf_nge_unknown = -1_,0
static int hf_nge_unknown_int32 = -1_,0
static int hf_nge_sequence = -1_,0
static int hf_nge_tlv_length = -1_,0
static int hf_nge_ensemble_name = -1_,0
static int hf_nge_firmware_name = -1_,0
static int hf_nge_region_name = -1_,0
static int hf_nge_firmware_version = -1_,0
static int hf_nge_ap_name = -1_,0
static int hf_nge_uptime = -1_,0
static int hf_nge_mac = -1_,0
static int hf_nge_ip = -1_,0
static int hf_nge_uuid = -1_,0
static gint ett_nge = -1_,0
static gint ett_nge_lv = -1_,0
static gint ett_nge_ensemble = -1_,0
"dissect_nge_lv(tvbuff_t *tvb, proto_tree *tree _U_, int offset, const char* name,int hfindex)",0
"    proto_tree *tlv_tree = proto_tree_add_subtree(tree, tvb, offset, length+4, ett_nge_lv, NULL,name)_",0
"    proto_item *ti = proto_tree_add_uint(tlv_tree, hf_nge_tlv_length, tvb, offset, 4, length)_",0
"    proto_item_append_text(tlv_tree, "": %s"", tvb_format_text(tvb, offset, length))_",0
"    ti = proto_tree_add_item(tlv_tree, hfindex, tvb, offset,length,ENC_NA)_",0
    offset += length_,0
    return offset_,1
"    proto_tree *ensemble_tree = proto_tree_add_subtree(tree, tvb, offset, length+4, ett_nge_ensemble, NULL,""Ensemble"")_",0
"    proto_tree_add_uint(ensemble_tree, hf_nge_tlv_length, tvb, offset, 4, length)_",0
"    proto_tree_add_item(ensemble_tree, hf_nge_unknown, tvb, offset, 17, ENC_BIG_ENDIAN)_",0
    offset += 17_,0
    /* type == 1 ? */,0
"    proto_tree_add_item(ensemble_tree, hf_nge_unknown_int32, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
    /* uuid ? */,0
"    proto_tree_add_item(ensemble_tree, hf_nge_uuid, tvb, offset, 16, ENC_BIG_ENDIAN)_",0
    offset += 16_,1
"    proto_tree_add_item(ensemble_tree, hf_nge_ip, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"    proto_tree_add_item(ensemble_tree, hf_nge_unknown, tvb, offset, 20, ENC_BIG_ENDIAN)_",0
    offset += 20_,1
"    proto_tree_add_item(ensemble_tree, hf_nge_mac, tvb, offset, 6, ENC_BIG_ENDIAN)_",0
    offset += 6_,1
    /* type == 2 ? */,0
"    offset =dissect_nge_lv(tvb,ensemble_tree, offset, ""Ensemble Name"", hf_nge_ensemble_name )_",0
"    offset =dissect_nge_lv(tvb,ensemble_tree, offset, ""Firmware Name"", hf_nge_firmware_name )_",0
"    offset =dissect_nge_lv(tvb,ensemble_tree, offset, ""Region Name"", hf_nge_region_name )_",0
    /* type == 0 ? */,0
"    offset =dissect_nge_lv(tvb,ensemble_tree, offset, ""Firmware Version"", hf_nge_firmware_version )_",0
"    proto_tree_add_item(ensemble_tree, hf_nge_unknown, tvb, offset, 16, ENC_BIG_ENDIAN)_",0
    /* timestamp? */,0
"    proto_tree_add_item(ensemble_tree, hf_nge_uptime, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"    offset =dissect_nge_lv(tvb,ensemble_tree, offset, ""AP Name"", hf_nge_ap_name )_",0
"    proto_tree_add_item(ensemble_tree, hf_nge_unknown, tvb, offset, -1, ENC_BIG_ENDIAN)_",0
"dissect_nge(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void *data _U_)",0
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""NGE"")_",0
    /* Clear out stuff in the info column */,0
"    col_clear(pinfo->cinfo,COL_INFO)_",0
"    proto_item *ti = proto_tree_add_item(tree, proto_nge, tvb, 0, -1, ENC_NA)_",0
"    proto_tree *nge_tree = proto_item_add_subtree(ti, ett_nge)_",0
    int offset =0_,0
    /* presumed version */,0
"    proto_tree_add_item(nge_tree, hf_nge_version, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
    offset += 1_,0
"    proto_tree_add_item(nge_tree, hf_nge_unknown, tvb, offset, 3, ENC_BIG_ENDIAN)_",0
    offset += 3_,0
"    proto_tree_add_item(nge_tree, hf_nge_sequence, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"    dissect_nge_esemble(tvb, nge_tree, offset)_",0
proto_reg_handoff_nge(void),0
    static dissector_handle_t nge_handle_,0
"    dissector_add_uint(""udp.port"", NETGEAR_ENSEMBLE_PORT, nge_handle)_",0
proto_register_nge(void),0
    static hf_register_info hf[] = {,1
"        { &hf_nge_version,",0
"            { ""Version"", ""nge.version"",FT_UINT8, BASE_DEC,",0
"                NULL, 0x0,NULL, HFILL }},",0
"        { &hf_nge_unknown,",0
"            { ""Unknown"", ""nge.unknown"", FT_BYTES, BASE_NONE,",0
"        { &hf_nge_unknown_int32,",0
"            { ""Unknown"", ""nge.unknown"", FT_UINT32, BASE_DEC,",0
"                NULL, 0x0, NULL, HFILL }},",0
"        { &hf_nge_sequence,",0
"            { ""Sequence"", ""nge.sequence"", FT_UINT32, BASE_DEC,",0
"        { &hf_nge_uptime,",0
"            { ""Uptime"", ""nge.uptime"", FT_UINT32, BASE_DEC,",0
"        { &hf_nge_mac,",0
"            { ""MAC"", ""nge.mac"", FT_ETHER, BASE_NONE,",0
"        { &hf_nge_ip,",0
"            { ""IP"", ""nge.ip"", FT_IPv4, BASE_NONE,",0
"        { &hf_nge_uuid,",0
"            { ""Device UUID"", ""nge.uuid"", FT_GUID, BASE_NONE,",0
"        { &hf_nge_ensemble_name,",0
"            { ""Ensemble Name"", ""nge.ensemble_name"", FT_STRING, BASE_NONE,",0
"        { &hf_nge_firmware_name,",0
"            { ""Firmware Name"", ""nge.firmware_name"", FT_STRING, BASE_NONE,",0
"        { &hf_nge_region_name,",0
"            { ""Region Name"", ""nge.region_name"", FT_STRING, BASE_NONE,",0
"        { &hf_nge_firmware_version,",0
"            { ""Firmware Version"", ""nge.firmware_version"", FT_STRING, BASE_NONE,",0
"        { &hf_nge_ap_name,",0
"            { ""AP Name"", ""nge.ap_name"", FT_STRING, BASE_NONE,",0
"        { &hf_nge_tlv_length,",0
"            { ""Length"",	""nge.tlv_len"", FT_UINT32, BASE_DEC,",0
    /* Setup protocol subtree array */,0
"        &ett_nge,",0
"        &ett_nge_lv,",0
        &ett_nge_ensemble,0
    proto_nge = proto_register_protocol (,0
"                                         ""Netgear Ensemble Protocol"", /* name       */",0
"                                         ""NGE"",      /* short name */",0
"                                         ""nge""       /* abbrev     */",0
                                         )_,0
"    proto_register_field_array(proto_nge, hf, array_length(hf))_",0
"                    show_compression_reduction(tvb, subtree, compressed_size, tvb_captured_length(payload))_",0
"                    show_compression_reduction(tvb, subtree, compressed_size, uncompressed_size)_",0
"        { &hf_ua3g_cs_ip_device_routing_cmd02_parameter_eth_driver_config_port_lan_speed, { ""Port Lan Speed"", ""ua3g.ip.cs.cmd02.parameter.eth_driver_config.port_lan_speed"", FT_UINT8, BASE_DEC, VALS(str_ethernet_speed_vals), 0x0, NULL, HFILL }},",1
static int hf_pie_gigamon                                   = -1_,0
    case ((VENDOR_GIGAMON << 16) | 110):,0
 case ((VENDOR_GIGAMON << 16) | 111):,0
"       not to dissect the field, but to skip it instead, as it is not needed for display or filtering",1
"    ProtoField f = shiftProtoField(L, WSLUA_ARG_TreeItem_referenced_F_or_D)_",0
  cf->epan = session_,0
            while (frame && !pkt_info->request_found) {,0
    /* Used when the capture is already unciphered */,0
"        ""Ignore the LTE RRC security algorithm configuration, to be used when PDCP is already unciphered in the capture"",",0
          conv_ntlmssp_info->rc4_handle_client = NULL_,1
 ws_hexstrtou8@Base 2.3.0,1
            conv_ntlmssp_info->rc4_handle_client = NULL_,1
#define MD5_BUFFER_SIZE  16,1
"	gcry_md_write(sha1_handle, key, 20)_",1
"	gcry_md_write(sha1_handle, engineID, engineLength)_",1
"    if (!gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {",1
"    gcry_md_write(md5_handle, serversealkey,*keylen)_",1
"                !gcry_cipher_setkey(conv_ntlmssp_info->rc4_handle_server, clientkey, ssp_key_len)) {",1
"        rc4_handle= get_encrypted_state(pinfo, 1)_",1
#define MD5_LEN 16,1
	return GPG_ERR_NO_ERROR_,0
DIAG_ON(deprecated-declarations),1
	wsutil/libwsutil.la		\,1
		is_valid = FALSE_,0
"    memcpy(fd_hash[cur_dup_entry].digest, gcry_md_read(md5_handle, 0), 16)_",1
    for(i = 0_ i < (x+159)/160_ i++),1
    iter[1] = 0_,0
    length[1] = (256 >> 8) & 0xff_,1
	/* freebsd */,1
    gcry_md_close(sha1_handle)_,1
    gcry_md_close(md5_handle)_,1
"		gcry_md_write(md5_handle, confounder, 8)_",1
"		digest = gcry_md_read(md5_handle, 0)_",1
"  if (gcry_mac_open(&hmac_handle, GCRY_MAC_HMAC_MD5, 0, NULL)) {",0
    return 0_,1
"  if (gcry_mac_setkey(hmac_handle, k5_data, 16)) {",0
    gcry_mac_close(hmac_handle)_,0
"  gcry_mac_write(hmac_handle, cksum_data, cksum_size)_",0
"  gcry_mac_read(hmac_handle, key6_data, &hmac_len)_",0
"  if (gcry_mac_setkey(hmac_handle, key_data, key_length)) {",0
"  gcry_mac_write(hmac_handle, signature, sizeof(signature))_",0
"  gcry_mac_read(hmac_handle, ksign_c, &hmac_len)_",0
"  if (memcmp (digest_comparison, hash_digest, SHA1_DIGEST_LEN) != 0)",1
"        memset(zeros,0,4)_",1
"               gcry_mac_write(hmac_handle, tunnel->lcce1_nonce, tunnel->lcce1_nonce_len)_",1
  /* remove this callback? */,0
  gcry_md_close(md5_handle)_,1
"  if (gcry_md_open(&md5_handle, GCRY_MD_MD5, 0)) {",1
"    if (gcry_md_open(&md5_handle, GCRY_MD_MD5, 0)) {",1
      return_,1
static gcry_cipher_hd_t ,1
"	digest = gcry_md_read(md5_handle, 0)_",0
	gcry_md_close(md5_handle)_,1
                gcry_md_close(sha1_handle)_,1
"    digest_buf = gcry_md_read(sha1_handle, 0)_",1
                gcry_cipher_close(rc4_handle)_,1
        guint8 dummy[256]_,1
    guint8 zeros[16]_,1
"    switch(gcry_mac_verify(cmac_handle, &data[offset_fte + 4], 16)) {",1
"    aes_cmac_encrypt_starts(&aes_ctx, key_input, 16)_",1
"    aes_cmac_encrypt_update(&aes_ctx, initiator, AIRPDCAP_MAC_LEN)_",1
"    aes_cmac_encrypt_update(&aes_ctx, responder, AIRPDCAP_MAC_LEN)_",1
"    aes_cmac_encrypt_update(&aes_ctx, &seq_num, 1)_",1
"    aes_cmac_encrypt_update(&aes_ctx, &data[offset_link], data[offset_link + 1] + 2)_",1
"    aes_cmac_encrypt_update(&aes_ctx, &data[offset_rsne], data[offset_rsne + 1] + 2)_",1
"    aes_cmac_encrypt_update(&aes_ctx, &data[offset_timeout], data[offset_timeout + 1] + 2)_",1
"    aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte], 4)_",1
"    memset(mic, 0, 16)_",1
"    aes_cmac_encrypt_update(&aes_ctx, mic, 16)_",1
"    aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte + 20], data[offset_fte + 1] + 2 - 20)_",1
"    aes_cmac_encrypt_finish(&aes_ctx, mic)_",1
"    if (memcmp(mic, &data[offset_fte + 4],16)) {",1
"        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapTDLSDeriveKey"", ""MIC verification failed"", AIRPDCAP_DEBUG_LEVEL_3)_",1
        return AIRPDCAP_RET_UNSUCCESS_,1
    return -13_,1
    return -14_,1
      return -17_,1
static gcry_cipher_hd_t *,1
"        if (gcry_cipher_encrypt(*rc4_handle_peer, peer_block, encrypted_block_length, peer_block, encrypted_block_length)) {",1
/* packet-ntlmssp.c,0
 * Add-on for better NTLM v1/v2 handling,0
" * Copyright 2009, 2012 Matthieu Patou <mat@matws.net>",0
 * Routines for NTLM Secure Service Provider,0
 * Devin Heitmueller <dheitmueller@netilla.com>,0
" * Copyright 2003, Tim Potter <tpot@samba.org>",0
/* Just set me to activate debug #define DEBUG_NTLMSSP */,0
#ifdef DEBUG_NTLMSSP,0
#include <epan/asn1.h>,0
#include <epan/tap.h>,0
#include <epan/show_exception.h>,0
#include <wsutil/wsgcrypt.h>,0
#include <wsutil/md5.h>,0
#include <wsutil/des.h>,0
#include <wsutil/crc32.h>,0
#include <wsutil/str_util.h>,0
"#include ""packet-windows-common.h""",0
"#include ""packet-smb-common.h""",0
"#include ""packet-kerberos.h""",0
"#include ""packet-dcerpc.h""",0
"#include ""packet-gssapi.h""",0
"#include ""read_keytab_file.h""",0
"#include ""packet-ntlmssp.h""",0
void proto_register_ntlmssp(void)_,0
void proto_reg_handoff_ntlmssp(void)_,0
static int ntlmssp_tap = -1_,0
"#define CLIENT_SIGN_TEXT ""session key to client-to-server signing key magic constant""",0
"#define CLIENT_SEAL_TEXT ""session key to client-to-server sealing key magic constant""",0
"#define SERVER_SIGN_TEXT ""session key to server-to-client signing key magic constant""",0
"#define SERVER_SEAL_TEXT ""session key to server-to-client sealing key magic constant""",0
static const value_string ntlmssp_message_types[] = {,0
"  { NTLMSSP_NEGOTIATE, ""NTLMSSP_NEGOTIATE"" },",0
"  { NTLMSSP_CHALLENGE, ""NTLMSSP_CHALLENGE"" },",0
"  { NTLMSSP_AUTH,      ""NTLMSSP_AUTH"" },",0
"  { NTLMSSP_UNKNOWN,   ""NTLMSSP_UNKNOWN"" },",0
"  { 0, NULL }",0
typedef struct _md4_pass {,0
  guint8 md4[NTLMSSP_KEY_LEN]_,0
} md4_pass_,0
"static const unsigned char gbl_zeros[24] = ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""_",0
static GHashTable* hash_packet = NULL_,0
 * NTLMSSP negotiation flags,0
 * Taken from Samba,0
 * See also,0
 *      http://davenport.sourceforge.net/ntlm.html,0
 * although that document says that:,0
" *      0x00010000 is ""Target Type Domain""_",0
" *      0x00020000 is ""Target Type Server""",0
" *      0x00040000 is ""Target Type Share""_",0
" * and that 0x00100000, 0x00200000, and 0x00400000 are",0
" * ""Request Init Response"", ""Request Accept Response"", and",0
" * ""Request Non-NT Session Key"", rather than those values shifted",0
 * right one having those interpretations.,0
 * UPDATE: Further information obtained from [MS-NLMP] 2.2.2.5:,0
 * NT LAN Manager (NTLM) Authentication Protocol Specification,0
 * http://msdn2.microsoft.com/en-us/library/cc236621.aspx,0
#define NTLMSSP_NEGOTIATE_UNICODE                  0x00000001,0
#define NTLMSSP_NEGOTIATE_OEM                      0x00000002,0
#define NTLMSSP_REQUEST_TARGET                     0x00000004,0
#define NTLMSSP_NEGOTIATE_00000008                 0x00000008,0
#define NTLMSSP_NEGOTIATE_SIGN                     0x00000010,0
#define NTLMSSP_NEGOTIATE_SEAL                     0x00000020,0
#define NTLMSSP_NEGOTIATE_DATAGRAM                 0x00000040,0
#define NTLMSSP_NEGOTIATE_LM_KEY                   0x00000080,0
#define NTLMSSP_NEGOTIATE_00000100                 0x00000100,0
#define NTLMSSP_NEGOTIATE_NTLM                     0x00000200,0
#define NTLMSSP_NEGOTIATE_NT_ONLY                  0x00000400,0
#define NTLMSSP_NEGOTIATE_ANONYMOUS                0x00000800,0
#define NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED      0x00001000,0
#define NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED 0x00002000,0
#define NTLMSSP_NEGOTIATE_00004000                 0x00004000,0
#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN              0x00008000,0
#define NTLMSSP_TARGET_TYPE_DOMAIN                 0x00010000,0
#define NTLMSSP_TARGET_TYPE_SERVER                 0x00020000,0
#define NTLMSSP_TARGET_TYPE_SHARE                  0x00040000,0
#define NTLMSSP_NEGOTIATE_EXTENDED_SECURITY        0x00080000,0
#define NTLMSSP_NEGOTIATE_IDENTIFY                 0x00100000,0
#define NTLMSSP_NEGOTIATE_00200000                 0x00200000,0
#define NTLMSSP_REQUEST_NON_NT_SESSION             0x00400000,0
#define NTLMSSP_NEGOTIATE_TARGET_INFO              0x00800000,0
#define NTLMSSP_NEGOTIATE_01000000                 0x01000000,0
#define NTLMSSP_NEGOTIATE_VERSION                  0x02000000,0
#define NTLMSSP_NEGOTIATE_04000000                 0x04000000,0
#define NTLMSSP_NEGOTIATE_08000000                 0x08000000,0
#define NTLMSSP_NEGOTIATE_10000000                 0x10000000,0
#define NTLMSSP_NEGOTIATE_128                      0x20000000,0
#define NTLMSSP_NEGOTIATE_KEY_EXCH                 0x40000000,0
#define NTLMSSP_NEGOTIATE_56                       0x80000000,0
static int proto_ntlmssp = -1_,0
static int hf_ntlmssp_auth = -1_,0
static int hf_ntlmssp_message_type = -1_,0
static int hf_ntlmssp_negotiate_flags = -1_,0
static int hf_ntlmssp_negotiate_flags_01 = -1_,0
static int hf_ntlmssp_negotiate_flags_02 = -1_,0
static int hf_ntlmssp_negotiate_flags_04 = -1_,0
static int hf_ntlmssp_negotiate_flags_08 = -1_,0
static int hf_ntlmssp_negotiate_flags_10 = -1_,0
static int hf_ntlmssp_negotiate_flags_20 = -1_,0
static int hf_ntlmssp_negotiate_flags_40 = -1_,0
static int hf_ntlmssp_negotiate_flags_80 = -1_,0
static int hf_ntlmssp_negotiate_flags_100 = -1_,0
static int hf_ntlmssp_negotiate_flags_200 = -1_,0
static int hf_ntlmssp_negotiate_flags_400 = -1_,0
static int hf_ntlmssp_negotiate_flags_800 = -1_,0
static int hf_ntlmssp_negotiate_flags_1000 = -1_,0
static int hf_ntlmssp_negotiate_flags_2000 = -1_,0
static int hf_ntlmssp_negotiate_flags_4000 = -1_,0
static int hf_ntlmssp_negotiate_flags_8000 = -1_,0
static int hf_ntlmssp_negotiate_flags_10000 = -1_,0
static int hf_ntlmssp_negotiate_flags_20000 = -1_,0
static int hf_ntlmssp_negotiate_flags_40000 = -1_,0
static int hf_ntlmssp_negotiate_flags_80000 = -1_,0
static int hf_ntlmssp_negotiate_flags_100000 = -1_,0
static int hf_ntlmssp_negotiate_flags_200000 = -1_,0
static int hf_ntlmssp_negotiate_flags_400000 = -1_,0
static int hf_ntlmssp_negotiate_flags_800000 = -1_,0
static int hf_ntlmssp_negotiate_flags_1000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_2000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_4000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_8000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_10000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_20000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_40000000 = -1_,0
static int hf_ntlmssp_negotiate_flags_80000000 = -1_,0
/* static int hf_ntlmssp_negotiate_workstation_strlen = -1_ */,0
/* static int hf_ntlmssp_negotiate_workstation_maxlen = -1_ */,0
/* static int hf_ntlmssp_negotiate_workstation_buffer = -1_ */,0
static int hf_ntlmssp_negotiate_workstation = -1_,0
/* static int hf_ntlmssp_negotiate_domain_strlen = -1_ */,0
/* static int hf_ntlmssp_negotiate_domain_maxlen = -1_ */,0
/* static int hf_ntlmssp_negotiate_domain_buffer = -1_ */,0
static int hf_ntlmssp_negotiate_domain = -1_,0
static int hf_ntlmssp_ntlm_server_challenge = -1_,0
static int hf_ntlmssp_ntlm_client_challenge = -1_,0
static int hf_ntlmssp_reserved = -1_,0
static int hf_ntlmssp_challenge_target_name = -1_,0
static int hf_ntlmssp_auth_username = -1_,0
static int hf_ntlmssp_auth_domain = -1_,0
static int hf_ntlmssp_auth_hostname = -1_,0
static int hf_ntlmssp_auth_lmresponse = -1_,0
static int hf_ntlmssp_auth_ntresponse = -1_,0
static int hf_ntlmssp_auth_sesskey = -1_,0
static int hf_ntlmssp_string_len = -1_,0
static int hf_ntlmssp_string_maxlen = -1_,0
static int hf_ntlmssp_string_offset = -1_,0
static int hf_ntlmssp_blob_len = -1_,0
static int hf_ntlmssp_blob_maxlen = -1_,0
static int hf_ntlmssp_blob_offset = -1_,0
static int hf_ntlmssp_version = -1_,0
static int hf_ntlmssp_version_major = -1_,0
static int hf_ntlmssp_version_minor = -1_,0
static int hf_ntlmssp_version_build_number = -1_,0
static int hf_ntlmssp_version_ntlm_current_revision = -1_,0
static int hf_ntlmssp_challenge_target_info = -1_,0
static int hf_ntlmssp_challenge_target_info_len = -1_,0
static int hf_ntlmssp_challenge_target_info_maxlen = -1_,0
static int hf_ntlmssp_challenge_target_info_offset = -1_,0
static int hf_ntlmssp_challenge_target_info_item_type = -1_,0
static int hf_ntlmssp_challenge_target_info_item_len = -1_,0
static int hf_ntlmssp_challenge_target_info_end = -1_,0
static int hf_ntlmssp_challenge_target_info_nb_computer_name = -1_,0
static int hf_ntlmssp_challenge_target_info_nb_domain_name = -1_,0
static int hf_ntlmssp_challenge_target_info_dns_computer_name = -1_,0
static int hf_ntlmssp_challenge_target_info_dns_domain_name = -1_,0
static int hf_ntlmssp_challenge_target_info_dns_tree_name = -1_,0
static int hf_ntlmssp_challenge_target_info_flags = -1_,0
static int hf_ntlmssp_challenge_target_info_timestamp = -1_,0
static int hf_ntlmssp_challenge_target_info_restrictions = -1_,0
static int hf_ntlmssp_challenge_target_info_target_name =-1_,0
static int hf_ntlmssp_challenge_target_info_channel_bindings =-1_,0
static int hf_ntlmssp_ntlmv2_response_item_type = -1_,0
static int hf_ntlmssp_ntlmv2_response_item_len = -1_,0
static int hf_ntlmssp_ntlmv2_response_end = -1_,0
static int hf_ntlmssp_ntlmv2_response_nb_computer_name = -1_,0
static int hf_ntlmssp_ntlmv2_response_nb_domain_name = -1_,0
static int hf_ntlmssp_ntlmv2_response_dns_computer_name = -1_,0
static int hf_ntlmssp_ntlmv2_response_dns_domain_name = -1_,0
static int hf_ntlmssp_ntlmv2_response_dns_tree_name = -1_,0
static int hf_ntlmssp_ntlmv2_response_flags = -1_,0
static int hf_ntlmssp_ntlmv2_response_timestamp = -1_,0
static int hf_ntlmssp_ntlmv2_response_restrictions = -1_,0
static int hf_ntlmssp_ntlmv2_response_target_name =-1_,0
static int hf_ntlmssp_ntlmv2_response_channel_bindings =-1_,0
static int hf_ntlmssp_message_integrity_code = -1_,0
static int hf_ntlmssp_verf = -1_,0
static int hf_ntlmssp_verf_vers = -1_,0
static int hf_ntlmssp_verf_body = -1_,0
static int hf_ntlmssp_verf_randompad = -1_,0
static int hf_ntlmssp_verf_hmacmd5 = -1_,0
static int hf_ntlmssp_verf_crc32 = -1_,0
static int hf_ntlmssp_verf_sequence = -1_,0
/* static int hf_ntlmssp_decrypted_payload = -1_ */,0
static int hf_ntlmssp_ntlmv2_response = -1_,0
static int hf_ntlmssp_ntlmv2_response_ntproofstr = -1_,0
static int hf_ntlmssp_ntlmv2_response_rversion = -1_,0
static int hf_ntlmssp_ntlmv2_response_hirversion = -1_,0
static int hf_ntlmssp_ntlmv2_response_z = -1_,0
static int hf_ntlmssp_ntlmv2_response_pad = -1_,0
static int hf_ntlmssp_ntlmv2_response_time = -1_,0
static int hf_ntlmssp_ntlmv2_response_chal = -1_,0
static gint ett_ntlmssp = -1_,0
static gint ett_ntlmssp_negotiate_flags = -1_,0
static gint ett_ntlmssp_string = -1_,0
static gint ett_ntlmssp_blob = -1_,0
static gint ett_ntlmssp_version = -1_,0
static gint ett_ntlmssp_challenge_target_info = -1_,0
static gint ett_ntlmssp_challenge_target_info_item = -1_,0
static gint ett_ntlmssp_ntlmv2_response = -1_,0
static gint ett_ntlmssp_ntlmv2_response_item = -1_,0
static expert_field ei_ntlmssp_v2_key_too_long = EI_INIT_,0
static expert_field ei_ntlmssp_blob_len_too_long = EI_INIT_,0
static expert_field ei_ntlmssp_target_info_attr = EI_INIT_,0
static expert_field ei_ntlmssp_message_type = EI_INIT_,0
"static dissector_handle_t ntlmssp_handle, ntlmssp_wrap_handle_",0
/* Configuration variables */,0
const char *gbl_nt_password = NULL_,0
#define MAX_BLOB_SIZE 10240,0
typedef struct _ntlmssp_blob {,0
  guint16 length_,0
  guint8* contents_,0
} ntlmssp_blob_,0
#define NTLMSSP_CONV_INFO_KEY 0,0
/* Used in the conversation function */,0
typedef struct _ntlmssp_info {,0
  guint32          flags_,0
  int              is_auth_ntlm_v2_,0
  gcry_cipher_hd_t rc4_handle_client_,0
  gcry_cipher_hd_t rc4_handle_server_,0
  guint8           sign_key_client[NTLMSSP_KEY_LEN]_,0
  guint8           sign_key_server[NTLMSSP_KEY_LEN]_,0
  guint32          server_dest_port_,0
  unsigned char    server_challenge[8]_,0
  unsigned char    client_challenge[8]_,0
  int              rc4_state_initialized_,0
  ntlmssp_blob     ntlm_response_,0
  ntlmssp_blob     lm_response_,0
} ntlmssp_info_,0
#define NTLMSSP_PACKET_INFO_KEY 1,0
"/* If this struct exists in the payload_decrypt, then we have already",0
   decrypted it once */,0
typedef struct _ntlmssp_packet_info {,0
  guint8   *decrypted_payload_,0
  guint8    payload_len_,0
  guint8    verifier[NTLMSSP_KEY_LEN]_,0
  gboolean  payload_decrypted_,0
  gboolean  verifier_decrypted_,0
} ntlmssp_packet_info_,0
"static void printnbyte(const guint8* tab, int nb, const char* txt, const char* txt2)",0
  int i_,0
"  fprintf(stderr, ""%s "", txt)_",0
  for (i=0_ i<nb_ i++),0
"    fprintf(stderr, ""%02X "", *(tab+i))_",0
"  fprintf(stderr, ""%s"", txt2)_",0
"static void printnchar(const guint8* tab, int nb, char* txt, char* txt2)",0
"    fprintf(stderr, ""%c"", *(tab+i))_",0
"static void printnbyte(const guint8* tab _U_, int nb _U_, const char* txt _U_, const char* txt2 _U_)",0
 * GSlist of decrypted payloads.,0
static GSList *decrypted_payloads_,0
LEBE_Convert(int value),0
"  char a, b, c, d_",0
  /* Get each byte */,0
  a = value&0x000000FF_,0
  b = (value&0x0000FF00) >> 8_,0
  c = (value&0x00FF0000) >> 16_,0
  d = (value&0xFF000000) >> 24_,0
  return (a << 24) | (b << 16) | (c << 8) | d_,0
  Perform a DES encryption with a 16-byte key and 8-byte data item.,0
  It's in fact 3 susbsequent call to crypt_des_ecb with a 7-byte key.,0
  Missing bytes for the key are replaced by 0_,0
"  Returns output in response, which is expected to be 24 bytes.",0
"crypt_des_ecb_long(guint8 *response,",0
"                   const guint8 *key,",0
                   const guint8 *data),0
  guint8 pw21[21]_ /* 21 bytes place for the needed key */,0
"  memset(pw21, 0, sizeof(pw21))_",0
"  memcpy(pw21, key, 16)_",0
"  memset(response, 0, 24)_",0
"  /* crypt_des_ecb(data, key)*/",0
"  crypt_des_ecb(response, data, pw21, 1)_",0
"  crypt_des_ecb(response + 8, data, pw21 + 7, 1)_",0
"  crypt_des_ecb(response + 16, data, pw21 + 14, 1)_",0
  return 1_,0
"  Generate a challenge response, given an eight byte challenge and",0
  either the NT or the Lan Manager password hash (16 bytes).,0
"ntlmssp_generate_challenge_response(guint8 *response,",0
"                                    const guint8 *passhash,",0
                                    const guint8 *challenge),0
  guint8 pw21[21]_ /* Password hash padded to 21 bytes */,0
"  memset(pw21, 0x0, sizeof(pw21))_",0
"  memcpy(pw21, passhash, 16)_",0
"  crypt_des_ecb(response, challenge, pw21, 1)_",0
"  crypt_des_ecb(response + 8, challenge, pw21 + 7, 1)_",0
"  crypt_des_ecb(response + 16, challenge, pw21 + 14, 1)_",0
"/* Ultra simple ainsi to unicode converter, will only work for ascii password ...*/",0
"str_to_unicode(const char *nt_password, char *nt_password_unicode)",0
  size_t password_len_,0
  size_t i_,0
  password_len = strlen(nt_password)_,0
  if (nt_password_unicode != NULL) {,0
    for (i=0_ i<(password_len)_ i++) {,0
      nt_password_unicode[i*2]=nt_password[i]_,0
      nt_password_unicode[i*2+1]=0_,0
    nt_password_unicode[2*password_len]='\0'_,0
/* This function generate the Key Exchange Key,0
 * Depending on the flags this key will either be used to crypt the exported session key,0
 * or will be used directly as exported session key.,0
 * Exported session key is the key that will be used for sealing and signing communication*/,0
"get_keyexchange_key(unsigned char keyexchangekey[NTLMSSP_KEY_LEN], const unsigned char sessionbasekey[NTLMSSP_KEY_LEN], const unsigned char lm_challenge_response[24], int flags)",0
  guint8 basekey[NTLMSSP_KEY_LEN]_,0
  guint8 zeros[24]_,0
"  memset(keyexchangekey, 0, NTLMSSP_KEY_LEN)_",0
"  memset(basekey, 0, NTLMSSP_KEY_LEN)_",0
  /* sessionbasekey is either derived from lm_password_hash or from nt_password_hash depending on the key type negotiated */,0
"  memcpy(basekey, sessionbasekey, 8)_",0
"  memset(basekey, 0xBD, 8)_",0
  if (flags&NTLMSSP_NEGOTIATE_LM_KEY) {,0
"    /*data, key*/",0
"    crypt_des_ecb(keyexchangekey, lm_challenge_response, basekey, 1)_",0
"    crypt_des_ecb(keyexchangekey+8, lm_challenge_response, basekey+7, 1)_",0
  else {,0
    if (flags&NTLMSSP_REQUEST_NON_NT_SESSION) {,0
      /*People from samba tends to use the same function in this case than in the previous one but with 0 data,0
       * it's not clear that it produce the good result,0
"       * memcpy(keyexchangekey, lm_hash, 8)_",0
       * Let's trust samba implementation it mights seem weird but they are more often rights than the spec !,0
       */,0
"      memset(zeros, 0, 24)_",0
"      crypt_des_ecb(keyexchangekey, zeros, basekey, 3)_",0
"      crypt_des_ecb(keyexchangekey+8, zeros, basekey+7, 1)_",0
      /* it is stated page 65 of NTLM SSP spec that sessionbasekey should be encrypted with hmac_md5 using the concact of both challenge,0
       * when it's NTLM v1 + extended security but it turns out to be wrong !,0
"      memcpy(keyexchangekey, sessionbasekey, NTLMSSP_KEY_LEN)_",0
#if defined(HAVE_HEIMDAL_KERBEROS) || defined(HAVE_MIT_KERBEROS),0
"get_md4pass_list(md4_pass** p_pass_list, const char* nt_password)",0
  guint32        nb_pass = 0_,0
  enc_key_t     *ek_,0
  unsigned char  nt_password_hash[NTLMSSP_KEY_LEN]_,0
  char           nt_password_unicode[256]_,0
  md4_pass*      pass_list_,0
  int            i_,0
  *p_pass_list = NULL_,0
  if (!krb_decrypt) {,0
  read_keytab_file_from_preferences()_,0
  for (ek=enc_key_list_ ek_ ek=ek->next) {,0
    if (ek->keylength == NTLMSSP_KEY_LEN) {,0
      nb_pass++_,0
"  memset(nt_password_unicode, 0, sizeof(nt_password_unicode))_",0
"  memset(nt_password_hash, 0, NTLMSSP_KEY_LEN)_",0
  if ((nt_password[0] != '\0') && (strlen(nt_password) < 129)) {,0
    int password_len_,0
    nb_pass++_,0
    password_len = (int)strlen(nt_password)_,0
"    str_to_unicode(nt_password, nt_password_unicode)_",0
"    gcry_md_hash_buffer(GCRY_MD_MD4, nt_password_hash, nt_password_unicode, password_len*2)_",0
  if (nb_pass == 0) {,0
    /* Unable to calculate the session key without a password or if password is more than 128 char ......*/,0
  i = 0_,0
"  *p_pass_list = (md4_pass *)wmem_alloc(wmem_packet_scope(), nb_pass*sizeof(md4_pass))_",0
  pass_list = *p_pass_list_,0
"  if (memcmp(nt_password_hash, gbl_zeros, NTLMSSP_KEY_LEN) != 0) {",0
"    memcpy(pass_list[i].md4, nt_password_hash, NTLMSSP_KEY_LEN)_",0
    i = 1_,0
"      memcpy(pass_list[i].md4, ek->keyvalue, NTLMSSP_KEY_LEN)_",0
      i++_,0
  return nb_pass_,0
/* Create an NTLMSSP version 2 key,0
"create_ntlmssp_v2_key(const char *nt_password _U_, const guint8 *serverchallenge , const guint8 *clientchallenge ,",0
"                      guint8 *sessionkey , const  guint8 *encryptedsessionkey , int flags ,",0
"                      const ntlmssp_blob *ntlm_response, const ntlmssp_blob *lm_response _U_, ntlmssp_header_t *ntlmssph)",0
"/* static const would be nicer, but -Werror=vla does not like it */",0
#define DOMAIN_NAME_BUF_SIZE 512,0
#define USER_BUF_SIZE 256,0
#define BUF_SIZE (DOMAIN_NAME_BUF_SIZE + USER_BUF_SIZE),0
  char              domain_name_unicode[DOMAIN_NAME_BUF_SIZE]_,0
  char              user_uppercase[USER_BUF_SIZE]_,0
  char              buf[BUF_SIZE]_,0
  /*guint8 md4[NTLMSSP_KEY_LEN]_*/,0
  unsigned char     nt_password_hash[NTLMSSP_KEY_LEN]_,0
  unsigned char     nt_proof[NTLMSSP_KEY_LEN]_,0
  unsigned char     ntowf[NTLMSSP_KEY_LEN]_,0
  guint8            sessionbasekey[NTLMSSP_KEY_LEN]_,0
  guint8            keyexchangekey[NTLMSSP_KEY_LEN]_,0
  guint8            lm_challenge_response[24]_,0
  guint32           i_,0
  guint32           j_,0
  gcry_cipher_hd_t  rc4_handle_,0
  size_t            user_len_,0
  size_t            domain_len_,0
  md4_pass         *pass_list = NULL_,0
  guint32           nb_pass = 0_,0
  gboolean          found = FALSE_,0
"  /* We are going to try password encrypted in keytab as well, it's an idea of Stefan Metzmacher <metze@samba.org>",0
   * The idea is to be able to test all the key of domain in once and to be able to decode the NTLM dialogs */,0
"  memset(sessionkey, 0, NTLMSSP_KEY_LEN)_",0
"  nb_pass = get_md4pass_list(&pass_list, nt_password)_",0
"  memset(user_uppercase, 0, USER_BUF_SIZE)_",0
  user_len = strlen(ntlmssph->acct_name)_,0
  if (user_len < USER_BUF_SIZE / 2) {,0
"    memset(buf, 0, BUF_SIZE)_",0
"    str_to_unicode(ntlmssph->acct_name, buf)_",0
    for (j = 0_ j < (2*user_len)_ j++) {,0
      if (buf[j] != '\0') {,0
        user_uppercase[j] = g_ascii_toupper(buf[j])_,0
"    /* Unable to calculate the session not enough space in buffer, note this is unlikely to happen but ......*/",0
  domain_len = strlen(ntlmssph->domain_name)_,0
  if (domain_len < DOMAIN_NAME_BUF_SIZE / 2) {,0
"    str_to_unicode(ntlmssph->domain_name, domain_name_unicode)_",0
  while (i < nb_pass) {,0
    #ifdef DEBUG_NTLMSSP,0
"    fprintf(stderr, ""Turn %d, "", i)_",0
    #endif,0
"    memcpy(nt_password_hash, pass_list[i].md4, NTLMSSP_KEY_LEN)_",0
"    printnbyte(nt_password_hash, NTLMSSP_KEY_LEN, ""Current NT password hash: "", ""\n"")_",0
    i++_,0
    /* ntowf computation */,0
"    memcpy(buf, user_uppercase, user_len*2)_",0
"    memcpy(buf+user_len*2, domain_name_unicode, domain_len*2)_",0
"    md5_hmac(buf, domain_len*2+user_len*2, nt_password_hash, NTLMSSP_KEY_LEN, ntowf)_",0
"    printnbyte(ntowf, NTLMSSP_KEY_LEN, ""NTOWF: "", ""\n"")_",0
    /* LM response */,0
"    memcpy(buf, serverchallenge, 8)_",0
"    memcpy(buf+8, clientchallenge, 8)_",0
"    md5_hmac(buf, NTLMSSP_KEY_LEN, ntowf, NTLMSSP_KEY_LEN, lm_challenge_response)_",0
"    memcpy(lm_challenge_response+NTLMSSP_KEY_LEN, clientchallenge, 8)_",0
"    printnbyte(lm_challenge_response, 24, ""LM Response: "", ""\n"")_",0
    /* NT proof = First NTLMSSP_KEY_LEN bytes of NT response */,0
"    memcpy(buf+8, ntlm_response->contents+NTLMSSP_KEY_LEN, MIN(BUF_SIZE - 8, ntlm_response->length-NTLMSSP_KEY_LEN))_",0
"    md5_hmac(buf, ntlm_response->length-8, ntowf, NTLMSSP_KEY_LEN, nt_proof)_",0
"    printnbyte(nt_proof, NTLMSSP_KEY_LEN, ""NT proof: "", ""\n"")_",0
"    if (!memcmp(nt_proof, ntlm_response->contents, NTLMSSP_KEY_LEN)) {",0
      found = TRUE_,0
      break_,0
  if (!found) {,0
"  md5_hmac(nt_proof, NTLMSSP_KEY_LEN, ntowf, NTLMSSP_KEY_LEN, sessionbasekey)_",0
"  get_keyexchange_key(keyexchangekey, sessionbasekey, lm_challenge_response, flags)_",0
  /* now decrypt session key if needed and setup sessionkey for decrypting further communications */,0
  if (flags & NTLMSSP_NEGOTIATE_KEY_EXCH),0
"    memcpy(sessionkey, encryptedsessionkey, NTLMSSP_KEY_LEN)_",0
"    if (gcry_cipher_open (&rc4_handle, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {",0
"    if (gcry_cipher_setkey(rc4_handle, keyexchangekey, NTLMSSP_KEY_LEN)) {",0
"    if (gcry_cipher_encrypt(rc4_handle, sessionkey, NTLMSSP_KEY_LEN, NULL, 0)) {",0
    gcry_cipher_close(rc4_handle)_,0
"    memcpy(sessionkey, keyexchangekey, NTLMSSP_KEY_LEN)_",0
"  memcpy(ntlmssph->session_key, sessionkey, NTLMSSP_KEY_LEN)_",0
 /* Create an NTLMSSP version 1 key,0
 * That is more complicated logic and methods and user challenge as well.,0
" * password points to the ANSI password to encrypt, challenge points to",0
 * the 8 octet challenge string,0
"create_ntlmssp_v1_key(const char *nt_password, const guint8 *serverchallenge, const guint8 *clientchallenge,",0
"                      guint8 *sessionkey, const  guint8 *encryptedsessionkey, int flags,",0
"                      const guint8 *ref_nt_challenge_response, const guint8 *ref_lm_challenge_response,",0
                      ntlmssp_header_t *ntlmssph),0
  unsigned char     lm_password_upper[NTLMSSP_KEY_LEN]_,0
  unsigned char     lm_password_hash[NTLMSSP_KEY_LEN]_,0
  unsigned char     challenges_hash[NTLMSSP_KEY_LEN]_,0
  unsigned char     challenges_hash_first8[8]_,0
  unsigned char     challenges[NTLMSSP_KEY_LEN]_,0
  guint8            md4[NTLMSSP_KEY_LEN]_,0
  guint8            nb_pass   = 0_,0
  guint8            nt_challenge_response[24]_,0
  md5_state_t       md5state_,0
  char              nt_password_unicode[256]_,0
  size_t            password_len_,0
  unsigned int      i_,0
  gboolean          found     = FALSE_,0
  static const unsigned char lmhash_key[] =,0
"    {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25}_",0
"  memset(lm_password_upper, 0, sizeof(lm_password_upper))_",0
  /* lm auth/lm session == (!NTLM_NEGOTIATE_NT_ONLY && NTLMSSP_NEGOTIATE_LM_KEY) || ! (EXTENDED_SECURITY) || ! NTLMSSP_NEGOTIATE_NTLM*/,0
  /* Create a Lan Manager hash of the input password */,0
  if (nt_password[0] != '\0') {,0
    password_len = strlen(nt_password)_,0
    /*Do not forget to free nt_password_nt*/,0
    /* Truncate password if too long */,0
    if (password_len > NTLMSSP_KEY_LEN),0
      password_len = NTLMSSP_KEY_LEN_,0
    for (i = 0_ i < password_len_ i++) {,0
      lm_password_upper[i] = g_ascii_toupper(nt_password[i])_,0
    /* Unable to calculate the session key without a password ... and we will not use one for a keytab*/,0
    if (!(flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY)) {,0
  if ((flags & NTLMSSP_NEGOTIATE_LM_KEY && !(flags & NTLMSSP_NEGOTIATE_NT_ONLY)) || !(flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY)  || !(flags & NTLMSSP_NEGOTIATE_NTLM)) {,0
"    crypt_des_ecb(lm_password_hash, lmhash_key, lm_password_upper, 1)_",0
"    crypt_des_ecb(lm_password_hash+8, lmhash_key, lm_password_upper+7, 1)_",0
"    ntlmssp_generate_challenge_response(lm_challenge_response,",0
"                                        lm_password_hash, serverchallenge)_",0
"    memcpy(sessionbasekey, lm_password_hash, NTLMSSP_KEY_LEN)_",0
"    memset(lm_challenge_response, 0, 24)_",0
    if (flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY) {,0
"      nb_pass = get_md4pass_list(&pass_list, nt_password)_",0
      i = 0_,0
      while (i < nb_pass) {,0
"        /*fprintf(stderr, ""Turn %d, "", i)_*/",0
"        memcpy(nt_password_hash, pass_list[i].md4, NTLMSSP_KEY_LEN)_",0
"        /*printnbyte(nt_password_hash, NTLMSSP_KEY_LEN, ""Current NT password hash: "", ""\n"")_*/",0
        i++_,0
        if(clientchallenge){,0
"          memcpy(lm_challenge_response, clientchallenge, 8)_",0
        md5_init(&md5state)_,0
"        md5_append(&md5state, serverchallenge, 8)_",0
"        md5_append(&md5state, clientchallenge, 8)_",0
"        md5_finish(&md5state, challenges_hash)_",0
"        memcpy(challenges_hash_first8, challenges_hash, 8)_",0
"        crypt_des_ecb_long(nt_challenge_response, nt_password_hash, challenges_hash_first8)_",0
"        if (ref_nt_challenge_response && !memcmp(ref_nt_challenge_response, nt_challenge_response, 24)) {",0
          found = TRUE_,0
"      crypt_des_ecb_long(nt_challenge_response, nt_password_hash, serverchallenge)_",0
      if (flags & NTLMSSP_NEGOTIATE_NT_ONLY) {,0
"        memcpy(lm_challenge_response, nt_challenge_response, 24)_",0
      else {,0
"        crypt_des_ecb_long(lm_challenge_response, lm_password_hash, serverchallenge)_",0
      if (ref_nt_challenge_response &&,0
"          !memcmp(ref_nt_challenge_response, nt_challenge_response, 24) &&",0
          ref_lm_challenge_response &&,0
"          !memcmp(ref_lm_challenge_response, lm_challenge_response, 24))",0
    /* So it's clearly not like this that's put into NTLMSSP doc but after some digging into samba code I'm quite confident,0
     * that sessionbasekey should be based md4(nt_password_hash) only in the case of some NT auth,0
     * Otherwise it should be lm_password_hash ...*/,0
"    gcry_md_hash_buffer(GCRY_MD_MD4, md4, nt_password_hash, NTLMSSP_KEY_LEN)_",0
"      memcpy(challenges, serverchallenge, 8)_",0
      if(clientchallenge){,0
"        memcpy(challenges+8, clientchallenge, 8)_",0
"      /*md5_hmac(text, text_len, key, key_len, digest)_*/",0
"      md5_hmac(challenges, NTLMSSP_KEY_LEN, md4, NTLMSSP_KEY_LEN, sessionbasekey)_",0
"     memcpy(sessionbasekey, md4, NTLMSSP_KEY_LEN)_",0
"  /*printnbyte(nt_challenge_response, 24, ""NT challenge response"", ""\n"")_",0
"  printnbyte(lm_challenge_response, 24, ""LM challenge response"", ""\n"")_*/",0
    if(encryptedsessionkey){,0
"      memcpy(sessionkey, encryptedsessionkey, NTLMSSP_KEY_LEN)_",0
"get_siging_key(guint8 *sign_key_server, guint8* sign_key_client, const guint8 key[NTLMSSP_KEY_LEN], int keylen)",0
  md5_state_t md5state_,0
  md5_state_t md5state2_,0
"  memset(sign_key_client, 0, NTLMSSP_KEY_LEN)_",0
"  memset(sign_key_server, 0, NTLMSSP_KEY_LEN)_",0
  md5_init(&md5state)_,0
"  md5_append(&md5state, key, keylen)_",0
"  md5_append(&md5state, CLIENT_SIGN_TEXT, strlen(CLIENT_SIGN_TEXT)+1)_",0
"  md5_finish(&md5state, sign_key_client)_",0
  md5_init(&md5state2)_,0
"  md5_append(&md5state2, key, keylen)_",0
"  md5_append(&md5state2, SERVER_SIGN_TEXT, strlen(SERVER_SIGN_TEXT)+1)_",0
"  md5_finish(&md5state2, sign_key_server)_",0
/* We return either a 128 or 64 bit key,0
"get_sealing_rc4key(const guint8 exportedsessionkey[NTLMSSP_KEY_LEN] , const int flags , int *keylen ,",0
"                   guint8 *clientsealkey , guint8 *serversealkey)",0
"  memset(clientsealkey, 0, NTLMSSP_KEY_LEN)_",0
"  memset(serversealkey, 0, NTLMSSP_KEY_LEN)_",0
"  memcpy(clientsealkey, exportedsessionkey, NTLMSSP_KEY_LEN)_",0
  if (flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY),0
    if (flags & NTLMSSP_NEGOTIATE_128),0
      /* The exportedsessionkey has already the good length just update the length*/,0
      *keylen = 16_,0
      if (flags & NTLMSSP_NEGOTIATE_56),0
"        memset(clientsealkey+7, 0, 9)_",0
        *keylen = 7_,0
      else,0
"        memset(clientsealkey+5, 0, 11)_",0
        *keylen = 5_,0
"    memcpy(serversealkey, clientsealkey, NTLMSSP_KEY_LEN)_",0
    md5_init(&md5state)_,0
"    md5_append(&md5state, clientsealkey,*keylen)_",0
"    md5_append(&md5state, CLIENT_SEAL_TEXT, strlen(CLIENT_SEAL_TEXT)+1)_",0
"    md5_finish(&md5state, clientsealkey)_",0
    md5_init(&md5state2)_,0
"    md5_append(&md5state2, serversealkey,*keylen)_",0
"    md5_append(&md5state2, SERVER_SEAL_TEXT, strlen(SERVER_SEAL_TEXT)+1)_",0
"    md5_finish(&md5state2, serversealkey)_",0
      *keylen = 8_,0
        clientsealkey[5]=0xe5_,0
        clientsealkey[6]=0x38_,0
        clientsealkey[7]=0xb0_,0
"    memcpy(serversealkey, clientsealkey,*keylen)_",0
/* Create an NTLMSSP version 1 key.,0
" * the 8 octet challenge string, key128 will do a 128 bit key if set to 1,",0
 * otherwise it will do a 40 bit key.  The result is stored in,0
 * sspkey (expected to be NTLMSSP_KEY_LEN octets),0
/* dissect a string - header area contains:,0
     two byte len,0
     two byte maxlen,0
     four byte offset of string in data area,0
"  The function returns the offset at the end of the string header,",0
  but the 'end' parameter returns the offset of the end of the string itself,0
  The 'start' parameter returns the offset of the beginning of the string,0
"  If there's no string, just use the offset of the end of the tvb as start/end.",0
"dissect_ntlmssp_string (tvbuff_t *tvb, int offset,",0
"                        proto_tree *ntlmssp_tree,",0
"                        gboolean unicode_strings,",0
"                        int string_hf, int *start, int *end,",0
                        const char **stringp),0
  proto_tree *tree          = NULL_,0
  proto_item *tf            = NULL_,0
"  gint16      string_length = tvb_get_letohs(tvb, offset)_",0
"  gint16      string_maxlen = tvb_get_letohs(tvb, offset+2)_",0
"  gint32      string_offset = tvb_get_letohl(tvb, offset+4)_",0
  const char *string_text   = NULL_,0
  int         result_length_,0
  guint16     bc_,0
  *start = (string_offset > offset+8 ? string_offset : (signed)tvb_reported_length(tvb))_,0
  if (0 == string_length) {,0
    *end = *start_,0
    if (ntlmssp_tree),0
"      proto_tree_add_string(ntlmssp_tree, string_hf, tvb,",0
"                            offset, 8, ""NULL"")_",0
    if (stringp != NULL),0
"      *stringp = """"_",0
    return offset+8_,0
  bc = result_length = string_length_,0
"  string_text = get_unicode_or_ascii_string(tvb, &string_offset,",0
"                                            unicode_strings, &result_length,",0
"                                            FALSE, TRUE, &bc)_",0
  if (stringp != NULL) {,0
"    if (!string_text) string_text = """"_ /* Make sure we don't blow up later */",0
    *stringp = string_text_,0
  if (ntlmssp_tree) {,0
"    tf = proto_tree_add_string(ntlmssp_tree, string_hf, tvb,",0
"                               string_offset, result_length, string_text)_",0
"    tree = proto_item_add_subtree(tf, ett_ntlmssp_string)_",0
"  proto_tree_add_uint(tree, hf_ntlmssp_string_len,",0
"                      tvb, offset, 2, string_length)_",0
  offset += 2_,0
"  proto_tree_add_uint(tree, hf_ntlmssp_string_maxlen,",0
"                      tvb, offset, 2, string_maxlen)_",0
"  proto_tree_add_uint(tree, hf_ntlmssp_string_offset,",0
"                      tvb, offset, 4, string_offset)_",0
  offset += 4_,0
  *end = string_offset + string_length_,0
/* dissect a generic blob - header area contains:,0
     four byte offset of blob in data area,0
"  The function returns the offset at the end of the blob header,",0
  but the 'end' parameter returns the offset of the end of the blob itself,0
"dissect_ntlmssp_blob (tvbuff_t *tvb, packet_info *pinfo,",0
"                      proto_tree *ntlmssp_tree, int offset,",0
"                      int blob_hf, int *end, ntlmssp_blob *result)",0
  proto_item *tf          = NULL_,0
  proto_tree *tree        = NULL_,0
"  guint16     blob_length = tvb_get_letohs(tvb, offset)_",0
"  guint16     blob_maxlen = tvb_get_letohs(tvb, offset+2)_",0
"  guint32     blob_offset = tvb_get_letohl(tvb, offset+4)_",0
  if (0 == blob_length) {,0
    *end                  = (blob_offset > ((guint)offset)+8 ? blob_offset : ((guint)offset)+8)_,0
"    proto_tree_add_bytes_format_value(ntlmssp_tree, blob_hf, tvb, offset, 8, NULL, ""Empty"")_",0
    result->length = 0_,0
    result->contents = NULL_,0
"    tf = proto_tree_add_item (ntlmssp_tree, blob_hf, tvb,",0
"                              blob_offset, blob_length, ENC_NA)_",0
"    tree = proto_item_add_subtree(tf, ett_ntlmssp_blob)_",0
"  proto_tree_add_uint(tree, hf_ntlmssp_blob_len,",0
"                      tvb, offset, 2, blob_length)_",0
"  proto_tree_add_uint(tree, hf_ntlmssp_blob_maxlen,",0
"                      tvb, offset, 2, blob_maxlen)_",0
"  proto_tree_add_uint(tree, hf_ntlmssp_blob_offset,",0
"                      tvb, offset, 4, blob_offset)_",0
  *end = blob_offset + blob_length_,0
  if (blob_length < MAX_BLOB_SIZE) {,0
    result->length = blob_length_,0
"    result->contents = (guint8 *)tvb_memdup(wmem_file_scope(), tvb, blob_offset, blob_length)_",0
"    expert_add_info_format(pinfo, tf, &ei_ntlmssp_v2_key_too_long,",0
"                           ""NTLM v2 key is %d bytes long, too big for our %d buffer"", blob_length, MAX_BLOB_SIZE)_",0
  /*,0
"   * XXX - for LmChallengeResponse (hf_ntlmssp_auth_lmresponse), should",0
"   * we have a field for both Response (2.2.2.3 ""LM_RESPONSE"" and",0
"   * 2.2.2.4 ""LMv2_RESPONSE"" in [MS-NLMP]) in addition to ClientChallenge",0
"   * (only in 2.2.2.4 ""LMv2_RESPONSE"")?",0
   *,0
   * XXX - should we also dissect the fields of an NtChallengeResponse,0
   * (hf_ntlmssp_auth_ntresponse)?,0
   * XXX - should we warn if the blob is too *small*?,0
   */,0
  if (blob_hf == hf_ntlmssp_auth_lmresponse) {,0
"     * LMChallengeResponse.  It's either 2.2.2.3 ""LM_RESPONSE"" or",0
"     * 2.2.2.4 ""LMv2_RESPONSE"", in [MS-NLMP].",0
     *,0
     * XXX - should we have a field for Response as well as,0
     * ClientChallenge?,0
"    if (tvb_memeql(tvb, blob_offset+8, ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"", NTLMSSP_KEY_LEN) == 0) {",0
      /*,0
       * LMv2_RESPONSE.,0
       *,0
"       * XXX - according to 2.2.2.4 ""LMv2_RESPONSE"", the ClientChallenge",0
       * is at an offset of 16 from the beginning of the blob_ it's not,0
       * at the beginning of the blob.,0
"      proto_tree_add_item (ntlmssp_tree,",0
"                           hf_ntlmssp_ntlm_client_challenge,",0
"                           tvb, blob_offset, 8, ENC_NA)_",0
  } else if (blob_hf == hf_ntlmssp_auth_ntresponse) {,0
"     * NTChallengeResponse.  It's either 2.2.2.6 ""NTLM v1 Response:",0
"     * NTLM_RESPONSE"" or 2.2.2.8 ""NTLM v2 Response: NTLMv2_RESPONSE""",0
     * in [MS-NLMP].,0
    if (blob_length > 24) {,0
"       * > 24 bytes, so it's ""NTLM v2 Response: NTLMv2_RESPONSE"".",0
       * An NTLMv2_RESPONSE has 16 bytes of Response followed,0
       * by an NTLMv2_CLIENT_CHALLENGE_ an NTLMv2_CLIENT_CHALLENGE,0
"       * is at least 32 bytes, so an NTLMv2_RESPONSE is at least",0
       * 48 bytes long.,0
"      dissect_ntlmv2_response(tvb, pinfo, tree, blob_offset, blob_length)_",0
static const int * ntlmssp_negotiate_flags[] = {,0
"    &hf_ntlmssp_negotiate_flags_80000000,",0
"    &hf_ntlmssp_negotiate_flags_40000000,",0
"    &hf_ntlmssp_negotiate_flags_20000000,",0
"    &hf_ntlmssp_negotiate_flags_10000000,",0
"    &hf_ntlmssp_negotiate_flags_8000000,",0
"    &hf_ntlmssp_negotiate_flags_4000000,",0
"    &hf_ntlmssp_negotiate_flags_2000000,",0
"    &hf_ntlmssp_negotiate_flags_1000000,",0
"    &hf_ntlmssp_negotiate_flags_800000,",0
"    &hf_ntlmssp_negotiate_flags_400000,",0
"    &hf_ntlmssp_negotiate_flags_200000,",0
"    &hf_ntlmssp_negotiate_flags_100000,",0
"    &hf_ntlmssp_negotiate_flags_80000,",0
"    &hf_ntlmssp_negotiate_flags_40000,",0
"    &hf_ntlmssp_negotiate_flags_20000,",0
"    &hf_ntlmssp_negotiate_flags_10000,",0
"    &hf_ntlmssp_negotiate_flags_8000,",0
"    &hf_ntlmssp_negotiate_flags_4000,",0
"    &hf_ntlmssp_negotiate_flags_2000,",0
"    &hf_ntlmssp_negotiate_flags_1000,",0
"    &hf_ntlmssp_negotiate_flags_800,",0
"    &hf_ntlmssp_negotiate_flags_400,",0
"    &hf_ntlmssp_negotiate_flags_200,",0
"    &hf_ntlmssp_negotiate_flags_100,",0
"    &hf_ntlmssp_negotiate_flags_80,",0
"    &hf_ntlmssp_negotiate_flags_40,",0
"    &hf_ntlmssp_negotiate_flags_20,",0
"    &hf_ntlmssp_negotiate_flags_10,",0
"    &hf_ntlmssp_negotiate_flags_08,",0
"    &hf_ntlmssp_negotiate_flags_04,",0
"    &hf_ntlmssp_negotiate_flags_02,",0
"    &hf_ntlmssp_negotiate_flags_01,",0
    NULL,0
"/* Dissect ""version"" */",0
/* From MS-NLMP:,0
    0   Major Version Number    1 byte,0
    1   Minor Version Number    1 byte,0
    2   Build Number            short(LE),0
    3   (Reserved)              3 bytes,0
    4   NTLM Current Revision   1 byte,0
"dissect_ntlmssp_version(tvbuff_t *tvb, int offset,",0
                        proto_tree *ntlmssp_tree),0
    proto_item *tf_,0
    proto_tree *version_tree_,0
"    tf = proto_tree_add_none_format(ntlmssp_tree, hf_ntlmssp_version, tvb, offset, 8,",0
"                                    ""Version %u.%u (Build %u)_ NTLM Current Revision %u"",",0
"                                    tvb_get_guint8(tvb, offset),",0
"                                    tvb_get_guint8(tvb, offset+1),",0
"                                    tvb_get_letohs(tvb, offset+2),",0
"                                    tvb_get_guint8(tvb, offset+7))_",0
"    version_tree = proto_item_add_subtree (tf, ett_ntlmssp_version)_",0
"    proto_tree_add_item(version_tree, hf_ntlmssp_version_major                , tvb, offset  , 1, ENC_LITTLE_ENDIAN)_",0
"    proto_tree_add_item(version_tree, hf_ntlmssp_version_minor                , tvb, offset+1, 1, ENC_LITTLE_ENDIAN)_",0
"    proto_tree_add_item(version_tree, hf_ntlmssp_version_build_number         , tvb, offset+2, 2, ENC_LITTLE_ENDIAN)_",0
"    proto_tree_add_item(version_tree, hf_ntlmssp_version_ntlm_current_revision, tvb, offset+7, 1, ENC_LITTLE_ENDIAN)_",0
  return offset+8_,0
/* Dissect a NTLM response. This is documented at,0
"   http://ubiqx.org/cifs/SMB.html#SMB.8, para 2.8.5.3 */",0
/* Attribute types */,0
" * XXX - the davenport document says that a type of 5 has been seen,",0
" * ""apparently containing the 'parent' DNS domain for servers in",0
" * subdomains"".",0
 * XXX: MS-NLMP info is newer than Davenport info_,0
 *      The attribute type list and the attribute names below are,0
 *      based upon MS-NLMP.,0
#define NTLM_TARGET_INFO_END               0x0000,0
#define NTLM_TARGET_INFO_NB_COMPUTER_NAME  0x0001,0
#define NTLM_TARGET_INFO_NB_DOMAIN_NAME    0x0002,0
#define NTLM_TARGET_INFO_DNS_COMPUTER_NAME 0x0003,0
#define NTLM_TARGET_INFO_DNS_DOMAIN_NAME   0x0004,0
#define NTLM_TARGET_INFO_DNS_TREE_NAME     0x0005,0
#define NTLM_TARGET_INFO_FLAGS             0x0006,0
#define NTLM_TARGET_INFO_TIMESTAMP         0x0007,0
#define NTLM_TARGET_INFO_RESTRICTIONS      0x0008,0
#define NTLM_TARGET_INFO_TARGET_NAME       0x0009,0
#define NTLM_TARGET_INFO_CHANNEL_BINDINGS  0x000A,0
static const value_string ntlm_name_types[] = {,0
"  { NTLM_TARGET_INFO_END,               ""End of list"" },",0
"  { NTLM_TARGET_INFO_NB_COMPUTER_NAME,  ""NetBIOS computer name"" },",0
"  { NTLM_TARGET_INFO_NB_DOMAIN_NAME,    ""NetBIOS domain name"" },",0
"  { NTLM_TARGET_INFO_DNS_COMPUTER_NAME, ""DNS computer name"" },",0
"  { NTLM_TARGET_INFO_DNS_DOMAIN_NAME,   ""DNS domain name"" },",0
"  { NTLM_TARGET_INFO_DNS_TREE_NAME,     ""DNS tree name"" },",0
"  { NTLM_TARGET_INFO_FLAGS,             ""Flags"" },",0
"  { NTLM_TARGET_INFO_TIMESTAMP,         ""Timestamp"" },",0
"  { NTLM_TARGET_INFO_RESTRICTIONS,      ""Restrictions"" },",0
"  { NTLM_TARGET_INFO_TARGET_NAME,       ""Target Name""},",0
"  { NTLM_TARGET_INFO_CHANNEL_BINDINGS,  ""Channel Bindings""},",0
static value_string_ext ntlm_name_types_ext = VALUE_STRING_EXT_INIT(ntlm_name_types)_,0
/* The following *must* match the order of the list of attribute types   */,0
/*  Assumption: values in the list are a sequence starting with 0 and    */,0
/*  with no gaps allowing a direct access of the array by attribute type */,0
static int *ntlmssp_hf_challenge_target_info_hf_ptr_array[] = {,0
"  &hf_ntlmssp_challenge_target_info_end,",0
"  &hf_ntlmssp_challenge_target_info_nb_computer_name,",0
"  &hf_ntlmssp_challenge_target_info_nb_domain_name,",0
"  &hf_ntlmssp_challenge_target_info_dns_computer_name,",0
"  &hf_ntlmssp_challenge_target_info_dns_domain_name,",0
"  &hf_ntlmssp_challenge_target_info_dns_tree_name,",0
"  &hf_ntlmssp_challenge_target_info_flags,",0
"  &hf_ntlmssp_challenge_target_info_timestamp,",0
"  &hf_ntlmssp_challenge_target_info_restrictions,",0
"  &hf_ntlmssp_challenge_target_info_target_name,",0
  &hf_ntlmssp_challenge_target_info_channel_bindings,0
static int *ntlmssp_hf_ntlmv2_response_hf_ptr_array[] = {,0
"  &hf_ntlmssp_ntlmv2_response_end,",0
"  &hf_ntlmssp_ntlmv2_response_nb_computer_name,",0
"  &hf_ntlmssp_ntlmv2_response_nb_domain_name,",0
"  &hf_ntlmssp_ntlmv2_response_dns_computer_name,",0
"  &hf_ntlmssp_ntlmv2_response_dns_domain_name,",0
"  &hf_ntlmssp_ntlmv2_response_dns_tree_name,",0
"  &hf_ntlmssp_ntlmv2_response_flags,",0
"  &hf_ntlmssp_ntlmv2_response_timestamp,",0
"  &hf_ntlmssp_ntlmv2_response_restrictions,",0
"  &hf_ntlmssp_ntlmv2_response_target_name,",0
  &hf_ntlmssp_ntlmv2_response_channel_bindings,0
typedef struct _tif {,0
  gint  *ett_,0
  int   *hf_item_type_,0
  int   *hf_item_length_,0
  int  **hf_attr_array_p_,0
} tif_t_,0
static tif_t ntlmssp_challenge_target_info_tif = {,0
"  &ett_ntlmssp_challenge_target_info_item,",0
"  &hf_ntlmssp_challenge_target_info_item_type,",0
"  &hf_ntlmssp_challenge_target_info_item_len,",0
  ntlmssp_hf_challenge_target_info_hf_ptr_array,0
static tif_t ntlmssp_ntlmv2_response_tif = {,0
"  &ett_ntlmssp_ntlmv2_response_item,",0
"  &hf_ntlmssp_ntlmv2_response_item_type,",0
"  &hf_ntlmssp_ntlmv2_response_item_len,",0
  ntlmssp_hf_ntlmv2_response_hf_ptr_array,0
/** See [MS-NLMP] 2.2.2.1 */,0
"dissect_ntlmssp_target_info_list(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",0
"                                 guint32 target_info_offset, guint16 target_info_length,",0
                                 tif_t *tif_p),0
  guint32 item_offset_,0
  guint16 item_type = ~0_,0
  guint16 item_length_,0
  /* Now enumerate through the individual items in the list */,0
  item_offset = target_info_offset_,0
  while (item_offset < (target_info_offset + target_info_length) && (item_type != NTLM_TARGET_INFO_END)) {,0
    proto_item   *target_info_tf_,0
    proto_tree   *target_info_tree_,0
    guint32       content_offset_,0
    guint16       content_length_,0
    guint32       type_offset_,0
    guint32       len_offset_,0
    const guint8 *text = NULL_,0
    int **hf_array_p = tif_p->hf_attr_array_p_,0
    /* Content type */,0
    type_offset = item_offset_,0
"    item_type = tvb_get_letohs(tvb, type_offset)_",0
    /* Content length */,0
    len_offset = type_offset + 2_,0
"    content_length = tvb_get_letohs(tvb, len_offset)_",0
    /* Content value */,0
    content_offset = len_offset + 2_,0
    item_length    = content_length + 4_,0
"    target_info_tree = proto_tree_add_subtree_format(tree, tvb, item_offset, item_length, *tif_p->ett, &target_info_tf,",0
"                                  ""Attribute: %s"", val_to_str_ext(item_type, &ntlm_name_types_ext, ""Unknown (%d)""))_",0
"    proto_tree_add_item (target_info_tree, *tif_p->hf_item_type,    tvb, type_offset, 2, ENC_LITTLE_ENDIAN)_",0
"    proto_tree_add_item (target_info_tree, *tif_p->hf_item_length,  tvb, len_offset,  2, ENC_LITTLE_ENDIAN)_",0
    if (content_length > 0) {,0
      switch (item_type) {,0
      case NTLM_TARGET_INFO_NB_COMPUTER_NAME:,0
      case NTLM_TARGET_INFO_NB_DOMAIN_NAME:,0
      case NTLM_TARGET_INFO_DNS_COMPUTER_NAME:,0
      case NTLM_TARGET_INFO_DNS_DOMAIN_NAME:,0
      case NTLM_TARGET_INFO_DNS_TREE_NAME:,0
      case NTLM_TARGET_INFO_TARGET_NAME:,0
"        proto_tree_add_item_ret_string(target_info_tree, *hf_array_p[item_type], tvb, content_offset, content_length, ENC_UTF_16|ENC_LITTLE_ENDIAN, wmem_packet_scope(), &text)_",0
"        proto_item_append_text(target_info_tf, "": %s"", text)_",0
      case NTLM_TARGET_INFO_FLAGS:,0
"        proto_tree_add_item(target_info_tree, *hf_array_p[item_type], tvb, content_offset, content_length, ENC_LITTLE_ENDIAN)_",0
      case NTLM_TARGET_INFO_TIMESTAMP:,0
"        dissect_nt_64bit_time(tvb, target_info_tree, content_offset, *hf_array_p[item_type])_",0
      case NTLM_TARGET_INFO_RESTRICTIONS:,0
      case NTLM_TARGET_INFO_CHANNEL_BINDINGS:,0
"        proto_tree_add_item(target_info_tree, *hf_array_p[item_type], tvb, content_offset, content_length, ENC_NA)_",0
      default:,0
"        proto_tree_add_expert(target_info_tree, pinfo, &ei_ntlmssp_target_info_attr,",0
"                                   tvb, content_offset, content_length)_",0
    item_offset += item_length_,0
  return item_offset_,0
/** See [MS-NLMP] 3.3.2 */,0
int,0
"dissect_ntlmv2_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int len)",0
  proto_item *ntlmv2_item = NULL_,0
  proto_tree *ntlmv2_tree = NULL_,0
  const int   orig_offset = offset_,0
  /* XXX - make sure we don't go past len? */,0
    ntlmv2_item = proto_tree_add_item(,0
"      tree, hf_ntlmssp_ntlmv2_response, tvb,",0
"      offset, len, ENC_NA)_",0
    ntlmv2_tree = proto_item_add_subtree(,0
"      ntlmv2_item, ett_ntlmssp_ntlmv2_response)_",0
  proto_tree_add_item(,0
"    ntlmv2_tree, hf_ntlmssp_ntlmv2_response_ntproofstr, tvb,",0
"    offset, 16, ENC_NA)_",0
  offset += 16_,0
"  proto_tree_add_item(ntlmv2_tree, hf_ntlmssp_ntlmv2_response_rversion, tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"  proto_tree_add_item(ntlmv2_tree, hf_ntlmssp_ntlmv2_response_hirversion, tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"  proto_tree_add_item(ntlmv2_tree, hf_ntlmssp_ntlmv2_response_z, tvb, offset, 6, ENC_NA)_",0
  offset += 6_,0
  offset = dissect_nt_64bit_time(,0
"    tvb, ntlmv2_tree, offset, hf_ntlmssp_ntlmv2_response_time)_",0
"    ntlmv2_tree, hf_ntlmssp_ntlmv2_response_chal, tvb,",0
"    offset, 8, ENC_NA)_",0
  offset += 8_,0
"  proto_tree_add_item(ntlmv2_tree, hf_ntlmssp_ntlmv2_response_z, tvb, offset, 4, ENC_NA)_",0
"  offset = dissect_ntlmssp_target_info_list(tvb, pinfo, ntlmv2_tree, offset, len - (offset - orig_offset), &ntlmssp_ntlmv2_response_tif)_",0
  if ((offset - orig_offset) < len) {,0
"    proto_tree_add_item(ntlmv2_tree, hf_ntlmssp_ntlmv2_response_z, tvb, offset, 4, ENC_NA)_",0
"    proto_tree_add_item(ntlmv2_tree, hf_ntlmssp_ntlmv2_response_pad, tvb, offset, len - (offset - orig_offset), ENC_NA)_",0
  return offset+len_,0
/* tapping into ntlmssph not yet implemented */,0
"dissect_ntlmssp_negotiate (tvbuff_t *tvb, int offset, proto_tree *ntlmssp_tree, ntlmssp_header_t *ntlmssph _U_)",0
  guint32 negotiate_flags_,0
  int     data_start_,0
  int     data_end_,0
  int     item_start_,0
  int     item_end_,0
  /* NTLMSSP Negotiate Flags */,0
"  negotiate_flags = tvb_get_letohl (tvb, offset)_",0
"  proto_tree_add_bitmask(ntlmssp_tree, tvb, offset, hf_ntlmssp_negotiate_flags, ett_ntlmssp_negotiate_flags, ntlmssp_negotiate_flags, ENC_LITTLE_ENDIAN)_",0
   * XXX - the davenport document says that these might not be,0
"   * sent at all, presumably meaning the length of the message",0
   * isn't enough to contain them.,0
"  offset = dissect_ntlmssp_string(tvb, offset, ntlmssp_tree, FALSE,",0
"                                  hf_ntlmssp_negotiate_domain,",0
"                                  &data_start, &data_end, NULL)_",0
"                                  hf_ntlmssp_negotiate_workstation,",0
"                                  &item_start, &item_end, NULL)_",0
"  data_start = MIN(data_start, item_start)_",0
"  data_end   = MAX(data_end,   item_end)_",0
  /* If there are more bytes before the data block dissect a version field,0
     if NTLMSSP_NEGOTIATE_VERSION is set in the flags (see MS-NLMP) */,0
  if (offset < data_start) {,0
    if (negotiate_flags & NTLMSSP_NEGOTIATE_VERSION),0
"      dissect_ntlmssp_version(tvb, offset, ntlmssp_tree)_",0
  return data_end_,0
"dissect_ntlmssp_challenge_target_info_blob (packet_info *pinfo, tvbuff_t *tvb, int offset,",0
"                                            proto_tree *ntlmssp_tree,",0
                                            int *end),0
"  guint16 challenge_target_info_length = tvb_get_letohs(tvb, offset)_",0
"  guint16 challenge_target_info_maxlen = tvb_get_letohs(tvb, offset+2)_",0
"  guint32 challenge_target_info_offset = tvb_get_letohl(tvb, offset+4)_",0
  proto_item *tf = NULL_,0
  proto_tree *challenge_target_info_tree = NULL_,0
  /* the target info list is just a blob */,0
  if (0 == challenge_target_info_length) {,0
    *end = (challenge_target_info_offset > ((guint)offset)+8 ? challenge_target_info_offset : ((guint)offset)+8)_,0
"    proto_tree_add_none_format(ntlmssp_tree, hf_ntlmssp_challenge_target_info, tvb, offset, 8,",0
"                          ""Target Info List: Empty"")_",0
"    tf = proto_tree_add_item (ntlmssp_tree, hf_ntlmssp_challenge_target_info, tvb,",0
"                              challenge_target_info_offset, challenge_target_info_length, ENC_NA)_",0
"    challenge_target_info_tree = proto_item_add_subtree(tf, ett_ntlmssp_challenge_target_info)_",0
"  proto_tree_add_uint(challenge_target_info_tree, hf_ntlmssp_challenge_target_info_len,",0
"                      tvb, offset, 2, challenge_target_info_length)_",0
"  proto_tree_add_uint(challenge_target_info_tree, hf_ntlmssp_challenge_target_info_maxlen,",0
"                      tvb, offset, 2, challenge_target_info_maxlen)_",0
"  proto_tree_add_uint(challenge_target_info_tree, hf_ntlmssp_challenge_target_info_offset,",0
"                      tvb, offset, 4, challenge_target_info_offset)_",0
"  dissect_ntlmssp_target_info_list(tvb, pinfo, challenge_target_info_tree,",0
"                                   challenge_target_info_offset, challenge_target_info_length,",0
                                   &ntlmssp_challenge_target_info_tif)_,0
  *end = challenge_target_info_offset + challenge_target_info_length_,0
"dissect_ntlmssp_challenge (tvbuff_t *tvb, packet_info *pinfo, int offset,",0
"                           proto_tree *ntlmssp_tree, ntlmssp_header_t *ntlmssph _U_)",0
  guint32         negotiate_flags_,0
"  int             item_start, item_end_",0
"  int             data_start, data_end_       /* MIN and MAX seen */",0
  guint8          clientkey[NTLMSSP_KEY_LEN]_ /* NTLMSSP cipher key for client */,0
  guint8          serverkey[NTLMSSP_KEY_LEN]_ /* NTLMSSP cipher key for server*/,0
  ntlmssp_info   *conv_ntlmssp_info = NULL_,0
  conversation_t *conversation_,0
  gboolean        unicode_strings   = FALSE_,0
  guint8          tmp[8]_,0
  guint8          sspkey[NTLMSSP_KEY_LEN]_ /* NTLMSSP cipher key */,0
  int             ssp_key_len_  /* Either 8 or 16 (40 bit or 128) */,0
  /* need to find unicode flag */,0
"  negotiate_flags = tvb_get_letohl (tvb, offset+8)_",0
  if (negotiate_flags & NTLMSSP_NEGOTIATE_UNICODE),0
    unicode_strings = TRUE_,0
  /* Target name */,0
"   * XXX - the davenport document (and MS-NLMP) calls this ""Target Name"",",0
   * presumably because non-domain targets are supported.,0
"   * XXX - Original name ""domain"" changed to ""target_name"" to match MS-NLMP",0
"  offset = dissect_ntlmssp_string(tvb, offset, ntlmssp_tree, unicode_strings,",0
"                                  hf_ntlmssp_challenge_target_name,",0
  data_start = item_start_,0
  data_end = item_end_,0
  /* NTLMSSP NT Lan Manager Challenge */,0
"  proto_tree_add_item (ntlmssp_tree,",0
"                       hf_ntlmssp_ntlm_server_challenge,",0
"                       tvb, offset, 8, ENC_NA)_",0
"   * Store the flags and the RC4 state information with the conversation,",0
   * as they're needed in order to dissect subsequent messages.,0
  conversation = find_or_create_conversation(pinfo)_,0
"  tvb_memcpy(tvb, tmp, offset, 8)_ /* challenge */",0
  /* We can face more than one NTLM exchange over the same couple of IP and ports ...*/,0
"  conv_ntlmssp_info = (ntlmssp_info *)conversation_get_proto_data(conversation, proto_ntlmssp)_",0
  /* XXX: The following code is (re)executed every time a particular frame is dissected,0
"   *      (in whatever order). Thus it seems to me that ""multiple exchanges"" might not be",0
   *      handled well depending on the order that frames are visited after the initial dissection.,0
"  if (!conv_ntlmssp_info || memcmp(tmp, conv_ntlmssp_info->server_challenge, 8) != 0) {",0
"    conv_ntlmssp_info = wmem_new0(wmem_file_scope(), ntlmssp_info)_",0
    /* Insert the flags into the conversation */,0
    conv_ntlmssp_info->flags = negotiate_flags_,0
    /* Insert the RC4 state information into the conversation */,0
"    tvb_memcpy(tvb, conv_ntlmssp_info->server_challenge, offset, 8)_",0
    conv_ntlmssp_info->is_auth_ntlm_v2 = 0_,0
"    /* Between the challenge and the user provided password, we can build the",0
       NTLMSSP key and initialize the cipher if we are not in EXTENDED SECURITY,0
       in this case we need the client challenge as well*/,0
    /* BTW this is true just if we are in LM Authentication if not the logic is a bit different.,0
     * Right now it's not very clear what is LM Authentication it __seems__ to be when,0
     * NEGOTIATE NT ONLY is not set and NEGOSIATE EXTENDED SECURITY is not set as well*/,0
    if (!(conv_ntlmssp_info->flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY)),0
      conv_ntlmssp_info->rc4_state_initialized = 0_,0
      /* XXX - Make sure there is 24 bytes for the key */,0
"      conv_ntlmssp_info->ntlm_response.contents = (guint8 *)wmem_alloc0(wmem_file_scope(), 24)_",0
"      conv_ntlmssp_info->lm_response.contents = (guint8 *)wmem_alloc0(wmem_file_scope(), 24)_",0
"      create_ntlmssp_v1_key(gbl_nt_password, conv_ntlmssp_info->server_challenge, NULL, sspkey, NULL, conv_ntlmssp_info->flags, conv_ntlmssp_info->ntlm_response.contents, conv_ntlmssp_info->lm_response.contents, ntlmssph)_",0
"      if (memcmp(sspkey, gbl_zeros, NTLMSSP_KEY_LEN) != 0) {",0
"        get_sealing_rc4key(sspkey, conv_ntlmssp_info->flags, &ssp_key_len, clientkey, serverkey)_",0
"        if (!gcry_cipher_open (&conv_ntlmssp_info->rc4_handle_client, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0) &&",0
"            !gcry_cipher_open (&conv_ntlmssp_info->rc4_handle_server, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {",0
"          if (!gcry_cipher_setkey(conv_ntlmssp_info->rc4_handle_client, sspkey, ssp_key_len) &&",0
"              !gcry_cipher_setkey(conv_ntlmssp_info->rc4_handle_server, sspkey, ssp_key_len)) {",0
            conv_ntlmssp_info->server_dest_port = pinfo->destport_,0
            conv_ntlmssp_info->rc4_state_initialized = 1_,0
"    conversation_add_proto_data(conversation, proto_ntlmssp, conv_ntlmssp_info)_",0
"  /* If no more bytes (ie: no ""reserved"", ...) before start of data block, then return */",0
"  /* XXX: According to Davenport ""This form is seen in older Win9x-based systems""      */",0
  /*      Also: I've seen a capture with an HTTP CONNECT proxy-authentication          */,0
  /*            message wherein the challenge from the proxy has this form.            */,0
  if (offset >= data_start) {,0
    return data_end_,0
  /* Reserved (function not completely known) */,0
   * XXX - SSP key?  The davenport document says,0
   *    The context field is typically populated when Negotiate Local,0
"   *    Call is set. It contains an SSPI context handle, which allows",0
"   *    the client to ""short-circuit"" authentication and effectively",0
"   *    circumvent responding to the challenge. Physically, the context",0
"   *    is two long values. This is covered in greater detail later,",0
"   *    in the ""Local Authentication"" section.",0
   * It also says that that information may be omitted.,0
"  proto_tree_add_item (ntlmssp_tree, hf_ntlmssp_reserved,",0
   * The presence or absence of this field is not obviously correlated,0
   * with any flags in the previous NEGOTIATE message or in this,0
"   * message (other than the ""Workstation Supplied"" and ""Domain",0
"   * Supplied"" flags in the NEGOTIATE message, at least in the capture",0
   * I've seen - but those also correlate with the presence of workstation,0
"   * and domain name fields, so it doesn't seem to make sense that they",0
   * actually *indicate* whether the subsequent CHALLENGE has an,0
   * address list).,0
"    offset = dissect_ntlmssp_challenge_target_info_blob(pinfo, tvb, offset, ntlmssp_tree, &item_end)_",0
    /* XXX: This code assumes that the address list in the data block */,0
    /*      is always after the target name. Is this OK ?             */,0
"    data_end = MAX(data_end, item_end)_",0
"      offset = dissect_ntlmssp_version(tvb, offset, ntlmssp_tree)_",0
"  return MAX(offset, data_end)_",0
"dissect_ntlmssp_auth (tvbuff_t *tvb, packet_info *pinfo, int offset,",0
"                      proto_tree *ntlmssp_tree, ntlmssp_header_t *ntlmssph)",0
"  int             data_start, data_end = 0_",0
  guint8          sspkey[NTLMSSP_KEY_LEN]_    /* exported session key */,0
  guint8          encryptedsessionkey[NTLMSSP_KEY_LEN]_,0
  ntlmssp_blob    sessionblob_,0
  gboolean        unicode_strings      = FALSE_,0
  ntlmssp_info   *conv_ntlmssp_info_,0
  int             ssp_key_len_,0
"   * Get flag info from the original negotiate message, if any.",0
   * This is because the flag information is sometimes missing from,0
"   * the AUTHENTICATE message, so we can't figure out whether",0
   * strings are Unicode or not by looking at *our* flags.,0
"   * XXX it seems it's more from the CHALLENGE message, which is more clever in fact",0
   * because the server can change some flags.,0
   * But according to MS NTLMSSP doc it's not that simple.,0
   * In case of Conection less mode AUTHENTICATE flags should be used because they,0
   * reprensent the choice of the client after having been informed of options of the,0
   * server in the CHALLENGE message.,0
   * In Connection mode then the CHALLENGE flags should (must ?) be used,0
"   * XXX: MS-NLMP says the flag field in the AUTHENTICATE message ""contains the set of bit",0
"   *   flags (section 2.2.2.5) negotiated in the previous messages.""",0
   *   I read that to mean that the flags for in connection-mode AUTHENTICATE also represent,0
   *   the choice of the client (for the flags which are negotiated).,0
"   * XXX: In the absence of CHALLENGE flags, as a last resort we'll use the flags",0
   *      (if available) from this AUTHENTICATE message.,0
   *      I've seen a capture which does an HTTP CONNECT which:,0
   *      - has the NEGOTIATE & CHALLENGE messages in one TCP connection_,0
   *      - has the AUTHENTICATE message in a second TCP connection_,0
   *        (The authentication aparently succeeded).,0
"  conv_ntlmssp_info = (ntlmssp_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_ntlmssp, NTLMSSP_CONV_INFO_KEY)_",0
  if (conv_ntlmssp_info == NULL) {,0
"     * There isn't any.  Is there any from this conversation?  If so,",0
"     * it means this is the first time we've dissected this frame, so",0
     * we should give it flag info.,0
    /* XXX: Create conv_ntlmssp_info & etc if no previous CHALLENGE seen */,0
    /*      so we'll have a place to store flags.                        */,0
    /*      This is a bit brute-force but looks like it will be OK.      */,0
    conversation = find_or_create_conversation(pinfo)_,0
"    conv_ntlmssp_info = (ntlmssp_info *)conversation_get_proto_data(conversation, proto_ntlmssp)_",0
    if (conv_ntlmssp_info == NULL) {,0
"      conv_ntlmssp_info = wmem_new0(wmem_file_scope(), ntlmssp_info)_",0
"      conversation_add_proto_data(conversation, proto_ntlmssp, conv_ntlmssp_info)_",0
    /* XXX: The *conv_ntlmssp_info struct attached to the frame is the,0
            same as the one attached to the conversation. That is: *both* point to,0
            the exact same struct in memory.  Is this what is indended ?  */,0
"    p_add_proto_data(wmem_file_scope(), pinfo, proto_ntlmssp, NTLMSSP_CONV_INFO_KEY, conv_ntlmssp_info)_",0
  if (conv_ntlmssp_info != NULL) {,0
    if (conv_ntlmssp_info->flags & NTLMSSP_NEGOTIATE_UNICODE),0
      unicode_strings = TRUE_,0
   * Sometimes the session key and flags are missing.,0
   * Sometimes the session key is present but the flags are missing.,0
   * XXX Who stay so ? Reading spec I would rather say the opposite: flags are,0
"   * always present, session information are always there as well but sometime",0
   * session information could be null (in case of no session),0
   * Sometimes they're both present.,0
   * This does not correlate with any flags in the previous CHALLENGE,0
"   * message, and only correlates with ""Negotiate Unicode"", ""Workstation",0
"   * Supplied"", and ""Domain Supplied"" in the NEGOTIATE message - but",0
   * those don't make sense as flags to use to determine this.,0
   * So we check all of the descriptors to figure out where the data,0
"   * area begins, and if the session key or the flags would be in the",0
"   * middle of the data area, we assume the field in question is",0
   * missing.,0
   * XXX - Reading Davenport and MS-NLMP: as I see it the possibilities are:,0
"   *       a. No session-key_ no flags_ no version (""Win9x"")",0
   *       b. Session-key & flags.,0
"   *       c. Session-key, flags & version.",0
"   *    In cases b and c the session key may be ""null"".",0
  /* Lan Manager response */,0
"  data_start = tvb_get_letohl(tvb, offset+4)_",0
"  offset = dissect_ntlmssp_blob(tvb, pinfo, ntlmssp_tree, offset,",0
"                                hf_ntlmssp_auth_lmresponse,",0
"                                &item_end,",0
                                conv_ntlmssp_info == NULL ? NULL :,0
                                &conv_ntlmssp_info->lm_response)_,0
"  data_end = MAX(data_end, item_end)_",0
  /* NTLM response */,0
"  item_start = tvb_get_letohl(tvb, offset+4)_",0
"                                hf_ntlmssp_auth_ntresponse,",0
                                &conv_ntlmssp_info->ntlm_response)_,0
  if (conv_ntlmssp_info != NULL),0
    if (conv_ntlmssp_info->ntlm_response.length > 24),0
      conv_ntlmssp_info->is_auth_ntlm_v2 = 1_,0
"       * XXX - at least according to 2.2.2.7 ""NTLM v2: NTLMv2_CLIENT_CHALLENGE""",0
"       * in [MS-NLMP], the client challenge is at an offset of 16 bytes,",0
"       * not 24 bytes, from the beginning of the blob.",0
"       * If so, that not only means that the ""+24"" should be ""+16"", it also",0
"       * means that the length check should be "">= 24"", and would thus be",0
       * redundant.,0
"       * If not, then we should handle a bad blob in which the client",0
"       * challenge is missing, and not try to use whatever random junk",0
       * is in conv_ntlmssp_info->client_challenge.,0
      if (conv_ntlmssp_info->ntlm_response.length >= 32) {,0
"        memcpy(conv_ntlmssp_info->client_challenge, conv_ntlmssp_info->ntlm_response.contents+24, 8)_",0
      conv_ntlmssp_info->is_auth_ntlm_v2 = 0_,0
  /* domain name */,0
"  offset = dissect_ntlmssp_string(tvb, offset, ntlmssp_tree,",0
"                                  unicode_strings,",0
"                                  hf_ntlmssp_auth_domain,",0
"                                  &item_start, &item_end, &(ntlmssph->domain_name))_",0
  /*ntlmssph->domain_name_len = item_end-item_start_*/,0
  /* user name */,0
"                                  hf_ntlmssp_auth_username,",0
"                                  &item_start, &item_end, &(ntlmssph->acct_name))_",0
  /*ntlmssph->acct_name_len = item_end-item_start_*/,0
"  col_append_sep_fstr(pinfo->cinfo, COL_INFO, "", "", ""User: %s\\%s"",",0
"                  ntlmssph->domain_name, ntlmssph->acct_name)_",0
  /* hostname */,0
"                                  hf_ntlmssp_auth_hostname,",0
"                                  &item_start, &item_end, &(ntlmssph->host_name))_",0
  sessionblob.length = 0_,0
    /* Session Key */,0
"    offset = dissect_ntlmssp_blob(tvb, pinfo, ntlmssp_tree, offset,",0
"                                  hf_ntlmssp_auth_sesskey,",0
"                                  &item_end, &sessionblob)_",0
    /* NTLMSSP Negotiate Flags */,0
"    negotiate_flags = tvb_get_letohl (tvb, offset)_",0
"    proto_tree_add_bitmask(ntlmssp_tree, tvb, offset, hf_ntlmssp_negotiate_flags, ett_ntlmssp_negotiate_flags, ntlmssp_negotiate_flags, ENC_LITTLE_ENDIAN)_",0
    /* If no previous flags seen (ie: no previous CHALLENGE) use flags,0
       from the AUTHENTICATE message).,0
       Assumption: (flags == 0) means flags not previously seen  */,0
    if ((conv_ntlmssp_info != NULL) && (conv_ntlmssp_info->flags == 0)) {,0
      conv_ntlmssp_info->flags = negotiate_flags_,0
  } else,0
    negotiate_flags = 0_,0
  /* If there are still more bytes before the data block dissect an MIC (message integrity_code) field */,0
  /*  (See MS-NLMP)                                                                    */,0
"    proto_tree_add_item(ntlmssp_tree, hf_ntlmssp_message_integrity_code, tvb, offset, 16, ENC_NA)_",0
  if (sessionblob.length > NTLMSSP_KEY_LEN) {,0
"    expert_add_info_format(pinfo, NULL, &ei_ntlmssp_blob_len_too_long, ""Session blob length too long: %u"", sessionblob.length)_",0
  } else if (sessionblob.length != 0) {,0
"    memcpy(encryptedsessionkey, sessionblob.contents, sessionblob.length)_",0
    /* Try to attach to an existing conversation if not then it's useless to try to do so,0
     * because we are missing important information (ie. server challenge),0
    if (conv_ntlmssp_info) {,0
      /* If we are in EXTENDED SECURITY then we can now initialize cipher */,0
      if ((conv_ntlmssp_info->flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY)),0
        conv_ntlmssp_info->rc4_state_initialized = 0_,0
        if (conv_ntlmssp_info->is_auth_ntlm_v2) {,0
"          create_ntlmssp_v2_key(gbl_nt_password, conv_ntlmssp_info->server_challenge, conv_ntlmssp_info->client_challenge, sspkey, encryptedsessionkey, conv_ntlmssp_info->flags, &conv_ntlmssp_info->ntlm_response, &conv_ntlmssp_info->lm_response, ntlmssph)_",0
          if (conv_ntlmssp_info->lm_response.contents == NULL || conv_ntlmssp_info->lm_response.length < 8) {,0
"            memset(conv_ntlmssp_info->client_challenge, 0, 8)_",0
          } else {,0
"            memcpy(conv_ntlmssp_info->client_challenge, conv_ntlmssp_info->lm_response.contents, 8)_",0
"          create_ntlmssp_v1_key(gbl_nt_password, conv_ntlmssp_info->server_challenge, conv_ntlmssp_info->client_challenge, sspkey, encryptedsessionkey, conv_ntlmssp_info->flags, conv_ntlmssp_info->ntlm_response.contents, conv_ntlmssp_info->lm_response.contents, ntlmssph)_",0
        /* ssp is the exported session key */,0
"        if (memcmp(sspkey, gbl_zeros, NTLMSSP_KEY_LEN) != 0) {",0
"          get_sealing_rc4key(sspkey, conv_ntlmssp_info->flags, &ssp_key_len, clientkey, serverkey)_",0
"          get_siging_key((guint8*)&conv_ntlmssp_info->sign_key_server, (guint8*)&conv_ntlmssp_info->sign_key_client, sspkey, ssp_key_len)_",0
"         if (!gcry_cipher_open (&conv_ntlmssp_info->rc4_handle_client, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0) &&",0
"              !gcry_cipher_open (&conv_ntlmssp_info->rc4_handle_server, GCRY_CIPHER_ARCFOUR, GCRY_CIPHER_MODE_STREAM, 0)) {",0
"            if (!gcry_cipher_setkey(conv_ntlmssp_info->rc4_handle_client, serverkey, ssp_key_len) &&",0
              conv_ntlmssp_info->server_dest_port = pinfo->destport_,0
              conv_ntlmssp_info->rc4_state_initialized = 1_,0
     },0
static guint8*,0
"get_sign_key(packet_info *pinfo, int cryptpeer)",0
"  conversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,",0
"                                   pinfo->ptype, pinfo->srcport,",0
"                                   pinfo->destport, 0)_",0
  if (conversation == NULL) {,0
"    /* We don't have a conversation.  In this case, stop processing",0
       because we do not have enough info to decrypt the payload */,0
"    /* We have a conversation, check for encryption state */",0
"    conv_ntlmssp_info = (ntlmssp_info *)conversation_get_proto_data(conversation,",0
                                                    proto_ntlmssp)_,0
"      /* No encryption state tied to the conversation.  Therefore, we",0
         cannot decrypt the payload */,0
      return NULL_,0
      /* We have the encryption state in the conversation.  So return the,0
         crypt state tied to the requested peer,0
      if (cryptpeer == 1) {,0
        return (guint8*)&conv_ntlmssp_info->sign_key_client_,0
        return (guint8*)&conv_ntlmssp_info->sign_key_server_,0
 * Get the encryption state tied to this conversation.  cryptpeer indicates,0
 * whether to retrieve the client key (1) or the server key (0),0
"get_encrypted_state(packet_info *pinfo, int cryptpeer)",0
        return &conv_ntlmssp_info->rc4_handle_client_,0
        return &conv_ntlmssp_info->rc4_handle_server_,0
static tvbuff_t*,0
"decrypt_data_payload(tvbuff_t *tvb, int offset, guint32 encrypted_block_length,",0
"                     packet_info *pinfo, proto_tree *tree _U_, gpointer key)_",0
"decrypt_verifier(tvbuff_t *tvb, int offset, guint32 encrypted_block_length,",0
"                 packet_info *pinfo, proto_tree *tree, gpointer key)_",0
static tvbuff_t *,0
"dissect_ntlmssp_encrypted_payload(tvbuff_t *data_tvb,",0
"                                  tvbuff_t *auth_tvb _U_,",0
"                                  int offset,",0
"                                  packet_info *pinfo,",0
                                  dcerpc_auth_info *auth_info _U_),0
"dissect_ntlmssp_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",0
  volatile int          offset              = 0_,0
  proto_tree *volatile  ntlmssp_tree        = NULL_,0
  proto_item           *tf                  = NULL_,0
  guint32               length_,0
  guint32               encrypted_block_length_,0
  guint8                key[NTLMSSP_KEY_LEN]_,0
  /* the magic ntlm is the identifier of a NTLMSSP packet that's 00 00 00 01 */,0
  guint32               ntlm_magic_size     = 4_,0
  guint32               ntlm_signature_size = 8_,0
  guint32               ntlm_seq_size       = 4_,0
  length = tvb_captured_length (tvb)_,0
  /* signature + seq + real payload */,0
  encrypted_block_length = length - ntlm_magic_size_,0
  if (encrypted_block_length < (ntlm_signature_size + ntlm_seq_size)) {,0
"    /* Don't know why this would happen, but if it does, don't even bother",0
       attempting decryption/dissection */,0
    return offset + length_,0
  /* Setup a new tree for the NTLMSSP payload */,0
"    tf = proto_tree_add_item (tree,",0
"                              hf_ntlmssp_verf,",0
"                              tvb, offset, -1, ENC_NA)_",0
"    ntlmssp_tree = proto_item_add_subtree (tf,",0
                                           ett_ntlmssp)_,0
   * Catch the ReportedBoundsError exception_ the stuff we've been,0
"   * handed doesn't necessarily run to the end of the packet, it's",0
"   * an item inside a packet, so if it happens to be malformed (or",0
"   * we, or a dissector we call, has a bug), so that an exception",0
"   * is thrown, we want to report the error, but return and let",0
   * our caller dissect the rest of the packet.,0
"   * If it gets a BoundsError, we can stop, as there's nothing more",0
"   * in the packet after our blob to see, so we just re-throw the",0
   * exception.,0
  TRY {,0
    /* Version number */,0
"    proto_tree_add_item (ntlmssp_tree, hf_ntlmssp_verf_vers,",0
"                         tvb, offset, 4, ENC_LITTLE_ENDIAN)_",0
    /* Encrypted body */,0
"    proto_tree_add_item (ntlmssp_tree, hf_ntlmssp_verf_body,",0
"                         tvb, offset, ntlm_signature_size + ntlm_seq_size, ENC_NA)_",0
"    memset(key, 0, sizeof(key))_",0
"    tvb_memcpy(tvb, key, offset, ntlm_signature_size + ntlm_seq_size)_",0
    /* Try to decrypt */,0
"    decrypt_data_payload (tvb, offset+(ntlm_signature_size + ntlm_seq_size), encrypted_block_length-(ntlm_signature_size + ntlm_seq_size), pinfo, ntlmssp_tree, key)_",0
"    decrypt_verifier (tvb, offset, ntlm_signature_size + ntlm_seq_size, pinfo, ntlmssp_tree, key)_",0
    /* let's try to hook ourselves here */,0
    offset += 12_,1
  } CATCH_NONFATAL_ERRORS {,0
"    show_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE)_",0
  } ENDTRY_,0
"                     packet_info *pinfo, proto_tree *tree _U_, gpointer key)",0
  tvbuff_t            *decr_tvb_ /* Used to display decrypted buffer */,0
  ntlmssp_packet_info *packet_ntlmssp_info_,0
  ntlmssp_packet_info *stored_packet_ntlmssp_info = NULL_,0
  /* Check to see if we already have state for this packet */,0
"  packet_ntlmssp_info = (ntlmssp_packet_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_ntlmssp, NTLMSSP_PACKET_INFO_KEY)_",0
  if (packet_ntlmssp_info == NULL) {,0
"    /* We don't have any packet state, so create one */",0
"    packet_ntlmssp_info = wmem_new0(wmem_file_scope(), ntlmssp_packet_info)_",0
"    p_add_proto_data(wmem_file_scope(), pinfo, proto_ntlmssp, NTLMSSP_PACKET_INFO_KEY, packet_ntlmssp_info)_",0
  if (!packet_ntlmssp_info->payload_decrypted) {,0
    conversation_t *conversation_,1
    ntlmssp_info   *conv_ntlmssp_info_,0
    /* Pull the challenge info from the conversation */,0
"    conversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,",0
"                                     pinfo->ptype, pinfo->srcport,",0
"                                     pinfo->destport, 0)_",0
    if (conversation == NULL) {,1
"      /* There is no conversation, thus no encryption state */",0
      /* There is no NTLMSSP state tied to the conversation */,0
    if (conv_ntlmssp_info->rc4_state_initialized != 1) {,0
      /* The crypto sybsystem is not initialized.  This means that either,0
"         the conversation did not include a challenge, or that we do not have the right password */",0
    if (key != NULL) {,0
"      stored_packet_ntlmssp_info = (ntlmssp_packet_info *)g_hash_table_lookup(hash_packet, key)_",0
    if (stored_packet_ntlmssp_info != NULL && stored_packet_ntlmssp_info->payload_decrypted == TRUE) {,0
"      /* Mat TBD (stderr, ""Found a already decrypted packet\n"")_*/",0
"      memcpy(packet_ntlmssp_info, stored_packet_ntlmssp_info, sizeof(ntlmssp_packet_info))_",0
"      /* Mat TBD printnbyte(packet_ntlmssp_info->decrypted_payload, encrypted_block_length, ""Data: "", ""\n"")_*/",0
      gcry_cipher_hd_t *rc4_handle_,0
      gcry_cipher_hd_t *rc4_handle_peer_,0
      /* Get the pair of RC4 state structures.  One is used for to decrypt the,0
         payload.  The other is used to re-encrypt the payload to represent,0
         the peer */,0
      if (conv_ntlmssp_info->server_dest_port == pinfo->destport) {,0
        /* client */,0
"        rc4_handle = get_encrypted_state(pinfo, 1)_",0
"        rc4_handle_peer = get_encrypted_state(pinfo, 0)_",0
        /* server */,0
"        rc4_handle = get_encrypted_state(pinfo, 0)_",0
"        rc4_handle_peer = get_encrypted_state(pinfo, 1)_",0
      if (rc4_handle == NULL) {,0
"        /* There is no encryption state, so we cannot decrypt */",0
        return NULL_,1
      /* Store the decrypted contents in the packet state struct,0
"         (of course at this point, they aren't decrypted yet) */",0
"      packet_ntlmssp_info->decrypted_payload = (guint8 *)tvb_memdup(wmem_file_scope(), tvb, offset,",0
                                                          encrypted_block_length)_,0
      packet_ntlmssp_info->payload_len = encrypted_block_length_,0
"      decrypted_payloads = g_slist_prepend(decrypted_payloads,",0
                                           packet_ntlmssp_info->decrypted_payload)_,0
      if (key != NULL) {,0
"        g_hash_table_insert(hash_packet, key, packet_ntlmssp_info)_",0
      /* Do the decryption of the payload */,0
"      if (gcry_cipher_encrypt(*rc4_handle, packet_ntlmssp_info->decrypted_payload, encrypted_block_length, packet_ntlmssp_info->decrypted_payload, encrypted_block_length)) {",0
      /* decrypt the verifier */,0
"      /*printnchar(packet_ntlmssp_info->decrypted_payload, encrypted_block_length, ""data: "", ""\n"")_*/",0
      /* We setup a temporary buffer so we can re-encrypt the payload after,0
         decryption.  This is to update the opposite peer's RC4 state,0
         it's useful when we have only one key for both conversation,0
         in case of KEY_EXCH we have independent key so this is not needed*/,0
      if (!(NTLMSSP_NEGOTIATE_KEY_EXCH & conv_ntlmssp_info->flags)) {,0
        guint8 *peer_block_,0
"        peer_block = (guint8 *)wmem_memdup(wmem_packet_scope(), packet_ntlmssp_info->decrypted_payload, encrypted_block_length)_",0
          return NULL_,0
      packet_ntlmssp_info->payload_decrypted = TRUE_,0
 /* Show the decrypted buffer in a new window */,0
"  decr_tvb = tvb_new_child_real_data(tvb, packet_ntlmssp_info->decrypted_payload,",0
"                                     encrypted_block_length,",0
                                     encrypted_block_length)_,0
"  add_new_data_source(pinfo, decr_tvb,",0
"                      ""Decrypted data"")_",0
  return decr_tvb_,0
"dissect_ntlmssp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)",0
  volatile int          offset       = 0_,0
  proto_tree *volatile  ntlmssp_tree = NULL_,0
"  proto_item           *tf, *type_item_",0
  ntlmssp_header_t     *ntlmssph_,0
"  ntlmssph = wmem_new(wmem_packet_scope(), ntlmssp_header_t)_",0
  ntlmssph->type = 0_,0
  ntlmssph->domain_name = NULL_,0
  ntlmssph->acct_name = NULL_,0
  ntlmssph->host_name = NULL_,0
"  memset(ntlmssph->session_key, 0, NTLMSSP_KEY_LEN)_",0
"  tf = proto_tree_add_item (tree,",0
"                              proto_ntlmssp,",0
"  ntlmssp_tree = proto_item_add_subtree (tf, ett_ntlmssp)_",0
    /* NTLMSSP constant */,0
"    proto_tree_add_item (ntlmssp_tree, hf_ntlmssp_auth,",0
"                         tvb, offset, 8, ENC_ASCII|ENC_NA)_",0
    offset += 8_,0
    /* NTLMSSP Message Type */,0
"    type_item = proto_tree_add_item (ntlmssp_tree, hf_ntlmssp_message_type,",0
"    ntlmssph->type = tvb_get_letohl (tvb, offset)_",0
"    col_append_sep_fstr(pinfo->cinfo, COL_INFO, "", "", ""%s"",",0
"                    val_to_str_const(ntlmssph->type,",0
"                                     ntlmssp_message_types,",0
"                                     ""Unknown NTLMSSP message type""))_",0
    /* Call the appropriate dissector based on the Message Type */,0
    switch (ntlmssph->type) {,0
    case NTLMSSP_NEGOTIATE:,0
"      dissect_ntlmssp_negotiate (tvb, offset, ntlmssp_tree, ntlmssph)_",0
    case NTLMSSP_CHALLENGE:,0
"      dissect_ntlmssp_challenge (tvb, pinfo, offset, ntlmssp_tree, ntlmssph)_",0
    case NTLMSSP_AUTH:,0
"      dissect_ntlmssp_auth (tvb, pinfo, offset, ntlmssp_tree, ntlmssph)_",0
    default:,1
      /* Unrecognized message type */,0
"      expert_add_info(pinfo, type_item, &ei_ntlmssp_message_type)_",0
"  tap_queue_packet(ntlmssp_tap, pinfo, ntlmssph)_",0
"dissect_ntlmssp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)",0
"  if (tvb_memeql(tvb, 0, ""NTLMSSP"", 8) == 0) {",0
"    dissect_ntlmssp(tvb, pinfo, parent_tree, data)_",0
  return FALSE_,0
" * See page 45 of ""DCE/RPC over SMB"" by Luke Kenneth Casson Leighton.",0
"                 packet_info *pinfo, proto_tree *tree, gpointer key)",0
  proto_tree          *decr_tree_,0
  conversation_t      *conversation_,0
  guint8*              sign_key_,0
  gcry_cipher_hd_t    *rc4_handle_,0
  gcry_cipher_hd_t    *rc4_handle_peer_,0
  guint8              *peer_block_,0
  guint8              *check_buf_,0
  guint8               calculated_md5[NTLMSSP_KEY_LEN]_,0
  ntlmssp_info        *conv_ntlmssp_info_,0
  int                  decrypted_offset    = 0_,0
  int                  sequence            = 0_,0
    /* We don't have data for this packet */,0
"    /* There is no conversation, thus no encryption state */",0
"  conv_ntlmssp_info = (ntlmssp_info *)conversation_get_proto_data(conversation,",0
                                                  proto_ntlmssp)_,0
  /* There is no NTLMSSP state tied to the conversation */,0
  if (key != NULL) {,0
"    stored_packet_ntlmssp_info = (ntlmssp_packet_info *)g_hash_table_lookup(hash_packet, key)_",0
  if (stored_packet_ntlmssp_info != NULL && stored_packet_ntlmssp_info->verifier_decrypted == TRUE) {,0
"      /* Mat TBD fprintf(stderr, ""Found a already decrypted packet\n"")_*/",0
"      /* In Theory it's aleady the case, and we should be more clever ... like just copying buffers ...*/",0
      packet_ntlmssp_info = stored_packet_ntlmssp_info_,0
    if (!packet_ntlmssp_info->verifier_decrypted) {,0
      if (conv_ntlmssp_info->rc4_state_initialized != 1) {,0
        /* The crypto sybsystem is not initialized.  This means that either,0
"           the conversation did not include a challenge, or we are doing",0
           something other than NTLMSSP v1 */,0
        /* client talk to server */,0
"        sign_key = get_sign_key(pinfo, 1)_",0
"        sign_key = get_sign_key(pinfo, 0)_",0
      if (rc4_handle == NULL || rc4_handle_peer == NULL) {,0
      /* Setup the buffer to decrypt to */,0
"      tvb_memcpy(tvb, packet_ntlmssp_info->verifier,",0
"                 offset, MIN(encrypted_block_length, sizeof(packet_ntlmssp_info->verifier)))_",0
      /*if (!(NTLMSSP_NEGOTIATE_KEY_EXCH & packet_ntlmssp_info->flags)) {*/,0
      if (conv_ntlmssp_info->flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY) {,0
        if ((NTLMSSP_NEGOTIATE_KEY_EXCH & conv_ntlmssp_info->flags)) {,0
          /* The spec says that if we have have a key exchange then we have a the signature that is crypted,0
"           * otherwise it's just a hmac_md5(keysign, concat(message, sequence))[0..7]",0
           */,0
"          if (gcry_cipher_encrypt(*rc4_handle, packet_ntlmssp_info->verifier, 8, NULL, 0)) {",0
        /*,0
         * Try to check the HMAC MD5 of the message against those calculated works great with LDAP payload but,0
         * don't with DCE/RPC calls.,0
         * Some analysis need to be done ...,0
         */,0
        if (sign_key != NULL) {,0
"          check_buf = (guint8 *)wmem_alloc(wmem_packet_scope(), packet_ntlmssp_info->payload_len+4)_",0
"          tvb_memcpy(tvb, &sequence, offset+8, 4)_",0
"          memcpy(check_buf, &sequence, 4)_",0
"          memcpy(check_buf+4, packet_ntlmssp_info->decrypted_payload, packet_ntlmssp_info->payload_len)_",0
"          md5_hmac(check_buf, (int)(packet_ntlmssp_info->payload_len+4), sign_key, NTLMSSP_KEY_LEN, calculated_md5)_",0
          /*,0
"          printnbyte(packet_ntlmssp_info->verifier, 8, ""HMAC from packet: "", ""\n"")_",0
"          printnbyte(calculated_md5, 8, ""HMAC            : "", ""\n"")_",0
          */,0
        /* The packet has a PAD then a checksum then a sequence and they are encoded in this order so we can decrypt all at once */,0
        /* Do the actual decryption of the verifier */,0
"        if (gcry_cipher_encrypt(*rc4_handle, packet_ntlmssp_info->verifier, encrypted_block_length, NULL, 0)) {",0
          return_,0
         This is not needed when we just have EXTENDED SECURITY because the signature is not crypted,0
         and it's also not needed when we have key exchange because server and client have independent keys */,0
      if (!(NTLMSSP_NEGOTIATE_KEY_EXCH & conv_ntlmssp_info->flags) && !(NTLMSSP_NEGOTIATE_EXTENDED_SECURITY & conv_ntlmssp_info->flags)) {,0
"        peer_block = (guint8 *)wmem_memdup(wmem_packet_scope(), packet_ntlmssp_info->verifier, encrypted_block_length)_",0
"        if (gcry_cipher_encrypt(*rc4_handle_peer, peer_block, encrypted_block_length, NULL, 0)) {",0
      /* Mark the packet as decrypted so that subsequent attempts to dissect,0
         the packet use the already decrypted payload instead of attempting,0
         to decrypt again */,0
      packet_ntlmssp_info->verifier_decrypted = TRUE_,0
  /* Show the decrypted buffer in a new window */,0
"  decr_tvb = tvb_new_child_real_data(tvb, packet_ntlmssp_info->verifier,",0
"                      ""Decrypted NTLMSSP Verifier"")_",0
  /* Show the decrypted payload in the tree */,0
"  decr_tree = proto_tree_add_subtree_format(tree, decr_tvb, 0, -1,",0
"                           ett_ntlmssp, NULL,",0
"                           ""Decrypted Verifier (%d byte%s)"",",0
"                           encrypted_block_length,",0
"                           plurality(encrypted_block_length, """", ""s""))_",0
  if (( conv_ntlmssp_info->flags & NTLMSSP_NEGOTIATE_EXTENDED_SECURITY)) {,0
"    proto_tree_add_item (decr_tree, hf_ntlmssp_verf_hmacmd5,",0
"                         decr_tvb, decrypted_offset, 8, ENC_NA)_",0
    decrypted_offset += 8_,0
    /* Incrementing sequence number of DCE conversation */,0
"    proto_tree_add_item (decr_tree, hf_ntlmssp_verf_sequence,",0
"                         decr_tvb, decrypted_offset, 4, ENC_NA)_",0
    /* RANDOM PAD usually it's 0 */,0
"    proto_tree_add_item (decr_tree, hf_ntlmssp_verf_randompad,",0
"                         decr_tvb, decrypted_offset, 4, ENC_LITTLE_ENDIAN)_",0
    decrypted_offset += 4_,0
    /* CRC32 of the DCE fragment data */,0
"    proto_tree_add_item (decr_tree, hf_ntlmssp_verf_crc32,",0
/* Used when NTLMSSP is done over DCE/RPC because in this case verifier and real payload are not contigious*/,0
"dissect_ntlmssp_payload_only(tvbuff_t *tvb, packet_info *pinfo, _U_ proto_tree *tree, void *data)",0
  tvbuff_t *volatile    decr_tvb_,0
  tvbuff_t**            ret_decr_tvb = (tvbuff_t**)data_,0
  if (ret_decr_tvb),0
    *ret_decr_tvb = NULL_,0
  /* the magic ntlm is the identifier of a NTLMSSP packet that's 00 00 00 01,0
  encrypted_block_length = tvb_captured_length (tvb)_,0
"    decr_tvb = decrypt_data_payload (tvb, offset, encrypted_block_length, pinfo, ntlmssp_tree, NULL)_",0
    if (ret_decr_tvb),0
       *ret_decr_tvb = decr_tvb_,0
/* Used when NTLMSSP is done over DCE/RPC because in this case verifier and real payload are not contigious,0
 * But in fact this function could be merged with wrap_dissect_ntlmssp_verf because it's only used there,0
"dissect_ntlmssp_verf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)",0
  proto_item           *tf           = NULL_,0
  guint32               verifier_length_,0
  verifier_length = tvb_captured_length (tvb)_,0
  encrypted_block_length = verifier_length - 4_,0
  if (encrypted_block_length < 12) {,0
    return offset + verifier_length_,0
"                         tvb, offset, encrypted_block_length, ENC_NA)_",0
"    decrypt_verifier (tvb, offset, encrypted_block_length, pinfo, ntlmssp_tree, NULL)_",0
    offset += encrypted_block_length_,0
"wrap_dissect_ntlmssp_payload_only(tvbuff_t *tvb, tvbuff_t *auth_tvb _U_,",0
"                                  int offset, packet_info *pinfo, dcerpc_auth_info *auth_info _U_)",0
"  tvbuff_t *data_tvb, *decrypted_tvb_",0
"  data_tvb = tvb_new_subset_remaining(tvb, offset)_",0
"  dissect_ntlmssp_payload_only(data_tvb, pinfo, NULL, &decrypted_tvb)_",0
  return decrypted_tvb_,0
  /* gssapi_decrypted_tvb = NULL */,0
  guint32              encrypted_block_length_,0
  ntlmssp_info        *conv_ntlmssp_info   = NULL_,0
"  encrypted_block_length = tvb_length_remaining (data_tvb, offset)_",0
"  fprintf(stderr, ""Called dissect_ntlmssp_encrypted_payload\n"")_",0
"  packet_ntlmssp_info = p_get_proto_data(wmem_file_scope(), pinfo, proto_ntlmssp, NTLMSSP_PACKET_INFO_KEY)_",0
"    conv_ntlmssp_info = conversation_get_proto_data(conversation,",0
    /* There is no NTLMSSP state tied to the conversation */,0
    /* Get the pair of RC4 state structures.  One is used for to decrypt the,0
       payload.  The other is used to re-encrypt the payload to represent,0
       the peer */,0
    if (conv_ntlmssp_info->server_dest_port == pinfo->destport) {,0
"      rc4_handle = get_encrypted_state(pinfo, 1)_",0
"      rc4_handle_peer = get_encrypted_state(pinfo, 0)_",0
"      rc4_handle = get_encrypted_state(pinfo, 0)_",0
"      rc4_handle_peer = get_encrypted_state(pinfo, 1)_",0
    if (rc4_handle == NULL || rc4_handle_peer == NULL) {,0
"      /* There is no encryption state, so we cannot decrypt */",0
    /* Store the decrypted contents in the packet state struct,0
"       (of course at this point, they aren't decrypted yet) */",0
"    packet_ntlmssp_info->decrypted_payload = tvb_memdup(wmem_file_scope(), data_tvb, offset,",0
                                                        encrypted_block_length)_,0
"    decrypted_payloads = g_slist_prepend(decrypted_payloads,",0
                                         packet_ntlmssp_info->decrypted_payload)_,0
    /* Do the decryption of the payload */,0
"    if (gcry_cipher_encrypt(*rc4_handle, packet_ntlmssp_info->decrypted_payload, encrypted_block_length, NULL, 0)) {",0
    /* We setup a temporary buffer so we can re-encrypt the payload after,0
       decryption.  This is to update the opposite peer's RC4 state */,0
"    peer_block = wmem_memdup(wmem_packet_scope(), packet_ntlmssp_info->decrypted_payload, encrypted_block_length)_",0
"    if (gcry_cipher_encrypt(*rc4_handle_peer, peer_block, encrypted_block_length, NULL, 0)) {",0
    packet_ntlmssp_info->payload_decrypted = TRUE_,0
"  decr_tvb = tvb_new_child_real_data(data_tvb, packet_ntlmssp_info->decrypted_payload,",0
  offset += encrypted_block_length_,0
header_hash(gconstpointer pointer),0
"  guint32 crc =  ~crc32c_calculate(pointer, NTLMSSP_KEY_LEN, CRC32C_PRELOAD)_",0
"  /* Mat TBD fprintf(stderr, ""Val: %u\n"", crc)_*/",0
  return crc_,0
"header_equal(gconstpointer pointer1, gconstpointer pointer2)",0
"  if (!memcmp(pointer1, pointer2, 16)) {",0
ntlmssp_init_protocol(void),0
"  hash_packet = g_hash_table_new(header_hash, header_equal)_",0
ntlmssp_cleanup_protocol(void),0
  if (decrypted_payloads != NULL) {,0
    g_slist_free(decrypted_payloads)_,0
    decrypted_payloads = NULL_,0
  g_hash_table_destroy(hash_packet)_,0
"wrap_dissect_ntlmssp(tvbuff_t *tvb, int offset, packet_info *pinfo,",0
"                     proto_tree *tree, dcerpc_info *di _U_, guint8 *drep _U_)",0
  tvbuff_t *auth_tvb_,0
"  auth_tvb = tvb_new_subset_remaining(tvb, offset)_",0
"  dissect_ntlmssp(auth_tvb, pinfo, tree, NULL)_",0
"  return tvb_captured_length_remaining(tvb, offset)_",0
"wrap_dissect_ntlmssp_verf(tvbuff_t *tvb, int offset, packet_info *pinfo,",0
"                          proto_tree *tree, dcerpc_info *di _U_, guint8 *drep _U_)",0
"  return dissect_ntlmssp_verf(auth_tvb, pinfo, tree, NULL)_",0
static dcerpc_auth_subdissector_fns ntlmssp_sign_fns = {,0
"  wrap_dissect_ntlmssp,                 /* Bind */",0
"  wrap_dissect_ntlmssp,                 /* Bind ACK */",0
"  wrap_dissect_ntlmssp,                 /* AUTH3 */",0
"  wrap_dissect_ntlmssp_verf,            /* Request verifier */",0
"  wrap_dissect_ntlmssp_verf,            /* Response verifier */",0
"  NULL,                                 /* Request data */",0
  NULL                                  /* Response data */,0
static dcerpc_auth_subdissector_fns ntlmssp_seal_fns = {,0
"  wrap_dissect_ntlmssp_payload_only,    /* Request data */",0
  wrap_dissect_ntlmssp_payload_only     /* Response data */,0
proto_register_ntlmssp(void),0
  static hf_register_info hf[] = {,0
"    { &hf_ntlmssp_auth,",0
"      { ""NTLMSSP identifier"", ""ntlmssp.identifier"",",0
"        FT_STRING, BASE_NONE, NULL, 0x0,",1
"        NULL, HFILL }",1
"    { &hf_ntlmssp_message_type,",0
"      { ""NTLM Message Type"", ""ntlmssp.messagetype"",",0
"        FT_UINT32, BASE_HEX, VALS(ntlmssp_message_types), 0x0,",0
"    { &hf_ntlmssp_negotiate_flags,",0
"      { ""Negotiate Flags"", ""ntlmssp.negotiateflags"",",0
"        FT_UINT32, BASE_HEX, NULL, 0x0,",1
"    { &hf_ntlmssp_negotiate_flags_01,",0
"      { ""Negotiate UNICODE"", ""ntlmssp.negotiateunicode"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_UNICODE,",0
"    { &hf_ntlmssp_negotiate_flags_02,",0
"      { ""Negotiate OEM"", ""ntlmssp.negotiateoem"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_OEM,",0
"    { &hf_ntlmssp_negotiate_flags_04,",0
"      { ""Request Target"", ""ntlmssp.requesttarget"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_REQUEST_TARGET,",0
"    { &hf_ntlmssp_negotiate_flags_08,",0
"      { ""Request 0x00000008"", ""ntlmssp.negotiate00000008"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_00000008,",0
"    { &hf_ntlmssp_negotiate_flags_10,",0
"      { ""Negotiate Sign"", ""ntlmssp.negotiatesign"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_SIGN,",0
"    { &hf_ntlmssp_negotiate_flags_20,",0
"      { ""Negotiate Seal"", ""ntlmssp.negotiateseal"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_SEAL,",0
"    { &hf_ntlmssp_negotiate_flags_40,",0
"      { ""Negotiate Datagram"", ""ntlmssp.negotiatedatagram"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_DATAGRAM,",0
"    { &hf_ntlmssp_negotiate_flags_80,",0
"      { ""Negotiate Lan Manager Key"", ""ntlmssp.negotiatelmkey"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_LM_KEY,",0
"    { &hf_ntlmssp_negotiate_flags_100,",0
"      { ""Negotiate 0x00000100"", ""ntlmssp.negotiate00000100"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_00000100,",0
"    { &hf_ntlmssp_negotiate_flags_200,",0
"      { ""Negotiate NTLM key"", ""ntlmssp.negotiatentlm"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_NTLM,",0
"    { &hf_ntlmssp_negotiate_flags_400,",0
"      { ""Negotiate NT Only"", ""ntlmssp.negotiatentonly"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_NT_ONLY,",0
"    { &hf_ntlmssp_negotiate_flags_800,",0
"      { ""Negotiate Anonymous"", ""ntlmssp.negotiateanonymous"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_ANONYMOUS,",0
"    { &hf_ntlmssp_negotiate_flags_1000,",0
"      { ""Negotiate OEM Domain Supplied"", ""ntlmssp.negotiateoemdomainsupplied"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED,",0
"    { &hf_ntlmssp_negotiate_flags_2000,",0
"      { ""Negotiate OEM Workstation Supplied"", ""ntlmssp.negotiateoemworkstationsupplied"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED,",0
"    { &hf_ntlmssp_negotiate_flags_4000,",0
"      { ""Negotiate 0x00004000"", ""ntlmssp.negotiate00004000"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_00004000,",0
"    { &hf_ntlmssp_negotiate_flags_8000,",0
"      { ""Negotiate Always Sign"", ""ntlmssp.negotiatealwayssign"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_ALWAYS_SIGN,",0
"    { &hf_ntlmssp_negotiate_flags_10000,",0
"      { ""Target Type Domain"", ""ntlmssp.targettypedomain"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_TARGET_TYPE_DOMAIN,",0
"    { &hf_ntlmssp_negotiate_flags_20000,",0
"      { ""Target Type Server"", ""ntlmssp.targettypeserver"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_TARGET_TYPE_SERVER,",0
"    { &hf_ntlmssp_negotiate_flags_40000,",0
"      { ""Target Type Share"", ""ntlmssp.targettypeshare"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_TARGET_TYPE_SHARE,",0
/* Negotiate Flags */,0
"    { &hf_ntlmssp_negotiate_flags_80000,",0
"      { ""Negotiate Extended Security"", ""ntlmssp.negotiatentlm2"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_EXTENDED_SECURITY,",0
"    { &hf_ntlmssp_negotiate_flags_100000,",0
"      { ""Negotiate Identify"", ""ntlmssp.negotiateidentify"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_IDENTIFY,",0
"    { &hf_ntlmssp_negotiate_flags_200000,",0
"      { ""Negotiate 0x00200000"", ""ntlmssp.negotiatent00200000"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_00200000,",0
"    { &hf_ntlmssp_negotiate_flags_400000,",0
"      { ""Request Non-NT Session"", ""ntlmssp.requestnonntsession"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_REQUEST_NON_NT_SESSION,",0
"    { &hf_ntlmssp_negotiate_flags_800000,",0
"      { ""Negotiate Target Info"", ""ntlmssp.negotiatetargetinfo"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_TARGET_INFO,",0
"    { &hf_ntlmssp_negotiate_flags_1000000,",0
"      { ""Negotiate 0x01000000"", ""ntlmssp.negotiatent01000000"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_01000000,",0
"    { &hf_ntlmssp_negotiate_flags_2000000,",0
"      { ""Negotiate Version"", ""ntlmssp.negotiateversion"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_VERSION,",0
"    { &hf_ntlmssp_negotiate_flags_4000000,",0
"      { ""Negotiate 0x04000000"", ""ntlmssp.negotiatent04000000"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_04000000,",0
"    { &hf_ntlmssp_negotiate_flags_8000000,",0
"      { ""Negotiate 0x08000000"", ""ntlmssp.negotiatent08000000"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_08000000,",0
"    { &hf_ntlmssp_negotiate_flags_10000000,",0
"      { ""Negotiate 0x10000000"", ""ntlmssp.negotiatent10000000"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_10000000,",0
"    { &hf_ntlmssp_negotiate_flags_20000000,",0
"      { ""Negotiate 128"", ""ntlmssp.negotiate128"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_128,",0
"        ""128-bit encryption is supported"", HFILL }",0
"    { &hf_ntlmssp_negotiate_flags_40000000,",0
"      { ""Negotiate Key Exchange"", ""ntlmssp.negotiatekeyexch"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_KEY_EXCH,",0
"    { &hf_ntlmssp_negotiate_flags_80000000,",0
"      { ""Negotiate 56"", ""ntlmssp.negotiate56"",",0
"        FT_BOOLEAN, 32, TFS (&tfs_set_notset), NTLMSSP_NEGOTIATE_56,",0
"        ""56-bit encryption is supported"", HFILL }",0
"    { &hf_ntlmssp_negotiate_workstation_strlen,",0
"      { ""Calling workstation name length"", ""ntlmssp.negotiate.callingworkstation.strlen"",",0
"        FT_UINT16, BASE_DEC, NULL, 0x0,",1
"    { &hf_ntlmssp_negotiate_workstation_maxlen,",0
"      { ""Calling workstation name max length"", ""ntlmssp.negotiate.callingworkstation.maxlen"",",0
"    { &hf_ntlmssp_negotiate_workstation_buffer,",0
"      { ""Calling workstation name buffer"", ""ntlmssp.negotiate.callingworkstation.buffer"",",0
"    { &hf_ntlmssp_negotiate_workstation,",0
"      { ""Calling workstation name"", ""ntlmssp.negotiate.callingworkstation"",",0
"    { &hf_ntlmssp_negotiate_domain_strlen,",0
"      { ""Calling workstation domain length"", ""ntlmssp.negotiate.domain.strlen"",",0
"    { &hf_ntlmssp_negotiate_domain_maxlen,",0
"      { ""Calling workstation domain max length"", ""ntlmssp.negotiate.domain.maxlen"",",0
"    { &hf_ntlmssp_negotiate_domain_buffer,",0
"      { ""Calling workstation domain buffer"", ""ntlmssp.negotiate.domain.buffer"",",0
"    { &hf_ntlmssp_negotiate_domain,",0
"      { ""Calling workstation domain"", ""ntlmssp.negotiate.domain"",",0
"    { &hf_ntlmssp_ntlm_client_challenge,",0
"      { ""LMv2 Client Challenge"", ""ntlmssp.ntlmclientchallenge"",",0
"        FT_BYTES, BASE_NONE, NULL, 0x0,",1
"        ""The 8-byte LMv2 challenge message generated by the client"", HFILL }",0
"    { &hf_ntlmssp_ntlm_server_challenge,",0
"      { ""NTLM Server Challenge"", ""ntlmssp.ntlmserverchallenge"",",0
"    { &hf_ntlmssp_reserved,",0
"      { ""Reserved"", ""ntlmssp.reserved"",",0
"    { &hf_ntlmssp_challenge_target_name,",0
"      { ""Target Name"", ""ntlmssp.challenge.target_name"",",0
"    { &hf_ntlmssp_auth_domain,",0
"      { ""Domain name"", ""ntlmssp.auth.domain"",",0
"    { &hf_ntlmssp_auth_username,",0
"      { ""User name"", ""ntlmssp.auth.username"",",0
"    { &hf_ntlmssp_auth_hostname,",0
"      { ""Host name"", ""ntlmssp.auth.hostname"",",0
"    { &hf_ntlmssp_auth_lmresponse,",0
"      { ""Lan Manager Response"", ""ntlmssp.auth.lmresponse"",",0
"    { &hf_ntlmssp_auth_ntresponse,",0
"      { ""NTLM Response"", ""ntlmssp.auth.ntresponse"",",0
"    { &hf_ntlmssp_auth_sesskey,",0
"      { ""Session Key"", ""ntlmssp.auth.sesskey"",",0
"    { &hf_ntlmssp_string_len,",0
"      { ""Length"", ""ntlmssp.string.length"",",0
"        NULL, HFILL}",0
"    { &hf_ntlmssp_string_maxlen,",0
"      { ""Maxlen"", ""ntlmssp.string.maxlen"",",0
"    { &hf_ntlmssp_string_offset,",0
"      { ""Offset"", ""ntlmssp.string.offset"",",0
"        FT_UINT32, BASE_DEC, NULL, 0x0,",1
"    { &hf_ntlmssp_blob_len,",0
"      { ""Length"", ""ntlmssp.blob.length"",",0
"    { &hf_ntlmssp_blob_maxlen,",0
"      { ""Maxlen"", ""ntlmssp.blob.maxlen"",",0
"    { &hf_ntlmssp_blob_offset,",0
"      { ""Offset"", ""ntlmssp.blob.offset"",",0
"    { &hf_ntlmssp_version,",0
"      { ""Version"", ""ntlmssp.version"",",0
"        FT_NONE, BASE_NONE, NULL, 0x0,",1
"    { &hf_ntlmssp_version_major,",0
"      { ""Major Version"", ""ntlmssp.version.major"",",0
"        FT_UINT8, BASE_DEC, NULL, 0x0,",1
"    { &hf_ntlmssp_version_minor,",0
"      { ""Minor Version"", ""ntlmssp.version.minor"",",0
"    { &hf_ntlmssp_version_build_number,",0
"      { ""Build Number"", ""ntlmssp.version.build_number"",",0
"    { &hf_ntlmssp_version_ntlm_current_revision,",0
"      { ""NTLM Current Revision"", ""ntlmssp.version.ntlm_current_revision"",",0
/* Target Info */,0
"    { &hf_ntlmssp_challenge_target_info,",0
"      { ""Target Info"", ""ntlmssp.challenge.target_info"",",0
"    { &hf_ntlmssp_challenge_target_info_len,",0
"      { ""Length"", ""ntlmssp.challenge.target_info.length"",",0
"    { &hf_ntlmssp_challenge_target_info_maxlen,",0
"      { ""Maxlen"", ""ntlmssp.challenge.target_info.maxlen"",",0
"    { &hf_ntlmssp_challenge_target_info_offset,",0
"      { ""Offset"", ""ntlmssp.challenge.target_info.offset"",",0
"    { &hf_ntlmssp_challenge_target_info_item_type,",0
"      { ""Target Info Item Type"", ""ntlmssp.challenge.target_info.item.type"",",0
"        FT_UINT16, BASE_HEX | BASE_EXT_STRING, &ntlm_name_types_ext, 0x0,",0
"    { &hf_ntlmssp_challenge_target_info_item_len,",0
"      { ""Target Info Item Length"", ""ntlmssp.challenge.target_info.item.length"",",0
"    { &hf_ntlmssp_challenge_target_info_end,",0
"      { ""List End"", ""ntlmssp.challenge.target_info.end"",",0
"    { &hf_ntlmssp_challenge_target_info_nb_computer_name,",0
"      { ""NetBIOS Computer Name"", ""ntlmssp.challenge.target_info.nb_computer_name"",",0
"        ""Server NetBIOS Computer Name"", HFILL }",0
"    { &hf_ntlmssp_challenge_target_info_nb_domain_name,",0
"      { ""NetBIOS Domain Name"", ""ntlmssp.challenge.target_info.nb_domain_name"",",0
"        ""Server NetBIOS Domain Name"", HFILL }",0
"    { &hf_ntlmssp_challenge_target_info_dns_computer_name,",0
"      { ""DNS Computer Name"", ""ntlmssp.challenge.target_info.dns_computer_name"",",0
"    { &hf_ntlmssp_challenge_target_info_dns_domain_name,",0
"      { ""DNS Domain Name"", ""ntlmssp.challenge.target_info.dns_domain_name"",",0
"    { &hf_ntlmssp_challenge_target_info_dns_tree_name,",0
"      { ""DNS Tree Name"", ""ntlmssp.challenge.target_info.dns_tree_name"",",0
"    { &hf_ntlmssp_challenge_target_info_flags,",0
"      { ""Flags"", ""ntlmssp.challenge.target_info.flags"",",0
"    { &hf_ntlmssp_challenge_target_info_timestamp,",0
"      { ""Timestamp"", ""ntlmssp.challenge.target_info.timestamp"",",0
"        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0,",0
"    { &hf_ntlmssp_challenge_target_info_restrictions,",0
"      { ""Restrictions"", ""ntlmssp.challenge.target_info.restrictions"",",0
"        FT_BYTES, BASE_NONE, NULL, 0,",1
"    { &hf_ntlmssp_challenge_target_info_target_name,",0
"      { ""Target Name"", ""ntlmssp.challenge.target_info.target_name"",",0
"    { &hf_ntlmssp_challenge_target_info_channel_bindings,",0
"      { ""Channel Bindings"", ""ntlmssp.challenge.target_info.channel_bindings"",",0
"    { &hf_ntlmssp_ntlmv2_response_item_type,",0
"      { ""NTLMV2 Response Item Type"", ""ntlmssp.ntlmv2_response.item.type"",",0
"    { &hf_ntlmssp_ntlmv2_response_item_len,",0
"      { ""NTLMV2 Response Item Length"", ""ntlmssp.ntlmv2_response.item.length"",",0
"    { &hf_ntlmssp_ntlmv2_response_end,",0
"      { ""List End"", ""ntlmssp.ntlmv2_response.end"",",0
"    { &hf_ntlmssp_ntlmv2_response_nb_computer_name,",0
"      { ""NetBIOS Computer Name"", ""ntlmssp.ntlmv2_response.nb_computer_name"",",0
"    { &hf_ntlmssp_ntlmv2_response_nb_domain_name,",0
"      { ""NetBIOS Domain Name"", ""ntlmssp.ntlmv2_response.nb_domain_name"",",0
"    { &hf_ntlmssp_ntlmv2_response_dns_computer_name,",0
"      { ""DNS Computer Name"", ""ntlmssp.ntlmv2_response.dns_computer_name"",",0
"    { &hf_ntlmssp_ntlmv2_response_dns_domain_name,",0
"      { ""DNS Domain Name"", ""ntlmssp.ntlmv2_response.dns_domain_name"",",0
"    { &hf_ntlmssp_ntlmv2_response_dns_tree_name,",0
"      { ""DNS Tree Name"", ""ntlmssp.ntlmv2_response.dns_tree_name"",",0
"    { &hf_ntlmssp_ntlmv2_response_flags,",0
"      { ""Flags"", ""ntlmssp.ntlmv2_response.flags"",",0
"    { &hf_ntlmssp_ntlmv2_response_timestamp,",0
"      { ""Timestamp"", ""ntlmssp.ntlmv2_response.timestamp"",",0
"    { &hf_ntlmssp_ntlmv2_response_restrictions,",0
"      { ""Restrictions"", ""ntlmssp.ntlmv2_response.restrictions"",",0
"    { &hf_ntlmssp_ntlmv2_response_target_name,",0
"      { ""Target Name"", ""ntlmssp.ntlmv2_response.target_name"",",0
"    { &hf_ntlmssp_ntlmv2_response_channel_bindings,",0
"      { ""Channel Bindings"", ""ntlmssp.ntlmv2_response.channel_bindings"",",0
"    { &hf_ntlmssp_message_integrity_code,",0
"      { ""MIC"", ""ntlmssp.authenticate.mic"",",0
"        ""Message Integrity Code"", HFILL}",0
"    { &hf_ntlmssp_verf,",0
"      { ""NTLMSSP Verifier"", ""ntlmssp.verf"",",0
"    { &hf_ntlmssp_verf_vers,",0
"      { ""Version Number"", ""ntlmssp.verf.vers"",",0
"    { &hf_ntlmssp_verf_body,",0
"      { ""Verifier Body"", ""ntlmssp.verf.body"",",0
"    { &hf_ntlmssp_decrypted_payload,",0
"      { ""NTLM Decrypted Payload"", ""ntlmssp.decrypted_payload"",",0
"    { &hf_ntlmssp_verf_randompad,",0
"      { ""Random Pad"", ""ntlmssp.verf.randompad"",",0
"    { &hf_ntlmssp_verf_crc32,",0
"      { ""Verifier CRC32"", ""ntlmssp.verf.crc32"",",0
"    { &hf_ntlmssp_verf_hmacmd5,",0
"      { ""HMAC MD5"", ""ntlmssp.verf.hmacmd5"",",0
"    { &hf_ntlmssp_verf_sequence,",0
"      { ""Sequence"", ""ntlmssp.verf.sequence"",",0
"    { &hf_ntlmssp_ntlmv2_response,",0
"      { ""NTLMv2 Response"", ""ntlmssp.ntlmv2_response"",",0
"    { &hf_ntlmssp_ntlmv2_response_ntproofstr,",0
"      { ""NTProofStr"", ""ntlmssp.ntlmv2_response.ntproofstr"",",0
"        ""The HMAC-MD5 of the challenge"", HFILL }",0
"    { &hf_ntlmssp_ntlmv2_response_rversion,",0
"      { ""Response Version"", ""ntlmssp.ntlmv2_response.rversion"",",0
"        ""The 1-byte response version, currently set to 1"", HFILL }",0
"    { &hf_ntlmssp_ntlmv2_response_hirversion,",0
"      { ""Hi Response Version"", ""ntlmssp.ntlmv2_response.hirversion"",",0
"        ""The 1-byte highest response version understood by the client, currently set to 1"", HFILL }",0
"    { &hf_ntlmssp_ntlmv2_response_z,",0
"      { ""Z"", ""ntlmssp.ntlmv2_response.z"",",0
"        ""byte array of zero bytes"", HFILL }",0
"    { &hf_ntlmssp_ntlmv2_response_pad,",0
"      { ""padding"", ""ntlmssp.ntlmv2_response.pad"",",0
"    { &hf_ntlmssp_ntlmv2_response_time,",0
"      { ""Time"", ""ntlmssp.ntlmv2_response.time"",",0
"        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0,",0
"        ""The 8-byte little-endian time in UTC"", HFILL }",0
"    { &hf_ntlmssp_ntlmv2_response_chal,",0
"      { ""NTLMv2 Client Challenge"", ""ntlmssp.ntlmv2_response.chal"",",0
"        ""The 8-byte NTLMv2 challenge message generated by the client"", HFILL }",0
  }_,0
  static gint *ett[] = {,0
"    &ett_ntlmssp,",0
"    &ett_ntlmssp_negotiate_flags,",0
"    &ett_ntlmssp_string,",0
"    &ett_ntlmssp_blob,",0
"    &ett_ntlmssp_version,",0
"    &ett_ntlmssp_challenge_target_info,",0
"    &ett_ntlmssp_challenge_target_info_item,",0
"    &ett_ntlmssp_ntlmv2_response,",0
"    &ett_ntlmssp_ntlmv2_response_item,",0
  static ei_register_info ei[] = {,0
"     { &ei_ntlmssp_v2_key_too_long, { ""ntlmssp.v2_key_too_long"", PI_UNDECODED, PI_WARN, ""NTLM v2 key is too long"", EXPFILL }},",0
"     { &ei_ntlmssp_blob_len_too_long, { ""ntlmssp.blob.length.too_long"", PI_UNDECODED, PI_WARN, ""Session blob length too long"", EXPFILL }},",0
"     { &ei_ntlmssp_target_info_attr, { ""ntlmssp.target_info_attr.unknown"", PI_UNDECODED, PI_WARN, ""unknown NTLMSSP Target Info Attribute"", EXPFILL }},",0
"     { &ei_ntlmssp_message_type, { ""ntlmssp.messagetype.unknown"", PI_PROTOCOL, PI_WARN, ""Unrecognized NTLMSSP Message"", EXPFILL }},",0
  module_t *ntlmssp_module_,0
  expert_module_t* expert_ntlmssp_,0
  proto_ntlmssp = proto_register_protocol (,0
"    ""NTLM Secure Service Provider"", /* name */",0
"    ""NTLMSSP"",  /* short name */",0
"    ""ntlmssp""   /* abbrev */",0
    )_,0
"  proto_register_field_array (proto_ntlmssp, hf, array_length (hf))_",0
"  proto_register_subtree_array (ett, array_length (ett))_",0
  expert_ntlmssp = expert_register_protocol(proto_ntlmssp)_,0
"  expert_register_field_array(expert_ntlmssp, ei, array_length(ei))_",0
  register_init_routine(&ntlmssp_init_protocol)_,0
  register_cleanup_routine(&ntlmssp_cleanup_protocol)_,0
"  ntlmssp_module = prefs_register_protocol(proto_ntlmssp, NULL)_",0
"  prefs_register_string_preference(ntlmssp_module, ""nt_password"",",0
"                                   ""NT Password"",",0
"                                   ""NT Password (used to decrypt payloads)"",",0
                                   &gbl_nt_password)_,0
"  ntlmssp_handle = register_dissector(""ntlmssp"", dissect_ntlmssp, proto_ntlmssp)_",0
"  ntlmssp_wrap_handle = register_dissector(""ntlmssp_payload"", dissect_ntlmssp_payload, proto_ntlmssp)_",0
"  register_dissector(""ntlmssp_data_only"", dissect_ntlmssp_payload_only, proto_ntlmssp)_",0
"  register_dissector(""ntlmssp_verf"", dissect_ntlmssp_verf, proto_ntlmssp)_",0
proto_reg_handoff_ntlmssp(void),0
  /* Register protocol with the GSS-API module */,0
"  gssapi_init_oid(""1.3.6.1.4.1.311.2.2.10"", proto_ntlmssp, ett_ntlmssp,",0
"                  ntlmssp_handle, ntlmssp_wrap_handle,",0
"                  ""NTLMSSP - Microsoft NTLM Security Support Provider"")_",0
  /* Register authenticated pipe dissector */,0
   * XXX - the verifiers here seem to have a version of 1 and a body of all,0
   * zeroes.,0
"   * XXX - DCE_C_AUTHN_LEVEL_CONNECT is, according to the DCE RPC 1.1",0
"   * spec, upgraded to DCE_C_AUTHN_LEVEL_PKT.  Should we register",0
   * any other levels here?,0
"  register_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_CONNECT,",0
"                                    DCE_C_RPC_AUTHN_PROTOCOL_NTLMSSP,",0
                                    &ntlmssp_sign_fns)_,0
"  register_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT,",0
"  register_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT_INTEGRITY,",0
"  register_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT_PRIVACY,",0
                                    &ntlmssp_seal_fns)_,0
"  ntlmssp_tap = register_tap(""ntlmssp"")_",0
"  heur_dissector_add(""credssp"", dissect_ntlmssp_heur, ""NTLMSSP over CredSSP"", ""ntlmssp_credssp"", proto_ntlmssp, HEURISTIC_ENABLE)_",0
 * c-basic-offset: 2,0
 * vi: set shiftwidth=2 tabstop=8 expandtab:,0
 * :indentSize=2:tabSize=8:noTabs=true:,0
"                        proto_tree_add_item(ua3g_param_tree, hf_ua3g_ip_device_routing_reset_parameter_appl_mode, tvb, offset, parameter_length, ENC_BIG_ENDIAN)_",1
"                        proto_tree_add_item(ua3g_param_tree, hf_ua3g_ip_device_routing_reset_parameter_reset_mac, tvb, offset, parameter_length, ENC_BIG_ENDIAN)_",1
static dissector_handle_t ieee80211_handle_,0
static int hf_radiotap_grp_id = -1_,0
static int hf_radiotap_beamformed = -1_,0
"            flttmp = (float)round(tvb_get_ntohs(tvb, offset) / 16.0f)_",0
"            rf_infot = proto_tree_add_none_format(vw_rfinfo_tree, hf_radiotap_rfinfo_sigdata, tvb, offset, 8, ""AVG EVM SIG Data:    "")_",0
"        proto_tree_add_item(tap_tree, hf_ixveriwave_vwf_txf,",0
    //phdr.presence_flags = 0_,0
"            proto_tree_add_uint(vw_plcpinfo_tree, hf_radiotap_grp_id,",0
"                proto_tree_add_uint(vw_plcpinfo_tree, hf_radiotap_su_nsts,",0
"                proto_tree_add_uint_format(vw_plcpinfo_tree, hf_radiotap_vht_su_coding_type,",0
"            proto_tree_add_item(vw_plcpinfo_tree, hf_radiotap_beamformed, tvb, offset, 1, ENC_NA)_",0
"    { &hf_radiotap_grp_id,",0
"        { ""VHT Group Id"", ""ixveriwave.VHT_GRPID"",",0
"    { &hf_radiotap_su_nsts,",0
"        { ""VHT NSTS"", ""ixveriwave.VHT_SU_NSTS"",",0
"        { ""SU Partial ID})"", ""ixveriwave.VHT_SU_PARTIAL_AID"",",0
"        { ""Coding Type"", ""ixveriwave.vht_su_coding_type"",",0
"    { &hf_radiotap_vht_u0_nsts,",0
"    { &hf_radiotap_beamformed,",0
"        { ""VHT Beamformed"", ""ixveriwave.VHT_BEAMFORMED"",",0
"    ieee80211_handle         = find_dissector_add_dependency(""wlan"", proto_ixveriwave)_",0
"static const char * global_filter_nodes = """"_",1
"                proto_item_append_text(phi_angle, ""PHI%d%d: %d, "", ir, ic, angle_val)_",0
"                proto_item_append_text(psi_angle, ""PSI%d%d: %d, "", ir, ic, angle_val)_",0
"        { &hf_ua3g_ip_device_routing_set_param_req_parameter_err_string, { ""Value"", ""ua3g.ip.set_param_req.parameter.err_string"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},",1
"    header_item = proto_tree_add_item(tree, hf_ieee802154_header_ie, tvb, *offset, -1, ENC_NA)_",1
            // TODO,1
            case 1:,0
	$(AM_V_LEX)$(LEX) -o$@ --header-file=$(@:.l=_lex.h) $<,0
"                            proto_tree_add_bytes_format_value(ua3g_param_tree, hf_ua3g_cs_ip_device_routing_cmd02_parameter_tscip_version, tvb, offset, 3, NULL, ""%d.%02d.%02d"", r, ss, ff)_",0
"void BluetoothDevicesDialog::tableItemDoubleClicked(QTreeWidgetItem *item, int column)",0
"gboolean MainWindow::addExportObjectsMenuItem(const void *key, void *value, void *userdata)",0
"		(strncmp((const gchar*)option_data->vendor_class_id, ""ArubaInstantAP"", strlen(""ArubaInstantAP"")) != 0))",0
	   XXX - Should we just diable by default? */,0
"        { &hf_ua3g_unsolicited_msg_hardware_config_export_full,",0
"            { ""Binary Type"", ""ua3g.unsolicited_msg.hardware_config.export_full"",",0
"            { ""Hardware Generation"", ""ua3g.unsolicited_msg.hardware_config.3g_set"",",0
"    GSM_MAP_RP_OA_NO_ID = 0,",0
		PROTO_ITEM_SET_GENERATED(r_ti)_,0
	if (tokenlen >= 1) {,0
"* Returns value from buffer if bufLength matches length parsed from data, 0 otherwise.",0
* @param bufLength [out]       Used to store determined buffer length,0
* @return                      Uncompressed value,0
"    char* com_token = (char*)wmem_alloc(wmem_packet_scope(), data_len+1)_",0
    int	com_token_length_,0
        if ((!*text) || (start == text_len)),0
"    col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, ""Key Server"")_",0
"	g_hash_table_foreach_remove(fvt_cache,free_value,NULL)_",0
"	fvt_cache = g_hash_table_new(g_str_hash,g_str_equal)_",0
        g_free(nl->name)_,0
        g_free(int_iter)_,0
"  g_hash_table_insert (table, key, ack_data2)_",0
"        wmem_map_insert (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP), ack_data)_",0
    *pkg_data = *p_mul_data_,0
"	<!ENTITY Juniper		SYSTEM ""Juinper.xml"">",0
#  License text for the above reference.),0
            || prefs_get_type(pref) == PREF_OPEN_FILENAME) {,0
				if (hfi_type->display & BASE_EXT_STRING) {,0
    code += 'static value_string_ext ws_%s_vals_ext =' % name,0
    /* TODO shouldn't genl just pass the parent tree? */,0
"    /* This is the first and only pass, so prime the epan_dissect_t",1
	offset = 0_,0
/* User string with the decryption key. */,1
static gboolean use_pan_id_in_key = FALSE_,1
static const gchar *thread_seq_ctr_str = NULL_,1
static gboolean thread_auto_acq_seq_ctr = TRUE_,1
static gboolean thread_seq_ctr_acqd = FALSE_,1
static guint8 thread_seq_ctr_bytes[4]_,1
static const guint8 thread_well_known_key[IEEE802154_CIPHER_SIZE] =,1
"{ 0x78, 0x58, 0x16, 0x86, 0xfd, 0xb4, 0x58, 0x0f, 0xb0, 0x92, 0x54, 0x6a, 0xec, 0xbd, 0x15, 0x66 }_",1
/* XXX - Should these somehow be folded into the 802.15.4 UAT structure? */,1
static guint8 ieee802154_temp_key[IEEE802154_CIPHER_SIZE]_,1
static guint8 ieee802154_temp_mle_key[IEEE802154_CIPHER_SIZE]_,1
static GByteArray *thread_set_seq_ctr_key_index(guint8 key_index),1
    GByteArray *seq_ctr_bytes = NULL_,1
    seq_ctr_bytes = g_byte_array_new()_,1
    if (thread_seq_ctr_acqd) {,1
"        seq_ctr_bytes = g_byte_array_set_size(seq_ctr_bytes, 4)_",1
"        memcpy(seq_ctr_bytes->data, thread_seq_ctr_bytes, 4)_",1
"        hex_str_to_bytes(thread_seq_ctr_str, seq_ctr_bytes, FALSE)_",1
        if (seq_ctr_bytes->len != 4) {,1
            /* Not read correctly - assume value is 0 */,1
"            seq_ctr_bytes = g_byte_array_set_size(seq_ctr_bytes, 4)_",1
"            memset(seq_ctr_bytes->data, 0, 4)_",1
    /* Replace lower part with counter based on packet key index */,1
    seq_ctr_bytes->data[3] = (seq_ctr_bytes->data[3] & 0x80) + ((key_index - 1) & 0x7F)_,1
    return seq_ctr_bytes_,1
"ieee802154_create_thread_temp_keys(GByteArray *seq_ctr_bytes, guint16 src_pan, ieee802154_key_t* key)",1
    GByteArray *bytes_,1
    char       buffer[10]_,1
    gboolean   res_,1
    gboolean   key_valid_,1
    gboolean   verbatim_key = TRUE_,1
    /* Get the IEEE 802.15.4 decryption key. */,1
    bytes = g_byte_array_new()_,1
"    res = hex_str_to_bytes(key->pref_key, bytes, FALSE)_",1
    key_valid = (res && bytes->len >= IEEE802154_CIPHER_SIZE)_,1
    if (key_valid) {,1
        if (use_pan_id_in_key) {,1
            /* Substitute the bottom two keys bytes with PAN ID */,1
            bytes->data[0] = (guint8)(src_pan & 0xFF)_,1
            bytes->data[1] = (guint8)(src_pan >> 8)_,1
        if (key->hash_type != KEY_HASH_NONE) {,1
            char digest[32]_,1
            if (key->hash_type == KEY_HASH_THREAD) {,1
"                memcpy(buffer, seq_ctr_bytes->data, 4)_",1
"                memcpy(&buffer[4], ""Thread"", 6)_ /* len(""Thread"") */",1
"                if (!ws_hmac_buffer(GCRY_MD_SHA256, digest, buffer, 10, bytes->data, IEEE802154_CIPHER_SIZE)) {",1
                    /* Copy upper hashed bytes to the key */,1
"                    memcpy(ieee802154_temp_key, &digest[IEEE802154_CIPHER_SIZE], IEEE802154_CIPHER_SIZE)_",1
                    /* Copy lower hashed bytes to the MLE key */,1
"                    memcpy(ieee802154_temp_mle_key, digest, IEEE802154_CIPHER_SIZE)_",1
                    verbatim_key = FALSE_,1
        if (verbatim_key) {,1
            /* Just copy the keys verbatim */,1
"            memcpy(ieee802154_temp_key, bytes->data, IEEE802154_CIPHER_SIZE)_",1
"            memcpy(ieee802154_temp_mle_key, bytes->data, IEEE802154_CIPHER_SIZE)_",1
"    g_byte_array_free(bytes, TRUE)_",1
/* Set MAC key for Thread hash */,1
"static gboolean thread_set_mac_key(ieee802154_packet * packet, unsigned char* key, unsigned char* alt_key, ieee802154_key_t* uat_key)",1
    if (packet->key_id_mode == KEY_ID_MODE_KEY_INDEX) {,1
        seq_ctr_bytes = thread_set_seq_ctr_key_index(packet->key_index)_,1
    } else if ((packet->key_id_mode == KEY_ID_MODE_KEY_EXPLICIT_4) &&,1
               (packet->key_index == IEEE802154_THR_WELL_KNOWN_KEY_INDEX) &&,1
               (packet->key_source.addr32 == IEEE802154_THR_WELL_KNOWN_KEY_SRC)),1
        /* This is the well-known key */,1
"        memcpy(key, thread_well_known_key, IEEE802154_CIPHER_SIZE)_",1
    if (seq_ctr_bytes != NULL) {,1
"        ieee802154_create_thread_temp_keys(seq_ctr_bytes, packet->src_pan, uat_key)_",1
"        memcpy(key, ieee802154_temp_key, IEEE802154_CIPHER_SIZE)_",1
        /* Create an alternate key based on the wraparound case */,1
        seq_ctr_bytes->data[3] ^= 0x80_,1
"        memcpy(alt_key, ieee802154_temp_key, IEEE802154_CIPHER_SIZE)_",1
"        g_byte_array_free(seq_ctr_bytes, TRUE)_",1
/* Set MLE key for Thread hash */,1
"static gboolean thread_set_mle_key(ieee802154_packet * packet, unsigned char* key, unsigned char* alt_key, ieee802154_key_t* uat_key)",1
    else if (packet->key_id_mode == KEY_ID_MODE_KEY_EXPLICIT_4) {,1
        /* Reconstruct the key source from the key source in the packet */,1
        seq_ctr_bytes = g_byte_array_new()_,1
        seq_ctr_bytes->data[0] = (packet->key_source.addr32 >> 24) & 0xFF_,1
        seq_ctr_bytes->data[1] = (packet->key_source.addr32 >> 16) & 0xFF_,1
        seq_ctr_bytes->data[2] = (packet->key_source.addr32 >> 8) & 0xFF_,1
        seq_ctr_bytes->data[3] = packet->key_source.addr32 & 0xFF_,1
        /* Acquire the sequence counter if configured in preferences */,1
        if (thread_auto_acq_seq_ctr && !thread_seq_ctr_acqd) {,1
"            memcpy(thread_seq_ctr_bytes, seq_ctr_bytes->data, 4)_",1
            thread_seq_ctr_acqd = TRUE_,1
"        memcpy(key, ieee802154_temp_mle_key, IEEE802154_CIPHER_SIZE)_",1
"        memcpy(alt_key, ieee802154_temp_mle_key, IEEE802154_CIPHER_SIZE)_",1
"    register_mle_key_hash_handler(KEY_HASH_THREAD, thread_set_mle_key)_",0
"        memcpy(d_a+16, (guint8 *)pinfo->dst.data, pinfo->dst.len)_",1
"                    proto_tree_add_item(tlv_tree, hf_mle_tlv_timeout, payload_tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"                    buffer = (guint8 *)wmem_alloc(wmem_packet_scope(), tlv_len + 4)_",1
#if THREAD_NWD_TLV_HAS_ROUTE_ENTRY_SIZE == 3,1
"                    tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, prefix_byte_len)_",1
    if (tokens[1] != NULL) {,1
            *payload_info->status = DECRYPT_PACKET_CRC_MAC_CHECK_FAILED_,0
        if (status == DECRYPT_PACKET_CRC_MAC_CHECK_FAILED),0
"        call_data_dissector(payload_tvb, pinfo, tree)_",0
                        for (i = 0_ i < count_ i++) {,1
                    /*  Flags & CID */,1
    uri_type = THREAD_COAP_URI_THREAD_,0
"    thread_coap_module = prefs_register_protocol(proto_thread_coap, proto_reg_handoff_thread_coap)_",0
"    /* Thread Content-Format is opaque byte string, i.e. application/octet-stream */",0
//#ifdef HAVE_CONFIG_H,0
#define THREAD_EXTENSIONS,0
 *  NAME,0
"        ti = proto_tree_add_item(header_tree, hf_mle_security_control, tvb, offset, 1, security_control)_",0
"        proto_tree_add_uint(field_tree, hf_mle_security_level, tvb, offset, 1, security_control & IEEE802154_AUX_SEC_LEVEL_MASK)_",0
    if (tree) {,1
"        proto_tree_add_uint(beacon_tree, hf_thread_bcn_protocol, tvb, offset, 1, proto_id)_",0
"                  ""noe.event_device_presence.state"",",0
  module_t *wlan_module_,0
	packet_info *pinfo_,0
"	WS_CTRL_ATTR_MCAST_GROUPS,",0
	(void)tvb_,0
"				label_fill_descr(label_str, 0, hfinfo, val_str, out)_",0
"            },",1
#define BASE_PROTOCOL_INFO      0x8000  /**< protocol_t in [FIELDCONVERT].  Internal use only. */,1
static gboolean ieee802154_pref_auto_acq_thr_seq_ctr = TRUE_,0
static void ieee802154_key_post_update_cb(void),0
"static gboolean ieee802154_key_update_cb(void *r, char **err)",0
    proto_item* ti_,1
    gboolean                srcPanPresent = FALSE_,1
            /* No problem */,0
    unsigned char       tmp[16]_,1
    guint            i = 0_,1
                    unsigned char *data_computed_md = NULL_,1
    if (rec->pref_key),1
"            err = gcry_md_open(&md_hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC)_",1
"    memset(ieee802154_thr_seq_ctr_bytes, 0, 4)_",0
"          packet->key_source.addr32 = tvb_get_ntohl(tvb, offset)_",0
"          packet->key_source.addr64 = tvb_get_ntoh64(tvb, offset)_",0
        /* Display the MIC. */,0
"    /* TODO: Implement a UAT for multiple keys, and with more advanced key management. */",0
    ieee802154_map_rec *map_rec_,0
    new_record->pref_key = g_strdup(old_record->pref_key)_,0
"        addrValue_item = proto_tree_add_bytes_format_value(addr_tree, hf_packetbb_addr_value[addressType],",1
        key[3].key = &side_id_,0
"        0x60, 0x00, 0x00, 0x00,",0
#define PROTOCOL_VER_0      0x00010000,0
"        &hf_dpnet_command_data,",0
"    proto_tree_add_bitmask(dpnet_tree, tvb, offset, hf_dpnet_data_command, ett_dpnet_command_flags, command_flags, ENC_BIG_ENDIAN)_ offset += 1_",0
"    proto_tree_add_item(dpnet_tree, hf_dpnet_data_cframe_control, tvb, offset, 1, ENC_LITTLE_ENDIAN)_ offset += 1_",0
"            """", HFILL}",0
"    { 23910, ""Slovenske zeleznice-Infrastruktura d.o.o."" },",0
static const value_string evt_context_switch_str_struct[] = {,0
"    { 0, ""Encryption: CCM with AES-128_ Signature: RSA with SHA-256"" },",0
#define OPCODE_P_B_address              30,0
"    proto_tree_add_ipv4_format_value(field_tree, hf_acn_blob_field_value_number, tvb, blob_offset, field_length, tvb_get_ipv4(tvb, blob_offset), ""Field Value: %u"", tvb_get_ipv4(tvb, blob_offset))_",0
  const gchar *range_type_,0
"  range_type = val_to_str(range, acn_blob_range_type_vals, ""not valid (%d)"")_",1
    if (protocol_id == ACN_PROTOCOL_ID_DMX_2) {,0
/* Blob Information */,0
  /* Create our tree */,0
"      command = tvb_get_ntohl(tvb, offset)_",0
static gfloat,0
static gdouble,0
    blob_offset += 1_,0
  if (tree) { /* we are being asked for details */,0
	*/,0
 * ********************************************************************** */,0
static int hf_nsha_version = -1_,0
"	nsha_handle = create_dissector_handle(dissect_ns_ha, proto_ns_ha)_",0
#define gslb_fixed_header_s 8 /*size of the gslb MEP header*/,0
typedef struct nsgslb_dom_info {,0
	/* Get the signature */,0
  	/* Get additional data from the packet */,0
"			ipaddr = tvb_get_ipv4(tvb, offset)_",0
			/* All the counters */,0
"    { 0, ""Medium"" },",0
        case T30_FC_DTC:,0
"	else if (!strcmp(tok_token, ""ssl-sessions""))",0
    if (plugin_list) {,1
    voip_calls_info_t *call_info = static_cast<voip_calls_info_t *>(callinfos_[index.row()])_,0
static const int start_time_col_ = 0_,1
static const int stop_time_col_ = 1_,1
static const int initial_speaker_col_ = 2_,1
static const int from_col_ = 3_,1
static const int to_col_ = 4_,1
static const int protocol_col_ = 5_,1
static const int duration_col_ = 6_,1
static const int packets_col_ = 7_,1
static const int state_col_ = 8_,1
    return static_cast<voip_calls_info_t *>(index.data(Qt::UserRole).value<void *>())_,1
        return QVariant::fromValue(static_cast<void *>(call_info))_,1
"    bool lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const_",1
    static inline voip_calls_info_t *indexToCallInfo(const QModelIndex &index),1
        return VariantPointer<voip_calls_info_t>::asPtr(index.data(Qt::UserRole))_,1
"   col_add_fstr( pinfo->cinfo, COL_INFO, ""%s, Update Id: %d"",",0
"        tmp16 = tvb_get_ntohs(tvb, offset)_",0
"        proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_distinguisher_type,",0
        case 0:,0
"                                     tvb, offset, 1, ENC_BIG_ENDIAN)_",0
"            /* Not valid. Tell the user, and go back and run the file",0
"                    pinfo->destport, pinfo->srcport, NO_ADDR_B)_",0
"static guint8 g_pdu_type, g_rim_application_identity_",0
"                 * message starts in the data it handed us, and how many",0
"        if (!device.selected && g_hash_table_lookup(selected_devices, device.name)) {",0
    /* Acknowledge with positive time correction in microseconds */,0
    if(raw_data <= 0x07ff) {,0
"        drift_item = proto_tree_add_item(time_correction_tree, hf_ieee802154_time_correction_value, tvb, *offset, 2, ENC_LITTLE_ENDIAN)_",0
"        proto_tree_add_boolean(h_inf_elem_tree_payload, hf_ieee802154_nack, tvb, *offset, 2, (gboolean) ((raw_data & (guint16)0x8000) ? 1 : 0))_",0
				 * have a precision in microseconds or greater.,0
" * Copyright 2006, Ravi Kondamuru <Ravi.Kondamuru@citrix.com>",0
 ** Wireshark - Network traffic analyzer,0
	guint16 data_length_,0
			{,0
		default:,0
"                umts_fp_conversation_info = wmem_new0(wmem_file_scope(), umts_fp_conversation_info_t)_",0
"                fill_pch_coversation_info_for_heur(umts_fp_conversation_info, pinfo)_",0
            /* TB present and PI bitmap length is known. Can calculate TB length.*/,0
value_string_ext mysql_command_vals_ext = VALUE_STRING_EXT_INIT(mysql_command_vals)_,0
/* packet-dcerpc-pn-io.c,1
 * Routines for PROFINET IO dissection.,1
 * The PN-IO protocol is a field bus protocol related to decentralized,1
" * periphery and is developed by the PROFIBUS Nutzerorganisation e.V. (PNO),",1
 * see: www.profibus.com,1
" * PN-IO is based on the common DCE-RPC and the ""lightweight"" PN-RT",1
 * (ethernet type 0x8892) protocols.,1
 * The context manager (CM) part is handling context information,1
" * (like establishing, ...) and is using DCE-RPC as its underlying",1
 * protocol.,1
 * The actual cyclic data transfer and acyclic notification uses the,1
" * ""lightweight"" PN-RT protocol.",1
" * There are some other related PROFINET protocols (e.g. PN-DCP, which is",1
 * handling addressing topics).,1
 * Please note: the PROFINET CBA protocol is independent of the PN-IO protocol!,1
 * Cyclic PNIO RTC1 Data Dissection:,1
" * To dissect cyclic PNIO RTC1 frames, this plug-in has to collect important module",1
" * information out of ""Ident OK"", ""Connect Request"" and ""Write Response""",1
" * frames first. This information will be used within ""packet-pn-rtc-one.c"" to",1
 * dissect PNIO and PROFIsafe RTC1 frames.,1
" * The data of Stationname-, -type and -id will be gained out of",1
 * packet-pn-dcp.c. The header packet-pn.h will save those data.,1
 * Overview for cyclic PNIO RTC1 data dissection functions:,1
" *   -> dissect_IOCRBlockReq_block     (Save amount of IODataObjects, IOCS)",1
 *   -> dissect_DataDescription        (Save important values for cyclic data),1
 *   -> dissect_ExpectedSubmoduleBlockReq_block    (Get GSD information),1
 *   -> dissect_ModuleDiffBlock_block  (Module has different ID),1
 *   -> dissect_ProfiSafeParameterRequest  (Save PROFIsafe parameters),1
 *   -> dissect_RecordDataWrite        (Call ProfiSafeParameterRequest),1
 *   -> pnio_rtc1_cleanup              (Reset routine of saved RTC1 information),1
#include <epan/wmem/wmem.h>,1
#include <epan/dissectors/packet-dcerpc.h>,1
#include <epan/dissector_filters.h>,1
#include <wsutil/file_util.h>,1
"#include ""packet-pn.h""",1
#include <stdlib.h>,1
void proto_register_pn_io(void)_,1
void proto_reg_handoff_pn_io(void)_,1
#define MAX_NAMELENGTH           200    /* max. length of the given paths */,1
#define F_MESSAGE_TRAILER_4BYTE  4      /* PROFIsafe: Defines the Amount of Bytes for CRC and Status-/Controlbyte */,1
#define PN_INPUT_CR              1      /* PROFINET Input Connect Request value */,1
#define PN_INPUT_DATADESCRITPION 1      /* PROFINET Input Data Description value */,1
static int proto_pn_io = -1_,1
static int proto_pn_io_device = -1_,1
static int proto_pn_io_controller = -1_,1
static int proto_pn_io_supervisor = -1_,1
static int proto_pn_io_parameterserver = -1_,1
static int proto_pn_io_implicitar = -1_,1
int proto_pn_io_apdu_status = -1_,1
static int hf_pn_io_opnum = -1_,1
static int hf_pn_io_reserved16 = -1_,1
static int hf_pn_io_array = -1_,1
static int hf_pn_io_status = -1_,1
static int hf_pn_io_args_max = -1_,1
static int hf_pn_io_args_len = -1_,1
static int hf_pn_io_array_max_count = -1_,1
static int hf_pn_io_array_offset = -1_,1
static int hf_pn_io_array_act_count = -1_,1
static int hf_pn_io_ar_type = -1_,1
static int hf_pn_io_artype_req = -1_,1
static int hf_pn_io_cminitiator_macadd = -1_,1
static int hf_pn_io_cminitiator_objectuuid = -1_,1
static int hf_pn_io_parameter_server_objectuuid = -1_,1
static int hf_pn_io_ar_data = -1_,1
static int hf_pn_io_ar_properties = -1_,1
static int hf_pn_io_ar_properties_state = -1_,1
static int hf_pn_io_ar_properties_supervisor_takeover_allowed = -1_,1
static int hf_pn_io_ar_properties_parametrization_server = -1_,1
/* removed within 2.3,1
static int hf_pn_io_ar_properties_data_rate = -1_,1
static int hf_pn_io_ar_properties_reserved_1 = -1_,1
static int hf_pn_io_ar_properties_device_access = -1_,1
static int hf_pn_io_ar_properties_companion_ar = -1_,1
static int hf_pn_io_ar_properties_achnowledge_companion_ar = -1_,1
static int hf_pn_io_ar_properties_reserved = -1_,1
static int hf_pn_io_ar_properties_combined_object_container_with_legacy_startupmode = -1_,1
static int hf_pn_io_ar_properties_combined_object_container_with_advanced_startupmode = -1_,1
static int hf_pn_io_ar_properties_pull_module_alarm_allowed = -1_,1
static int hf_pn_RedundancyInfo = -1_,1
static int hf_pn_RedundancyInfo_reserved = -1_,1
static int hf_pn_io_number_of_ARDATAInfo = -1_,1
static int hf_pn_io_cminitiator_activitytimeoutfactor = -1_,1
static int hf_pn_io_cminitiator_udprtport = -1_,1
static int hf_pn_io_station_name_length = -1_,1
static int hf_pn_io_cminitiator_station_name = -1_,1
/* static int hf_pn_io_responder_station_name = -1_ */,1
static int hf_pn_io_arproperties_StartupMode = -1_,1
static int hf_pn_io_parameter_server_station_name = -1_,1
static int hf_pn_io_cmresponder_macadd = -1_,1
static int hf_pn_io_cmresponder_udprtport = -1_,1
static int hf_pn_io_number_of_iocrs = -1_,1
static int hf_pn_io_iocr_tree = -1_,1
static int hf_pn_io_iocr_type = -1_,1
static int hf_pn_io_iocr_reference = -1_,1
static int hf_pn_io_iocr_SubframeOffset = -1_,1
static int hf_pn_io_iocr_SubframeData =-1_,1
/* static int hf_pn_io_iocr_txports_port = -1_ */,1
/* static int hf_pn_io_iocr_txports_redundantport = -1_ */,1
static int hf_pn_io_sr_properties_Reserved_1 = -1_,1
static int hf_pn_io_sr_properties_Mode = -1_,1
static int hf_pn_io_sr_properties_Reserved_2 = -1_,1
static int hf_pn_io_sr_properties_Reserved_3 = -1_,1
static int hf_pn_io_RedundancyDataHoldFactor = -1_,1
static int hf_pn_io_sr_properties = -1_,1
static int hf_pn_io_sr_properties_InputValidOnBackupAR_with_SRProperties_Mode_0 = -1_,1
static int hf_pn_io_sr_properties_InputValidOnBackupAR_with_SRProperties_Mode_1 = -1_,1
static int hf_pn_io_arvendor_strucidentifier_if0_low = -1_,1
static int hf_pn_io_arvendor_strucidentifier_if0_high = -1_,1
static int hf_pn_io_arvendor_strucidentifier_if0_is8000= -1_,1
static int hf_pn_io_arvendor_strucidentifier_not0 = -1_,1
static int hf_pn_io_lt = -1_,1
static int hf_pn_io_iocr_properties = -1_,1
static int hf_pn_io_iocr_properties_rtclass = -1_,1
static int hf_pn_io_iocr_properties_reserved_1 = -1_,1
static int hf_pn_io_iocr_properties_media_redundancy = -1_,1
static int hf_pn_io_iocr_properties_reserved_2 = -1_,1
static int hf_pn_io_iocr_properties_reserved_3 = -1_,1
static int hf_pn_io_iocr_properties_fast_forwarding_mac_adr = -1_,1
static int hf_pn_io_iocr_properties_distributed_subframe_watchdog = -1_,1
static int hf_pn_io_iocr_properties_full_subframe_structure = -1_,1
static int hf_pn_io_data_length = -1_,1
static int hf_pn_io_ir_frame_data = -1_,1
static int hf_pn_io_frame_id = -1_,1
static int hf_pn_io_send_clock_factor = -1_,1
static int hf_pn_io_reduction_ratio = -1_,1
static int hf_pn_io_phase = -1_,1
static int hf_pn_io_sequence = -1_,1
static int hf_pn_io_frame_send_offset = -1_,1
static int hf_pn_io_frame_data_properties = -1_,1
static int hf_pn_io_frame_data_properties_forwarding_Mode = -1_,1
static int hf_pn_io_frame_data_properties_FastForwardingMulticastMACAdd = -1_,1
static int hf_pn_io_frame_data_properties_FragmentMode = -1_,1
static int hf_pn_io_frame_data_properties_reserved_1 = -1_,1
static int hf_pn_io_frame_data_properties_reserved_2 = -1_,1
static int hf_pn_io_watchdog_factor = -1_,1
static int hf_pn_io_data_hold_factor = -1_,1
static int hf_pn_io_iocr_tag_header = -1_,1
static int hf_pn_io_iocr_multicast_mac_add = -1_,1
static int hf_pn_io_number_of_apis = -1_,1
static int hf_pn_io_number_of_io_data_objects = -1_,1
static int hf_pn_io_io_data_object_frame_offset = -1_,1
static int hf_pn_io_number_of_iocs = -1_,1
static int hf_pn_io_iocs_frame_offset = -1_,1
static int hf_pn_io_SFIOCRProperties = -1_,1
static int hf_pn_io_DistributedWatchDogFactor = -1_,1
static int hf_pn_io_RestartFactorForDistributedWD = -1_,1
static int hf_pn_io_SFIOCRProperties_DFPmode = -1_,1
static int hf_pn_io_SFIOCRProperties_reserved_1 = -1_,1
static int hf_pn_io_SFIOCRProperties_reserved_2 = -1_,1
static int hf_pn_io_SFIOCRProperties_DFPType =-1_,1
static int hf_pn_io_SFIOCRProperties_DFPRedundantPathLayout = -1_,1
static int hf_pn_io_SFIOCRProperties_SFCRC16 = -1_,1
static int hf_pn_io_subframe_data = -1_,1
static int hf_pn_io_subframe_data_reserved1 = -1_,1
static int hf_pn_io_subframe_data_reserved2 = -1_,1
static int hf_pn_io_subframe_data_position = -1_,1
static int hf_pn_io_subframe_reserved1 = -1_,1
static int hf_pn_io_subframe_data_length = -1_,1
static int hf_pn_io_subframe_reserved2 = -1_,1
static int hf_pn_io_alarmcr_type = -1_,1
static int hf_pn_io_alarmcr_properties = -1_,1
static int hf_pn_io_alarmcr_properties_priority = -1_,1
static int hf_pn_io_alarmcr_properties_transport = -1_,1
static int hf_pn_io_alarmcr_properties_reserved = -1_,1
static int hf_pn_io_rta_timeoutfactor = -1_,1
static int hf_pn_io_rta_retries = -1_,1
static int hf_pn_io_localalarmref = -1_,1
static int hf_pn_io_remotealarmref = -1_,1
static int hf_pn_io_maxalarmdatalength = -1_,1
static int hf_pn_io_alarmcr_tagheaderhigh = -1_,1
static int hf_pn_io_alarmcr_tagheaderlow = -1_,1
static int hf_pn_io_IRData_uuid = -1_,1
static int hf_pn_io_ar_uuid = -1_,1
static int hf_pn_io_target_ar_uuid = -1_,1
static int hf_pn_io_ar_discriminator = -1_,1
static int hf_pn_io_ar_configid = -1_,1
static int hf_pn_io_ar_arnumber = -1_,1
static int hf_pn_io_ar_arresource = -1_,1
static int hf_pn_io_ar_arreserved = -1_,1
static int hf_pn_io_ar_selector = -1_,1
static int hf_pn_io_api_tree = -1_,1
static int hf_pn_io_module_tree = -1_,1
static int hf_pn_io_submodule_tree = -1_,1
static int hf_pn_io_io_data_object = -1_,1
/* General module information */,1
static int hf_pn_io_io_cs = -1_,1
static int hf_pn_io_substitutionmode = -1_,1
static int hf_pn_io_api = -1_,1
static int hf_pn_io_slot_nr = -1_,1
static int hf_pn_io_subslot_nr = -1_,1
static int hf_pn_io_index = -1_,1
static int hf_pn_io_seq_number = -1_,1
static int hf_pn_io_record_data_length = -1_,1
static int hf_pn_io_add_val1 = -1_,1
static int hf_pn_io_add_val2 = -1_,1
static int hf_pn_io_block = -1_,1
static int hf_pn_io_block_header = -1_,1
static int hf_pn_io_block_type = -1_,1
static int hf_pn_io_block_length = -1_,1
static int hf_pn_io_block_version_high = -1_,1
static int hf_pn_io_block_version_low = -1_,1
static int hf_pn_io_sessionkey = -1_,1
static int hf_pn_io_control_command = -1_,1
static int hf_pn_io_control_command_prmend = -1_,1
static int hf_pn_io_control_command_applready = -1_,1
static int hf_pn_io_control_command_release = -1_,1
static int hf_pn_io_control_command_done = -1_,1
static int hf_pn_io_control_command_ready_for_companion = -1_,1
static int hf_pn_io_control_command_ready_for_rt_class3 = -1_,1
static int hf_pn_io_control_command_prmbegin = -1_,1
static int hf_pn_io_control_command_reserved_7_15 = -1_,1
static int hf_pn_io_control_block_properties = -1_,1
static int hf_pn_io_control_block_properties_applready = -1_,1
static int hf_pn_io_control_block_properties_applready0 = -1_,1
/* static int hf_pn_io_AlarmSequenceNumber = -1_ */,1
static int hf_pn_io_control_command_reserved = -1_,1
static int hf_pn_io_SubmoduleListEntries = -1_,1
static int hf_pn_io_error_code = -1_,1
static int hf_pn_io_error_decode = -1_,1
static int hf_pn_io_error_code1 = -1_,1
static int hf_pn_io_error_code1_pniorw = -1_,1
static int hf_pn_io_error_code1_pnio = -1_,1
static int hf_pn_io_error_code2 = -1_,1
static int hf_pn_io_error_code2_pniorw = -1_,1
static int hf_pn_io_error_code2_pnio_1 = -1_,1
static int hf_pn_io_error_code2_pnio_2 = -1_,1
static int hf_pn_io_error_code2_pnio_3 = -1_,1
static int hf_pn_io_error_code2_pnio_4 = -1_,1
static int hf_pn_io_error_code2_pnio_5 = -1_,1
static int hf_pn_io_error_code2_pnio_6 = -1_,1
static int hf_pn_io_error_code2_pnio_7 = -1_,1
static int hf_pn_io_error_code2_pnio_8 = -1_,1
static int hf_pn_io_error_code2_pnio_13 = -1_,1
static int hf_pn_io_error_code2_pnio_20 = -1_,1
static int hf_pn_io_error_code2_pnio_21 = -1_,1
static int hf_pn_io_error_code2_pnio_22 = -1_,1
static int hf_pn_io_error_code2_pnio_23 = -1_,1
static int hf_pn_io_error_code2_pnio_40 = -1_,1
static int hf_pn_io_error_code2_pnio_60 = -1_,1
static int hf_pn_io_error_code2_pnio_61 = -1_,1
static int hf_pn_io_error_code2_pnio_62 = -1_,1
static int hf_pn_io_error_code2_pnio_63 = -1_,1
static int hf_pn_io_error_code2_pnio_64 = -1_,1
static int hf_pn_io_error_code2_pnio_65 = -1_,1
static int hf_pn_io_error_code2_pnio_66 = -1_,1
static int hf_pn_io_error_code2_pnio_70 = -1_,1
static int hf_pn_io_error_code2_pnio_71 = -1_,1
static int hf_pn_io_error_code2_pnio_72 = -1_,1
static int hf_pn_io_error_code2_pnio_73 = -1_,1
static int hf_pn_io_error_code2_pnio_74 = -1_,1
static int hf_pn_io_error_code2_pnio_75 = -1_,1
static int hf_pn_io_error_code2_pnio_76 = -1_,1
static int hf_pn_io_error_code2_pnio_77 = -1_,1
static int hf_pn_io_error_code2_pnio_253 = -1_,1
static int hf_pn_io_error_code2_pnio_255 = -1_,1
static int hf_pn_io_alarm_type = -1_,1
static int hf_pn_io_alarm_specifier = -1_,1
static int hf_pn_io_alarm_specifier_sequence = -1_,1
static int hf_pn_io_alarm_specifier_channel = -1_,1
static int hf_pn_io_alarm_specifier_manufacturer = -1_,1
static int hf_pn_io_alarm_specifier_submodule = -1_,1
static int hf_pn_io_alarm_specifier_ardiagnosis = -1_,1
static int hf_pn_io_alarm_dst_endpoint = -1_,1
static int hf_pn_io_alarm_src_endpoint = -1_,1
static int hf_pn_io_pdu_type = -1_,1
static int hf_pn_io_pdu_type_type = -1_,1
static int hf_pn_io_pdu_type_version = -1_,1
static int hf_pn_io_add_flags = -1_,1
static int hf_pn_io_window_size = -1_,1
static int hf_pn_io_tack = -1_,1
static int hf_pn_io_send_seq_num = -1_,1
static int hf_pn_io_ack_seq_num = -1_,1
static int hf_pn_io_var_part_len = -1_,1
static int hf_pn_io_number_of_modules = -1_,1
static int hf_pn_io_module_ident_number = -1_,1
static int hf_pn_io_module_properties = -1_,1
static int hf_pn_io_module_state = -1_,1
static int hf_pn_io_number_of_submodules = -1_,1
static int hf_pn_io_submodule_ident_number = -1_,1
static int hf_pn_io_submodule_properties = -1_,1
static int hf_pn_io_submodule_properties_type = -1_,1
static int hf_pn_io_submodule_properties_shared_input = -1_,1
static int hf_pn_io_submodule_properties_reduce_input_submodule_data_length = -1_,1
static int hf_pn_io_submodule_properties_reduce_output_submodule_data_length = -1_,1
static int hf_pn_io_submodule_properties_discard_ioxs = -1_,1
static int hf_pn_io_submodule_properties_reserved = -1_,1
static int hf_pn_io_submodule_state = -1_,1
static int hf_pn_io_submodule_state_format_indicator = -1_,1
static int hf_pn_io_submodule_state_add_info = -1_,1
static int hf_pn_io_submodule_state_qualified_info = -1_,1
static int hf_pn_io_submodule_state_maintenance_required = -1_,1
static int hf_pn_io_submodule_state_maintenance_demanded = -1_,1
static int hf_pn_io_submodule_state_diag_info = -1_,1
static int hf_pn_io_submodule_state_ar_info = -1_,1
static int hf_pn_io_submodule_state_ident_info = -1_,1
static int hf_pn_io_submodule_state_detail = -1_,1
static int hf_pn_io_data_description_tree = -1_,1
static int hf_pn_io_data_description = -1_,1
static int hf_pn_io_submodule_data_length = -1_,1
static int hf_pn_io_length_iocs = -1_,1
static int hf_pn_io_length_iops = -1_,1
static int hf_pn_io_iocs = -1_,1
static int hf_pn_io_iops = -1_,1
static int hf_pn_io_ioxs_extension = -1_,1
static int hf_pn_io_ioxs_res14 = -1_,1
static int hf_pn_io_ioxs_instance = -1_,1
static int hf_pn_io_ioxs_datastate = -1_,1
static int hf_pn_io_address_resolution_properties = -1_,1
static int hf_pn_io_mci_timeout_factor = -1_,1
static int hf_pn_io_provider_station_name = -1_,1
static int hf_pn_io_user_structure_identifier = -1_,1
static int hf_pn_io_user_structure_identifier_manf = -1_,1
static int hf_pn_io_channel_number = -1_,1
static int hf_pn_io_channel_properties = -1_,1
static int hf_pn_io_channel_properties_type = -1_,1
static int hf_pn_io_channel_properties_accumulative = -1_,1
static int hf_pn_io_channel_properties_maintenance = -1_,1
static int hf_pn_io_NumberOfSubframeBlocks = -1_,1
static int hf_pn_io_channel_properties_specifier = -1_,1
static int hf_pn_io_channel_properties_direction = -1_,1
static int hf_pn_io_channel_error_type = -1_,1
static int hf_pn_io_ext_channel_error_type0 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8000 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8001 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8002 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8003 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8004 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8005 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8007 = -1_,1
static int hf_pn_io_ext_channel_error_type0x8008 = -1_,1
static int hf_pn_io_ext_channel_error_type0x800A = -1_,1
static int hf_pn_io_ext_channel_error_type0x800B = -1_,1
static int hf_pn_io_ext_channel_error_type0x800C = -1_,1
static int hf_pn_io_ext_channel_error_type = -1_,1
static int hf_pn_io_ext_channel_add_value = -1_,1
static int hf_pn_io_ptcp_subdomain_id = -1_,1
static int hf_pn_io_ir_data_id = -1_,1
static int hf_pn_io_max_bridge_delay = -1_,1
static int hf_pn_io_number_of_ports = -1_,1
static int hf_pn_io_max_port_tx_delay = -1_,1
static int hf_pn_io_max_port_rx_delay = -1_,1
static int hf_pn_io_max_line_rx_delay = -1_,1
static int hf_pn_io_yellowtime = -1_,1
static int hf_pn_io_reserved_interval_begin = -1_,1
static int hf_pn_io_reserved_interval_end = -1_,1
static int hf_pn_io_pllwindow = -1_,1
static int hf_pn_io_sync_send_factor = -1_,1
static int hf_pn_io_sync_properties = -1_,1
static int hf_pn_io_sync_frame_address = -1_,1
static int hf_pn_io_ptcp_timeout_factor = -1_,1
static int hf_pn_io_ptcp_takeover_timeout_factor = -1_,1
static int hf_pn_io_ptcp_master_startup_time = -1_,1
static int hf_pn_io_ptcp_master_priority_1 = -1_,1
static int hf_pn_io_ptcp_master_priority_2 = -1_,1
static int hf_pn_io_ptcp_length_subdomain_name = -1_,1
static int hf_pn_io_ptcp_subdomain_name = -1_,1
static int hf_pn_io_MultipleInterfaceMode_NameOfDevice = -1_,1
static int hf_pn_io_MultipleInterfaceMode_reserved_1 = -1_,1
static int hf_pn_io_MultipleInterfaceMode_reserved_2 = -1_,1
/* added Portstatistics */,1
static int hf_pn_io_pdportstatistic_counter_status = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_ifInOctets = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_ifOutOctets = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_ifInDiscards = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_ifOutDiscards = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_ifInErrors = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_ifOutErrors = -1_,1
static int hf_pn_io_pdportstatistic_counter_status_reserved = -1_,1
static int hf_pn_io_pdportstatistic_ifInOctets = -1_,1
static int hf_pn_io_pdportstatistic_ifOutOctets = -1_,1
static int hf_pn_io_pdportstatistic_ifInDiscards = -1_,1
static int hf_pn_io_pdportstatistic_ifOutDiscards = -1_,1
static int hf_pn_io_pdportstatistic_ifInErrors = -1_,1
static int hf_pn_io_pdportstatistic_ifOutErrors = -1_,1
/* end of port statistics */,1
static int hf_pn_io_domain_boundary = -1_,1
static int hf_pn_io_domain_boundary_ingress = -1_,1
static int hf_pn_io_domain_boundary_egress = -1_,1
static int hf_pn_io_multicast_boundary = -1_,1
static int hf_pn_io_adjust_properties = -1_,1
static int hf_pn_io_PreambleLength = -1_,1
static int hf_pn_io_mau_type = -1_,1
static int hf_pn_io_mau_type_mode = -1_,1
static int hf_pn_io_port_state = -1_,1
static int hf_pn_io_line_delay = -1_,1
static int hf_pn_io_line_delay_value = -1_,1
static int hf_pn_io_cable_delay_value = -1_,1
static int hf_pn_io_line_delay_format_indicator = -1_,1
static int hf_pn_io_number_of_peers = -1_,1
static int hf_pn_io_length_peer_port_id = -1_,1
static int hf_pn_io_peer_port_id = -1_,1
static int hf_pn_io_length_peer_chassis_id = -1_,1
static int hf_pn_io_peer_chassis_id = -1_,1
static int hf_pn_io_length_own_port_id = -1_,1
static int hf_pn_io_own_port_id = -1_,1
static int hf_pn_io_peer_macadd = -1_,1
static int hf_pn_io_media_type = -1_,1
static int hf_pn_io_macadd = -1_,1
static int hf_pn_io_length_own_chassis_id = -1_,1
static int hf_pn_io_own_chassis_id = -1_,1
static int hf_pn_io_ethertype = -1_,1
static int hf_pn_io_rx_port = -1_,1
static int hf_pn_io_frame_details = -1_,1
static int hf_pn_io_frame_details_sync_frame = -1_,1
static int hf_pn_io_frame_details_meaning_frame_send_offset = -1_,1
static int hf_pn_io_frame_details_reserved = -1_,1
static int hf_pn_io_nr_of_tx_port_groups = -1_,1
static int hf_pn_io_TxPortGroupProperties = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit0 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit1 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit2 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit3 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit4 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit5 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit6 = -1_,1
static int hf_pn_io_TxPortGroupProperties_bit7 = -1_,1
static int hf_pn_io_start_of_red_frame_id = -1_,1
static int hf_pn_io_end_of_red_frame_id = -1_,1
static int hf_pn_io_ir_begin_end_port = -1_,1
static int hf_pn_io_number_of_assignments = -1_,1
static int hf_pn_io_number_of_phases = -1_,1
static int hf_pn_io_red_orange_period_begin_tx = -1_,1
static int hf_pn_io_orange_period_begin_tx = -1_,1
static int hf_pn_io_green_period_begin_tx = -1_,1
static int hf_pn_io_red_orange_period_begin_rx = -1_,1
static int hf_pn_io_orange_period_begin_rx = -1_,1
static int hf_pn_io_green_period_begin_rx = -1_,1
/* static int hf_pn_io_tx_phase_assignment = -1_ */,1
static int hf_pn_ir_tx_phase_assignment = -1_,1
static int hf_pn_ir_rx_phase_assignment = -1_,1
static int hf_pn_io_tx_phase_assignment_begin_value = -1_,1
static int hf_pn_io_tx_phase_assignment_orange_begin = -1_,1
static int hf_pn_io_tx_phase_assignment_end_reserved = -1_,1
static int hf_pn_io_tx_phase_assignment_reserved = -1_,1
/* static int hf_pn_io_rx_phase_assignment = -1_ */,1
static int hf_pn_io_slot = -1_,1
static int hf_pn_io_subslot = -1_,1
static int hf_pn_io_number_of_slots = -1_,1
static int hf_pn_io_number_of_subslots = -1_,1
/* static int hf_pn_io_maintenance_required_drop_budget = -1_ */,1
/* static int hf_pn_io_maintenance_demanded_drop_budget = -1_ */,1
/* static int hf_pn_io_error_drop_budget = -1_ */,1
static int hf_pn_io_maintenance_required_power_budget = -1_,1
static int hf_pn_io_maintenance_demanded_power_budget = -1_,1
static int hf_pn_io_error_power_budget = -1_,1
static int hf_pn_io_fiber_optic_type = -1_,1
static int hf_pn_io_fiber_optic_cable_type = -1_,1
static int hf_pn_io_controller_appl_cycle_factor = -1_,1
static int hf_pn_io_time_data_cycle = -1_,1
static int hf_pn_io_time_io_input = -1_,1
static int hf_pn_io_time_io_output = -1_,1
static int hf_pn_io_time_io_input_valid = -1_,1
static int hf_pn_io_time_io_output_valid = -1_,1
static int hf_pn_io_maintenance_status = -1_,1
static int hf_pn_io_maintenance_status_required = -1_,1
static int hf_pn_io_maintenance_status_demanded = -1_,1
static int hf_pn_io_vendor_id_high = -1_,1
static int hf_pn_io_vendor_id_low = -1_,1
static int hf_pn_io_vendor_block_type = -1_,1
static int hf_pn_io_order_id = -1_,1
static int hf_pn_io_im_serial_number = -1_,1
static int hf_pn_io_im_hardware_revision = -1_,1
static int hf_pn_io_im_revision_prefix = -1_,1
static int hf_pn_io_im_sw_revision_functional_enhancement = -1_,1
static int hf_pn_io_im_revision_bugfix = -1_,1
static int hf_pn_io_im_sw_revision_internal_change = -1_,1
static int hf_pn_io_im_revision_counter = -1_,1
static int hf_pn_io_im_profile_id = -1_,1
static int hf_pn_io_im_profile_specific_type = -1_,1
static int hf_pn_io_im_version_major = -1_,1
static int hf_pn_io_im_version_minor = -1_,1
static int hf_pn_io_im_supported = -1_,1
static int hf_pn_io_im_numberofentries = -1_,1
static int hf_pn_io_im_annotation = -1_,1
static int hf_pn_io_im_order_id = -1_,1
static int hf_pn_io_number_of_ars = -1_,1
static int hf_pn_io_cycle_counter = -1_,1
static int hf_pn_io_data_status = -1_,1
static int hf_pn_io_data_status_res67 = -1_,1
static int hf_pn_io_data_status_ok = -1_,1
static int hf_pn_io_data_status_operate = -1_,1
static int hf_pn_io_data_status_res3 = -1_,1
static int hf_pn_io_data_status_valid = -1_,1
static int hf_pn_io_data_status_res1 = -1_,1
static int hf_pn_io_data_status_primary = -1_,1
static int hf_pn_io_transfer_status = -1_,1
static int hf_pn_io_actual_local_time_stamp = -1_,1
static int hf_pn_io_number_of_log_entries = -1_,1
static int hf_pn_io_local_time_stamp = -1_,1
static int hf_pn_io_entry_detail = -1_,1
static int hf_pn_io_ip_address = -1_,1
static int hf_pn_io_subnetmask = -1_,1
static int hf_pn_io_standard_gateway = -1_,1
static int hf_pn_io_mrp_domain_uuid = -1_,1
static int hf_pn_io_mrp_role = -1_,1
static int hf_pn_io_mrp_length_domain_name = -1_,1
static int hf_pn_io_mrp_domain_name = -1_,1
static int hf_pn_io_mrp_instances = -1_,1
static int hf_pn_io_mrp_instance = -1_,1
static int hf_pn_io_mrp_prio = -1_,1
static int hf_pn_io_mrp_topchgt = -1_,1
static int hf_pn_io_mrp_topnrmax = -1_,1
static int hf_pn_io_mrp_tstshortt = -1_,1
static int hf_pn_io_mrp_tstdefaultt = -1_,1
static int hf_pn_io_mrp_tstnrmax = -1_,1
static int hf_pn_io_mrp_check = -1_,1
static int hf_pn_io_mrp_check_mrm = -1_,1
static int hf_pn_io_mrp_check_mrpdomain = -1_,1
static int hf_pn_io_mrp_check_reserved_1 = -1_,1
static int hf_pn_io_mrp_check_reserved_2 = -1_,1
static int hf_pn_io_mrp_rtmode = -1_,1
static int hf_pn_io_mrp_rtmode_rtclass12 = -1_,1
static int hf_pn_io_mrp_rtmode_rtclass3 = -1_,1
static int hf_pn_io_mrp_rtmode_reserved1 = -1_,1
static int hf_pn_io_mrp_rtmode_reserved2 = -1_,1
static int hf_pn_io_mrp_lnkdownt = -1_,1
static int hf_pn_io_mrp_lnkupt = -1_,1
static int hf_pn_io_mrp_lnknrmax = -1_,1
static int hf_pn_io_mrp_version = -1_,1
static int hf_pn_io_substitute_active_flag = -1_,1
static int hf_pn_io_length_data = -1_,1
static int hf_pn_io_mrp_ring_state = -1_,1
static int hf_pn_io_mrp_rt_state = -1_,1
static int hf_pn_io_im_tag_function = -1_,1
static int hf_pn_io_im_tag_location = -1_,1
static int hf_pn_io_im_date = -1_,1
static int hf_pn_io_im_descriptor = -1_,1
static int hf_pn_io_fs_hello_mode = -1_,1
static int hf_pn_io_fs_hello_interval = -1_,1
static int hf_pn_io_fs_hello_retry = -1_,1
static int hf_pn_io_fs_hello_delay = -1_,1
static int hf_pn_io_fs_parameter_mode = -1_,1
static int hf_pn_io_fs_parameter_uuid = -1_,1
static int hf_pn_io_check_sync_mode = -1_,1
static int hf_pn_io_check_sync_mode_reserved = -1_,1
static int hf_pn_io_check_sync_mode_sync_master = -1_,1
static int hf_pn_io_check_sync_mode_cable_delay = -1_,1
/* PROFIsafe fParameters */,1
static int hf_pn_io_ps_f_prm_flag1 = -1_,1
static int hf_pn_io_ps_f_prm_flag1_chck_seq = -1_,1
static int hf_pn_io_ps_f_prm_flag1_chck_ipar = -1_,1
static int hf_pn_io_ps_f_prm_flag1_sil = -1_,1
static int hf_pn_io_ps_f_prm_flag1_crc_len = -1_,1
static int hf_pn_io_ps_f_prm_flag1_crc_seed = -1_,1
static int hf_pn_io_ps_f_prm_flag1_reserved = -1_,1
static int hf_pn_io_ps_f_prm_flag2 = -1_,1
static int hf_pn_io_ps_f_wd_time = -1_,1
static int hf_pn_io_ps_f_ipar_crc = -1_,1
static int hf_pn_io_ps_f_par_crc = -1_,1
static int hf_pn_io_ps_f_src_adr = -1_,1
static int hf_pn_io_ps_f_dest_adr = -1_,1
static int hf_pn_io_ps_f_prm_flag2_reserved = -1_,1
static int hf_pn_io_ps_f_prm_flag2_f_block_id = -1_,1
static int hf_pn_io_ps_f_prm_flag2_f_par_version = -1_,1
static int hf_pn_io_profidrive_request_reference = -1_,1
static int hf_pn_io_profidrive_request_id = -1_,1
static int hf_pn_io_profidrive_do_id = -1_,1
static int hf_pn_io_profidrive_no_of_parameters = -1_,1
static int hf_pn_io_profidrive_response_id = -1_,1
static int hf_pn_io_profidrive_param_attribute = -1_,1
static int hf_pn_io_profidrive_param_no_of_elems = -1_,1
static int hf_pn_io_profidrive_param_number = -1_,1
static int hf_pn_io_profidrive_param_subindex = -1_,1
static int hf_pn_io_profidrive_param_format = -1_,1
static int hf_pn_io_profidrive_param_no_of_values = -1_,1
static int hf_pn_io_profidrive_param_value_byte = -1_,1
static int hf_pn_io_profidrive_param_value_word = -1_,1
static int hf_pn_io_profidrive_param_value_dword = -1_,1
static int hf_pn_io_profidrive_param_value_float = -1_,1
static int hf_pn_io_profidrive_param_value_string = -1_,1
/* Sequence of Events - Reporting System Alarm/Event Information */,1
static int hf_pn_io_rs_alarm_info_reserved_0_7 = -1_,1
static int hf_pn_io_rs_alarm_info_reserved_8_15 = -1_,1
static int hf_pn_io_rs_alarm_info = -1_,1
static int hf_pn_io_rs_event_info = -1_,1
static int hf_pn_io_rs_event_block = -1_,1
static int hf_pn_io_rs_adjust_block = -1_,1
static int hf_pn_io_rs_event_data_extension = -1_,1
static int hf_pn_io_number_of_rs_event_info = -1_,1
static int hf_pn_io_rs_block_type = -1_,1
static int hf_pn_io_rs_block_length = -1_,1
static int hf_pn_io_rs_specifier = -1_,1
static int hf_pn_io_rs_specifier_sequence = -1_,1
static int hf_pn_io_rs_specifier_reserved = -1_,1
static int hf_pn_io_rs_specifier_specifier = -1_,1
static int hf_pn_io_rs_time_stamp = -1_,1
static int hf_pn_io_rs_time_stamp_status = -1_,1
static int hf_pn_io_rs_time_stamp_value = -1_,1
static int hf_pn_io_rs_minus_error = -1_,1
static int hf_pn_io_rs_plus_error = -1_,1
static int hf_pn_io_rs_extension_block_type = -1_,1
static int hf_pn_io_rs_extension_block_length = -1_,1
static int hf_pn_io_rs_reason_code = -1_,1
static int hf_pn_io_rs_reason_code_reason = -1_,1
static int hf_pn_io_rs_reason_code_detail = -1_,1
static int hf_pn_io_rs_domain_identification = -1_,1
static int hf_pn_io_rs_master_identification = -1_,1
static int hf_pn_io_soe_digital_input_current_value = -1_,1
static int hf_pn_io_soe_digital_input_current_value_value = -1_,1
static int hf_pn_io_soe_digital_input_current_value_reserved = -1_,1
static int hf_pn_io_am_device_identification = -1_,1
static int hf_pn_io_am_device_identification_device_sub_id = -1_,1
static int hf_pn_io_am_device_identification_device_id = -1_,1
static int hf_pn_io_am_device_identification_vendor_id = -1_,1
static int hf_pn_io_am_device_identification_organization = -1_,1
static int hf_pn_io_rs_adjust_info = -1_,1
static int hf_pn_io_soe_max_scan_delay = -1_,1
static int hf_pn_io_soe_adjust_specifier = -1_,1
static int hf_pn_io_soe_adjust_specifier_reserved = -1_,1
static int hf_pn_io_soe_adjust_specifier_incident = -1_,1
static int hf_pn_io_rs_properties = -1_,1
static int hf_pn_io_rs_properties_alarm_transport = -1_,1
static int hf_pn_io_rs_properties_reserved1 = -1_,1
static int hf_pn_io_rs_properties_reserved2 = -1_,1
static int hf_pn_io_asset_management_info = -1_,1
static int hf_pn_io_number_of_asset_management_info = -1_,1
static int hf_pn_io_im_uniqueidentifier = -1_,1
static int hf_pn_io_am_location_structure = -1_,1
static int hf_pn_io_am_location_level_0 = -1_,1
static int hf_pn_io_am_location_level_1 = -1_,1
static int hf_pn_io_am_location_level_2 = -1_,1
static int hf_pn_io_am_location_level_3 = -1_,1
static int hf_pn_io_am_location_level_4 = -1_,1
static int hf_pn_io_am_location_level_5 = -1_,1
static int hf_pn_io_am_location_level_6 = -1_,1
static int hf_pn_io_am_location_level_7 = -1_,1
static int hf_pn_io_am_location_level_8 = -1_,1
static int hf_pn_io_am_location_level_9 = -1_,1
static int hf_pn_io_am_location_level_10 = -1_,1
static int hf_pn_io_am_location_level_11 = -1_,1
static int hf_pn_io_am_location = -1_,1
static int hf_pn_io_am_location_reserved1 = -1_,1
static int hf_pn_io_am_location_reserved2 = -1_,1
static int hf_pn_io_am_location_reserved3 = -1_,1
static int hf_pn_io_am_location_reserved4 = -1_,1
static int hf_pn_io_am_software_revision = -1_,1
static int hf_pn_io_am_hardware_revision = -1_,1
static int hf_pn_io_am_type_identification = -1_,1
/* static int hf_pn_io_packedframe_SFCRC = -1_ */,1
static gint ett_pn_io = -1_,1
static gint ett_pn_io_block = -1_,1
static gint ett_pn_io_block_header = -1_,1
static gint ett_pn_io_status = -1_,1
static gint ett_pn_io_rtc = -1_,1
static gint ett_pn_io_rta = -1_,1
static gint ett_pn_io_pdu_type = -1_,1
static gint ett_pn_io_add_flags = -1_,1
static gint ett_pn_io_control_command = -1_,1
static gint ett_pn_io_ioxs = -1_,1
static gint ett_pn_io_api = -1_,1
static gint ett_pn_io_data_description = -1_,1
static gint ett_pn_io_module = -1_,1
static gint ett_pn_io_submodule = -1_,1
static gint ett_pn_io_io_data_object = -1_,1
static gint ett_pn_io_io_cs = -1_,1
static gint ett_pn_io_ar_properties = -1_,1
static gint ett_pn_io_iocr_properties = -1_,1
static gint ett_pn_io_submodule_properties = -1_,1
static gint ett_pn_io_alarmcr_properties = -1_,1
static gint ett_pn_io_submodule_state = -1_,1
static gint ett_pn_io_channel_properties = -1_,1
static gint ett_pn_io_slot = -1_,1
static gint ett_pn_io_subslot = -1_,1
static gint ett_pn_io_maintenance_status = -1_,1
static gint ett_pn_io_data_status = -1_,1
static gint ett_pn_io_iocr = -1_,1
static gint ett_pn_io_mrp_rtmode = -1_,1
static gint ett_pn_io_control_block_properties = -1_,1
static gint ett_pn_io_check_sync_mode = -1_,1
static gint ett_pn_io_ir_frame_data = -1_,1
static gint ett_pn_FrameDataProperties = -1_,1
static gint ett_pn_io_ar_info = -1_,1
static gint ett_pn_io_ar_data = -1_,1
static gint ett_pn_io_ir_begin_end_port = -1_,1
static gint ett_pn_io_ir_tx_phase = -1_,1
static gint ett_pn_io_ir_rx_phase = -1_,1
static gint ett_pn_io_subframe_data =-1_,1
static gint ett_pn_io_SFIOCRProperties = -1_,1
static gint ett_pn_io_frame_defails = -1_,1
static gint ett_pn_io_profisafe_f_parameter = -1_,1
static gint ett_pn_io_profisafe_f_parameter_prm_flag1 = -1_,1
static gint ett_pn_io_profisafe_f_parameter_prm_flag2 = -1_,1
static gint ett_pn_io_profidrive_parameter_request = -1_,1
static gint ett_pn_io_profidrive_parameter_response = -1_,1
static gint ett_pn_io_profidrive_parameter_address = -1_,1
static gint ett_pn_io_profidrive_parameter_value = -1_,1
static gint ett_pn_io_rs_alarm_info = -1_,1
static gint ett_pn_io_rs_event_info = -1_,1
static gint ett_pn_io_rs_event_block = -1_,1
static gint ett_pn_io_rs_adjust_block = -1_,1
static gint ett_pn_io_rs_event_data_extension = -1_,1
static gint ett_pn_io_rs_specifier = -1_,1
static gint ett_pn_io_rs_time_stamp = -1_,1
static gint ett_pn_io_am_device_identification = -1_,1
static gint ett_pn_io_rs_reason_code = -1_,1
static gint ett_pn_io_soe_digital_input_current_value = -1_,1
static gint ett_pn_io_rs_adjust_info = -1_,1
static gint ett_pn_io_soe_adjust_specifier = -1_,1
static gint ett_pn_io_sr_properties = -1_,1
static gint ett_pn_io_line_delay = -1_,1
static gint ett_pn_io_counter_status = -1_,1
static gint ett_pn_io_GroupProperties = -1_,1
static gint ett_pn_io_asset_management_info = -1_,1
static gint ett_pn_io_asset_management_block = -1_,1
static gint ett_pn_io_am_location = -1_,1
#define PD_SUB_FRAME_BLOCK_FIOCR_PROPERTIES_LENGTH 4,1
#define PD_SUB_FRAME_BLOCK_FRAME_ID_LENGTH 2,1
#define PD_SUB_FRAME_BLOCK_SUB_FRAME_DATA_LENGTH 4,1
static expert_field ei_pn_io_block_version = EI_INIT_,1
static expert_field ei_pn_io_block_length = EI_INIT_,1
static expert_field ei_pn_io_unsupported = EI_INIT_,1
static expert_field ei_pn_io_error_code1 = EI_INIT_,1
static expert_field ei_pn_io_localalarmref = EI_INIT_,1
static expert_field ei_pn_io_mrp_instances = EI_INIT_,1
static expert_field ei_pn_io_error_code2 = EI_INIT_,1
static expert_field ei_pn_io_ar_info_not_found = EI_INIT_,1
static expert_field ei_pn_io_iocr_type = EI_INIT_,1
static expert_field ei_pn_io_frame_id = EI_INIT_,1
static expert_field ei_pn_io_nr_of_tx_port_groups = EI_INIT_,1
"static e_guid_t uuid_pn_io_device = { 0xDEA00001, 0x6C97, 0x11D1, { 0x82, 0x71, 0x00, 0xA0, 0x24, 0x42, 0xDF, 0x7D } }_",1
static guint16  ver_pn_io_device = 1_,1
"static e_guid_t uuid_pn_io_controller = { 0xDEA00002, 0x6C97, 0x11D1, { 0x82, 0x71, 0x00, 0xA0, 0x24, 0x42, 0xDF, 0x7D } }_",1
static guint16  ver_pn_io_controller = 1_,1
"static e_guid_t uuid_pn_io_supervisor = { 0xDEA00003, 0x6C97, 0x11D1, { 0x82, 0x71, 0x00, 0xA0, 0x24, 0x42, 0xDF, 0x7D } }_",1
static guint16  ver_pn_io_supervisor = 1_,1
"static e_guid_t uuid_pn_io_parameterserver = { 0xDEA00004, 0x6C97, 0x11D1, { 0x82, 0x71, 0x00, 0xA0, 0x24, 0x42, 0xDF, 0x7D } }_",1
static guint16  ver_pn_io_parameterserver = 1_,1
/* According to specification:,1
 * Value(UUID): 00000000-0000-0000-0000-000000000000,1
 * Meaning: Reserved,1
 * Use: The value NIL indicates the usage of the implicit AR.,1
"static e_guid_t uuid_pn_io_implicitar = { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } }_",1
static guint16  ver_pn_io_implicitar = 1_,1
/* PNIO Preference Variables */,1
gboolean           pnio_ps_selection = TRUE_,1
"static const char *pnio_ps_networkpath = """"_",1
/* Allow heuristic dissection */,1
static heur_dissector_list_t heur_pn_subdissector_list_,1
static const value_string pn_io_block_type[] = {,1
"    { 0x0000, ""Reserved"" },",1
"    { 0x0001, ""Alarm Notification High""},",1
"    { 0x0002, ""Alarm Notification Low""},",1
"    { 0x0008, ""IODWriteReqHeader""},",1
"    { 0x8008, ""IODWriteResHeader""},",1
"    { 0x0009, ""IODReadReqHeader""},",1
"    { 0x8009, ""IODReadResHeader""},",1
"    { 0x0010, ""DiagnosisData""},",1
"    { 0x0011, ""Reserved""},",1
"    { 0x0012, ""ExpectedIdentificationData""},",1
"    { 0x0013, ""RealIdentificationData""},",1
"    { 0x0014, ""SubstituteValue""},",1
"    { 0x0015, ""RecordInputDataObjectElement""},",1
"    { 0x0016, ""RecordOutputDataObjectElement""},",1
"    { 0x0017, ""reserved""},",1
"    { 0x0018, ""ARData""},",1
"    { 0x0019, ""LogData""},",1
"    { 0x001A, ""APIData""},",1
"    { 0x001b, ""SRLData""},",1
"    { 0x0020, ""I&M0""},",1
"    { 0x0021, ""I&M1""},",1
"    { 0x0022, ""I&M2""},",1
"    { 0x0023, ""I&M3""},",1
"    { 0x0024, ""I&M4""},",1
"    { 0x0025, ""I&M5""},",1
"    { 0x0026, ""I&M6""},",1
"    { 0x0027, ""I&M7""},",1
"    { 0x0028, ""I&M8""},",1
"    { 0x0029, ""I&M9""},",1
"    { 0x002A, ""I&M10""},",1
"    { 0x002B, ""I&M11""},",1
"    { 0x002C, ""I&M12""},",1
"    { 0x002D, ""I&M13""},",1
"    { 0x002E, ""I&M14""},",1
"    { 0x002F, ""I&M15""},",1
"    { 0x0030, ""I&M0FilterDataSubmodul""},",1
"    { 0x0031, ""I&M0FilterDataModul""},",1
"    { 0x0032, ""I&M0FilterDataDevice""},",1
"    { 0x0033, ""Reserved"" },",1
"    { 0x0034, ""I&M5Data""},",1
"    { 0x0035, ""AssetManagementData""},",1
"    { 0x0036, ""AM_FullInformation""},",1
"    { 0x0037, ""AM_HardwareOnlyInformation""},",1
"    { 0x0038, ""AM_FirmwareOnlyInformation"" },",1
"    { 0x8001, ""Alarm Ack High""},",1
"    { 0x8002, ""Alarm Ack Low""},",1
"    { 0x0101, ""ARBlockReq""},",1
"    { 0x8101, ""ARBlockRes""},",1
"    { 0x0102, ""IOCRBlockReq""},",1
"    { 0x8102, ""IOCRBlockRes""},",1
"    { 0x0103, ""AlarmCRBlockReq""},",1
"    { 0x8103, ""AlarmCRBlockRes""},",1
"    { 0x0104, ""ExpectedSubmoduleBlockReq""},",1
"    { 0x8104, ""ModuleDiffBlock""},",1
"    { 0x0105, ""PrmServerBlockReq""},",1
"    { 0x8105, ""PrmServerBlockRes""},",1
"    { 0x0106, ""MCRBlockReq""},",1
"    { 0x8106, ""ARServerBlock""},",1
"    { 0x0107, ""SubFrameBlock""},",1
"    { 0x0108, ""ARVendorBlockReq""},",1
"    { 0x8108, ""ARVendorBlockRes""},",1
"    { 0x0109, ""IRInfoBlock""},",1
"    { 0x010A, ""SRInfoBlock""},",1
"    { 0x010B, ""ARFSUBlock""},",1
"    { 0x010C, ""RSInfoBlock""},",1
"    { 0x0110, ""IODControlReq Prm End.req""},",1
"    { 0x8110, ""IODControlRes Prm End.rsp""},",1
"    { 0x0111, ""IODControlReq Prm End.req""},",1
"    { 0x8111, ""IODControlRes Prm End.rsp""},",1
"    { 0x0112, ""IOXBlockReq Application Ready.req""},",1
"    { 0x8112, ""IOXBlockRes Application Ready.rsp""},",1
"    { 0x0113, ""IOXBlockReq Application Ready.req""},",1
"    { 0x8113, ""IOXBlockRes Application Ready.rsp""},",1
"    { 0x0114, ""IODReleaseReq""},",1
"    { 0x8114, ""IODReleaseRes""},",1
"    { 0x0115, ""ARRPCServerBlockReq""},",1
"    { 0x8115, ""ARRPCServerBlockRes""},",1
"    { 0x0116, ""IOXControlReq Ready for Companion.req""},",1
"    { 0x8116, ""IOXControlRes Ready for Companion.rsp""},",1
"    { 0x0117, ""IOXControlReq Ready for RT_CLASS_3.req""},",1
"    { 0x8117, ""IOXControlRes Ready for RT_CLASS_3.rsp""},",1
"    { 0x0118, ""ControlBlockPrmBegin""},",1
"    { 0x0119, ""SubmoduleListBlock""},",1
"    { 0x8118, ""ControlBlockPrmBeginRes""},",1
"    { 0x0200, ""PDPortDataCheck""},",1
"    { 0x0201, ""PDevData""},",1
"    { 0x0202, ""PDPortDataAdjust""},",1
"    { 0x0203, ""PDSyncData""},",1
"    { 0x0204, ""IsochronousModeData""},",1
"    { 0x0205, ""PDIRData""},",1
"    { 0x0206, ""PDIRGlobalData""},",1
"    { 0x0207, ""PDIRFrameData""},",1
"    { 0x0208, ""PDIRBeginEndData""},",1
"    { 0x0209, ""AdjustDomainBoundary""},",1
"    { 0x020A, ""CheckPeers""},",1
"    { 0x020B, ""CheckLineDelay""},",1
"    { 0x020C, ""Checking MAUType""},",1
"    { 0x020E, ""Adjusting MAUType""},",1
"    { 0x020F, ""PDPortDataReal""},",1
"    { 0x0210, ""AdjustMulticastBoundary""},",1
"    { 0x0211, ""PDInterfaceMrpDataAdjust""},",1
"    { 0x0212, ""PDInterfaceMrpDataReal""},",1
"    { 0x0213, ""PDInterfaceMrpDataCheck""},",1
"    { 0x0214, ""PDPortMrpDataAdjust""},",1
"    { 0x0215, ""PDPortMrpDataReal""},",1
"    { 0x0216, ""Media redundancy manager parameters""},",1
"    { 0x0217, ""Media redundancy client parameters""},",1
"    { 0x0218, ""Media redundancy RT mode for manager""},",1
"    { 0x0219, ""Media redundancy ring state data""},",1
"    { 0x021A, ""Media redundancy RT ring state data""},",1
"    { 0x021B, ""Adjust LinkState""},",1
"    { 0x021C, ""Checking LinkState""},",1
"    { 0x021D, ""Media redundancy RT mode for clients""},",1
"    { 0x021E, ""CheckSyncDifference""},",1
"    { 0x021F, ""CheckMAUTypeDifference""},",1
"    { 0x0220, ""PDPortFODataReal""},",1
"    { 0x0221, ""Reading real fiber optic manufacturerspecific data""},",1
"    { 0x0222, ""PDPortFODataAdjust""},",1
"    { 0x0223, ""PDPortFODataCheck""},",1
"    { 0x0224, ""Adjust PeerToPeerBoundary""},",1
"    { 0x0225, ""Adjust DCPBoundary""},",1
"    { 0x0226, ""Adjust PreambleLength""},",1
"    { 0x0227, ""Adjust FastForwardingBoundary""},",1
"    { 0x0228, ""Reading real fiber optic diagnosis data""},",1
"    { 0x022A, ""PDIRSubframeData""},",1
"    { 0x022B, ""SubframeBlock""},",1
"    { 0x0230, ""PDNCDataCheck""},",1
"    { 0x0231, ""MrpInstanceDataAdjust""},",1
"    { 0x0232, ""MrpInstanceDataReal""},",1
"    { 0x0233, ""MrpInstanceDataCheck""},",1
"    { 0x0240, ""PDInterfaceDataReal""},",1
"    { 0x0250, ""PDInterfaceAdjust""},",1
"    { 0x0251, ""PDPortStatistic""},",1
"    { 0x0400, ""MultipleBlockHeader""},",1
"    { 0x0401, ""COContainerContent""},",1
"    { 0x0500, ""RecordDataReadQuery""},",1
"    { 0x0600, ""FSHello""},",1
"    { 0x0601, ""FSParameterBlock""},",1
"    { 0x0608, ""PDInterfaceFSUDataAdjust""},",1
"    { 0x0609, ""ARFSUDataAdjust""},",1
"    { 0x0700, ""AutoConfiguration""},",1
"    { 0x0701, ""AutoConfiguration Communication""},",1
"    { 0x0702, ""AutoConfiguration Configuration""},",1
"    { 0x0900, ""RS_AdjustObserver"" },",1
"    { 0x0901, ""RS_GetEvent"" },",1
"    { 0x0902, ""RS_AckEvent"" },",1
"    { 0xB050, ""Ext-PLL Control / RTC+RTA SyncID 0 (EDD)"" },",1
"    { 0xB051, ""Ext-PLL Control / RTA SyncID 1 (GSY)"" },",1
"    { 0xB060, ""EDD Trace Unit (EDD)"" },",1
"    { 0xB061, ""EDD Trace Unit (EDD)"" },",1
"    { 0xB070, ""OHA Info (OHA)"" },",1
"    { 0x0F00, ""MaintenanceItem""},",1
"    { 0x0F01, ""Upload selected Records within Upload&RetrievalItem""},",1
"    { 0x0F02, ""iParameterItem""},",1
"    { 0x0F03, ""Retrieve selected Records within Upload&RetrievalItem""},",1
"    { 0x0F04, ""Retrieve all Records within Upload&RetrievalItem""},",1
static const value_string pn_io_alarm_type[] = {,1
"    { 0x0001, ""Diagnosis"" },",1
"    { 0x0002, ""Process"" },",1
"    { 0x0003, ""Pull"" },",1
"    { 0x0004, ""Plug"" },",1
"    { 0x0005, ""Status"" },",1
"    { 0x0006, ""Update"" },",1
"    { 0x0007, ""Redundancy"" },",1
"    { 0x0008, ""Controlled by supervisor"" },",1
"    { 0x0009, ""Released"" },",1
"    { 0x000A, ""Plug wrong submodule"" },",1
"    { 0x000B, ""Return of submodule"" },",1
"    { 0x000C, ""Diagnosis disappears"" },",1
"    { 0x000D, ""Multicast communication mismatch notification"" },",1
"    { 0x000E, ""Port data change notification"" },",1
"    { 0x000F, ""Sync data changed notification"" },",1
"    { 0x0010, ""Isochronous mode problem notification"" },",1
"    { 0x0011, ""Network component problem notification"" },",1
"    { 0x0012, ""Time data changed notification"" },",1
"    { 0x0013, ""Dynamic Frame Packing problem notification"" },",1
    /*0x0014 - 0x001D reserved */,1
"    { 0x001E, ""Upload and retrieval notification"" },",1
"    { 0x001F, ""Pull module"" },",1
    /*0x0020 - 0x007F manufacturer specific */,1
    /*0x0080 - 0x00FF reserved for profiles */,1
    /*0x0100 - 0xFFFF reserved */,1
static const value_string pn_io_pdu_type[] = {,1
"    { 0x01, ""Data-RTA-PDU"" },",1
"    { 0x02, ""NACK-RTA-PDU"" },",1
"    { 0x03, ""ACK-RTA-PDU"" },",1
"    { 0x04, ""ERR-RTA-PDU"" },",1
static const value_string hf_pn_io_frame_data_properties_forwardingMode[] = {,1
"    { 0x00, ""absolute mode"" },",1
"    { 0x01, ""relative mode""},",1
static const value_string hf_pn_io_frame_data_properties_FFMulticastMACAdd[] = {,1
"    { 0x00, ""Use interface MAC destination unicast address"" },",1
"    { 0x01, ""Use RT_CLASS_3 destination multicast address""},",1
"    { 0x02, ""Use FastForwardingMulticastMACAdd""},",1
"    { 0x03, ""reserved""},",1
"    { 0, NULL }}_",1
static const value_string hf_pn_io_frame_data_properties_FragMode[] = {,1
"    { 0x00, ""No fragmentation"" },",1
"    { 0x01, ""Fragmentation enabled maximum size for static fragmentation 128 bytes""},",1
"    { 0x02, ""Fragmentation enabled maximum size for static fragmentation 256 bytes""},",1
static const value_string pn_io_SFIOCRProperties_DFPType_vals[] = {,1
"    { 0x00, ""DFP_INBOUND"" },",1
"    { 0x01, ""DFP_OUTBOUND"" },",1
static const value_string pn_io_DFPRedundantPathLayout_decode[] = {,1
"    { 0x00, ""The Frame for the redundant path contains the ordering shown by SubframeData"" },",1
"    { 0x01, ""The Frame for the redundant path contains the inverse ordering shown by SubframeData"" },",1
static const value_string pn_io_SFCRC16_Decode[] = {,1
"    { 0x00, ""SFCRC16 and SFCycleCounter shall be created or set to zero by the sender and not checked by the receiver"" },",1
"    { 0x01, ""SFCRC16 and SFCycleCounter shall be created by the sender and checked by the receiver."" },",1
static const value_string pn_io_txgroup_state[] = {,1
"    { 0x00, ""Transmission off"" },",1
"    { 0x01, ""Transmission on "" },",1
static const value_string pn_io_error_code[] = {,1
"    { 0x00, ""OK"" },",1
"    { 0x81, ""PNIO"" },",1
"    { 0xCF, ""RTA error"" },",1
"    { 0xDA, ""AlarmAck"" },",1
"    { 0xDB, ""IODConnectRes"" },",1
"    { 0xDC, ""IODReleaseRes"" },",1
"    { 0xDD, ""IODControlRes"" },",1
"    { 0xDE, ""IODReadRes"" },",1
"    { 0xDF, ""IODWriteRes"" },",1
static const value_string pn_io_error_decode[] = {,1
"    { 0x80, ""PNIORW"" },",1
/* dummy for unknown decode */,1
static const value_string pn_io_error_code1[] = {,1
/* dummy for unknown decode/code1 combination */,1
static const value_string pn_io_error_code2[] = {,1
static const value_string pn_io_error_code1_pniorw[] = {,1
    /* high nibble 0-9 not specified -> legacy codes */,1
"    { 0xa0, ""application: read error"" },",1
"    { 0xa1, ""application: write error"" },",1
"    { 0xa2, ""application: module failure"" },",1
"    { 0xa3, ""application: not specified"" },",1
"    { 0xa4, ""application: not specified"" },",1
"    { 0xa5, ""application: not specified"" },",1
"    { 0xa6, ""application: not specified"" },",1
"    { 0xa7, ""application: busy"" },",1
"    { 0xa8, ""application: version conflict"" },",1
"    { 0xa9, ""application: feature not supported"" },",1
"    { 0xaa, ""application: User specific 1"" },",1
"    { 0xab, ""application: User specific 2"" },",1
"    { 0xac, ""application: User specific 3"" },",1
"    { 0xad, ""application: User specific 4"" },",1
"    { 0xae, ""application: User specific 5"" },",1
"    { 0xaf, ""application: User specific 6"" },",1
"    { 0xb0, ""access: invalid index"" },",1
"    { 0xb1, ""access: write length error"" },",1
"    { 0xb2, ""access: invalid slot/subslot"" },",1
"    { 0xb3, ""access: type conflict"" },",1
"    { 0xb4, ""access: invalid area"" },",1
"    { 0xb5, ""access: state conflict"" },",1
"    { 0xb6, ""access: access denied"" },",1
"    { 0xb7, ""access: invalid range"" },",1
"    { 0xb8, ""access: invalid parameter"" },",1
"    { 0xb9, ""access: invalid type"" },",1
"    { 0xba, ""access: backup"" },",1
"    { 0xbb, ""access: User specific 7"" },",1
"    { 0xbc, ""access: User specific 8"" },",1
"    { 0xbd, ""access: User specific 9"" },",1
"    { 0xbe, ""access: User specific 10"" },",1
"    { 0xbf, ""access: User specific 11"" },",1
"    { 0xc0, ""resource: read constrain conflict"" },",1
"    { 0xc1, ""resource: write constrain conflict"" },",1
"    { 0xc2, ""resource: resource busy"" },",1
"    { 0xc3, ""resource: resource unavailable"" },",1
"    { 0xc4, ""resource: not specified"" },",1
"    { 0xc5, ""resource: not specified"" },",1
"    { 0xc6, ""resource: not specified"" },",1
"    { 0xc7, ""resource: not specified"" },",1
"    { 0xc8, ""resource: User specific 12"" },",1
"    { 0xc9, ""resource: User specific 13"" },",1
"    { 0xca, ""resource: User specific 14"" },",1
"    { 0xcb, ""resource: User specific 15"" },",1
"    { 0xcc, ""resource: User specific 16"" },",1
"    { 0xcd, ""resource: User specific 17"" },",1
"    { 0xce, ""resource: User specific 18"" },",1
"    { 0xcf, ""resource: User specific 19"" },",1
    /* high nibble d-f user specific */,1
static const value_string pn_io_error_code2_pniorw[] = {,1
    /* all values are user specified */,1
static const value_string pn_io_error_code1_pnio[] = {,1
"    { 0x00 /*  0*/, ""Reserved"" },",1
"    { 0x01 /*  1*/, ""Connect: Faulty ARBlockReq"" },",1
"    { 0x02 /*  2*/, ""Connect: Faulty IOCRBlockReq"" },",1
"    { 0x03 /*  3*/, ""Connect: Faulty ExpectedSubmoduleBlockReq"" },",1
"    { 0x04 /*  4*/, ""Connect: Faulty AlarmCRBlockReq"" },",1
"    { 0x05 /*  5*/, ""Connect: Faulty PrmServerBlockReq"" },",1
"    { 0x06 /*  6*/, ""Connect: Faulty MCRBlockReq"" },",1
"    { 0x07 /*  7*/, ""Connect: Faulty ARRPCBlockReq"" },",1
"    { 0x08 /*  8*/, ""Read/Write Record: Faulty Record"" },",1
"    { 0x09 /*  9*/, ""Connect: Faulty SubFrameBlock"" },",1
"    { 0x0A /* 10*/, ""Connect: Faulty IRTFrameBlock"" },",1
"    { 0x0D /* 13*/, ""Connect: Faulty RSInfoBlock"" },",1
"    { 0x14 /* 20*/, ""IODControl: Faulty ControlBlockConnect"" },",1
"    { 0x15 /* 21*/, ""IODControl: Faulty ControlBlockPlug"" },",1
"    { 0x16 /* 22*/, ""IOXControl: Faulty ControlBlock after a connect est."" },",1
"    { 0x17 /* 23*/, ""IOXControl: Faulty ControlBlock a plug alarm"" },",1
"    { 0x28 /* 40*/, ""Release: Faulty ReleaseBlock"" },",1
"    { 0x32 /* 50*/, ""Response: Faulty ARBlockRes"" },",1
"    { 0x33 /* 51*/, ""Response: Faulty IOCRBlockRes"" },",1
"    { 0x34 /* 52*/, ""Response: Faulty AlarmCRBlockRes"" },",1
"    { 0x35 /* 53*/, ""Response: Faulty ModuleDifflock"" },",1
"    { 0x36 /* 54*/, ""Response: Faulty ARRPCBlockRes"" },",1
"    { 0x3c /* 60*/, ""AlarmAck Error Codes"" },",1
"    { 0x3d /* 61*/, ""CMDEV"" },",1
"    { 0x3e /* 62*/, ""CMCTL"" },",1
"    { 0x3f /* 63*/, ""NRPM"" },",1
"    { 0x40 /* 64*/, ""RMPM"" },",1
"    { 0x41 /* 65*/, ""ALPMI"" },",1
"    { 0x42 /* 66*/, ""ALPMR"" },",1
"    { 0x43 /* 67*/, ""LMPM"" },",1
"    { 0x44 /* 68*/, ""MMAC"" },",1
"    { 0x45 /* 69*/, ""RPC"" },",1
"    { 0x46 /* 70*/, ""APMR"" },",1
"    { 0x47 /* 71*/, ""APMS"" },",1
"    { 0x48 /* 72*/, ""CPM"" },",1
"    { 0x49 /* 73*/, ""PPM"" },",1
"    { 0x4a /* 74*/, ""DCPUCS"" },",1
"    { 0x4b /* 75*/, ""DCPUCR"" },",1
"    { 0x4c /* 76*/, ""DCPMCS"" },",1
"    { 0x4d /* 77*/, ""DCPMCR"" },",1
"    { 0x4e /* 78*/, ""FSPM"" },",1
"    { 0xfd /*253*/, ""RTA_ERR_CLS_PROTOCOL"" },",1
"    { 0xff /*255*/, ""User specific"" },",1
static const value_string pn_io_error_code2_pnio_1[] = {,1
    /* CheckingRules for ARBlockReq */,1
"    {  0, ""Error in Parameter BlockType"" },",1
"    {  1, ""Error in Parameter BlockLength"" },",1
"    {  2, ""Error in Parameter BlockVersionHigh"" },",1
"    {  3, ""Error in Parameter BlockVersionLow"" },",1
"    {  4, ""Error in Parameter ARType"" },",1
"    {  5, ""Error in Parameter ARUUID"" },",1
"    {  7, ""Error in Parameter CMInitiatorMACAddress"" },",1
"    {  8, ""Error in Parameter CMInitiatorObjectUUID"" },",1
"    {  9, ""Error in Parameter ARProperties"" },",1
"    { 10, ""Error in Parameter CMInitiatorActivityTimeoutFactor"" },",1
"    { 11, ""Error in Parameter InitiatorUDPRTPort"" },",1
"    { 12, ""Error in Parameter StationNameLength"" },",1
"    { 13, ""Error in Parameter CMInitiatorStationName"" },",1
"    {  0, NULL }",1
static const value_string pn_io_error_code2_pnio_2[] = {,1
    /* CheckingRules for IOCRBlockReq */,1
"    {  4, ""Error in Parameter IOCRType"" },",1
"    {  5, ""Error in Parameter IOCRReference"" },",1
"    {  6, ""Error in Parameter LT"" },",1
"    {  7, ""Error in Parameter IOCRProperties"" },",1
"    {  8, ""Error in Parameter DataLength"" },",1
"    {  9, ""Error in Parameter FrameID"" },",1
"    { 10, ""Error in Parameter SendClockFactor"" },",1
"    { 11, ""Error in Parameter ReductionRatio"" },",1
"    { 12, ""Error in Parameter Phase"" },",1
"    { 14, ""Error in Parameter FrameSendOffset"" },",1
"    { 15, ""Error in Parameter WatchdogFactor"" },",1
"    { 16, ""Error in Parameter DataHoldFactor"" },",1
"    { 17, ""Error in Parameter IOCRTagHeader"" },",1
"    { 18, ""Error in Parameter IOCRMulticastMacAddress"" },",1
"    { 19, ""Error in Parameter NumberOfAPI"" },",1
"    { 20, ""Error in Parameter API"" },",1
"    { 21, ""Error in Parameter NumberOfIODataObjects"" },",1
"    { 22, ""Error in Parameter SlotNumber"" },",1
"    { 23, ""Error in Parameter SubslotNumber"" },",1
"    { 24, ""Error in Parameter IODataObjectFrameOffset"" },",1
"    { 25, ""Error in Parameter NumberOfIOCS"" },",1
"    { 26, ""Error in Parameter SlotNumber"" },",1
"    { 27, ""Error in Parameter SubslotNumber"" },",1
"    { 28, ""Error in Parameter IOCSFrameOffset"" },",1
static const value_string pn_io_error_code2_pnio_3[] = {,1
    /* CheckingRules for ExpectedSubmoduleBlockReq */,1
"    {  4, ""Error in Parameter NumberOfAPI"" },",1
"    {  5, ""Error in Parameter API"" },",1
"    {  6, ""Error in Parameter SlotNumber"" },",1
"    {  7, ""Error in Parameter ModuleIdentNumber"" },",1
"    {  8, ""Error in Parameter ModuleProperties"" },",1
"    {  9, ""Error in Parameter NumberOfSubmodules"" },",1
"    { 10, ""Error in Parameter SubslotNumber"" },",1
"    { 12, ""Error in Parameter SubmoduleProperties"" },",1
"    { 13, ""Error in Parameter DataDescription"" },",1
"    { 14, ""Error in Parameter SubmoduleDataLength"" },",1
"    { 15, ""Error in Parameter LengthIOPS"" },",1
"    { 16, ""Error in Parameter LengthIOCS"" },",1
static const value_string pn_io_error_code2_pnio_4[] = {,1
    /* CheckingRules for AlarmCRBlockReq */,1
"    {  4, ""Error in Parameter AlarmCRType"" },",1
"    {  5, ""Error in Parameter LT"" },",1
"    {  6, ""Error in Parameter AlarmCRProperties"" },",1
"    {  7, ""Error in Parameter RTATimeoutFactor"" },",1
"    {  8, ""Error in Parameter RTARetries"" },",1
"    { 10, ""Error in Parameter MaxAlarmDataLength"" },",1
"    { 11, ""Error in Parameter AlarmCRTagHeaderHigh"" },",1
"    { 12, ""Error in Parameter AlarmCRTagHeaderLow"" },",1
static const value_string pn_io_error_code2_pnio_5[] = {,1
    /* CheckingRules for PrmServerBlockReq */,1
"    { 0, ""Error in Parameter BlockType"" },",1
"    { 1, ""Error in Parameter BlockLength"" },",1
"    { 2, ""Error in Parameter BlockVersionHigh"" },",1
"    { 3, ""Error in Parameter BlockVersionLow"" },",1
"    { 6, ""Error in Parameter CMInitiatorActivityTimeoutFactor"" },",1
"    { 7, ""Error in Parameter StationNameLength"" },",1
"    { 8, ""Error in Parameter ParameterServerStationName"" },",1
static const value_string pn_io_error_code2_pnio_6[] = {,1
    /* CheckingRules for MCRBlockReq */,1
"    { 4, ""Error in Parameter IOCRReference"" },",1
"    { 5, ""Error in Parameter AddressResolutionProperties"" },",1
"    { 6, ""Error in Parameter MCITimeoutFactor"" },",1
"    { 8, ""Error in Parameter ProviderStationName"" },",1
static const value_string pn_io_error_code2_pnio_7[] = {,1
"    { 4, ""Error in Parameter InitiatorRPCServerPort"" },",1
static const value_string pn_io_error_code2_pnio_8[] = {,1
    /* CheckingRules for Read/Write ParameterReqHeader */,1
"    {  6, ""Error in Parameter API"" },",1
"    {  7, ""Error in Parameter SlotNumber"" },",1
"    {  8, ""Error in Parameter SubslotNumber"" },",1
"    {  9, ""Error in Parameter Padding"" },",1
"    { 10, ""Error in Parameter Index"" },",1
"    { 11, ""Error in Parameter RecordDataLength"" },",1
"    { 12, ""Error in Parameter TargetARUUID"" },",1
static const value_string pn_io_error_code2_pnio_13[] = {,1
    /* CheckingRules for RSInfoBlock */,1
"    { 4, ""Error in Parameter Padding"" },",1
"    { 5, ""Error in Parameter RSProperties"" },",1
static const value_string pn_io_error_code2_pnio_20[] = {,1
    /* CheckingRules for ControlBlockConnect */,1
"    { 6, ""Error in Parameter SessionKey"" },",1
"    { 7, ""Error in Parameter Padding"" },",1
"    { 8, ""Error in Parameter ControlCommand"" },",1
"    { 9, ""Error in Parameter ControlBlockProperties"" },",1
static const value_string pn_io_error_code2_pnio_21[] = {,1
    /* CheckingRules for ControlBlockPlug */,1
"    { 7, ""Error in Parameter AlarmSequenceNumber"" },",1
static const value_string pn_io_error_code2_pnio_22[] = {,1
    /* CheckingRule for ControlBlockConnect */,1
static const value_string pn_io_error_code2_pnio_23[] = {,1
static const value_string pn_io_error_code2_pnio_40[] = {,1
    /* CheckingRules for ReleaseBlock */,1
static const value_string pn_io_error_code2_pnio_60[] = {,1
    /* AlarmAck Error Codes */,1
"    { 0, ""Alarm Type Not Supported"" },",1
"    { 1, ""Wrong Submodule State"" },",1
"    { 2, ""IOCARSR Backup - Alarm not executed"" },",1
static const value_string pn_io_error_code2_pnio_61[] = {,1
    /* CMDEV */,1
"    { 0, ""State Conflict"" },",1
"    { 1, ""Resources"" },",1
static const value_string pn_io_error_code2_pnio_62[] = {,1
    /* CMCTL */,1
"    { 1, ""Timeout"" },",1
"    { 2, ""No data send"" },",1
static const value_string pn_io_error_code2_pnio_63[] = {,1
    /* NRPM */,1
"    { 0, ""No DCP active"" },",1
"    { 1, ""DNS Unknown_RealStationName"" },",1
"    { 2, ""DCP No_RealStationName"" },",1
"    { 3, ""DCP Multiple_RealStationName"" },",1
"    { 4, ""DCP No_StationName"" },",1
"    { 5, ""No_IP_Addr"" },",1
"    { 6, ""DCP_Set_Error"" },",1
static const value_string pn_io_error_code2_pnio_64[] = {,1
    /* RMPM */,1
"    { 0, ""ArgsLength invalid"" },",1
"    { 1, ""Unknown Blocks"" },",1
"    { 2, ""IOCR Missing"" },",1
"    { 3, ""Wrong AlarmCRBlock count"" },",1
"    { 4, ""Out of AR Resources"" },",1
"    { 5, ""AR UUID unknown"" },",1
"    { 6, ""State conflict"" },",1
"    { 7, ""Out of Provider, Consumer or Alarm Resources"" },",1
"    { 8, ""Out of Memory"" },",1
static const value_string pn_io_error_code2_pnio_65[] = {,1
    /* ALPMI */,1
"    { 0, ""Invalid State"" },",1
"    { 1, ""Wrong ACK-PDU"" },",1
static const value_string pn_io_error_code2_pnio_66[] = {,1
    /* ALPMR */,1
"    { 1, ""Wrong Notification PDU"" },",1
static const value_string pn_io_error_code2_pnio_70[] = {,1
    /* APMR */,1
"    { 1, ""LMPM signaled error"" },",1
static const value_string pn_io_error_code2_pnio_71[] = {,1
    /* APMS */,1
"    { 2, ""Timeout"" },",1
static const value_string pn_io_error_code2_pnio_72[] = {,1
    /* CPM */,1
"    { 1, ""Invalid State"" },",1
static const value_string pn_io_error_code2_pnio_73[] = {,1
    /* PPM */,1
static const value_string pn_io_error_code2_pnio_74[] = {,1
    /* DCPUCS */,1
"    { 1, ""LMPM signaled an error"" },",1
static const value_string pn_io_error_code2_pnio_75[] = {,1
    /* DCPUCR */,1
static const value_string pn_io_error_code2_pnio_76[] = {,1
    /* DCPMCS */,1
static const value_string pn_io_error_code2_pnio_77[] = {,1
    /* DCPMCR */,1
static const value_string pn_io_error_code2_pnio_253[] = {,1
"    {  0, ""reserved"" },",1
"    {  1, ""Error within the coordination of sequence numbers (RTA_ERR_CODE_SEQ) error"" },",1
"    {  2, ""Instance closed (RTA_ERR_ABORT)"" },",1
"    {  3, ""AR out of memory (RTA_ERR_ABORT)"" },",1
"    {  4, ""AR add provider or consumer failed (RTA_ERR_ABORT)"" },",1
"    {  5, ""AR consumer DHT/WDT expired (RTA_ERR_ABORT)"" },",1
"    {  6, ""AR cmi timeout (RTA_ERR_ABORT)"" },",1
"    {  7, ""AR alarm-open failed (RTA_ERR_ABORT)"" },",1
"    {  8, ""AR alarm-send.cnf(-) (RTA_ERR_ABORT)"" },",1
"    {  9, ""AR alarm-ack-send.cnf(-) (RTA_ERR_ABORT)"" },",1
"    { 10, ""AR alarm data too long (RTA_ERR_ABORT)"" },",1
"    { 11, ""AR alarm.ind(err) (RTA_ERR_ABORT)"" },",1
"    { 12, ""AR rpc-client call.cnf(-) (RTA_ERR_ABORT)"" },",1
"    { 13, ""AR abort.req (RTA_ERR_ABORT)"" },",1
"    { 14, ""AR re-run aborts existing (RTA_ERR_ABORT)"" },",1
"    { 15, ""AR release.ind received (RTA_ERR_ABORT)"" },",1
"    { 16, ""AR device deactivated (RTA_ERR_ABORT)"" },",1
"    { 17, ""AR removed (RTA_ERR_ABORT)"" },",1
"    { 18, ""AR protocol violation (RTA_ERR_ABORT)"" },",1
"    { 19, ""AR name resolution error (RTA_ERR_ABORT)"" },",1
"    { 20, ""AR RPC-Bind error (RTA_ERR_ABORT)"" },",1
"    { 21, ""AR RPC-Connect error (RTA_ERR_ABORT)"" },",1
"    { 22, ""AR RPC-Read error (RTA_ERR_ABORT)"" },",1
"    { 23, ""AR RPC-Write error (RTA_ERR_ABORT)"" },",1
"    { 24, ""AR RPC-Control error (RTA_ERR_ABORT)"" },",1
"    { 25, ""AR forbidden pull or plug after check.rsp and before in-data.ind (RTA_ERR_ABORT)"" },",1
"    { 26, ""AR AP removed (RTA_ERR_ABORT)"" },",1
"    { 27, ""AR link down (RTA_ERR_ABORT)"" },",1
"    { 28, ""AR could not register multicast-mac address (RTA_ERR_ABORT)"" },",1
"    { 29, ""not synchronized (cannot start companion-ar) (RTA_ERR_ABORT)"" },",1
"    { 30, ""wrong topology (cannot start companion-ar) (RTA_ERR_ABORT)"" },",1
"    { 31, ""dcp, station-name changed (RTA_ERR_ABORT)"" },",1
"    { 32, ""dcp, reset to factory-settings (RTA_ERR_ABORT)"" },",1
"    { 33, ""cannot start companion-AR because a 0x8ipp submodule in the first AR... (RTA_ERR_ABORT)"" },",1
"    { 34, ""no irdata record yet (RTA_ERR_ABORT)"" },",1
"    { 35, ""PDEV (RTA_ERROR_ABORT)"" },",1
"    { 36, ""PDEV, no port offers required speed/duplexity (RTA_ERROR_ABORT)"" },",1
"    { 37, ""IP-Suite [of the IOC] changed by means of DCP_Set(IPParameter) or local engineering (RTA_ERROR_ABORT)"" },",1
static const value_string pn_io_error_code2_pnio_255[] = {,1
    /* User specific */,1
"    { 255, ""User abort"" },",1
static const value_string pn_io_ioxs[] = {,1
"    { 0x00 /*  0*/, ""detected by subslot"" },",1
"    { 0x01 /*  1*/, ""detected by slot"" },",1
"    { 0x02 /*  2*/, ""detected by IO device"" },",1
"    { 0x03 /*  3*/, ""detected by IO controller"" },",1
static const value_string pn_io_ar_type[] = {,1
"    { 0x0000, ""reserved"" },",1
"    { 0x0001, ""IO Controller AR""},",1
"    { 0x0002, ""reserved"" },",1
"    { 0x0003, ""IOCARCIR"" },",1
"    { 0x0004, ""reserved"" },",1
"    { 0x0005, ""reserved"" },",1
"    { 0x0006, ""IO Supervisor AR / DeviceAccess AR"" },",1
    /*0x0007 - 0x000F reserved */,1
"    { 0x0010, ""IO Controller AR (RT_CLASS_3)"" },",1
    /*0x0011 - 0x001F reserved */,1
"    { 0x0020, ""IO Controller AR (sysred/CiR)"" },",1
    /*0x0007 - 0xFFFF reserved */,1
static const value_string pn_io_iocr_type[] = {,1
"    { 0x0001, ""Input CR"" },",1
"    { 0x0002, ""Output CR"" },",1
"    { 0x0003, ""Multicast Provider CR"" },",1
"    { 0x0004, ""Multicast Consumer CR"" },",1
    /*0x0005 - 0xFFFF reserved */,1
static const value_string pn_io_data_description[] = {,1
"    { 0x0001, ""Input"" },",1
"    { 0x0002, ""Output"" },",1
"    { 0x0003, ""reserved"" },",1
    /*0x0004 - 0xFFFF reserved */,1
static const value_string pn_io_module_state[] = {,1
"    { 0x0000, ""no module"" },",1
"    { 0x0001, ""wrong module"" },",1
"    { 0x0002, ""proper module"" },",1
"    { 0x0003, ""substitute"" },",1
static const value_string pn_io_arproperties_state[] = {,1
"    { 0x00000000, ""Reserved"" },",1
"    { 0x00000001, ""Active"" },",1
"    { 0x00000002, ""reserved"" },",1
"    { 0x00000003, ""reserved"" },",1
"    { 0x00000004, ""reserved"" },",1
"    { 0x00000005, ""reserved"" },",1
"    { 0x00000006, ""reserved"" },",1
"    { 0x00000007, ""reserved"" },",1
static const value_string pn_io_arproperties_supervisor_takeover_allowed[] = {,1
"    { 0x00000000, ""not allowed"" },",1
"    { 0x00000001, ""allowed"" },",1
static const value_string pn_io_arproperties_parametrization_server[] = {,1
"    { 0x00000000, ""External PrmServer"" },",1
"    { 0x00000001, ""CM Initiator"" },",1
/* BIT 8 */,1
static const value_string pn_io_arproperties_DeviceAccess[] = {,1
"    { 0x00000000, ""Only the submodules from the ExpectedSubmoduleBlock are accessible"" },",1
"    { 0x00000001, ""Submodule access is controlled by IO device application"" },",1
/* Bit 9 - 10 */,1
static const value_string pn_io_arproperties_companion_ar[] = {,1
"    { 0x00000000, ""Single AR"" },",1
"    { 0x00000001, ""First AR of a companion pair and a companion AR shall follow"" },",1
"    { 0x00000002, ""Companion AR"" },",1
"    { 0x00000003, ""Reserved"" },",1
/* REMOVED with 2.3,1
static const value_string pn_io_arproperties_data_rate[] = {,1
"    { 0x00000000, ""at least 100 MB/s or more"" },",1
"    { 0x00000001, ""100 MB/s"" },",1
"    { 0x00000002, ""1 GB/s"" },",1
"    { 0x00000003, ""10 GB/s"" },",1
/* BIT 11 */,1
static const value_string pn_io_arproperties_acknowldege_companion_ar[] = {,1
"    { 0x00000000, ""No companion AR or no acknowledge for the companion AR required"" },",1
"    { 0x00000001, ""Companion AR with acknowledge"" },",1
/* bit 29 for legacy startup mode*/,1
static const value_string pn_io_arproperties_combined_object_container_with_legacy_startupmode[] = {,1
"    { 0x00000000, ""CombinedObjectContainer not used"" },",1
"    { 0x00000001, ""Reserved"" },",1
/* bit 29 for advanced statup mode*/,1
static const value_string pn_io_arproperties_combined_object_container_with_advanced_startupmode[] = {,1
"    { 0x00000001, ""Usage of CombinedObjectContainer required"" },",1
/* bit 30 */,1
static const value_string pn_io_arpropertiesStartupMode[] = {,1
"    { 0x00000000, ""Legacy"" },",1
"    { 0x00000001, ""Advanced"" },",1
/* bit 31 */,1
static const value_string pn_io_arproperties_pull_module_alarm_allowed[] = {,1
"    { 0x00000000, ""AlarmType(=Pull) shall signal pulling of submodule and module"" },",1
"    { 0x00000001, ""AlarmType(=Pull) shall signal pulling of submodule"" },",1
static const value_string pn_io_RedundancyInfo[] = {,1
"    { 0x00000001, ""The delivering node is the left or below one"" },",1
"    { 0x00000002, ""The delivering node is the right or above one"" },",1
static const value_string pn_io_iocr_properties_rtclass[] = {,1
"    { 0x00000000, ""reserved"" },",1
"    { 0x00000001, ""RT_CLASS_1"" },",1
"    { 0x00000002, ""RT_CLASS_2"" },",1
"    { 0x00000003, ""RT_CLASS_3"" },",1
"    { 0x00000004, ""RT_CLASS_UDP"" },",1
    /*0x00000005 - 0x00000007 reserved */,1
static const value_string pn_io_MultipleInterfaceMode_NameOfDevice[] = {,1
"    { 0x00000000, ""PortID of LLDP contains name of port (Default)"" },",1
"    { 0x00000001, ""PortID of LLDP contains name of port and NameOfStation"" },",1
static const true_false_string tfs_pn_io_sr_properties_BackupAR_with_SRProperties_Mode_0 =,1
"    { ""The device shall deliver valid input data"", ""The IO controller shall not evaluate the input data."" }_",1
static const true_false_string tfs_pn_io_sr_properties_BackupAR_with_SRProperties_Mode_1 =,1
"    { ""The device shall deliver valid input data"", ""The IO device shall mark the data as invalid using APDU_Status.DataStatus.DataValid == Invalid."" }_",1
static const true_false_string tfs_pn_io_sr_properties_Mode =,1
"    { ""Default The IO device shall use APDU_Status.DataStatus.DataValid == Invalid if input data is request as not valid."",",1
"      ""The IO controller do not support APDU_Status.DataStatus.DataValid == Invalid if input data is request as not valid."" }_",1
static const true_false_string tfs_pn_io_sr_properties_Reserved1 =,1
"    { ""Legacy mode"", ""Shall be set to zero for this standard."" }_",1
static const value_string pn_io_iocr_properties_media_redundancy[] = {,1
"    { 0x00000000, ""No media redundant frame transfer"" },",1
"    { 0x00000001, ""Media redundant frame transfer"" },",1
static const value_string pn_io_submodule_properties_type[] = {,1
"    { 0x0000, ""no input and no output data"" },",1
"    { 0x0001, ""input data"" },",1
"    { 0x0002, ""output data"" },",1
"    { 0x0003, ""input and output data"" },",1
static const value_string pn_io_submodule_properties_shared_input[] = {,1
"    { 0x0000, ""IO controller"" },",1
"    { 0x0001, ""IO controller shared"" },",1
static const value_string pn_io_submodule_properties_reduce_input_submodule_data_length[] = {,1
"    { 0x0000, ""Expected"" },",1
"    { 0x0001, ""Zero"" },",1
static const value_string pn_io_submodule_properties_reduce_output_submodule_data_length[] = {,1
static const value_string pn_io_submodule_properties_discard_ioxs[] = {,1
static const value_string pn_io_alarmcr_properties_priority[] = {,1
"    { 0x0000, ""user priority (default)"" },",1
"    { 0x0001, ""use only low priority"" },",1
static const value_string pn_io_alarmcr_properties_transport[] = {,1
"    { 0x0000, ""RTA_CLASS_1"" },",1
"    { 0x0001, ""RTA_CLASS_UDP"" },",1
static const value_string pn_io_submodule_state_format_indicator[] = {,1
"    { 0x0000, ""Coding uses Detail"" },",1
"    { 0x0001, ""Coding uses .IdentInfo, ..."" },",1
static const value_string pn_io_submodule_state_add_info[] = {,1
"    { 0x0000, ""None"" },",1
"    { 0x0001, ""Takeover not allowed"" },",1
    /*0x0002 - 0x0007 reserved */,1
static const value_string pn_io_submodule_state_qualified_info[] = {,1
"    { 0x0000, ""No QualifiedInfo available"" },",1
"    { 0x0001, ""QualifiedInfo available"" },",1
static const value_string pn_io_submodule_state_maintenance_required[] = {,1
"    { 0x0000, ""No MaintenanceRequired available"" },",1
"    { 0x0001, ""MaintenanceRequired available"" },",1
static const value_string pn_io_submodule_state_maintenance_demanded[] = {,1
"    { 0x0000, ""No MaintenanceDemanded available"" },",1
"    { 0x0001, ""MaintenanceDemanded available"" },",1
static const value_string pn_io_submodule_state_diag_info[] = {,1
"    { 0x0000, ""No DiagnosisData available"" },",1
"    { 0x0001, ""DiagnosisData available"" },",1
static const value_string pn_io_submodule_state_ar_info[] = {,1
"    { 0x0000, ""Own"" },",1
"    { 0x0001, ""ApplicationReadyPending (ARP)"" },",1
"    { 0x0002, ""Superordinated Locked (SO)"" },",1
"    { 0x0003, ""Locked By IO Controller (IOC)"" },",1
"    { 0x0004, ""Locked By IO Supervisor (IOS)"" },",1
    /*0x0005 - 0x000F reserved */,1
static const value_string pn_io_submodule_state_ident_info[] = {,1
"    { 0x0000, ""OK"" },",1
"    { 0x0001, ""Substitute (SU)"" },",1
"    { 0x0002, ""Wrong (WR)"" },",1
"    { 0x0003, ""NoSubmodule (NO)"" },",1
    /*0x0004 - 0x000F reserved */,1
static const value_string pn_io_submodule_state_detail[] = {,1
"    { 0x0000, ""no submodule"" },",1
"    { 0x0001, ""wrong submodule"" },",1
"    { 0x0002, ""locked by IO controller"" },",1
"    { 0x0004, ""application ready pending"" },",1
"    { 0x0006, ""reserved"" },",1
"    { 0x0007, ""Substitute"" },",1
    /*0x0008 - 0x7FFF reserved */,1
static const value_string pn_io_substitutionmode[] = {,1
"    { 0x0000, ""ZERO"" },",1
"    { 0x0001, ""Last value"" },",1
"    { 0x0002, ""Replacement value"" },",1
    /*0x0003 - 0xFFFF reserved */,1
static const value_string pn_io_index[] = {,1
    /*0x0008 - 0x7FFF user specific */,1
    /* PROFISafe */,1
"    { 0x0100, ""PROFISafe"" },",1
    /* subslot specific */,1
"    { 0x8000, ""ExpectedIdentificationData for one subslot"" },",1
"    { 0x8001, ""RealIdentificationData for one subslot"" },",1
    /*0x8002 - 0x8009 reserved */,1
"    { 0x800A, ""Diagnosis in channel coding for one subslot"" },",1
"    { 0x800B, ""Diagnosis in all codings for one subslot"" },",1
"    { 0x800C, ""Diagnosis, Maintenance, Qualified and Status for one subslot"" },",1
    /*0x800D - 0x800F reserved */,1
"    { 0x8010, ""Maintenance required in channel coding for one subslot"" },",1
"    { 0x8011, ""Maintenance demanded in channel coding for one subslot"" },",1
"    { 0x8012, ""Maintenance required in all codings for one subslot"" },",1
"    { 0x8013, ""Maintenance demanded in all codings for one subslot"" },",1
    /*0x8014 - 0x801D reserved */,1
"    { 0x801E, ""SubstituteValues for one subslot"" },",1
    /*0x801F - 0x8027 reserved */,1
"    { 0x8028, ""RecordInputDataObjectElement for one subslot"" },",1
"    { 0x8029, ""RecordOutputDataObjectElement for one subslot"" },",1
"    { 0x802A, ""PDPortDataReal for one subslot"" },",1
"    { 0x802B, ""PDPortDataCheck for one subslot"" },",1
"    { 0x802C, ""PDIRData for one subslot"" },",1
"    { 0x802D, ""Expected PDSyncData for one subslot with SyncID value 0"" },",1
    /*0x802E reserved */,1
"    { 0x802F, ""PDPortDataAdjust for one subslot"" },",1
"    { 0x8030, ""IsochronousModeData for one subslot"" },",1
"    { 0x8031, ""Expected PDSyncData for one subslot with SyncID value 1"" },",1
"    { 0x8032, ""Expected PDSyncData for one subslot with SyncID value 2"" },",1
"    { 0x8033, ""Expected PDSyncData for one subslot with SyncID value 3"" },",1
"    { 0x8034, ""Expected PDSyncData for one subslot with SyncID value 4"" },",1
"    { 0x8035, ""Expected PDSyncData for one subslot with SyncID value 5"" },",1
"    { 0x8036, ""Expected PDSyncData for one subslot with SyncID value 6"" },",1
"    { 0x8037, ""Expected PDSyncData for one subslot with SyncID value 7"" },",1
"    { 0x8038, ""Expected PDSyncData for one subslot with SyncID value 8"" },",1
"    { 0x8039, ""Expected PDSyncData for one subslot with SyncID value 9"" },",1
"    { 0x803A, ""Expected PDSyncData for one subslot with SyncID value 10"" },",1
"    { 0x803B, ""Expected PDSyncData for one subslot with SyncID value 11"" },",1
"    { 0x803C, ""Expected PDSyncData for one subslot with SyncID value 12"" },",1
"    { 0x803D, ""Expected PDSyncData for one subslot with SyncID value 13"" },",1
"    { 0x803E, ""Expected PDSyncData for one subslot with SyncID value 14"" },",1
"    { 0x803F, ""Expected PDSyncData for one subslot with SyncID value 15"" },",1
"    { 0x8040, ""Expected PDSyncData for one subslot with SyncID value 16"" },",1
"    { 0x8041, ""Expected PDSyncData for one subslot with SyncID value 17"" },",1
"    { 0x8042, ""Expected PDSyncData for one subslot with SyncID value 18"" },",1
"    { 0x8043, ""Expected PDSyncData for one subslot with SyncID value 19"" },",1
"    { 0x8044, ""Expected PDSyncData for one subslot with SyncID value 20"" },",1
"    { 0x8045, ""Expected PDSyncData for one subslot with SyncID value 21"" },",1
"    { 0x8046, ""Expected PDSyncData for one subslot with SyncID value 22"" },",1
"    { 0x8047, ""Expected PDSyncData for one subslot with SyncID value 23"" },",1
"    { 0x8048, ""Expected PDSyncData for one subslot with SyncID value 24"" },",1
"    { 0x8049, ""Expected PDSyncData for one subslot with SyncID value 25"" },",1
"    { 0x804A, ""Expected PDSyncData for one subslot with SyncID value 26"" },",1
"    { 0x804B, ""Expected PDSyncData for one subslot with SyncID value 27"" },",1
"    { 0x804C, ""Expected PDSyncData for one subslot with SyncID value 28"" },",1
"    { 0x804D, ""Expected PDSyncData for one subslot with SyncID value 29"" },",1
"    { 0x804E, ""Expected PDSyncData for one subslot with SyncID value 30"" },",1
"    { 0x804F, ""Expected PDSyncData for one subslot with SyncID value 31"" },",1
"    { 0x8050, ""PDInterfaceMrpDataReal for one subslot"" },",1
"    { 0x8051, ""PDInterfaceMrpDataCheck for one subslot"" },",1
"    { 0x8052, ""PDInterfaceMrpDataAdjust for one subslot"" },",1
"    { 0x8053, ""PDPortMrpDataAdjust for one subslot"" },",1
"    { 0x8054, ""PDPortMrpDataReal for one subslot"" },",1
    /*0x8055 - 0x805F reserved */,1
"    { 0x8060, ""PDPortFODataReal for one subslot"" },",1
"    { 0x8061, ""PDPortFODataCheck for one subslot"" },",1
"    { 0x8062, ""PDPortFODataAdjust for one subslot"" },",1
    /*0x8063 - 0x806F reserved */,1
"    { 0x8070, ""PDNCDataCheck for one subslot"" },",1
"    { 0x8071, ""PDInterfaceAdjust for one subslot"" },",1
"    { 0x8072, ""PDPortStatistic for one subslot"" },",1
    /*0x8071 - 0x807F reserved */,1
"    { 0x8080, ""PDInterfaceDataReal"" },",1
    /*0x8081 - 0x808F reserved */,1
"    { 0x8090, ""Expected PDInterfaceFSUDataAdjust"" },",1
    /*0x8091 - 0xAFEF reserved except 0x80B0*/,1
"    { 0x80B0, ""CombinedObjectContainer"" },",1
"    { 0x80CF, ""RS_AdjustObserver"" },",1
"    { 0xAFF0, ""I&M0"" },",1
"    { 0xAFF1, ""I&M1"" },",1
"    { 0xAFF2, ""I&M2"" },",1
"    { 0xAFF3, ""I&M3"" },",1
"    { 0xAFF4, ""I&M4"" },",1
"    { 0xAFF5, ""I&M5"" },",1
"    { 0xAFF6, ""I&M6"" },",1
"    { 0xAFF7, ""I&M7"" },",1
"    { 0xAFF8, ""I&M8"" },",1
"    { 0xAFF9, ""I&M9"" },",1
"    { 0xAFFA, ""I&M10"" },",1
"    { 0xAFFB, ""I&M11"" },",1
"    { 0xAFFC, ""I&M12"" },",1
"    { 0xAFFD, ""I&M13"" },",1
"    { 0xAFFE, ""I&M14"" },",1
"    { 0xAFFF, ""I&M15"" },",1
    /*0xB000 - 0xB02D reserved for profiles */,1
"    { 0xB000, ""Sync-Log / RTA SyncID 0 (GSY)"" },",1
"    { 0xB001, ""Sync-Log / RTA SyncID 1 (GSY)"" },",1
"    { 0xB002, ""reserved for profiles"" },",1
"    { 0xB003, ""reserved for profiles"" },",1
"    { 0xB004, ""reserved for profiles"" },",1
"    { 0xB005, ""reserved for profiles"" },",1
"    { 0xB006, ""reserved for profiles"" },",1
"    { 0xB007, ""reserved for profiles"" },",1
"    { 0xB008, ""reserved for profiles"" },",1
"    { 0xB009, ""reserved for profiles"" },",1
"    { 0xB00A, ""reserved for profiles"" },",1
"    { 0xB00B, ""reserved for profiles"" },",1
"    { 0xB00C, ""reserved for profiles"" },",1
"    { 0xB00D, ""reserved for profiles"" },",1
"    { 0xB00E, ""reserved for profiles"" },",1
"    { 0xB00F, ""reserved for profiles"" },",1
"    { 0xB010, ""reserved for profiles"" },",1
"    { 0xB011, ""reserved for profiles"" },",1
"    { 0xB012, ""reserved for profiles"" },",1
"    { 0xB013, ""reserved for profiles"" },",1
"    { 0xB014, ""reserved for profiles"" },",1
"    { 0xB015, ""reserved for profiles"" },",1
"    { 0xB016, ""reserved for profiles"" },",1
"    { 0xB017, ""reserved for profiles"" },",1
"    { 0xB018, ""reserved for profiles"" },",1
"    { 0xB019, ""reserved for profiles"" },",1
"    { 0xB01A, ""reserved for profiles"" },",1
"    { 0xB01B, ""reserved for profiles"" },",1
"    { 0xB01C, ""reserved for profiles"" },",1
"    { 0xB01D, ""reserved for profiles"" },",1
"    { 0xB01E, ""reserved for profiles"" },",1
"    { 0xB01F, ""reserved for profiles"" },",1
"    { 0xB020, ""reserved for profiles"" },",1
"    { 0xB001, ""reserved for profiles"" },",1
"    { 0xB022, ""reserved for profiles"" },",1
"    { 0xB023, ""reserved for profiles"" },",1
"    { 0xB024, ""reserved for profiles"" },",1
"    { 0xB025, ""reserved for profiles"" },",1
"    { 0xB026, ""reserved for profiles"" },",1
"    { 0xB027, ""reserved for profiles"" },",1
"    { 0xB028, ""reserved for profiles"" },",1
"    { 0xB029, ""reserved for profiles"" },",1
"    { 0xB02A, ""reserved for profiles"" },",1
"    { 0xB02B, ""reserved for profiles"" },",1
"    { 0xB02C, ""reserved for profiles"" },",1
"    { 0xB02D, ""reserved for profiles"" },",1
    /* PROFIDrive */,1
"    { 0xB02E, ""PROFIDrive Parameter Access - Local""},",1
"    { 0xB02F, ""PROFIDrive Parameter Access - Global""},",1
    /*0xB030 - 0xBFFF reserved for profiles */,1
"    { 0xB060, ""EDD Trace Unit (EDD"" },",1
"    { 0xB061, ""EDD Trace Unit (EDD"" },",1
    /* slot specific */,1
"    { 0xC000, ""ExpectedIdentificationData for one slot"" },",1
"    { 0xC001, ""RealIdentificationData for one slot"" },",1
    /*0xC002 - 0xC009 reserved */,1
"    { 0xC00A, ""Diagnosis in channel coding for one slot"" },",1
"    { 0xC00B, ""Diagnosis in all codings for one slot"" },",1
"    { 0xC00C, ""Diagnosis, Maintenance, Qualified and Status for one slot"" },",1
    /*0xC00D - 0xC00F reserved */,1
"    { 0xC010, ""Maintenance required in channel coding for one slot"" },",1
"    { 0xC011, ""Maintenance demanded in channel coding for one slot"" },",1
"    { 0xC012, ""Maintenance required in all codings for one slot"" },",1
"    { 0xC013, ""Maintenance demanded in all codings for one slot"" },",1
    /*0xC014 - 0xCFFF reserved */,1
    /*0xD000 - 0xDFFF reserved for profiles */,1
    /* AR specific */,1
"    { 0xE000, ""ExpectedIdentificationData for one AR"" },",1
"    { 0xE001, ""RealIdentificationData for one AR"" },",1
"    { 0xE002, ""ModuleDiffBlock for one AR"" },",1
    /*0xE003 - 0xE009 reserved */,1
"    { 0xE00A, ""Diagnosis in channel coding for one AR"" },",1
"    { 0xE00B, ""Diagnosis in all codings for one AR"" },",1
"    { 0xE00C, ""Diagnosis, Maintenance, Qualified and Status for one AR"" },",1
    /*0xE00D - 0xE00F reserved */,1
"    { 0xE010, ""Maintenance required in channel coding for one AR"" },",1
"    { 0xE011, ""Maintenance demanded in channel coding for one AR"" },",1
"    { 0xE012, ""Maintenance required in all codings for one AR"" },",1
"    { 0xE013, ""Maintenance demanded in all codings for one AR"" },",1
    /*0xE014 - 0xE02F reserved */,1
"    { 0xE030, ""IsochronousModeData for one AR"" },",1
    /*0xE031 - 0xE03F reserved */,1
"    { 0xE040, ""MultipleWrite"" },",1
    /*0xE041 - 0xE04F reserved */,1
"    { 0xE050, ""ARFSUDataAdjust data for one AR"" },",1
    /*0xE051 - 0xE05F reserved */,1
"    { 0xE060, ""RS_GetEvent (using RecordDataRead service)"" },",1
"    { 0xE061, ""RS_AckEvent (using RecordDataWrite service)"" },",1
    /*0xEC00 - 0xEFFF reserved */,1
    /* API specific */,1
"    { 0xF000, ""RealIdentificationData for one API"" },",1
    /*0xF001 - 0xF009 reserved */,1
"    { 0xF00A, ""Diagnosis in channel coding for one API"" },",1
"    { 0xF00B, ""Diagnosis in all codings for one API"" },",1
"    { 0xF00C, ""Diagnosis, Maintenance, Qualified and Status for one API"" },",1
    /*0xF00D - 0xF00F reserved */,1
"    { 0xF010, ""Maintenance required in channel coding for one API"" },",1
"    { 0xF011, ""Maintenance demanded in channel coding for one API"" },",1
"    { 0xF012, ""Maintenance required in all codings for one API"" },",1
"    { 0xF013, ""Maintenance demanded in all codings for one API"" },",1
    /*0xF014 - 0xF01F reserved */,1
"    { 0xF020, ""ARData for one API"" },",1
    /*0xF021 - 0xF3FF reserved */,1
    /*0xF400 - 0xF7FF reserved */,1
    /* device specific */,1
    /*0xF800 - 0xF80B reserved */,1
"    { 0xF80C, ""Diagnosis, Maintenance, Qualified and Status for one device"" },",1
    /*0xF80D - 0xF81F reserved */,1
"    { 0xF820, ""ARData"" },",1
"    { 0xF821, ""APIData"" },",1
    /*0xF822 - 0xF82F reserved */,1
"    { 0xF830, ""LogData"" },",1
"    { 0xF831, ""PDevData"" },",1
    /*0xF832 - 0xF83F reserved */,1
"    { 0xF840, ""I&M0FilterData"" },",1
"    { 0xF841, ""PDRealData"" },",1
"    { 0xF842, ""PDExpectedData"" },",1
    /*0xF843 - 0xF84F reserved */,1
"    { 0xF850, ""AutoConfigurarion"" },",1
"    { 0xF880, ""AssetManagementData"" },",1
    /*0xF851 - 0xFBFF reserved */,1
    /*0xFC00 - 0xFFFF reserved for profiles */,1
static const value_string pn_io_user_structure_identifier[] = {,1
    /*0x0000 - 0x7FFF manufacturer specific */,1
"    { 0x8000, ""ChannelDiagnosis"" },",1
"    { 0x8001, ""Multiple"" },",1
"    { 0x8002, ""ExtChannelDiagnosis"" },",1
"    { 0x8003, ""QualifiedChannelDiagnosis"" },",1
    /*0x8004 - 0x80FF reserved */,1
"    { 0x8100, ""Maintenance"" },",1
"    /*0x8101 - 0x8FFF reserved  except 8300, 8301, 8302, 8303 */",1
"    { 0x8300, ""Sequence of events RS_LowWatermark"" },",1
"    { 0x8301, ""Sequence of events RS_Timeout"" },",1
"    { 0x8302, ""Sequence of events RS_Overflow"" },",1
"    { 0x8303, ""Sequence of events RS_Event"" },",1
    /*0x9000 - 0x9FFF reserved for profiles */,1
    /*0xA000 - 0xFFFF reserved */,1
static const value_string pn_io_channel_error_type[] = {,1
"    { 0x0001, ""short circuit"" },",1
"    { 0x0002, ""Undervoltage"" },",1
"    { 0x0003, ""Overvoltage"" },",1
"    { 0x0004, ""Overload"" },",1
"    { 0x0005, ""Overtemperature"" },",1
"    { 0x0006, ""line break"" },",1
"    { 0x0007, ""upper limit value exceeded"" },",1
"    { 0x0008, ""lower limit value exceeded"" },",1
"    { 0x0009, ""Error"" },",1
    /*0x000A - 0x000F reserved */,1
"    { 0x0010, ""parametrization fault"" },",1
"    { 0x0011, ""power supply fault"" },",1
"    { 0x0012, ""fuse blown / open"" },",1
"    { 0x0013, ""Manufacturer specific"" },",1
"    { 0x0014, ""ground fault"" },",1
"    { 0x0015, ""reference point lost"" },",1
"    { 0x0016, ""process event lost / sampling error"" },",1
"    { 0x0017, ""threshold warning"" },",1
"    { 0x0018, ""output disabled"" },",1
"    { 0x0019, ""safety event"" },",1
"    { 0x001A, ""external fault"" },",1
    /*0x001B - 0x001F manufacturer specific */,1
    /*0x0020 - 0x00FF reserved for common profiles */,1
    /*0x0100 - 0x7FFF manufacturer specific */,1
"    { 0x8000, ""Data transmission impossible"" },",1
"    { 0x8001, ""Remote mismatch"" },",1
"    { 0x8002, ""Media redundancy mismatch"" },",1
"    { 0x8003, ""Sync mismatch"" },",1
"    { 0x8004, ""IsochronousMode mismatch"" },",1
"    { 0x8005, ""Multicast CR mismatch"" },",1
"    { 0x8006, ""reserved"" },",1
"    { 0x8007, ""Fiber optic mismatch"" },",1
"    { 0x8008, ""Network component function mismatch"" },",1
"    { 0x8009, ""Time mismatch"" },",1
    /* added values for IEC version 2.3: */,1
"    { 0x800A, ""Dynamic frame packing function mismatch"" },",1
"    { 0x800B, ""Media redundancy with planned duplication mismatch""},",1
"    { 0x800C, ""System redundancy mismatch""},",1
    /* ends */,1
    /*0x800D - 0x8FFF reserved */,1
    /*0x9000 - 0x9FFF reserved for profile */,1
    /* ExtChannelErrorType for ChannelErrorType 0 - 0x7FFF */,1
static const value_string pn_io_ext_channel_error_type0[] = {,1
    /* 0x0000 Reserved */,1
    /* 0x0001 - 0x7FFF Manufacturer specific */,1
"    { 0x8000, ""Accumulative Info""},",1
    /* 0x8001 - 0x8FFF Reserved */,1
    /* 0x9000 - 0x9FFF Reserved for profiles */,1
    /* 0xA000 - 0xFFFF Reserved */,1
"    /* ExtChannelErrorType for ChannelErrorType ""Data transmission impossible"" */",1
static const value_string pn_io_ext_channel_error_type0x8000[] = {,1
"    { 0x8000, ""Link State mismatch - Link down""},",1
"    { 0x8001, ""MAUType mismatch""},",1
"    { 0x8002, ""Line Delay mismatch""},",1
    /* 0x8003 - 0x8FFF Reserved */,1
"    /* ExtChannelErrorType for ChannelErrorType ""Remote mismatch"" */",1
static const value_string pn_io_ext_channel_error_type0x8001[] = {,1
"    { 0x8000, ""Peer Chassis ID mismatch""},",1
"    { 0x8001, ""Peer Port ID mismatch""},",1
"    { 0x8002, ""Peer RT_CLASS_3 mismatch a""},",1
"    { 0x8003, ""Peer MAUType mismatch""},",1
"    { 0x8004, ""Peer MRP domain mismatch""},",1
"    { 0x8005, ""No peer detected""},",1
"    { 0x8006, ""Reserved""},",1
"    { 0x8007, ""Peer Line Delay mismatch""},",1
"    { 0x8008, ""Peer PTCP mismatch b""},",1
"    { 0x8009, ""Peer Preamble Length mismatch""},",1
"    { 0x800A, ""Peer Fragmentation mismatch""},",1
    /* 0x800B - 0x8FFF Reserved */,1
"    /* ExtChannelErrorType for ChannelErrorType ""Media redundancy mismatch"" 0x8002 */",1
static const value_string pn_io_ext_channel_error_type0x8002[] = {,1
"    { 0x8000, ""Manager role fail MRP-instance 1""},",1
"    { 0x8001, ""MRP-instance 1 ring open""},",1
"    { 0x8002, ""Reserved""},",1
"    { 0x8003, ""Multiple manager MRP-instance 1""},",1
"    { 0x8010, ""Manager role fail MRP-instance 2""},",1
"    { 0x8011, ""MRP-instance 2 ring open""},",1
"    { 0x8012, ""Reserved""},",1
"    { 0x8013, ""Multiple manager MRP-instance 2""},",1
"    { 0x8020, ""Manager role fail MRP-instance 3""},",1
"    { 0x8021, ""MRP-instance 3 ring open""},",1
"    { 0x8023, ""Multiple manager MRP-instance 3""},",1
"    { 0x8030, ""Manager role fail MRP-instance 4""},",1
"    { 0x8031, ""MRP-instance 4 ring open""},",1
"    { 0x8033, ""Multiple manager MRP-instance 4""},",1
"    { 0x8040, ""Manager role fail MRP-instance 5""},",1
"    { 0x8041, ""MRP-instance 5 ring open""},",1
"    { 0x8043, ""Multiple manager MRP-instance 5""},",1
"    { 0x8050, ""Manager role fail MRP-instance 6""},",1
"    { 0x8051, ""MRP-instance 6 ring open""},",1
"    { 0x8053, ""Multiple manager MRP-instance 6""},",1
"    { 0x8060, ""Manager role fail MRP-instance 7""},",1
"    { 0x8061, ""MRP-instance 7 ring open""},",1
"    { 0x8063, ""Multiple manager MRP-instance 7""},",1
"    { 0x8070, ""Manager role fail MRP-instance 8""},",1
"    { 0x8071, ""MRP-instance 8 ring open""},",1
"    { 0x8073, ""Multiple manager MRP-instance 8""},",1
"    { 0x8080, ""Manager role fail MRP-instance 9""},",1
"    { 0x8081, ""MRP-instance 9 ring open""},",1
"    { 0x8083, ""Multiple manager MRP-instance 9""},",1
"    { 0x8090, ""Manager role fail MRP-instance 10""},",1
"    { 0x8091, ""MRP-instance 10 ring open""},",1
"    { 0x8093, ""Multiple manager MRP-instance 10""},",1
"    { 0x80A0, ""Manager role fail MRP-instance 11""},",1
"    { 0x80A1, ""MRP-instance 11 ring open""},",1
"    { 0x80A3, ""Multiple manager MRP-instance 11""},",1
"    { 0x80B0, ""Manager role fail MRP-instance 12""},",1
"    { 0x80B1, ""MRP-instance 12 ring open""},",1
"    { 0x80B3, ""Multiple manager MRP-instance 12""},",1
"    { 0x80C0, ""Manager role fail MRP-instance 13""},",1
"    { 0x80C1, ""MRP-instance 13 ring open""},",1
"    { 0x80C3, ""Multiple manager MRP-instance 13""},",1
"    { 0x80D0, ""Manager role fail MRP-instance 14""},",1
"    { 0x80D1, ""MRP-instance 14 ring open""},",1
"    { 0x80D3, ""Multiple manager MRP-instance 14""},",1
"    { 0x80E0, ""Manager role fail MRP-instance 15""},",1
"    { 0x80E1, ""MRP-instance 15 ring open""},",1
"    { 0x80E3, ""Multiple manager MRP-instance 15""},",1
"    { 0x80F0, ""Manager role fail MRP-instance 16""},",1
"    { 0x80F1, ""MRP-instance 16 ring open""},",1
"    { 0x80F3, ""Multiple manager MRP-instance 16""},",1
    /* 0x8004 - 0x8FFF Reserved */,1
"    /* ExtChannelErrorType for ChannelErrorType ""Sync mismatch"" and for ChannelErrorType ""Time mismatch"" 0x8003 and 0x8009*/",1
static const value_string pn_io_ext_channel_error_type0x8003[] = {,1
"    { 0x8000, ""No sync message received""},",1
"    { 0x8001, ""- 0x8002 Reserved""},",1
"    { 0x8003, ""Jitter out of boundary""},",1
"    /*ExtChannelErrorType for ChannelErrorType ""Isochronous mode mismatch"" 0x8004 */",1
static const value_string pn_io_ext_channel_error_type0x8004[] = {,1
"    { 0x8000, ""Output Time Failure - Output update missing or out of order""},",1
"    { 0x8001, ""Input Time Failure""},",1
"    { 0x8002, ""Master Life Sign Failure - Error in MLS update detected""},",1
"    /* ExtChannelErrorType for ChannelErrorType ""Multicast CR mismatch"" 0x8005 */",1
static const value_string pn_io_ext_channel_error_type0x8005[] = {,1
"    { 0x8000, ""Multicast Consumer CR timed out""},",1
"    { 0x8001, ""Address resolution failed""},",1
    /* 0x8002 - 0x8FFF Reserved */,1
"    /* ExtChannelErrorType for ChannelErrorType ""Fiber optic mismatch"" 0x8007*/",1
static const value_string pn_io_ext_channel_error_type0x8007[] = {,1
"    { 0x8000, ""Power Budget""},",1
"    /* ExtChannelErrorType for ChannelErrorType ""Network component function mismatch"" 0x8008 */",1
static const value_string pn_io_ext_channel_error_type0x8008[] = {,1
"    { 0x8000, ""Frame dropped - no resource""},",1
"    /* ExtChannelErrorType for ChannelErrorType ""Dynamic Frame Packing function mismatch"" 0x800A */",1
static const value_string pn_io_ext_channel_error_type0x800A[] = {,1
    /* 0x8000 - 0x80FF Reserved */,1
"    { 0x8100, ""Frame late error for FrameID (0x0100)""},",1
    /* 0x8101 + 0x8FFE See Equation (56) */,1
"    { 0x8FFF, ""Frame late error for FrameID (0x0FFF)""},",1
"    /* ExtChannelErrorType for ChannelErrorType ""Media redundancy with planned duplication mismatch"" 0x800B */",1
static const value_string pn_io_ext_channel_error_type0x800B[] = {,1
    /* 0x8000 - 0x86FF Reserved */,1
"    { 0x8700, ""MRPD duplication void for FrameID (0x0700)""},",1
    /* 0x8701 + 0x8FFE See Equation (57) */,1
"    { 0x8FFF, ""MRPD duplication void for FrameID (0x0FFF)""},",1
"    /* ExtChannelErrorType for ChannelErrorType ""System redundancy mismatch"" 0x800C */",1
static const value_string pn_io_ext_channel_error_type0x800C[] = {,1
"    { 0x8000, ""System redundancy event""},",1
static const value_string pn_io_channel_properties_type[] = {,1
"    { 0x0000, ""submodule or unspecified"" },",1
"    { 0x0001, ""1 Bit"" },",1
"    { 0x0002, ""2 Bit"" },",1
"    { 0x0003, ""4 Bit"" },",1
"    { 0x0004, ""8 Bit"" },",1
"    { 0x0005, ""16 Bit"" },",1
"    { 0x0006, ""32 Bit"" },",1
"    { 0x0007, ""64 Bit"" },",1
    /*0x0008 - 0x00FF reserved */,1
static const value_string pn_io_channel_properties_accumulative_vals[] = {,1
"    { 0x0000, ""Channel"" },",1
"    { 0x0001, ""ChannelGroup"" },",1
"/* We are reading this as a two bit value, but the spec specifies each bit",1
 * separately. Beware endianness when reading spec,1
static const value_string pn_io_channel_properties_maintenance[] = {,1
"    { 0x0000, ""Failure"" },",1
"    { 0x0001, ""Maintenance required"" },",1
"    { 0x0002, ""Maintenance demanded"" },",1
"    { 0x0003, ""see QualifiedChannelQualifier"" },",1
static const value_string pn_io_channel_properties_specifier[] = {,1
"    { 0x0000, ""All subsequent disappears"" },",1
"    { 0x0001, ""Appears"" },",1
"    { 0x0002, ""Disappears"" },",1
"    { 0x0003, ""Disappears but others remain"" },",1
static const value_string pn_io_channel_properties_direction[] = {,1
"    { 0x0000, ""Manufacturer-specific"" },",1
"    { 0x0003, ""Input/Output"" },",1
    /*0x0004 - 0x0007 reserved */,1
static const value_string pn_io_alarmcr_type[] = {,1
"    { 0x0001, ""Alarm CR"" },",1
    /*0x0002 - 0xFFFF reserved */,1
static const value_string pn_io_mau_type[] = {,1
    /*0x0000 - 0x0004 reserved */,1
"    { 0x0005, ""10BASET"" },",1
    /*0x0006 - 0x0009 reserved */,1
"    { 0x000A, ""10BASETXHD"" },",1
"    { 0x000B, ""10BASETXFD"" },",1
"    { 0x000C, ""10BASEFLHD"" },",1
"    { 0x000D, ""10BASEFLFD"" },",1
"    { 0x000F, ""100BASETXHD"" },",1
"    { 0x0010, ""100BASETXFD"" },",1
"    { 0x0011, ""100BASEFXHD"" },",1
"    { 0x0012, ""100BASEFXFD"" },",1
    /*0x0013 - 0x0014 reserved */,1
"    { 0x0015, ""1000BASEXHD"" },",1
"    { 0x0016, ""1000BASEXFD"" },",1
"    { 0x0017, ""1000BASELXHD"" },",1
"    { 0x0018, ""1000BASELXFD"" },",1
"    { 0x0019, ""1000BASESXHD"" },",1
"    { 0x001A, ""1000BASESXFD"" },",1
    /*0x001B - 0x001C reserved */,1
"    { 0x001D, ""1000BASETHD"" },",1
"    { 0x001E, ""1000BASETFD"" },",1
"    { 0x001F, ""10GigBASEFX"" },",1
    /*0x0020 - 0x002D reserved */,1
"    { 0x002E, ""100BASELX10"" },",1
    /*0x002F - 0x0035 reserved */,1
"    { 0x0036, ""100BASEPXFD"" },",1
    /*0x0037 - 0xFFFF reserved */,1
static const value_string pn_io_preamble_length[] = {,1
"    { 0x0000, ""Seven octets Preamble shall be used"" },",1
"    { 0x0001, ""One octet Preamble shall be used"" },",1
static const value_string pn_io_mau_type_mode[] = {,1
"    { 0x0000, ""OFF"" },",1
"    { 0x0001, ""ON"" },",1
static const value_string pn_io_port_state[] = {,1
"    { 0x0001, ""up"" },",1
"    { 0x0002, ""down"" },",1
"    { 0x0003, ""testing"" },",1
"    { 0x0004, ""unknown"" },",1
static const value_string pn_io_media_type[] = {,1
"    { 0x0000, ""Unknown"" },",1
"    { 0x0001, ""Copper cable"" },",1
"    { 0x0002, ""Fiber optic cable"" },",1
"    { 0x0003, ""Radio communication"" },",1
static const value_string pn_io_fiber_optic_type[] = {,1
"    { 0x0000, ""No fiber type adjusted"" },",1
"    { 0x0001, ""9 um single mode fiber"" },",1
"    { 0x0002, ""50 um multi mode fiber"" },",1
"    { 0x0003, ""62,5 um multi mode fiber"" },",1
"    { 0x0004, ""SI-POF, NA=0.5"" },",1
"    { 0x0005, ""SI-PCF, NA=0.36"" },",1
"    { 0x0006, ""LowNA-POF, NA=0.3"" },",1
"    { 0x0007, ""GI-POF"" },",1
    /*0x0008 - 0xFFFF reserved */,1
static const value_string pn_io_fiber_optic_cable_type[] = {,1
"    { 0x0000, ""No cable specified"" },",1
"    { 0x0001, ""Inside/outside cable, fixed installation"" },",1
"    { 0x0002, ""Inside/outside cable, flexible installation"" },",1
"    { 0x0003, ""Outdoor cable, fixed installation"" },",1
static const value_string pn_io_im_revision_prefix_vals[] = {,1
"    { 'V', ""V - Officially released version"" },",1
"    { 'R', ""R - Revision"" },",1
"    { 'P', ""P - Prototype"" },",1
"    { 'U', ""U - Under Test (Field Test)"" },",1
"    { 'T', ""T - Test Device"" },",1
    /*all others reserved */,1
static const value_string pn_io_mrp_role_vals[] = {,1
"    { 0x0000, ""Media Redundancy disabled"" },",1
"    { 0x0001, ""Media Redundancy Client"" },",1
"    { 0x0002, ""Media Redundancy Manager"" },",1
static const value_string pn_io_mrp_instance_no[] = {,1
"    { 0x0000, ""MRP_Instance 1"" },",1
"    { 0x0001, ""MRP_Instance 2"" },",1
"    { 0x0002, ""MRP_Instance 3"" },",1
"    { 0x0003, ""MRP_Instance 4"" },",1
"    { 0x0004, ""MRP_Instance 5"" },",1
"    { 0x0005, ""MRP_Instance 6"" },",1
"    { 0x0006, ""MRP_Instance 7"" },",1
"    { 0x0007, ""MRP_Instance 8"" },",1
"    { 0x0008, ""MRP_Instance 9"" },",1
"    { 0x0009, ""MRP_Instance 10"" },",1
"    { 0x000A, ""MRP_Instance 11"" },",1
"    { 0x000B, ""MRP_Instance 12"" },",1
"    { 0x000C, ""MRP_Instance 13"" },",1
"    { 0x000D, ""MRP_Instance 14"" },",1
"    { 0x000E, ""MRP_Instance 15"" },",1
"    { 0x000F, ""MRP_Instance 16"" },",1
static const value_string pn_io_mrp_mrm_on[] = {,1
"    { 0x0000, ""Disable MediaRedundancyManager diagnosis"" },",1
"    { 0x0001, ""Enable MediaRedundancyManager diagnosis""},",1
static const value_string pn_io_mrp_checkUUID[] = {,1
"    { 0x0000, ""Disable the check of the MRP_DomainUUID"" },",1
"    { 0x0001, ""Enable the check of the MRP_DomainUUID""},",1
static const value_string pn_io_mrp_prio_vals[] = {,1
"    { 0x0000, ""Highest priority redundancy manager"" },",1
    /* 0x1000 - 0x7000 High priorities */,1
"    { 0x8000, ""Default priority for redundancy manager"" },",1
    /* 0x9000 - 0xE000 Low priorities */,1
"    { 0xF000, ""Lowest priority redundancy manager"" },",1
static const value_string pn_io_mrp_rtmode_rtclass12_vals[] = {,1
"    { 0x0000, ""RT_CLASS_1 and RT_CLASS_2 redundancy mode deactivated"" },",1
"    { 0x0001, ""RT_CLASS_1 and RT_CLASS_2 redundancy mode activated"" },",1
static const value_string pn_io_mrp_rtmode_rtclass3_vals[] = {,1
"    { 0x0000, ""RT_CLASS_3 redundancy mode deactivated"" },",1
"    { 0x0001, ""RT_CLASS_3 redundancy mode activated"" },",1
static const value_string pn_io_mrp_ring_state_vals[] = {,1
"    { 0x0000, ""Ring open"" },",1
"    { 0x0001, ""Ring closed"" },",1
static const value_string pn_io_mrp_rt_state_vals[] = {,1
"    { 0x0000, ""RT media redundancy lost"" },",1
"    { 0x0001, ""RT media redundancy available"" },",1
static const value_string pn_io_control_properties_vals[] = {,1
static const value_string pn_io_control_properties_prmbegin_vals[] = {,1
"    { 0x0000, ""No PrmBegin"" },",1
"    { 0x0001, ""The IO controller starts the transmisson of the stored start-up parameter"" },",1
static const value_string pn_io_control_properties_application_ready_vals[] = {,1
"    { 0x0000, ""Wait for explicit ControlCommand.ReadyForCompanion"" },",1
"    { 0x0001, ""Implicit ControlCommand.ReadyForCompanion"" },",1
static const value_string pn_io_fs_hello_mode_vals[] = {,1
"    { 0x0001, ""Send req on LinkUp"" },",1
"    { 0x0002, ""Send req on LinkUp after HelloDelay"" },",1
static const value_string pn_io_fs_parameter_mode_vals[] = {,1
"    { 0x0002, ""Reserved"" },",1
"    { 0x0003, ""Reserved"" },",1
static const value_string pn_io_frame_details_sync_master_vals[] = {,1
"    { 0x0000, ""No Sync Frame"" },",1
"    { 0x0001, ""Primary sync frame"" },",1
"    { 0x0002, ""Secondary sync frame"" },",1
static const value_string pn_io_frame_details_meaning_frame_send_offset_vals[] = {,1
"    { 0x0000, ""Field FrameSendOffset specifies the point of time for receiving or transmitting a frame "" },",1
"    { 0x0001, ""Field FrameSendOffset specifies the beginning of the RT_CLASS_3 interval within a phase"" },",1
"    { 0x0002, ""Field FrameSendOffset specifies the ending of the RT_CLASS_3 interval within a phase"" },",1
static const value_string pn_io_f_check_seqnr[] = {,1
"    { 0x00, ""consecutive number not included in crc"" },",1
"    { 0x01, ""consecutive number included in crc"" },",1
static const value_string pn_io_f_check_ipar[] = {,1
"    { 0x00, ""no check"" },",1
"    { 0x01, ""check"" },",1
static const value_string pn_io_f_sil[] = {,1
"    { 0x00, ""SIL1"" },",1
"    { 0x01, ""SIL2"" },",1
"    { 0x02, ""SIL3"" },",1
"    { 0x03, ""NoSIL"" },",1
static const value_string pn_io_f_crc_len[] = {,1
"    { 0x00, ""3 octet CRC"" },",1
"    { 0x01, ""2 octet CRC"" },",1
"    { 0x02, ""4 octet CRC"" },",1
"    { 0x03, ""reserved"" },",1
static const value_string pn_io_f_crc_seed[] = {,1
"    { 0x00, ""CRC-FP as seed value and counter"" },",1
"    { 0x01, ""'1' as seed value and CRC-FP+/MNR"" },",1
/* F_Block_ID dissection due to ver2.6 specifikation of PI */,1
static const value_string pn_io_f_block_id[] = {,1
"    { 0x00, ""No F_WD_Time_2, no F_iPar_CRC"" },",1
"    { 0x01, ""No F_WD_Time_2, F_iPar_CRC"" },",1
"    { 0x02, ""F_WD_Time_2, no F_iPar_CRC"" },",1
"    { 0x03, ""F_WD_Time_2, F_iPar_CRC"" },",1
    /* 0x04..0x07 reserved */,1
"    /* { 0x00, ""Parameter set for F-Host/F-Device relationship"" }, */",1
"    /* { 0x01, ""Additional F_Address parameter block"" }, */",1
    /* 0x02..0x07 reserved */,1
static const value_string pn_io_f_par_version[] = {,1
"    { 0x00, ""Valid for V1-mode"" },",1
"    { 0x01, ""Valid for V2-mode"" },",1
    /* 0x02..0x03 reserved */,1
static const value_string pn_io_profidrive_request_id_vals[] = {,1
"    { 0x00, ""Reserved"" },",1
"    { 0x01, ""Read request"" },",1
"    { 0x02, ""Change request"" },",1
static const value_string pn_io_profidrive_response_id_vals[] = {,1
"    { 0x01, ""Positive read response"" },",1
"    { 0x02, ""Positive change response"" },",1
"    { 0x81, ""Negative read response"" },",1
"    { 0x82, ""Negative change response"" },",1
static const value_string pn_io_profidrive_attribute_vals[] = {,1
"    { 0x10, ""Value"" },",1
"    { 0x20, ""Description"" },",1
"    { 0x30, ""Text"" },",1
static const value_string pn_io_profidrive_format_vals[] = {,1
"    {0x01, ""Boolean"" },",1
"    {0x02, ""Integer8"" },",1
"    {0x03, ""Integer16"" },",1
"    {0x04, ""Integer32"" },",1
"    {0x05, ""Unsigned8"" },",1
"    {0x06, ""Unsigned16"" },",1
"    {0x07, ""Unsigned32"" },",1
"    {0x08, ""Float32"" },",1
"    {0x09, ""VisibleString"" },",1
"    {0x0A, ""OctetString"" },",1
"    {0x0C, ""TimeOfDay"" },",1
"    {0x0D, ""TimeDifference"" },",1
"    {0x32, ""Date"" },",1
"    {0x34, ""TimeOfDay"" },",1
"    {0x35, ""TimeDifference"" },",1
"    {0x36, ""TimeDifference"" },",1
static const range_string pn_io_rs_block_type[] = {,1
    /* Following ranges are used for events */,1
"    { 0x0000, 0x0000, ""reserved"" },",1
"    { 0x0001, 0x3FFF, ""Manufacturer specific"" },",1
"    { 0x4000, 0x4000, ""Stop observer - Observer Status Observer"" },",1
"    { 0x4001, 0x4001, ""Buffer observer - RS_BufferObserver"" },",1
"    { 0x4002, 0x4002, ""Time status observer - RS_TimeStatus"" },",1
"    { 0x4003, 0x4003, ""System redundancy layer observer - RS_SRLObserver"" },",1
"    { 0x4004, 0x4004, ""Source identification observer - RS_SourceIdentification"" },",1
"    { 0x4005, 0x400F, ""reserved"" },",1
"    { 0x4010, 0x4010, ""Digital input observer - SoE_DigitalInputObserver"" },",1
"    { 0x4011, 0x6FFF, ""Reserved for normative usage"" },",1
"    { 0x7000, 0x7FFF, ""Reserved for profile usage"" },",1
    /* Following ranges are used for adjust */,1
"    { 0x8000, 0x8000, ""reserved"" },",1
"    { 0x8001, 0xBFFF, ""Manufacturer specific"" },",1
"    { 0xC000, 0xC00F, ""Reserved for normative usage"" },",1
"    { 0xC010, 0xC010, ""Digital input observer - SoE_DigitalInputObserver"" },",1
"    { 0xC011, 0xEFFF, ""Reserved for normative usage""},",1
"    { 0xF000, 0xFFFF, ""Reserved for profile usage""},",1
"    { 0, 0, NULL }",1
static const value_string pn_io_rs_specifier_specifier[] = {,1
"    { 0x0, ""Current value"" },",1
"    { 0x1, ""Appears"" },",1
"    { 0x2, ""Disappears"" },",1
"    { 0x3, ""Reserved"" },",1
static const value_string pn_io_rs_time_stamp_status[] = {,1
"    { 0x0, ""TimeStamp related to global synchronized time"" },",1
"    { 0x1, ""TimeStamp related to local time"" },",1
"    { 0x2, ""TimeStamp related to local (arbitrary timescale) time"" },",1
static const value_string pn_io_rs_reason_code_reason[] = {,1
"    { 0x00000001, ""Observed data status unclear"" },",1
"    { 0x00000002, ""Buffer overrun"" },",1
    /* 0x0003 - 0xFFFF Reserved */,1
static const value_string pn_io_rs_reason_code_detail[] = {,1
"    { 0x00000000, ""No Detail"" },",1
    /* 0x0001 - 0xFFFF Reserved */,1
static const value_string pn_io_soe_digital_input_current_value_value[] = {,1
"    { 0x0, ""Digital input is zero"" },",1
"    { 0x1, ""Digital input is one"" },",1
static const value_string pn_io_soe_adjust_specifier_incident[] = {,1
"    { 0x01, ""Rising edge"" },",1
"    { 0x02, ""Falling edge"" },",1
"    { 0x03, ""Reserved"" },",1
static const value_string pn_io_rs_properties_alarm_transport[] = {,1
"    { 0x00000000, ""Default Reporting system events need to be read by record "" },",1
"    { 0x00000001, ""Reporting system events shall be forwarded to the IOC using the alarm transport"" },",1
static const value_string pn_io_am_location_structure_vals[] = {,1
"    { 0x01, ""Twelve level tree format"" },",1
"    { 0x02, ""Slot - and SubslotNumber format"" },",1
static const range_string pn_io_am_location_level_vals[] = {,1
"    { 0x0000, 0x03FE, ""Address information to identify a reported node"" },",1
"    { 0x03FF, 0x03FF, ""Level not used"" },",1
static const value_string pn_io_am_location_reserved_vals[] = {,1
static const range_string pn_io_RedundancyDataHoldFactor[] = {,1
"    { 0x0000, 0x0002, ""Reserved"" },",1
"    { 0x0003, 0x00C7, ""Optional - An expiration of the time leads to an AR termination."" },",1
"    { 0x00C8, 0xFFFF, ""Mandatory - An expiration of the time leads to an AR termination."" },",1
static const value_string pn_io_ar_arnumber[] = {,1
"    { 0x0001, ""1st AR of an ARset"" },",1
"    { 0x0002, ""2nd AR of an ARset"" },",1
"    { 0x0003, ""3rd AR of an ARset"" },",1
"    { 0x0004, ""4th AR of an ARset"" },",1
static const value_string pn_io_ar_arresource[] = {,1
"    { 0x0002, ""Communication endpoint shall allocate two ARs for the ARset"" },",1
    /*0x0001 and 0x0003 - 0xFFFF reserved */,1
static const range_string pn_io_line_delay_value[] = {,1
"    { 0x00000000, 0x00000000, ""Line delay and cable delay unknown"" },",1
"    { 0x00000001, 0x7FFFFFFF, ""Line delay in nanoseconds"" },",1
static const range_string pn_io_cable_delay_value[] = {,1
"    { 0x00000000, 0x00000000, ""Reserved"" },",1
"    { 0x00000001, 0x7FFFFFFF, ""Cable delay in nanoseconds"" },",1
static const true_false_string pn_io_pdportstatistic_counter_status_ifInOctets = {,1
"    ""The content of the field ifInOctets is invalid. It shall be set to zero."",",1
"    ""The content of the field ifInOctets is valid""",1
static const true_false_string pn_io_pdportstatistic_counter_status_ifOutOctets = {,1
"    ""The content of the field ifOutOctets is invalid. It shall be set to zero."",",1
"    ""The content of the field ifOutOctet is valid""",1
static const true_false_string pn_io_pdportstatistic_counter_status_ifInDiscards = {,1
"    ""The content of the field ifInDiscards is invalid. It shall be set to zero."",",1
"    ""The content of the field ifInDiscards is valid""",1
static const true_false_string pn_io_pdportstatistic_counter_status_ifOutDiscards = {,1
"    ""The content of the field ifOutDiscards is invalid. It shall be set to zero."",",1
"    ""The content of the field ifOutDiscards is valid""",1
static const true_false_string pn_io_pdportstatistic_counter_status_ifInErrors = {,1
"    ""The content of the field ifInErrors is invalid. It shall be set to zero."",",1
"    ""The content of the field ifInErrors is valid""",1
static const true_false_string pn_io_pdportstatistic_counter_status_ifOutErrors = {,1
"    ""The content of the field ifOutErrors is invalid. It shall be set to zero."",",1
"    ""The content of the field ifOutErrors is valid""",1
static const value_string pn_io_pdportstatistic_counter_status_reserved[] = {,1
"dissect_profidrive_value(tvbuff_t *tvb, gint offset, packet_info *pinfo,",1
"                         proto_tree *tree, guint8 *drep, guint8 format_val)",1
    guint32 value32_,1
    guint16 value16_,1
    guint8  value8_,1
    switch(format_val),1
    case 1:,1
    case 2:,1
    case 5:,1
"        offset = dissect_dcerpc_uint8(tvb, offset, pinfo, tree, drep,",1
"            hf_pn_io_profidrive_param_value_byte, &value8)_",1
    case 3:,1
    case 6:,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,",1
"            hf_pn_io_profidrive_param_value_word, &value16)_",1
    case 4:,1
    case 7:,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,",1
"            hf_pn_io_profidrive_param_value_dword, &value32)_",1
    case 8:,1
"            hf_pn_io_profidrive_param_value_float, &value32)_",1
    case 9:,1
    case 0x0A:,1
            gint sLen_,1
"            sLen = (gint)tvb_strnlen( tvb, offset, -1)_",1
"            proto_tree_add_item(tree, hf_pn_io_profidrive_param_value_string, tvb, offset, sLen, ENC_ASCII|ENC_NA)_",1
            offset = (offset + sLen)_,1
        offset = offset + 1_,1
"        expert_add_info_format(pinfo, tree, &ei_pn_io_unsupported, ""Not supported or invalid format %u!"", format_val)_",1
    return(offset)_,1
static GList *pnio_ars_,1
typedef struct pnio_ar_s {,1
    /* generic */,1
    e_guid_t     aruuid_,1
    guint16      inputframeid_,1
    guint16      outputframeid_,1
    /* controller only */,1
    /*const char      controllername[33]_*/,1
    const guint8 controllermac[6]_,1
    guint16      controlleralarmref_,1
    /* device only */,1
    const guint8 devicemac[6]_,1
    guint16      devicealarmref_,1
    guint16      arType_,1
} pnio_ar_t_,1
"pnio_ar_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, pnio_ar_t *ar)",1
"    p_add_proto_data(wmem_file_scope(), pinfo, proto_pn_io, 0, ar )_",1
"    p_add_proto_data(pinfo->pool, pinfo, proto_pn_io, 0, GUINT_TO_POINTER(10))_",1
        proto_item *item_,1
        proto_item *sub_item_,1
        proto_tree *sub_tree_,1
"        address   controllermac_addr, devicemac_addr_",1
"        set_address(&controllermac_addr, AT_ETHER, 6, ar->controllermac)_",1
"        set_address(&devicemac_addr, AT_ETHER, 6, ar->devicemac)_",1
"        sub_tree = proto_tree_add_subtree_format(tree, tvb, 0, 0, ett_pn_io_ar_info, &sub_item,",1
"            ""ARUUID:%s ContrMAC:%s ContrAlRef:0x%x DevMAC:%s DevAlRef:0x%x InCR:0x%x OutCR=0x%x"",",1
"            guid_to_str(wmem_packet_scope(), (const e_guid_t*) &ar->aruuid),",1
"            address_to_str(wmem_packet_scope(), &controllermac_addr), ar->controlleralarmref,",1
"            address_to_str(wmem_packet_scope(), &devicemac_addr), ar->devicealarmref,",1
"            ar->inputframeid, ar->outputframeid)_",1
        PROTO_ITEM_SET_GENERATED(sub_item)_,1
"        item = proto_tree_add_guid(sub_tree, hf_pn_io_ar_uuid, tvb, 0, 0, (e_guid_t *) &ar->aruuid)_",1
        PROTO_ITEM_SET_GENERATED(item)_,1
"        item = proto_tree_add_ether(sub_tree, hf_pn_io_cminitiator_macadd, tvb, 0, 0, ar->controllermac)_",1
"        item = proto_tree_add_uint(sub_tree, hf_pn_io_localalarmref, tvb, 0, 0, ar->controlleralarmref)_",1
"        item = proto_tree_add_ether(sub_tree, hf_pn_io_cmresponder_macadd, tvb, 0, 0, ar->devicemac)_",1
"        item = proto_tree_add_uint(sub_tree, hf_pn_io_localalarmref, tvb, 0, 0, ar->devicealarmref)_",1
"        item = proto_tree_add_uint(sub_tree, hf_pn_io_frame_id, tvb, 0, 0, ar->inputframeid)_",1
"        item = proto_tree_add_uint(sub_tree, hf_pn_io_frame_id, tvb, 0, 0, ar->outputframeid)_",1
"static int dissect_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, guint16 *u16Index, guint32 *u32RecDataLen, pnio_ar_t **ar)_",1
"static int dissect_a_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep)_",1
"static int dissect_blocks(tvbuff_t *tvb, int offset,",1
"static int dissect_PNIO_IOxS(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, int hfindex)_",1
static pnio_ar_t *,1
"pnio_ar_find_by_aruuid(packet_info *pinfo _U_, e_guid_t *aruuid)",1
    GList     *ars_,1
    pnio_ar_t *ar_,1
    /* find pdev */,1
    for(ars = pnio_ars_ ars != NULL_ ars = g_list_next(ars)) {,1
        ar = (pnio_ar_t *)ars->data_,1
"        if (memcmp(&ar->aruuid, aruuid, sizeof(e_guid_t)) == 0) {",1
            return ar_,1
pnio_ar_new(e_guid_t *aruuid),1
"    ar = (pnio_ar_t *)wmem_alloc0(wmem_file_scope(), sizeof(pnio_ar_t))_",1
"    memcpy(&ar->aruuid, aruuid, sizeof(e_guid_t))_",1
    ar->controlleralarmref  = 0xffff_,1
    ar->devicealarmref      = 0xffff_,1
"    pnio_ars = g_list_append(pnio_ars, ar)_",1
    return ar_,1
/* dissect the four status (error) fields */,1
"dissect_PNIO_status(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep)",1
    guint8  u8ErrorCode_,1
    guint8  u8ErrorDecode_,1
    guint8  u8ErrorCode1_,1
    guint8  u8ErrorCode2_,1
    proto_item *sub_item_,1
    proto_tree *sub_tree_,1
    guint32     u32SubStart_,1
    int         bytemask = (drep[0] & DREP_LITTLE_ENDIAN) ? 3 : 0_,1
    const value_string *error_code1_vals_,1
    const value_string *error_code2_vals = pn_io_error_code2_   /* defaults */,1
    /* status */,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_status, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_status)_",1
    u32SubStart = offset_,1
"    /* the PNIOStatus field is existing in both the RPC and the application data,",1
     * depending on the current PDU.,1
"     * As the byte representation of these layers are different, this has to be handled",1
     * in a somewhat different way than elsewhere. */,1
"    dissect_dcerpc_uint8(tvb, offset+(0^bytemask), pinfo, sub_tree, drep,",1
"                         hf_pn_io_error_code, &u8ErrorCode)_",1
"    dissect_dcerpc_uint8(tvb, offset+(1^bytemask), pinfo, sub_tree, drep,",1
"                         hf_pn_io_error_decode, &u8ErrorDecode)_",1
    switch (u8ErrorDecode) {,1
    case(0x80): /* PNIORW */,1
"        dissect_dcerpc_uint8(tvb, offset+(2^bytemask), pinfo, sub_tree, drep,",1
"                             hf_pn_io_error_code1_pniorw, &u8ErrorCode1)_",1
        error_code1_vals = pn_io_error_code1_pniorw_,1
        /* u8ErrorCode2 for PNIORW is always user specific */,1
"        dissect_dcerpc_uint8(tvb, offset+(3^bytemask), pinfo, sub_tree, drep,",1
"                             hf_pn_io_error_code2_pniorw, &u8ErrorCode2)_",1
        error_code2_vals = pn_io_error_code2_pniorw_,1
    case(0x81): /* PNIO */,1
"                             hf_pn_io_error_code1_pnio, &u8ErrorCode1)_",1
        error_code1_vals = pn_io_error_code1_pnio_,1
        switch (u8ErrorCode1) {,1
        case(1):,1
"            dissect_dcerpc_uint8(tvb, offset+(3^bytemask), pinfo, sub_tree, drep,",1
"                                 hf_pn_io_error_code2_pnio_1, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_1_,1
        case(2):,1
"                                 hf_pn_io_error_code2_pnio_2, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_2_,1
        case(3):,1
"                                 hf_pn_io_error_code2_pnio_3, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_3_,1
        case(4):,1
"                                 hf_pn_io_error_code2_pnio_4, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_4_,1
        case(5):,1
"                                 hf_pn_io_error_code2_pnio_5, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_5_,1
        case(6):,1
"                                 hf_pn_io_error_code2_pnio_6, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_6_,1
        case(7):,1
"                                 hf_pn_io_error_code2_pnio_7, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_7_,1
        case(8):,1
"                                 hf_pn_io_error_code2_pnio_8, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_8_,1
        case(13):,1
"            dissect_dcerpc_uint8(tvb, offset + (3 ^ bytemask), pinfo, sub_tree, drep,",1
"                                 hf_pn_io_error_code2_pnio_13, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_13_,1
        case(20):,1
"                                 hf_pn_io_error_code2_pnio_20, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_20_,1
        case(21):,1
"                                 hf_pn_io_error_code2_pnio_21, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_21_,1
        case(22):,1
"                                 hf_pn_io_error_code2_pnio_22, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_22_,1
        case(23):,1
"                                 hf_pn_io_error_code2_pnio_23, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_23_,1
        case(40):,1
"                                 hf_pn_io_error_code2_pnio_40, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_40_,1
        case(60) :,1
"                                 hf_pn_io_error_code2_pnio_60, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_60_,1
        case(61):,1
"                                 hf_pn_io_error_code2_pnio_61, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_61_,1
        case(62):,1
"                                 hf_pn_io_error_code2_pnio_62, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_62_,1
        case(63):,1
"                                 hf_pn_io_error_code2_pnio_63, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_63_,1
        case(64):,1
"                                 hf_pn_io_error_code2_pnio_64, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_64_,1
        case(65):,1
"                                 hf_pn_io_error_code2_pnio_65, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_65_,1
        case(66):,1
"                                 hf_pn_io_error_code2_pnio_66, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_66_,1
        case(70):,1
"                                 hf_pn_io_error_code2_pnio_70, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_70_,1
        case(71):,1
"                                 hf_pn_io_error_code2_pnio_71, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_71_,1
        case(72):,1
"                                 hf_pn_io_error_code2_pnio_72, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_72_,1
        case(73):,1
"                                 hf_pn_io_error_code2_pnio_73, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_73_,1
        case(74):,1
"                                 hf_pn_io_error_code2_pnio_74, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_74_,1
        case(75):,1
"                                 hf_pn_io_error_code2_pnio_75, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_75_,1
        case(76):,1
"                                 hf_pn_io_error_code2_pnio_76, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_76_,1
        case(77):,1
"                                 hf_pn_io_error_code2_pnio_77, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_77_,1
        case(253):,1
"                                 hf_pn_io_error_code2_pnio_253, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_253_,1
        case(255):,1
"                                 hf_pn_io_error_code2_pnio_255, &u8ErrorCode2)_",1
            error_code2_vals = pn_io_error_code2_pnio_255_,1
"            /* don't know this u8ErrorCode1 for PNIO, use defaults */",1
"                                 hf_pn_io_error_code2, &u8ErrorCode2)_",1
"            expert_add_info_format(pinfo, sub_item, &ei_pn_io_error_code1, ""Unknown ErrorCode1 0x%x (for ErrorDecode==PNIO)"", u8ErrorCode1)_",1
"                             hf_pn_io_error_code1, &u8ErrorCode1)_",1
        if (u8ErrorDecode!=0) {,1
"            expert_add_info_format(pinfo, sub_item, &ei_pn_io_error_code1, ""Unknown ErrorDecode 0x%x"", u8ErrorDecode)_",1
        error_code1_vals = pn_io_error_code1_,1
"        /* don't know this u8ErrorDecode, use defaults */",1
"                             hf_pn_io_error_code2, &u8ErrorCode2)_",1
        if (u8ErrorDecode != 0) {,1
"            expert_add_info_format(pinfo, sub_item, &ei_pn_io_error_code2, ""Unknown ErrorDecode 0x%x"", u8ErrorDecode)_",1
    if ((u8ErrorCode == 0) && (u8ErrorDecode == 0) && (u8ErrorCode1 == 0) && (u8ErrorCode2 == 0)) {,1
"        proto_item_append_text(sub_item, "": OK"")_",1
"        col_append_str(pinfo->cinfo, COL_INFO, "", OK"")_",1
"        proto_item_append_text(sub_item, "": Error: \""%s\"", \""%s\"", \""%s\"", \""%s\"""",",1
"            val_to_str(u8ErrorCode, pn_io_error_code, ""(0x%x)""),",1
"            val_to_str(u8ErrorDecode, pn_io_error_decode, ""(0x%x)""),",1
"            val_to_str(u8ErrorCode1, error_code1_vals, ""(0x%x)""),",1
"            val_to_str(u8ErrorCode2, error_code2_vals, ""(0x%x)""))_",1
"        col_append_fstr(pinfo->cinfo, COL_INFO, "", Error: \""%s\"", \""%s\"", \""%s\"", \""%s\"""",",1
"    proto_item_set_len(sub_item, offset - u32SubStart)_",1
/* dissect the alarm specifier */,1
"dissect_Alarm_specifier(tvbuff_t *tvb, int offset,",1
    guint16     u16AlarmSpecifierSequence_,1
    guint16     u16AlarmSpecifierChannel_,1
    guint16     u16AlarmSpecifierManufacturer_,1
    guint16     u16AlarmSpecifierSubmodule_,1
    guint16     u16AlarmSpecifierAR_,1
    /* alarm specifier */,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_alarm_specifier, tvb, offset, 2, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_pdu_type)_",1
"    dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,",1
"                        hf_pn_io_alarm_specifier_sequence, &u16AlarmSpecifierSequence)_",1
    u16AlarmSpecifierSequence &= 0x07FF_,1
"                        hf_pn_io_alarm_specifier_channel, &u16AlarmSpecifierChannel)_",1
    u16AlarmSpecifierChannel = (u16AlarmSpecifierChannel &0x0800) >> 11_,1
"                        hf_pn_io_alarm_specifier_manufacturer, &u16AlarmSpecifierManufacturer)_",1
    u16AlarmSpecifierManufacturer = (u16AlarmSpecifierManufacturer &0x1000) >> 12_,1
"                        hf_pn_io_alarm_specifier_submodule, &u16AlarmSpecifierSubmodule)_",1
    u16AlarmSpecifierSubmodule = (u16AlarmSpecifierSubmodule & 0x2000) >> 13_,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,",1
"                        hf_pn_io_alarm_specifier_ardiagnosis, &u16AlarmSpecifierAR)_",1
    u16AlarmSpecifierAR = (u16AlarmSpecifierAR & 0x8000) >> 15_,1
"    proto_item_append_text(sub_item, "", Sequence: %u, Channel: %u, Manuf: %u, Submodule: %u AR: %u"",",1
"        u16AlarmSpecifierSequence, u16AlarmSpecifierChannel,",1
"        u16AlarmSpecifierManufacturer, u16AlarmSpecifierSubmodule, u16AlarmSpecifierAR)_",1
/* dissect the alarm header */,1
"dissect_Alarm_header(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep)",1
    guint16 u16AlarmType_,1
    guint32 u32Api_,1
    guint16 u16SlotNr_,1
    guint16 u16SubslotNr_,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,",1
"                        hf_pn_io_alarm_type, &u16AlarmType)_",1
"    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,",1
"                        hf_pn_io_api, &u32Api)_",1
"                        hf_pn_io_slot_nr, &u16SlotNr)_",1
"                        hf_pn_io_subslot_nr, &u16SubslotNr)_",1
"    proto_item_append_text(item, "", %s, API:%u, Slot:0x%x/0x%x"",",1
"        val_to_str(u16AlarmType, pn_io_alarm_type, ""(0x%x)""),",1
"        u32Api, u16SlotNr, u16SubslotNr)_",1
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", %s, Slot: 0x%x/0x%x"",",1
"        u16SlotNr, u16SubslotNr)_",1
"dissect_ChannelProperties(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 *drep)",1
    guint16     u16ChannelProperties_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_channel_properties, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_channel_properties)_",1
"                    hf_pn_io_channel_properties_direction, &u16ChannelProperties)_",1
"                    hf_pn_io_channel_properties_specifier, &u16ChannelProperties)_",1
"                    hf_pn_io_channel_properties_maintenance, &u16ChannelProperties)_",1
"                    hf_pn_io_channel_properties_accumulative, &u16ChannelProperties)_",1
"                    hf_pn_io_channel_properties_type, &u16ChannelProperties)_",1
/* dissect the RS_BlockHeader */,1
"dissect_RS_BlockHeader(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, proto_item *item, guint8 *drep,",1
"    guint16 *u16RSBodyLength, guint16 *u16RSBlockType)",1
    guint16 u16RSBlockLength_,1
    guint8  u8BlockVersionHigh_,1
    guint8  u8BlockVersionLow_,1
    /* u16RSBlockType is needed for further dissection */,1
"        hf_pn_io_rs_block_type, u16RSBlockType)_",1
"        hf_pn_io_rs_block_length, &u16RSBlockLength)_",1
"    offset = dissect_dcerpc_uint8(tvb, offset, pinfo, tree, drep,",1
"        hf_pn_io_block_version_high, &u8BlockVersionHigh)_",1
"        hf_pn_io_block_version_low, &u8BlockVersionLow)_",1
"    proto_item_append_text(item, "": Type=%s, Length=%u(+4), Version=%u.%u"",",1
"        rval_to_str(*u16RSBlockType, pn_io_rs_block_type, ""Unknown (0x%04x)""),",1
"        u16RSBlockLength, u8BlockVersionHigh, u8BlockVersionLow)_",1
"    /* Block length is without type and length fields, but with version field */",1
"    /* as it's already dissected, remove it */",1
    *u16RSBodyLength = u16RSBlockLength - 2_,1
    /* Padding 2 + 2 + 1 + 1 = 6 */,1
    /* Therefore we need 2 byte padding to make the block u32 aligned */,1
"    offset = dissect_pn_padding(tvb, offset, pinfo, tree, 2)_",1
    /* remove padding */,1
    *u16RSBodyLength -= 2_,1
"dissect_RS_AddressInfo(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, guint8 *drep, guint16 *u16RSBodyLength)",1
    e_guid_t IM_UniqueIdentifier_,1
    guint32  u32Api_,1
    guint16  u16SlotNr_,1
    guint16  u16SubslotNr_,1
    guint16  u16ChannelNumber_,1
    /* IM_UniqueIdentifier */,1
"    offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, tree, drep,",1
"        hf_pn_io_ar_uuid, &IM_UniqueIdentifier)_",1
    *u16RSBodyLength -= 16_,1
    /* API */,1
"        hf_pn_io_api, &u32Api)_",1
    *u16RSBodyLength -= 4_,1
    /* SlotNumber */,1
"        hf_pn_io_slot_nr, &u16SlotNr)_",1
    /* SubSlotNumber*/,1
"        hf_pn_io_subslot_nr, &u16SubslotNr)_",1
    /* Channel Number*/,1
"        hf_pn_io_channel_number, &u16ChannelNumber)_",1
/* dissect the RS_EventDataCommon */,1
"dissect_RS_EventDataCommon(tvbuff_t *tvb, int offset,",1
    guint16     u16RSSpecifierSequenceNumber_,1
    guint16     u16RSSpecifierReserved_,1
    guint16     u16RSSpecifierSpecifier_,1
    guint16     u16RSMinorError_,1
    guint16     u16RSPlusError_,1
    proto_item  *sub_item_,1
    proto_tree  *sub_tree_,1
    proto_item  *sub_item_time_stamp_,1
    proto_tree  *sub_tree_time_stamp_,1
    nstime_t    timestamp_,1
    guint16     u16RSTimeStampStatus_,1
    /* RS_AddressInfo */,1
"    offset = dissect_RS_AddressInfo(tvb, offset, pinfo, tree, drep, u16RSBodyLength)_",1
    /* RS_Specifier */,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_rs_specifier, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_specifier)_",1
    /* RS_Specifier.SequenceNumber */,1
"        hf_pn_io_rs_specifier_sequence, &u16RSSpecifierSequenceNumber)_",1
    /* RS_Specifier.Reserved */,1
"        hf_pn_io_rs_specifier_reserved, &u16RSSpecifierReserved)_",1
    /* RS_Specifier.Specifier */,1
"        hf_pn_io_rs_specifier_specifier, &u16RSSpecifierSpecifier)_",1
    /* RS_TimeStamp */,1
"    sub_item_time_stamp = proto_tree_add_item(tree, hf_pn_io_rs_time_stamp, tvb, offset, 12, ENC_NA)_",1
"    sub_tree_time_stamp = proto_item_add_subtree(sub_item_time_stamp, ett_pn_io_rs_time_stamp)_",1
    /* RS_TimeStamp.Status */,1
"    dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree_time_stamp, drep,",1
"        hf_pn_io_rs_time_stamp_status, &u16RSTimeStampStatus)_",1
    /* RS_TimeStamp.TimeStamp */,1
    /* Start after from 2 bytes Status */,1
"    timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset + 2)_",1
    /* Start after from 4 bytes timestamp.secs */,1
"    timestamp.nsecs = (int)tvb_get_ntohl(tvb, offset + 8)_",1
    /* Start after from 2 bytes Status and get all 10 bytes */,1
"    proto_tree_add_time(sub_tree_time_stamp, hf_pn_io_rs_time_stamp_value, tvb, offset + 2, 10, &timestamp)_",1
    *u16RSBodyLength -= 12_,1
    /* RS_MinusError */,1
"        hf_pn_io_rs_minus_error, &u16RSMinorError)_",1
    /* RS_PlusError */,1
"        hf_pn_io_rs_plus_error, &u16RSPlusError)_",1
/* dissect the RS_IdentificationInfo */,1
"dissect_RS_IdentificationInfo(tvbuff_t *tvb, int offset,",1
    dcerpc_info di_ /* fake dcerpc_info struct */,1
    guint64     u64AMDeviceIdentificationDeviceSubID_,1
    guint64     u64AMDeviceIdentificationDeviceID_,1
    guint64     u64AMDeviceIdentificationVendorID_,1
    guint64     u64AM_DeviceIdentificationOrganization_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_am_device_identification, tvb, offset, 8, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_am_device_identification)_",1
    /* AM_DeviceIdentification */,1
"    dissect_dcerpc_uint64(tvb, offset, pinfo, sub_tree, &di, drep,",1
"        hf_pn_io_am_device_identification_device_sub_id, &u64AMDeviceIdentificationDeviceSubID)_",1
"        hf_pn_io_am_device_identification_device_id, &u64AMDeviceIdentificationDeviceID)_",1
"        hf_pn_io_am_device_identification_vendor_id, &u64AMDeviceIdentificationVendorID)_",1
"    offset = dissect_dcerpc_uint64(tvb, offset, pinfo, sub_tree, &di, drep,",1
"        hf_pn_io_am_device_identification_organization, &u64AM_DeviceIdentificationOrganization)_",1
    /* IM_Tag_Function [32] */,1
"    proto_tree_add_item(tree, hf_pn_io_im_tag_function, tvb, offset, 32, ENC_ASCII|ENC_NA)_",1
    offset += 32_,1
    /* IM_Tag_Location [22] */,1
"    proto_tree_add_item(tree, hf_pn_io_im_tag_location, tvb, offset, 22, ENC_ASCII|ENC_NA)_",1
    offset += 22_,1
/* dissect the RS_EventDataExtension_Data */,1
"dissect_RS_EventDataExtension_Data(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep,",1
"    guint8 *u8RSExtensionBlockLength, guint16 *u16RSBlockType)",1
    guint32     u32RSReasonCodeReason_,1
    guint32     u32RSReasonCodeDetail_,1
    guint8      u8LengthRSDomainIdentification = 16_,1
    guint8      u8LengthRSMasterIdentification = 8_,1
    guint16     u16SoE_DigitalInputCurrentValueValue_,1
    guint16     u16SoE_DigitalInputCurrentValueReserved_,1
    nstime_t timestamp_,1
    guint16 u16RSTimeStampStatus_,1
    proto_item *sub_item_time_stamp_,1
    proto_tree *sub_tree_time_stamp_,1
    switch (*u16RSBlockType) {,1
    case(0x4000): /* RS_StopObserver */,1
        /* RS_BlockType */,1
        /* RS_ReasonCode */,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_rs_reason_code, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_reason_code)_",1
"        dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,",1
"            hf_pn_io_rs_reason_code_reason, &u32RSReasonCodeReason)_",1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,",1
"            hf_pn_io_rs_reason_code_detail, &u32RSReasonCodeDetail)_",1
        *u8RSExtensionBlockLength -= 6_,1
    case(0x4001): /* RS_BufferObserver */,1
"        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, *u8RSExtensionBlockLength, ""UserData"")_",1
        *u8RSExtensionBlockLength = 0_,1
    case(0x4002): /* RS_TimeStatus */,1
        /* Padding 1 + 1 + 16 + 8 = 26  or 1 + 1 + 16 + 8 + 12 = 38 */,1
        /* Therefore we need 2 byte padding to make the block u32 aligned */,1
"        offset = dissect_pn_padding(tvb, offset, pinfo, tree, 2)_",1
        *u8RSExtensionBlockLength -= 2_,1
        /* RS_DomainIdentification */,1
"        proto_tree_add_item(tree, hf_pn_io_rs_domain_identification, tvb, offset, u8LengthRSDomainIdentification, ENC_NA)_",1
        offset += u8LengthRSDomainIdentification_,1
        *u8RSExtensionBlockLength -= 16_,1
        /* RS_MasterIdentification */,1
"        proto_tree_add_item(tree, hf_pn_io_rs_master_identification, tvb, offset, u8LengthRSMasterIdentification, ENC_NA)_",1
        offset += u8LengthRSMasterIdentification_,1
        *u8RSExtensionBlockLength -= 8_,1
        if (*u8RSExtensionBlockLength > 2),1
            /* RS_TimeStamp */,1
"            sub_item_time_stamp = proto_tree_add_item(tree, hf_pn_io_rs_time_stamp, tvb, offset, 12, ENC_NA)_",1
"            sub_tree_time_stamp = proto_item_add_subtree(sub_item_time_stamp, ett_pn_io_rs_time_stamp)_",1
            /* RS_TimeStamp.Status */,1
"            dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree_time_stamp, drep,",1
"                hf_pn_io_rs_time_stamp_status, &u16RSTimeStampStatus)_",1
            /* RS_TimeStamp.TimeStamp */,1
"            timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset + 2)_ // Start after from 2 bytes Status",1
"            timestamp.nsecs = (int)tvb_get_ntohl(tvb, offset + 8)_  // Start after from 4 bytes timestamp.secs",1
            // Start after from 2 bytes Status and get all 10 bytes,1
"            proto_tree_add_time(sub_tree_time_stamp, hf_pn_io_rs_time_stamp_value, tvb, offset + 2, 10, &timestamp)_",1
            offset += 12_,1
    case(0x4003): /* RS_SRLObserver */,1
    case(0x4004): /* RS_SourceIdentification */,1
"        offset = dissect_RS_IdentificationInfo(tvb, offset, pinfo, tree, drep)_",1
    case(0x4010): /* SoE_DigitalInputObserver */,1
        /* SoE_DigitalInputCurrentValue */,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_soe_digital_input_current_value, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_soe_digital_input_current_value)_",1
"        dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,",1
"        hf_pn_io_soe_digital_input_current_value_value, &u16SoE_DigitalInputCurrentValueValue)_",1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,",1
"            hf_pn_io_soe_digital_input_current_value_reserved, &u16SoE_DigitalInputCurrentValueReserved)_",1
/* dissect the RS_EventDataExtension */,1
"dissect_RS_EventDataExtension(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,",1
"    proto_tree *tree, guint8 *drep, guint16 *u16RSBlockLength, guint16 *u16RSBlockType)",1
    guint8 u8RSExtensionBlockType_,1
    guint8 u8RSExtensionBlockLength_,1
    /* RS_ExtensionBlockType */,1
"        hf_pn_io_rs_extension_block_type, &u8RSExtensionBlockType)_",1
    *u16RSBlockLength -= 1_,1
    /* RS_ExtensionBlockLength */,1
"        hf_pn_io_rs_extension_block_length, &u8RSExtensionBlockLength)_",1
    /* Data*[Padding] * a*/,1
    while (u8RSExtensionBlockLength) {,1
        *u16RSBlockLength -= u8RSExtensionBlockLength_,1
"        offset = dissect_RS_EventDataExtension_Data(tvb, offset, pinfo, tree, drep,",1
"            &u8RSExtensionBlockLength, u16RSBlockType)_",1
/* dissect the RS_EventData */,1
"dissect_RS_EventData(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, guint8 *drep,",1
    /* RS_EventDataCommon */,1
"    offset = dissect_RS_EventDataCommon(tvb, offset, pinfo, tree, drep, u16RSBodyLength)_",1
    /* optional: RS_EventDataExtension */,1
    while (*u16RSBodyLength > 0) {,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_rs_event_data_extension, tvb, offset, 0, ENC_NA)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_event_data_extension)_",1
"        offset = dissect_RS_EventDataExtension(tvb, offset, pinfo, sub_tree, drep,",1
"            u16RSBodyLength, u16RSBlockType)_",1
/* dissect the RS_EventBlock */,1
"dissect_RS_EventBlock(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, guint8 *drep)",1
    guint16 u16RSBodyLength_,1
    guint16 u16RSBlockType_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_rs_event_block, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_event_block)_",1
    /* RS_BlockHeader */,1
"    offset = dissect_RS_BlockHeader(tvb, offset, pinfo, sub_tree, sub_item, drep,",1
"        &u16RSBodyLength, &u16RSBlockType)_",1
    /* RS_EventData */,1
"    offset = dissect_RS_EventData(tvb, offset, pinfo, sub_tree, drep,",1
/* dissect the RS_AlarmInfo */,1
"dissect_RS_AlarmInfo(tvbuff_t *tvb, int offset,",1
    guint16    u16RSAlarmInfo_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_rs_alarm_info, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_alarm_info)_",1
"        hf_pn_io_rs_alarm_info_reserved_0_7, &u16RSAlarmInfo)_",1
"        hf_pn_io_rs_alarm_info_reserved_8_15, &u16RSAlarmInfo)_",1
/* dissect the RS_EventInfo */,1
"dissect_RS_EventInfo(tvbuff_t *tvb, int offset,",1
    guint16    u16NumberofEntries_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_rs_event_info, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_event_info)_",1
"        hf_pn_io_number_of_rs_event_info, &u16NumberofEntries)_",1
    while (u16NumberofEntries > 0) {,1
        u16NumberofEntries--_,1
"        offset = dissect_RS_EventBlock(tvb, offset, pinfo, sub_tree, drep)_",1
"dissect_AlarmUserStructure(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep,",1
"        guint16 *body_length, guint16 u16UserStructureIdentifier)",1
    guint16    u16ChannelNumber_,1
    guint16    u16ChannelErrorType_,1
    guint16    u16ExtChannelErrorType_,1
    guint32    u32ExtChannelAddValue_,1
    guint16    u16Index = 0_,1
    guint32    u32RecDataLen_,1
    pnio_ar_t *ar       = NULL_,1
    switch (u16UserStructureIdentifier) {,1
    case(0x8000):   /* ChannelDiagnosisData */,1
"                        hf_pn_io_channel_number, &u16ChannelNumber)_",1
"        offset = dissect_ChannelProperties(tvb, offset, pinfo, tree, item, drep)_",1
"                        hf_pn_io_channel_error_type, &u16ChannelErrorType)_",1
        *body_length -= 6_,1
    case(0x8002):   /* ExtChannelDiagnosisData */,1
        if (u16ChannelErrorType < 0x7fff),1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep,",1
"                        hf_pn_io_ext_channel_error_type0, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8000),1
"                        hf_pn_io_ext_channel_error_type0x8000, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8001),1
"                        hf_pn_io_ext_channel_error_type0x8001, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8002),1
"                        hf_pn_io_ext_channel_error_type0x8002, &u16ExtChannelErrorType)_",1
        else if ((u16ChannelErrorType == 0x8003)||(u16ChannelErrorType == 0x8009)),1
"                        hf_pn_io_ext_channel_error_type0x8003, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8004),1
"                        hf_pn_io_ext_channel_error_type0x8004, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8005),1
"                        hf_pn_io_ext_channel_error_type0x8005, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8007),1
"                        hf_pn_io_ext_channel_error_type0x8007, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x8008),1
"                        hf_pn_io_ext_channel_error_type0x8008, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x800A),1
"                        hf_pn_io_ext_channel_error_type0x800A, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x800B),1
"                        hf_pn_io_ext_channel_error_type0x800B, &u16ExtChannelErrorType)_",1
        else if (u16ChannelErrorType == 0x800C),1
"                        hf_pn_io_ext_channel_error_type0x800C, &u16ExtChannelErrorType)_",1
"                        hf_pn_io_ext_channel_error_type, &u16ExtChannelErrorType)_",1
"                        hf_pn_io_ext_channel_add_value, &u32ExtChannelAddValue)_",1
        *body_length -= 12_,1
    case(0x8100):   /* MaintenanceItem */,1
"        offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
    case(0x8300): /* RS_AlarmInfo (Reporting System Alarm Information) */,1
    case(0x8301): /* RS_AlarmInfo */,1
    case(0x8302): /* RS_AlarmInfo */,1
"        offset = dissect_RS_AlarmInfo(tvb, offset, pinfo, tree, drep)_",1
        *body_length = 0_,1
    case(0x8303): /* RS_EventInfo (Reporting System Event Information) */,1
"        offset = dissect_RS_EventInfo(tvb, offset, pinfo, tree, drep)_",1
    /* XXX - dissect remaining user structures of [AlarmItem] */,1
    case(0x8001):   /* DiagnosisData */,1
    case(0x8003):   /* QualifiedChannelDiagnosisData */,1
        if (u16UserStructureIdentifier >= 0x8000) {,1
"            offset = dissect_pn_undecoded(tvb, offset, pinfo, tree, *body_length)_",1
"            offset = dissect_pn_user_data(tvb, offset, pinfo, tree, *body_length, ""UserData"")_",1
/* dissect the alarm notification block */,1
"dissect_AlarmNotification_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow,",1
    guint16 body_length),1
    guint32 u32ModuleIdentNumber_,1
    guint32 u32SubmoduleIdentNumber_,1
    guint16 u16UserStructureIdentifier_,1
    if (u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) {,1
"        expert_add_info_format(pinfo, item, &ei_pn_io_block_version,",1
"            ""Block version %u.%u not implemented yet!"", u8BlockVersionHigh, u8BlockVersionLow)_",1
"    offset = dissect_Alarm_header(tvb, offset, pinfo, tree, item, drep)_",1
"                        hf_pn_io_module_ident_number, &u32ModuleIdentNumber)_",1
"                        hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber)_",1
"    offset = dissect_Alarm_specifier(tvb, offset, pinfo, tree, drep)_",1
"    proto_item_append_text(item, "", Ident:0x%x, SubIdent:0x%x"",",1
"        u32ModuleIdentNumber, u32SubmoduleIdentNumber)_",1
    body_length -= 20_,1
    /* the rest of the block contains optional: [MaintenanceItem] and/or [AlarmItem] */,1
    while (body_length) {,1
"                            hf_pn_io_user_structure_identifier, &u16UserStructureIdentifier)_",1
"        proto_item_append_text(item, "", USI:0x%x"", u16UserStructureIdentifier)_",1
        body_length -= 2_,1
"        offset = dissect_AlarmUserStructure(tvb, offset, pinfo, tree, item, drep, &body_length, u16UserStructureIdentifier)_",1
"dissect_IandM0_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
    guint8   u8VendorIDHigh_,1
    guint8   u8VendorIDLow_,1
    char    *pOrderID_,1
    char    *pIMSerialNumber_,1
    guint16  u16IMHardwareRevision_,1
    guint8   u8SWRevisionPrefix_,1
    guint8   u8IMSWRevisionFunctionalEnhancement_,1
    guint8   u8IMSWRevisionBugFix_,1
    guint8   u8IMSWRevisionInternalChange_,1
    guint16  u16IMRevisionCounter_,1
    guint16  u16IMProfileID_,1
    guint16  u16IMProfileSpecificType_,1
    guint8   u8IMVersionMajor_,1
    guint8   u8IMVersionMinor_,1
    guint16  u16IMSupported_,1
    /* x8 VendorIDHigh */,1
"                    hf_pn_io_vendor_id_high, &u8VendorIDHigh)_",1
    /* x8 VendorIDLow */,1
"                    hf_pn_io_vendor_id_low, &u8VendorIDLow)_",1
    /* c8[20] OrderID */,1
"    pOrderID = (char *)wmem_alloc(wmem_packet_scope(), 20+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pOrderID, offset, 20)_",1
    pOrderID[20] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_order_id, tvb, offset, 20, pOrderID)_",1
    /* c8[16] IM_Serial_Number */,1
"    pIMSerialNumber = (char *)wmem_alloc(wmem_packet_scope(), 16+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pIMSerialNumber, offset, 16)_",1
    pIMSerialNumber[16] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_im_serial_number, tvb, offset, 16, pIMSerialNumber)_",1
    /* x16 IM_Hardware_Revision */,1
"                    hf_pn_io_im_hardware_revision, &u16IMHardwareRevision)_",1
    /* c8 SWRevisionPrefix */,1
"    offset = dissect_dcerpc_char(tvb, offset, pinfo, tree, drep,",1
"                    hf_pn_io_im_revision_prefix, &u8SWRevisionPrefix)_",1
    /* x8 IM_SWRevision_Functional_Enhancement */,1
"                    hf_pn_io_im_sw_revision_functional_enhancement, &u8IMSWRevisionFunctionalEnhancement)_",1
    /* x8 IM_SWRevision_Bug_Fix */,1
"                    hf_pn_io_im_revision_bugfix, &u8IMSWRevisionBugFix)_",1
    /* x8 IM_SWRevision_Internal_Change */,1
"                    hf_pn_io_im_sw_revision_internal_change, &u8IMSWRevisionInternalChange)_",1
    /* x16 IM_Revision_Counter */,1
"                    hf_pn_io_im_revision_counter, &u16IMRevisionCounter)_",1
    /* x16 IM_Profile_ID */,1
"                    hf_pn_io_im_profile_id, &u16IMProfileID)_",1
    /* x16 IM_Profile_Specific_Type */,1
"                    hf_pn_io_im_profile_specific_type, &u16IMProfileSpecificType)_",1
    /* x8 IM_Version_Major (values) */,1
"                    hf_pn_io_im_version_major, &u8IMVersionMajor)_",1
    /* x8 IM_Version_Minor (values) */,1
"                    hf_pn_io_im_version_minor, &u8IMVersionMinor)_",1
    /* x16 IM_Supported (bitfield) */,1
"                    hf_pn_io_im_supported, &u16IMSupported)_",1
"dissect_IandM1_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, proto_item *item, guint8 *drep _U_, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
    char *pTagFunction_,1
    char *pTagLocation_,1
"    pTagFunction = (char *)wmem_alloc(wmem_packet_scope(), 32+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pTagFunction, offset, 32)_",1
    pTagFunction[32] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_im_tag_function, tvb, offset, 32, pTagFunction)_",1
"    pTagLocation = (char *)wmem_alloc(wmem_packet_scope(), 22+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pTagLocation, offset, 22)_",1
    pTagLocation[22] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_im_tag_location, tvb, offset, 22, pTagLocation)_",1
"    proto_item_append_text(item, "": TagFunction:\""%s\"", TagLocation:\""%s\"""", pTagFunction, pTagLocation)_",1
"dissect_IandM2_block(tvbuff_t *tvb, int offset,",1
    char *pDate_,1
    /* IM_Date [16] */,1
"    pDate = (char *)wmem_alloc(wmem_packet_scope(), 16+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pDate, offset, 16)_",1
    pDate[16] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_im_date, tvb, offset, 16, pDate)_",1
"    proto_item_append_text(item, "": Date:\""%s\"""", pDate)_",1
"dissect_IandM3_block(tvbuff_t *tvb, int offset,",1
    char *pDescriptor_,1
    /* IM_Descriptor [54] */,1
"    pDescriptor = (char *)wmem_alloc(wmem_packet_scope(), 54+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pDescriptor, offset, 54)_",1
    pDescriptor[54] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_im_descriptor, tvb, offset, 54, pDescriptor)_",1
    offset += 54_,1
"    proto_item_append_text(item, "": Descriptor:\""%s\"""", pDescriptor)_",1
"dissect_IandM4_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint8 *drep _U_, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
"    dissect_pn_user_data(tvb, offset, pinfo, tree, 54, ""IM Signature"")_",1
"dissect_IandM5_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_im_numberofentries, &u16NumberofEntries)_",1
    while(u16NumberofEntries > 0) {,1
"        offset = dissect_a_block(tvb, offset, pinfo, tree, drep)_",1
"dissect_IandM0FilterData_block(tvbuff_t *tvb, int offset,",1
    guint16     u16NumberOfAPIs_,1
    guint32     u32Api_,1
    guint16     u16NumberOfModules_,1
    guint16     u16SlotNr_,1
    guint32     u32ModuleIdentNumber_,1
    guint16     u16NumberOfSubmodules_,1
    guint16     u16SubslotNr_,1
    guint32     u32SubmoduleIdentNumber_,1
    proto_item *subslot_item_,1
    proto_tree *subslot_tree_,1
    proto_item *module_item_,1
    proto_tree *module_tree_,1
    guint32     u32ModuleStart_,1
    /* NumberOfAPIs */,1
"                    hf_pn_io_number_of_apis, &u16NumberOfAPIs)_",1
    while (u16NumberOfAPIs--) {,1
        /* API */,1
        /* NumberOfModules */,1
"                        hf_pn_io_number_of_modules, &u16NumberOfModules)_",1
        while (u16NumberOfModules--) {,1
"            module_item = proto_tree_add_item(tree, hf_pn_io_subslot, tvb, offset, 6, ENC_NA)_",1
"            module_tree = proto_item_add_subtree(module_item, ett_pn_io_module)_",1
            u32ModuleStart = offset_,1
            /* SlotNumber */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, module_tree, drep,",1
"                            hf_pn_io_slot_nr, &u16SlotNr)_",1
            /* ModuleIdentNumber */,1
"            offset = dissect_dcerpc_uint32(tvb, offset, pinfo, module_tree, drep,",1
"                            hf_pn_io_module_ident_number, &u32ModuleIdentNumber)_",1
            /* NumberOfSubmodules */,1
"                            hf_pn_io_number_of_submodules, &u16NumberOfSubmodules)_",1
"            proto_item_append_text(module_item, "": Slot:%u, Ident:0x%x Submodules:%u"",",1
"                u16SlotNr, u32ModuleIdentNumber, u16NumberOfSubmodules)_",1
            while (u16NumberOfSubmodules--) {,1
"                subslot_item = proto_tree_add_item(module_tree, hf_pn_io_subslot, tvb, offset, 6, ENC_NA)_",1
"                subslot_tree = proto_item_add_subtree(subslot_item, ett_pn_io_subslot)_",1
                /* SubslotNumber */,1
"                offset = dissect_dcerpc_uint16(tvb, offset, pinfo, subslot_tree, drep,",1
"                                    hf_pn_io_subslot_nr, &u16SubslotNr)_",1
                /* SubmoduleIdentNumber */,1
"                offset = dissect_dcerpc_uint32(tvb, offset, pinfo, subslot_tree, drep,",1
"                                hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber)_",1
"                proto_item_append_text(subslot_item, "": Number:0x%x, Ident:0x%x"",",1
"                    u16SubslotNr, u32SubmoduleIdentNumber)_",1
"            proto_item_set_len(module_item, offset-u32ModuleStart)_",1
"dissect_IandM5Data_block(tvbuff_t *tvb, int offset,",1
    char       *pIMAnnotation_,1
    char       *pIMOrderID_,1
    guint8     u8VendorIDHigh_,1
    guint8     u8VendorIDLow_,1
    char       *pIMSerialNumber_,1
    guint16    u16IMHardwareRevision_,1
    guint8     u8SWRevisionPrefix_,1
    guint8     u8IMSWRevisionFunctionalEnhancement_,1
    guint8     u8IMSWRevisionBugFix_,1
    guint8     u8IMSWRevisionInternalChange_,1
    /* c8[64] IM Annotation */,1
"    pIMAnnotation = (char *)wmem_alloc(wmem_packet_scope(), 64+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pIMAnnotation, offset, 64)_",1
    pIMAnnotation[64] = '\0'_,1
"    proto_tree_add_string(tree, hf_pn_io_im_annotation, tvb, offset, 64, pIMAnnotation)_",1
    offset += 64_,1
    /* c8[64] IM Order ID */,1
"    pIMOrderID = (char *)wmem_alloc(wmem_packet_scope(), 64+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pIMOrderID, offset, 64)_",1
    pIMOrderID[64] = '\0'_,1
"    proto_tree_add_string(tree, hf_pn_io_im_order_id, tvb, offset, 64, pIMOrderID)_",1
    /* c8[16] IM Serial Number */,1
"    proto_tree_add_string(tree, hf_pn_io_im_serial_number, tvb, offset, 16, pIMSerialNumber)_",1
"                hf_pn_io_im_hardware_revision, &u16IMHardwareRevision)_",1
        /* c8 SWRevisionPrefix */,1
"                hf_pn_io_im_revision_prefix, &u8SWRevisionPrefix)_",1
"                hf_pn_io_im_sw_revision_functional_enhancement, &u8IMSWRevisionFunctionalEnhancement)_",1
"                hf_pn_io_im_revision_bugfix, &u8IMSWRevisionBugFix)_",1
"                hf_pn_io_im_sw_revision_internal_change, &u8IMSWRevisionInternalChange)_",1
"dissect_AM_Location(tvbuff_t *tvb, int offset,",1
"packet_info *pinfo, proto_tree *tree, guint8 *drep)",1
    proto_item          *sub_item_,1
    proto_tree          *sub_tree_,1
    guint8              am_location_structtype_,1
    int bit_offset_,1
    guint8 am_location_reserved1_,1
    guint16 am_location_begin_slot_number_,1
    guint16 am_location_begin_subslot_number_,1
    guint16 am_location_end_slot_number_,1
    guint16 am_location_end_subslot_number_,1
    guint16 am_location_reserved2_,1
    guint16 am_location_reserved3_,1
    guint16 am_location_reserved4_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_am_location, tvb, offset, 16, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_am_location)_",1
"    offset = dissect_dcerpc_char(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_am_location_structure,",1
        &am_location_structtype)_,1
    bit_offset = offset << 3_,1
    switch (am_location_structtype),1
    case (0x01):,1
        /* level 0 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_0, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        bit_offset += 10_,1
        /* level 1 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_1, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 2 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_2, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 3 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_3, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 4 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_4, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 5 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_5, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 6 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_6, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 7 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_7, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 8 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_8, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 9 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_9, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 10 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_10, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        /* level 11 */,1
"        proto_tree_add_bits_item(sub_tree, hf_pn_io_am_location_level_11, tvb, bit_offset, 10, ENC_BIG_ENDIAN)_",1
        offset = bit_offset >> 3_,1
    case (0x02):,1
        /* Reserved1 */,1
"        offset = dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep,",1
"            hf_pn_io_am_location_reserved1, &am_location_reserved1)_",1
        /* BeginSlotNumber */,1
"            hf_pn_io_slot_nr, &am_location_begin_slot_number)_",1
        /* BeginSubslotNumber */,1
"            hf_pn_io_subslot_nr, &am_location_begin_subslot_number)_",1
        /* EndSlotNumber*/,1
"            hf_pn_io_slot_nr, &am_location_end_slot_number)_",1
        /* EndSubSlotNumber*/,1
"            hf_pn_io_subslot_nr, &am_location_end_subslot_number)_",1
        /* Reserved 2 */,1
"            hf_pn_io_am_location_reserved2, &am_location_reserved2)_",1
        /* Reserved 3 */,1
"            hf_pn_io_am_location_reserved3, &am_location_reserved3)_",1
        /* Reserved 4 */,1
"            hf_pn_io_am_location_reserved4, &am_location_reserved4)_",1
    default: /* will not execute because of the line preceding the switch */,1
        offset += 15_,1
"dissect_IM_software_revision(tvbuff_t *tvb, int offset,",1
    /* SWRevisionPrefix */,1
"        hf_pn_io_im_revision_prefix, &u8SWRevisionPrefix)_",1
    /* IM_SWRevision_Functional_Enhancement */,1
"        hf_pn_io_im_sw_revision_functional_enhancement, &u8IMSWRevisionFunctionalEnhancement)_",1
    /* IM_SWRevision_Bug_Fix */,1
"        hf_pn_io_im_revision_bugfix, &u8IMSWRevisionBugFix)_",1
    /* IM_SWRevision_Internal_Change */,1
"        hf_pn_io_im_sw_revision_internal_change, &u8IMSWRevisionInternalChange)_",1
"dissect_AM_device_identification(tvbuff_t *tvb, int offset,",1
"dissect_AM_FullInformation_block(tvbuff_t *tvb, int offset,",1
"packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep,",1
"guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
    guint16  u16AM_TypeIdentification_,1
    /* align padding */,1
"        hf_pn_io_im_uniqueidentifier, &IM_UniqueIdentifier)_",1
    /* AM_Location */,1
"    offset = dissect_AM_Location(tvb, offset, pinfo, tree, drep)_",1
    /* IM_Annotation */,1
"    proto_tree_add_item(tree, hf_pn_io_im_annotation, tvb, offset, 64, ENC_ASCII|ENC_NA)_",1
    /* IM_OrderID */,1
"    proto_tree_add_item(tree, hf_pn_io_im_order_id, tvb, offset, 64, ENC_ASCII|ENC_NA)_",1
    /* AM_SoftwareRevision */,1
"    proto_tree_add_item(tree, hf_pn_io_am_software_revision, tvb, offset, 64, ENC_ASCII|ENC_NA)_",1
    /* AM_HardwareRevision */,1
"    proto_tree_add_item(tree, hf_pn_io_am_hardware_revision, tvb, offset, 64, ENC_ASCII|ENC_NA)_",1
    /* IM_Serial_Number */,1
"    proto_tree_add_item(tree, hf_pn_io_im_serial_number, tvb, offset, 16, ENC_ASCII|ENC_NA)_",1
    /* IM_Software_Revision */,1
"    offset = dissect_IM_software_revision(tvb, offset, pinfo, tree, drep)_",1
"    offset = dissect_AM_device_identification(tvb, offset, pinfo, tree, drep)_",1
    /* AM_TypeIdentification */,1
"        hf_pn_io_am_type_identification, &u16AM_TypeIdentification)_",1
    /* IM_Hardware_Revision */,1
"        hf_pn_io_im_hardware_revision, &u16IMHardwareRevision)_",1
"dissect_AM_HardwareOnlyInformation_block(tvbuff_t *tvb, int offset,",1
"    proto_tree_add_item(tree, hf_pn_io_im_annotation, tvb, offset, 64, ENC_ASCII | ENC_NA)_",1
"    proto_tree_add_item(tree, hf_pn_io_im_order_id, tvb, offset, 64, ENC_ASCII | ENC_NA)_",1
"    proto_tree_add_item(tree, hf_pn_io_am_hardware_revision, tvb, offset, 64, ENC_ASCII | ENC_NA)_",1
"    proto_tree_add_item(tree, hf_pn_io_im_serial_number, tvb, offset, 16, ENC_ASCII | ENC_NA)_",1
"dissect_AM_FirmwareOnlyInformation_block(tvbuff_t *tvb, int offset,",1
"    proto_tree_add_item(tree, hf_pn_io_am_software_revision, tvb, offset, 64, ENC_ASCII | ENC_NA)_",1
/* dissect the AssetManagementInfo */,1
"dissect_AssetManagementInfo(tvbuff_t *tvb, int offset,",1
"packet_info *pinfo _U_, proto_tree *tree, guint8 *drep)",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_asset_management_info, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_asset_management_info)_",1
"        hf_pn_io_number_of_asset_management_info, &u16NumberofEntries)_",1
"        offset = dissect_a_block(tvb, offset, pinfo, sub_tree, drep)_",1
/* dissect the AssetManagementData block */,1
"dissect_AssetManagementData_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_AssetManagementInfo(tvb, offset, pinfo, tree, drep)_",1
/* dissect the IdentificationData block */,1
"dissect_IdentificationData_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
    guint16     u16NumberOfAPIs = 1_,1
    guint16     u16NumberOfSlots_,1
    guint16     u16NumberOfSubslots_,1
    proto_item *slot_item_,1
    proto_tree *slot_tree_,1
    guint32     u32SlotStart_,1
    if (u8BlockVersionHigh != 1 || (u8BlockVersionLow != 0 && u8BlockVersionLow != 1)) {,1
    if (u8BlockVersionLow == 1) {,1
        /* NumberOfAPIs */,1
"                            hf_pn_io_number_of_apis, &u16NumberOfAPIs)_",1
"    proto_item_append_text(item, "": APIs:%u"", u16NumberOfAPIs)_",1
        if (u8BlockVersionLow == 1) {,1
            /* API */,1
"            offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,",1
"                            hf_pn_io_api, &u32Api)_",1
        /* NumberOfSlots */,1
"                            hf_pn_io_number_of_slots, &u16NumberOfSlots)_",1
"        proto_item_append_text(item, "", Slots:%u"", u16NumberOfSlots)_",1
        while (u16NumberOfSlots--) {,1
"            slot_item = proto_tree_add_item(tree, hf_pn_io_slot, tvb, offset, 0, ENC_NA)_",1
"            slot_tree = proto_item_add_subtree(slot_item, ett_pn_io_slot)_",1
            u32SlotStart = offset_,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, slot_tree, drep,",1
"                                hf_pn_io_slot_nr, &u16SlotNr)_",1
"            offset = dissect_dcerpc_uint32(tvb, offset, pinfo, slot_tree, drep,",1
"                                hf_pn_io_module_ident_number, &u32ModuleIdentNumber)_",1
            /* NumberOfSubslots */,1
"                                hf_pn_io_number_of_subslots, &u16NumberOfSubslots)_",1
"            proto_item_append_text(slot_item, "": SlotNr:%u Ident:0x%x Subslots:%u"",",1
"                u16SlotNr, u32ModuleIdentNumber, u16NumberOfSubslots)_",1
            while (u16NumberOfSubslots--) {,1
"                subslot_item = proto_tree_add_item(slot_tree, hf_pn_io_subslot, tvb, offset, 6, ENC_NA)_",1
"            proto_item_set_len(slot_item, offset-u32SlotStart)_",1
/* dissect the substitute value block */,1
"dissect_SubstituteValue_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow,",1
    guint16 u16BodyLength),1
    guint16 u16SubstitutionMode_,1
    /* SubstitutionMode */,1
"                    hf_pn_io_substitutionmode, &u16SubstitutionMode)_",1
    /* SubstituteDataItem */,1
    /* IOCS */,1
"    offset = dissect_PNIO_IOxS(tvb, offset, pinfo, tree, drep, hf_pn_io_iocs)_",1
    u16BodyLength -= 3_,1
    /* SubstituteDataObjectElement */,1
"    dissect_pn_user_data_bytes(tvb, offset, pinfo, tree, u16BodyLength, SUBST_DATA)_",1
/* dissect the RecordInputDataObjectElement block */,1
"dissect_RecordInputDataObjectElement_block(tvbuff_t *tvb, int offset,",1
    guint8  u8LengthIOCS_,1
    guint8  u8LengthIOPS_,1
    guint16 u16LengthData_,1
    /* LengthIOCS */,1
"                hf_pn_io_length_iocs, &u8LengthIOCS)_",1
    /* LengthIOPS */,1
"                hf_pn_io_length_iops, &u8LengthIOPS)_",1
    /* IOPS */,1
"    offset = dissect_PNIO_IOxS(tvb, offset, pinfo, tree, drep, hf_pn_io_iops)_",1
    /* LengthData */,1
"                hf_pn_io_length_data, &u16LengthData)_",1
"    offset = dissect_pn_user_data(tvb, offset, pinfo, tree, u16LengthData, ""Data"")_",1
/* dissect the RecordOutputDataObjectElement block */,1
"dissect_RecordOutputDataObjectElement_block(tvbuff_t *tvb, int offset,",1
    guint16    u16SubstituteActiveFlag_,1
    guint8     u8LengthIOCS_,1
    guint8     u8LengthIOPS_,1
    guint16    u16LengthData_,1
    /* SubstituteActiveFlag */,1
"                hf_pn_io_substitute_active_flag, &u16SubstituteActiveFlag)_",1
"    /* DataItem (IOCS, Data, IOPS) */",1
    /* SubstituteValue */,1
"    offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
/* dissect the alarm acknowledge block */,1
"dissect_Alarm_ack_block(tvbuff_t *tvb, int offset,",1
"    col_append_str(pinfo->cinfo, COL_INFO, "", Alarm Ack"")_",1
"    offset = dissect_PNIO_status(tvb, offset, pinfo, tree, drep)_",1
/* dissect the maintenance block */,1
"dissect_Maintenance_block(tvbuff_t *tvb, int offset,",1
    guint32     u32MaintenanceStatus_,1
"    offset = dissect_pn_align4(tvb, offset, pinfo, tree)_",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_maintenance_status, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_maintenance_status)_",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,",1
"                    hf_pn_io_maintenance_status_demanded, &u32MaintenanceStatus)_",1
"    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,",1
"                    hf_pn_io_maintenance_status_required, &u32MaintenanceStatus)_",1
    if (u32MaintenanceStatus & 0x0002) {,1
"        proto_item_append_text(item, "", Demanded"")_",1
"        proto_item_append_text(sub_item, "", Demanded"")_",1
    if (u32MaintenanceStatus & 0x0001) {,1
"        proto_item_append_text(item, "", Required"")_",1
"        proto_item_append_text(sub_item, "", Required"")_",1
/* dissect the read/write header */,1
"dissect_ReadWrite_header(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint16 *u16Index, e_guid_t *aruuid)",1
    guint16 u16SeqNr_,1
"                        hf_pn_io_seq_number, &u16SeqNr)_",1
"                        hf_pn_io_ar_uuid, aruuid)_",1
        /* padding doesn't match offset required for align4 */,1
"                        hf_pn_io_index, u16Index)_",1
"    proto_item_append_text(item, "": Seq:%u, Api:0x%x, Slot:0x%x/0x%x"",",1
"        u16SeqNr, u32Api, u16SlotNr, u16SubslotNr)_",1
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", Api:0x%x, Slot:0x%x/0x%x, Index:%s"",",1
"        u32Api, u16SlotNr, u16SubslotNr,",1
"        val_to_str(*u16Index, pn_io_index, ""(0x%x)""))_",1
/* dissect the write request block */,1
"dissect_IODWriteReqHeader_block(tvbuff_t *tvb, int offset,",1
"    guint16 *u16Index, guint32 *u32RecDataLen, pnio_ar_t ** ar)",1
    e_guid_t aruuid_,1
    e_guid_t null_uuid_,1
"    offset = dissect_ReadWrite_header(tvb, offset, pinfo, tree, item, drep, u16Index, &aruuid)_",1
    /* The value NIL indicates the usage of the implicit AR*/,1
"    *ar = pnio_ar_find_by_aruuid(pinfo, &aruuid)_",1
"                        hf_pn_io_record_data_length, u32RecDataLen)_",1
"    memset(&null_uuid, 0, sizeof(e_guid_t))_",1
"    if (memcmp(&aruuid, &null_uuid, sizeof (e_guid_t)) == 0) {",1
"        offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, tree, drep,",1
"                        hf_pn_io_target_ar_uuid, &aruuid)_",1
"    offset = dissect_pn_padding(tvb, offset, pinfo, tree, 24)_",1
"    proto_item_append_text(item, "", Len:%u"", *u32RecDataLen)_",1
    if (*u32RecDataLen != 0),1
"        col_append_fstr(pinfo->cinfo, COL_INFO, "", %u bytes"",",1
            *u32RecDataLen)_,1
/* dissect the read request block */,1
"dissect_IODReadReqHeader_block(tvbuff_t *tvb, int offset,",1
"    guint16 *u16Index, guint32 *u32RecDataLen, pnio_ar_t **ar)",1
"        offset = dissect_pn_padding(tvb, offset, pinfo, tree, 8)_",1
"        offset = dissect_pn_padding(tvb, offset, pinfo, tree, 24)_",1
/* dissect the write response block */,1
"dissect_IODWriteResHeader_block(tvbuff_t *tvb, int offset,",1
    guint16  u16AddVal1_,1
    guint16  u16AddVal2_,1
    guint32  u32Status_,1
"                        hf_pn_io_add_val1, &u16AddVal1)_",1
"                        hf_pn_io_add_val2, &u16AddVal2)_",1
    u32Status = ((drep[0] & DREP_LITTLE_ENDIAN),1
"            ? tvb_get_letohl (tvb, offset)",1
"            : tvb_get_ntohl (tvb, offset))_",1
"    offset = dissect_pn_padding(tvb, offset, pinfo, tree, 16)_",1
"    proto_item_append_text(item, "", Len:%u, Index:0x%x, Status:0x%x, Val1:%u, Val2:%u"",",1
"        *u32RecDataLen, *u16Index, u32Status, u16AddVal1, u16AddVal2)_",1
/* dissect the read response block */,1
"dissect_IODReadResHeader_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_pn_padding(tvb, offset, pinfo, tree, 20)_",1
"    proto_item_append_text(item, "", Len:%u, AddVal1:%u, AddVal2:%u"",",1
"        *u32RecDataLen, u16AddVal1, u16AddVal2)_",1
/* dissect the control/connect block */,1
"dissect_ControlConnect_block(tvbuff_t *tvb, int offset,",1
    pnio_ar_t **ar),1
    e_guid_t    ar_uuid_,1
    guint16     u16SessionKey_,1
    guint16     u16Command_,1
    guint16     u16Properties_,1
"                        hf_pn_io_reserved16, NULL)_",1
"                        hf_pn_io_ar_uuid, &ar_uuid)_",1
"    *ar = pnio_ar_find_by_aruuid(pinfo, &ar_uuid)_",1
"                        hf_pn_io_sessionkey, &u16SessionKey)_",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_control_command, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_control_command)_",1
"                        hf_pn_io_control_command_prmend, &u16Command)_",1
"                        hf_pn_io_control_command_applready, &u16Command)_",1
"                        hf_pn_io_control_command_release, &u16Command)_",1
"                        hf_pn_io_control_command_done, &u16Command)_",1
"                        hf_pn_io_control_command_ready_for_companion, &u16Command)_",1
"                        hf_pn_io_control_command_ready_for_rt_class3, &u16Command)_",1
    /* Prm.Begin */,1
"                        hf_pn_io_control_command_prmbegin, &u16Command)_",1
    if (u16Command & 0x0002) {,1
        /* ApplicationReady: special decode */,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_control_block_properties_applready, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_control_block_properties)_",1
"                            hf_pn_io_control_block_properties_applready0, &u16Properties)_",1
"                            hf_pn_io_control_block_properties, &u16Properties)_",1
"    proto_item_append_text(item, "": Session:%u, Command:"", u16SessionKey)_",1
    if (u16Command & 0x0001) {,1
"        proto_item_append_text(sub_item, "", ParameterEnd"")_",1
"        proto_item_append_text(item, "" ParameterEnd"")_",1
"        col_append_str(pinfo->cinfo, COL_INFO, "", Command: ParameterEnd"")_",1
"        proto_item_append_text(sub_item, "", ApplicationReady"")_",1
"        proto_item_append_text(item, "" ApplicationReady"")_",1
"        col_append_str(pinfo->cinfo, COL_INFO, "", Command: ApplicationReady"")_",1
    if (u16Command & 0x0004) {,1
"        proto_item_append_text(sub_item, "", Release"")_",1
"        proto_item_append_text(item, "" Release"")_",1
"        col_append_str(pinfo->cinfo, COL_INFO, "", Command: Release"")_",1
    if (u16Command & 0x0008) {,1
"        proto_item_append_text(sub_item, "", Done"")_",1
"        proto_item_append_text(item, "", Done"")_",1
"        col_append_str(pinfo->cinfo, COL_INFO, "", Command: Done"")_",1
"    proto_item_append_text(item, "", Properties:0x%x"", u16Properties)_",1
/* dissect the ControlBlockPrmBegin block */,1
"dissect_ControlBlockPrmBegin(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow, guint32 u32RecDataLen,",1
    if (u32RecDataLen != 28-2) /* must be 28 see specification (version already dissected) */,1
"        expert_add_info_format(pinfo, item, &ei_pn_io_block_length, ""Block length of %u is invalid!"", u32RecDataLen)_",1
    /* ARUUID */,1
"    offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, tree, drep, hf_pn_io_ar_uuid, &ar_uuid)_",1
    /* SessionKey */,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_sessionkey, &u16SessionKey)_",1
    /* ControlCommand */,1
"                        hf_pn_io_control_command_reserved_7_15, &u16Command)_",1
    /* ControlBlockProperties.reserved */,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_control_command_reserved, NULL)_",1
/* dissect the SubmoduleListBlock  block */,1
"dissect_SubmoduleListBlock(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow, guint32 u32RecDataLen _U_,",1
    pnio_ar_t **ar _U_),1
    guint16 u16Entries_,1
    guint32 u32API_,1
    guint16 u16SlotNumber_,1
    guint16 u16SubSlotNumber_,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_SubmoduleListEntries, &u16Entries)_",1
    while (u16Entries --),1
        /*API */,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep, hf_pn_io_api, &u32API)_",1
        /*SlotNumber */,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_slot_nr, &u16SlotNumber)_",1
        /* SubSlotNumber */,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_subslot_nr, &u16SubSlotNumber)_",1
/* dissect the PDevData block */,1
"dissect_PDevData_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_blocks(tvb, offset, pinfo, tree, drep)_",1
/* dissect the AdjustPreambleLength block */,1
"dissect_AdjustPreambleLength_block(tvbuff_t *tvb, int offset,",1
    guint16 u16AdjustProperties_,1
    guint16 u16PreambleLength_,1
    /* PreambleLength */,1
"        hf_pn_io_PreambleLength, &u16PreambleLength)_",1
    /* AdjustProperties */,1
"        hf_pn_io_adjust_properties, &u16AdjustProperties)_",1
/* dissect the PDPortDataAdjust block */,1
"dissect_PDPortData_Adjust_block(tvbuff_t *tvb, int offset,",1
    guint16   u16SlotNr_,1
    guint16   u16SubslotNr_,1
    tvbuff_t *new_tvb_,1
    /* Subslotnumber */,1
"    proto_item_append_text(item, "": Slot:0x%x/0x%x"", u16SlotNr, u16SubslotNr)_",1
    u16BodyLength -= 6_,1
"    new_tvb = tvb_new_subset_length(tvb, offset, u16BodyLength)_",1
"    dissect_blocks(new_tvb, 0, pinfo, tree, drep)_",1
    offset += u16BodyLength_,1
    /* XXX - do we have to free the new_tvb somehow? */,1
/* dissect the PDPortDataCheck blocks */,1
"dissect_PDPortData_Check_block(tvbuff_t *tvb, int offset,",1
/* dissect the Line Delay */,1
"dissect_Line_Delay(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint8 *drep,",1
    guint32  *u32LineDelayValue),1
    guint32  u32FormatIndicator_,1
    guint8   isFormatIndicatorEnabled_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_line_delay, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_line_delay)_",1
"        hf_pn_io_line_delay_format_indicator, &u32FormatIndicator)_",1
    isFormatIndicatorEnabled = (guint8)((u32FormatIndicator >> 31) & 0x01)_,1
    if (isFormatIndicatorEnabled),1
"            hf_pn_io_cable_delay_value, u32LineDelayValue)_",1
"            hf_pn_io_line_delay_value, u32LineDelayValue)_",1
/* dissect the PDPortDataReal blocks */,1
"dissect_PDPortDataReal_block(tvbuff_t *tvb, int offset,",1
    guint8   u8LengthOwnPortID_,1
    char    *pOwnPortID_,1
    guint8   u8NumberOfPeers_,1
    guint8   u8I_,1
    guint8   u8LengthPeerPortID_,1
    char    *pPeerPortID_,1
    guint8   u8LengthPeerChassisID_,1
    char    *pPeerChassisID_,1
    guint8   mac[6]_,1
    guint16  u16MAUType_,1
    guint32  u32DomainBoundary_,1
    guint32  u32MulticastBoundary_,1
    guint16  u16PortState_,1
    guint32  u32MediaType_,1
    guint32  u32LineDelayValue_,1
    /* LengthOwnPortID */,1
"                        hf_pn_io_length_own_port_id, &u8LengthOwnPortID)_",1
    /* OwnPortID */,1
"    pOwnPortID = (char *)wmem_alloc(wmem_packet_scope(), u8LengthOwnPortID+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pOwnPortID, offset, u8LengthOwnPortID)_",1
    pOwnPortID[u8LengthOwnPortID] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_own_port_id, tvb, offset, u8LengthOwnPortID, pOwnPortID)_",1
    offset += u8LengthOwnPortID_,1
    /* NumberOfPeers */,1
"                        hf_pn_io_number_of_peers, &u8NumberOfPeers)_",1
    /* Padding */,1
    u8I = u8NumberOfPeers_,1
    while (u8I--) {,1
        /* LengthPeerPortID */,1
"                            hf_pn_io_length_peer_port_id, &u8LengthPeerPortID)_",1
        /* PeerPortID */,1
"        pPeerPortID = (char *)wmem_alloc(wmem_packet_scope(), u8LengthPeerPortID+1)_",1
"        tvb_memcpy(tvb, (guint8 *) pPeerPortID, offset, u8LengthPeerPortID)_",1
        pPeerPortID[u8LengthPeerPortID] = '\0'_,1
"        proto_tree_add_string (tree, hf_pn_io_peer_port_id, tvb, offset, u8LengthPeerPortID, pPeerPortID)_",1
        offset += u8LengthPeerPortID_,1
        /* LengthPeerChassisID */,1
"                            hf_pn_io_length_peer_chassis_id, &u8LengthPeerChassisID)_",1
        /* PeerChassisID */,1
"        pPeerChassisID = (char *)wmem_alloc(wmem_packet_scope(), u8LengthPeerChassisID+1)_",1
"        tvb_memcpy(tvb, (guint8 *) pPeerChassisID, offset, u8LengthPeerChassisID)_",1
        pPeerChassisID[u8LengthPeerChassisID] = '\0'_,1
"        proto_tree_add_string (tree, hf_pn_io_peer_chassis_id, tvb, offset, u8LengthPeerChassisID, pPeerChassisID)_",1
        offset += u8LengthPeerChassisID_,1
        /* Padding */,1
"        offset = dissect_pn_align4(tvb, offset, pinfo, tree)_",1
        /* LineDelay */,1
"        offset = dissect_Line_Delay(tvb, offset, pinfo, tree, drep, &u32LineDelayValue)_",1
        /* PeerMACAddress */,1
"        offset = dissect_pn_mac(tvb, offset, pinfo, tree,",1
"                            hf_pn_io_peer_macadd, mac)_",1
    /* MAUType */,1
"                        hf_pn_io_mau_type, &u16MAUType)_",1
    /* DomainBoundary */,1
"                        hf_pn_io_domain_boundary, &u32DomainBoundary)_",1
    /* MulticastBoundary */,1
"                        hf_pn_io_multicast_boundary, &u32MulticastBoundary)_",1
    /* PortState */,1
"                        hf_pn_io_port_state, &u16PortState)_",1
    /* MediaType */,1
"                        hf_pn_io_media_type, &u32MediaType)_",1
"    proto_item_append_text(item, "": Slot:0x%x/0x%x, OwnPortID:%s, Peers:%u PortState:%s MediaType:%s"",",1
"        u16SlotNr, u16SubslotNr, pOwnPortID, u8NumberOfPeers,",1
"        val_to_str(u16PortState, pn_io_port_state, ""0x%x""),",1
"        val_to_str(u32MediaType, pn_io_media_type, ""0x%x""))_",1
"dissect_PDInterfaceMrpDataAdjust_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow, guint16 u16BodyLength)",1
    e_guid_t  uuid_,1
    guint16   u16Role_,1
    guint8    u8LengthDomainName_,1
    guint8    u8NumberOfMrpInstances_,1
    char     *pDomainName_,1
    int       iStartOffset = offset_,1
    if (u8BlockVersionHigh != 1 || u8BlockVersionLow > 1) { /* added low version == 1 */,1
    if (u8BlockVersionLow == 0) /*dissect LowVersion == 0 */,1
    /* MRP_DomainUUID */,1
"                        hf_pn_io_mrp_domain_uuid, &uuid)_",1
    /* MRP_Role */,1
"                    hf_pn_io_mrp_role, &u16Role)_",1
    /* MRP_LengthDomainName */,1
"                    hf_pn_io_mrp_length_domain_name, &u8LengthDomainName)_",1
    /* MRP_DomainName */,1
"    pDomainName = (char *)wmem_alloc(wmem_packet_scope(), u8LengthDomainName+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pDomainName, offset, u8LengthDomainName)_",1
    pDomainName[u8LengthDomainName] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_mrp_domain_name, tvb, offset, u8LengthDomainName, pDomainName)_",1
    offset += u8LengthDomainName_,1
    if ((offset - iStartOffset) < u16BodyLength),1
"        offset = dissect_blocks(tvb, offset, pinfo, tree, drep)_",1
    else if (u8BlockVersionLow == 1) /*dissect LowVersion == 1 */,1
        /* Padding one byte */,1
"        offset = dissect_pn_padding(tvb, offset, pinfo, tree, 1)_",1
        /* Number of Mrp Instances */,1
"            hf_pn_io_mrp_instances, &u8NumberOfMrpInstances)_",1
        if (u8NumberOfMrpInstances > 0xf) {,1
"             expert_add_info_format(pinfo, item, &ei_pn_io_mrp_instances, ""Number of MrpInstances greater 0x0f is (0x%x)"", u8NumberOfMrpInstances)_",1
        while(u8NumberOfMrpInstances > 0),1
"            offset = dissect_a_block(tvb, offset, pinfo, tree, drep)_",1
            u8NumberOfMrpInstances--_,1
"dissect_PDInterfaceMrpDataReal_block(tvbuff_t *tvb, int offset,",1
    guint16   u16Version_,1
    int       endoffset = offset + u16BodyLength_,1
    /* added blockversion 1 */,1
    if (u8BlockVersionHigh != 1 || u8BlockVersionLow > 2) {,1
    if (u8BlockVersionLow < 2) /* dissect low versions 0 and 1 */,1
        /* MRP_DomainUUID */,1
"                hf_pn_io_mrp_domain_uuid, &uuid)_",1
        /* MRP_Role */,1
"                hf_pn_io_mrp_role, &u16Role)_",1
            /* MRP_Version */,1
"                    hf_pn_io_mrp_version, &u16Version)_",1
        /* MRP_LengthDomainName */,1
"                hf_pn_io_mrp_length_domain_name, &u8LengthDomainName)_",1
        /* MRP_DomainName */,1
"        pDomainName = (char *)wmem_alloc(wmem_packet_scope(), u8LengthDomainName+1)_",1
"        tvb_memcpy(tvb, (guint8 *) pDomainName, offset, u8LengthDomainName)_",1
        pDomainName[u8LengthDomainName] = '\0'_,1
"        proto_tree_add_string (tree, hf_pn_io_mrp_domain_name, tvb, offset, u8LengthDomainName, pDomainName)_",1
        offset += u8LengthDomainName_,1
        if (u8BlockVersionLow == 0) {,1
        while(endoffset > offset),1
    else if (u8BlockVersionLow == 2),1
"                hf_pn_io_mrp_instances, &u8NumberOfMrpInstances)_",1
"            expert_add_info_format(pinfo, item, &ei_pn_io_mrp_instances, ""Number of MrpInstances greater 0x0f is (0x%x)"", u8NumberOfMrpInstances)_",1
"dissect_PDInterfaceMrpDataCheck_block(tvbuff_t *tvb, int offset,",1
    e_guid_t uuid_,1
    guint32 u32Check_,1
    guint8 u8NumberOfMrpInstances_,1
    /* BlockVersionLow == 1 added */,1
    if (u8BlockVersionHigh != 1 || u8BlockVersionLow > 1) {,1
    if (u8BlockVersionLow == 0),1
    /* MRP_Check */,1
"        dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,",1
"            hf_pn_io_mrp_check, &u32Check)_",1
"            hf_pn_io_mrp_check_mrm, &u32Check)_",1
"            hf_pn_io_mrp_check_mrpdomain, &u32Check)_",1
"            hf_pn_io_mrp_check_reserved_1, &u32Check)_",1
"            hf_pn_io_mrp_check_reserved_2, &u32Check)_",1
        offset +=4_ /* MRP_Check (32 bit) done */,1
    else if (u8BlockVersionLow == 1),1
"dissect_PDPortMrpData_block(tvbuff_t *tvb, int offset,",1
    guint8  u8MrpInstance_,1
    /* added BlockVersionLow == 1 */,1
    if (u8BlockVersionLow == 0) {,1
    else /*if (u8BlockVersionLow == 1) */,1
        /* Mrp Instance */,1
"            hf_pn_io_mrp_instance, &u8MrpInstance)_",1
"dissect_MrpManagerParams_block(tvbuff_t *tvb, int offset,",1
    guint16 u16Prio_,1
    guint16 u16TOPchgT_,1
    guint16 u16TOPNRmax_,1
    guint16 u16TSTshortT_,1
    guint16 u16TSTdefaultT_,1
    guint16 u16TSTNRmax_,1
    /* MRP_Prio */,1
"                    hf_pn_io_mrp_prio, &u16Prio)_",1
    /* MRP_TOPchgT */,1
"                    hf_pn_io_mrp_topchgt, &u16TOPchgT)_",1
    /* MRP_TOPNRmax */,1
"                    hf_pn_io_mrp_topnrmax, &u16TOPNRmax)_",1
    /* MRP_TSTshortT */,1
"                    hf_pn_io_mrp_tstshortt, &u16TSTshortT)_",1
    /* MRP_TSTdefaultT */,1
"                    hf_pn_io_mrp_tstdefaultt, &u16TSTdefaultT)_",1
    /* MSP_TSTNRmax */,1
"                    hf_pn_io_mrp_tstnrmax, &u16TSTNRmax)_",1
"dissect_MrpRTMode(tvbuff_t *tvb, int offset,",1
    guint32     u32RTMode_,1
    /* MRP_RTMode */,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_mrp_rtmode, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_mrp_rtmode)_",1
"                    hf_pn_io_mrp_rtmode_reserved2, &u32RTMode)_",1
"                    hf_pn_io_mrp_rtmode_reserved1, &u32RTMode)_",1
"                    hf_pn_io_mrp_rtmode_rtclass3, &u32RTMode)_",1
"                    hf_pn_io_mrp_rtmode_rtclass12, &u32RTMode)_",1
"dissect_MrpRTModeManagerData_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_MrpRTMode(tvb, offset, pinfo, tree, item, drep)_",1
"dissect_MrpRingStateData_block(tvbuff_t *tvb, int offset,",1
    guint16 u16RingState_,1
    /* MRP_RingState */,1
"                    hf_pn_io_mrp_ring_state, &u16RingState)_",1
"dissect_MrpRTStateData_block(tvbuff_t *tvb, int offset,",1
    guint16 u16RTState_,1
    /* MRP_RTState */,1
"                    hf_pn_io_mrp_rt_state, &u16RTState)_",1
"dissect_MrpClientParams_block(tvbuff_t *tvb, int offset,",1
    guint16 u16MRP_LNKdownT_,1
    guint16 u16MRP_LNKupT_,1
    guint16 u16MRP_LNKNRmax_,1
    /* MRP_LNKdownT */,1
"                    hf_pn_io_mrp_lnkdownt, &u16MRP_LNKdownT)_",1
    /* MRP_LNKupT */,1
"                    hf_pn_io_mrp_lnkupt, &u16MRP_LNKupT)_",1
    /* MRP_LNKNRmax u16 */,1
"                    hf_pn_io_mrp_lnknrmax, &u16MRP_LNKNRmax)_",1
"dissect_MrpRTModeClientData_block(tvbuff_t *tvb, int offset,",1
"dissect_CheckSyncDifference_block(tvbuff_t *tvb, int offset,",1
    guint16     u16CheckSyncMode_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_check_sync_mode, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_check_sync_mode)_",1
"                    hf_pn_io_check_sync_mode_reserved, &u16CheckSyncMode)_",1
"                    hf_pn_io_check_sync_mode_sync_master, &u16CheckSyncMode)_",1
"                    hf_pn_io_check_sync_mode_cable_delay, &u16CheckSyncMode)_",1
"    proto_item_append_text(sub_item, ""CheckSyncMode: SyncMaster:%d, CableDelay:%d"",",1
"        (u16CheckSyncMode >> 1) & 1, u16CheckSyncMode & 1)_",1
"    proto_item_append_text(item, "" : SyncMaster:%d, CableDelay:%d"",",1
"dissect_CheckMAUTypeDifference_block(tvbuff_t *tvb, int offset,",1
    guint16 u16MAUTypeMode_,1
"                    hf_pn_io_mau_type_mode, &u16MAUTypeMode)_",1
"    proto_item_append_text(item, "": MAUTypeMode:%s"",",1
"        val_to_str(u16MAUTypeMode, pn_io_mau_type_mode, ""0x%x""))_",1
/* dissect the AdjustDomainBoundary blocks */,1
"dissect_AdjustDomainBoundary_block(tvbuff_t *tvb, int offset,",1
    guint32 u32DomainBoundary_,1
    guint32 u32DomainBoundaryIngress_,1
    guint32 u32DomainBoundaryEgress_,1
    switch (u8BlockVersionLow) {,1
        case(0):,1
        /* DomainBoundary */,1
"                            hf_pn_io_domain_boundary, &u32DomainBoundary)_",1
        /* AdjustProperties */,1
"                            hf_pn_io_adjust_properties, &u16AdjustProperties)_",1
"        proto_item_append_text(item, "": Boundary:0x%x, Properties:0x%x"",",1
"            u32DomainBoundary, u16AdjustProperties)_",1
        /* DomainBoundaryIngress */,1
"                            hf_pn_io_domain_boundary_ingress, &u32DomainBoundaryIngress)_",1
        /* DomainBoundaryEgress */,1
"                            hf_pn_io_domain_boundary_egress, &u32DomainBoundaryEgress)_",1
"        proto_item_append_text(item, "": BoundaryIngress:0x%x, BoundaryEgress:0x%x, Properties:0x%x"",",1
"            u32DomainBoundaryIngress, u32DomainBoundaryEgress, u16AdjustProperties)_",1
/* dissect the AdjustMulticastBoundary blocks */,1
"dissect_AdjustMulticastBoundary_block(tvbuff_t *tvb, int offset,",1
    guint32 u32MulticastBoundary_,1
    /* Boundary */,1
"                        hf_pn_io_adjust_properties, &u16AdjustProperties)_",1
"    proto_item_append_text(item, "": Boundary:0x%x, Properties:0x%x"",",1
"        u32MulticastBoundary, u16AdjustProperties)_",1
/* dissect the AdjustMAUType block */,1
"dissect_AdjustMAUType_block(tvbuff_t *tvb, int offset,",1
    guint16 u16MAUType_,1
"    proto_item_append_text(item, "": MAUType:%s, Properties:0x%x"",",1
"        val_to_str(u16MAUType, pn_io_mau_type, ""0x%x""),",1
        u16AdjustProperties)_,1
/* dissect the CheckMAUType block */,1
"dissect_CheckMAUType_block(tvbuff_t *tvb, int offset,",1
"    proto_item_append_text(item, "": MAUType:%s"",",1
"        val_to_str(u16MAUType, pn_io_mau_type, ""0x%x""))_",1
/* dissect the CheckLineDelay block */,1
"dissect_CheckLineDelay_block(tvbuff_t *tvb, int offset,",1
    guint32 u32LineDelay_,1
    /* LineDelay */,1
"    offset = dissect_Line_Delay(tvb, offset, pinfo, tree, drep, &u32LineDelay)_",1
"    proto_item_append_text(item, "": LineDelay:%uns"", u32LineDelay)_",1
/* dissect the CheckPeers block */,1
"dissect_CheckPeers_block(tvbuff_t *tvb, int offset,",1
    guint8  u8NumberOfPeers_,1
    guint8  u8I_,1
    guint8  u8LengthPeerPortID_,1
    char   *pPeerPortID_,1
    guint8  u8LengthPeerChassisID_,1
    char   *pPeerChassisID_,1
"    proto_item_append_text(item, "": NumberOfPeers:%u"", u8NumberOfPeers)_",1
/* dissect the AdjustPortState block */,1
"dissect_AdjustPortState_block(tvbuff_t *tvb, int offset,",1
    guint16 u16PortState_,1
"    proto_item_append_text(item, "": PortState:%s, Properties:0x%x"",",1
/* dissect the CheckPortState block */,1
"dissect_CheckPortState_block(tvbuff_t *tvb, int offset,",1
"    proto_item_append_text(item, "": %s"",",1
"        val_to_str(u16PortState, pn_io_port_state, ""0x%x""))_",1
/* dissect the PDPortFODataReal block */,1
"dissect_PDPortFODataReal_block(tvbuff_t *tvb, int offset,",1
    guint32    u32FiberOpticType_,1
    guint32    u32FiberOpticCableType_,1
    /* FiberOpticType */,1
"                        hf_pn_io_fiber_optic_type, &u32FiberOpticType)_",1
    /* FiberOpticCableType */,1
"                        hf_pn_io_fiber_optic_cable_type, &u32FiberOpticCableType)_",1
    /* optional: FiberOpticManufacturerSpecific */,1
    if (u16BodyLength != 10) {,1
"        dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
/* dissect the FiberOpticManufacturerSpecific block */,1
"dissect_FiberOpticManufacturerSpecific_block(tvbuff_t *tvb, int offset,",1
    guint8  u8VendorIDHigh_,1
    guint8  u8VendorIDLow_,1
    guint16 u16VendorBlockType_,1
    /* VendorBlockType */,1
"                    hf_pn_io_vendor_block_type, &u16VendorBlockType)_",1
"    offset = dissect_pn_user_data(tvb, offset, pinfo, tree, u16BodyLength-4, ""Data"")_",1
/* dissect the FiberOpticDiagnosisInfo block */,1
"dissect_FiberOpticDiagnosisInfo_block(tvbuff_t *tvb, int offset,",1
    guint32 u32FiberOpticPowerBudget_,1
    /* decode the u32FiberOpticPowerBudget better */,1
"                        hf_pn_io_maintenance_required_power_budget, &u32FiberOpticPowerBudget)_",1
/* dissect the PDPortFODataAdjust block */,1
"dissect_PDPortFODataAdjust_block(tvbuff_t *tvb, int offset,",1
    guint32 u32FiberOpticType_,1
    guint32 u32FiberOpticCableType_,1
"        val_to_str(u16PortState, pn_io_port_state, ""0x%x""))_*/",1
/* dissect the PDPortFODataCheck block */,1
"dissect_PDPortFODataCheck_block(tvbuff_t *tvb, int offset,",1
    /* MaintenanceRequiredPowerBudget */,1
    /* XXX - decode the u32FiberOpticPowerBudget better */,1
    /* MaintenanceDemandedPowerBudget */,1
"                        hf_pn_io_maintenance_demanded_power_budget, &u32FiberOpticPowerBudget)_",1
    /* ErrorPowerBudget */,1
"                        hf_pn_io_error_power_budget, &u32FiberOpticPowerBudget)_",1
"dissect_MrpInstanceDataAdjust_block(tvbuff_t *tvb, int offset,",1
    guint16 u16Role_,1
    guint8  u8LengthDomainName_,1
    char*   pDomainName_,1
    int endoffset = offset + u16BodyLength_,1
    /* Padding one byte */,1
"    offset = dissect_pn_padding(tvb, offset, pinfo, tree, 1)_",1
    /* Mrp Instance */,1
"        hf_pn_io_mrp_instance, &u8MrpInstance)_",1
"        hf_pn_io_mrp_domain_uuid, &uuid)_",1
    while(endoffset > offset),1
"dissect_MrpInstanceDataReal_block(tvbuff_t *tvb, int offset,",1
    guint16 u16Version_,1
    int     endoffset = offset + u16BodyLength_,1
    /* MRP_Version */,1
"        hf_pn_io_mrp_version, &u16Version)_",1
"dissect_MrpInstanceDataCheck_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow, guint16 u16BodyLength _U_)",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,",1
"                          hf_pn_io_mrp_check, &u32Check)_",1
"                          hf_pn_io_mrp_check_mrm, &u32Check)_",1
"                          hf_pn_io_mrp_check_mrpdomain, &u32Check)_",1
"                          hf_pn_io_mrp_check_reserved_1, &u32Check)_",1
"                          hf_pn_io_mrp_check_reserved_2, &u32Check)_",1
    offset +=4_ /* MRP_Check (32 bit) done */,1
/* PDInterfaceAdjust */,1
"dissect_PDInterfaceAdjust_block(tvbuff_t *tvb, int offset,",1
" packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
    guint32     u32SMultipleInterfaceMode_,1
/* MultipleInterfaceMode */,1
"                        hf_pn_io_MultipleInterfaceMode_NameOfDevice, &u32SMultipleInterfaceMode)_",1
"                        hf_pn_io_MultipleInterfaceMode_reserved_1, &u32SMultipleInterfaceMode)_",1
"                        hf_pn_io_MultipleInterfaceMode_reserved_2, &u32SMultipleInterfaceMode)_",1
/* PDPortStatistic for one subslot */,1
"dissect_PDPortStatistic_block(tvbuff_t *tvb, int offset,",1
    guint32 u32StatValue_,1
    guint16 u16CounterStatus_,1
    case(0):,1
    break_,1
    case(1):,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_pdportstatistic_counter_status, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_counter_status)_",1
        /* bit 0 */,1
"            hf_pn_io_pdportstatistic_counter_status_ifInOctets, &u16CounterStatus)_",1
        /* bit 1 */,1
"            hf_pn_io_pdportstatistic_counter_status_ifOutOctets, &u16CounterStatus)_",1
        /* bit 2 */,1
"            hf_pn_io_pdportstatistic_counter_status_ifInDiscards, &u16CounterStatus)_",1
        /* bit 3 */,1
"            hf_pn_io_pdportstatistic_counter_status_ifOutDiscards, &u16CounterStatus)_",1
        /* bit 4 */,1
"            hf_pn_io_pdportstatistic_counter_status_ifInErrors, &u16CounterStatus)_",1
        /* bit 5 */,1
"            hf_pn_io_pdportstatistic_counter_status_ifOutErrors, &u16CounterStatus)_",1
        /* bit 6-15 */,1
"            hf_pn_io_pdportstatistic_counter_status_reserved, &u16CounterStatus)_",1
"                        hf_pn_io_pdportstatistic_ifInOctets, &u32StatValue)_",1
"                        hf_pn_io_pdportstatistic_ifOutOctets, &u32StatValue)_",1
"                        hf_pn_io_pdportstatistic_ifInDiscards, &u32StatValue)_",1
"                        hf_pn_io_pdportstatistic_ifOutDiscards, &u32StatValue)_",1
"                        hf_pn_io_pdportstatistic_ifInErrors, &u32StatValue)_",1
"                        hf_pn_io_pdportstatistic_ifOutErrors, &u32StatValue)_",1
/* dissect the PDInterfaceDataReal block */,1
"dissect_PDInterfaceDataReal_block(tvbuff_t *tvb, int offset,",1
    guint8   u8LengthOwnChassisID_,1
    char    *pOwnChassisID_,1
    guint32  ip_,1
    /* LengthOwnChassisID */,1
"                        hf_pn_io_length_own_chassis_id, &u8LengthOwnChassisID)_",1
    /* OwnChassisID */,1
"    pOwnChassisID = (char *)wmem_alloc(wmem_packet_scope(), u8LengthOwnChassisID+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pOwnChassisID, offset, u8LengthOwnChassisID)_",1
    pOwnChassisID[u8LengthOwnChassisID] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_own_chassis_id, tvb, offset, u8LengthOwnChassisID, pOwnChassisID)_",1
    offset += u8LengthOwnChassisID_,1
    /* MACAddressValue */,1
"    offset = dissect_pn_mac(tvb, offset, pinfo, tree, hf_pn_io_macadd, mac)_",1
    /* IPAddress */,1
"    offset = dissect_pn_ipv4(tvb, offset, pinfo, tree, hf_pn_io_ip_address, &ip)_",1
"    /*proto_item_append_text(block_item, "", IP: %s"", ip_to_str((guint8*)&ip))_*/",1
    /* Subnetmask */,1
"    offset = dissect_pn_ipv4(tvb, offset, pinfo, tree, hf_pn_io_subnetmask, &ip)_",1
"    /*proto_item_append_text(block_item, "", Subnet: %s"", ip_to_str((guint8*)&ip))_*/",1
    /* StandardGateway */,1
"    offset = dissect_pn_ipv4(tvb, offset, pinfo, tree, hf_pn_io_standard_gateway, &ip)_",1
"    /*proto_item_append_text(block_item, "", Router: %s"", ip_to_str((guint8*)&ip))_*/",1
/* dissect the PDSyncData block */,1
"dissect_PDSyncData_block(tvbuff_t *tvb, int offset,",1
    guint32   u32ReservedIntervalBegin_,1
    guint32   u32ReservedIntervalEnd_,1
    guint32   u32PLLWindow_,1
    guint32   u32SyncSendFactor_,1
    guint16   u16SendClockFactor_,1
    guint16   u16SyncProperties_,1
    guint16   u16SyncFrameAddress_,1
    guint16   u16PTCPTimeoutFactor_,1
    guint16   u16PTCPTakeoverTimeoutFactor_,1
    guint16   u16PTCPMasterStartupTime_,1
    guint8    u8MasterPriority1_,1
    guint8    u8MasterPriority2_,1
    guint8    u8LengthSubdomainName_,1
    char     *pSubdomainName_,1
    if (u8BlockVersionHigh != 1) {,1
        /* SlotNumber */,1
        /* Subslotnumber */,1
"                            hf_pn_io_subslot_nr, &u16SubslotNr)_",1
        /* PTCPSubdomainID */,1
"                            hf_pn_io_ptcp_subdomain_id, &uuid)_",1
        /* IRDataID */,1
"                            hf_pn_io_ir_data_id, &uuid)_",1
        /* ReservedIntervalBegin */,1
"                            hf_pn_io_reserved_interval_begin, &u32ReservedIntervalBegin)_",1
        /* ReservedIntervalEnd */,1
"                            hf_pn_io_reserved_interval_end, &u32ReservedIntervalEnd)_",1
        /* PLLWindow enum */,1
"                            hf_pn_io_pllwindow, &u32PLLWindow)_",1
        /* SyncSendFactor 32 enum */,1
"                            hf_pn_io_sync_send_factor, &u32SyncSendFactor)_",1
        /* SendClockFactor 16 */,1
"                            hf_pn_io_send_clock_factor, &u16SendClockFactor)_",1
        /* SyncProperties 16 bitfield */,1
"                            hf_pn_io_sync_properties, &u16SyncProperties)_",1
        /* SyncFrameAddress 16 bitfield */,1
"                            hf_pn_io_sync_frame_address, &u16SyncFrameAddress)_",1
        /* PTCPTimeoutFactor 16 enum */,1
"                            hf_pn_io_ptcp_timeout_factor, &u16PTCPTimeoutFactor)_",1
"        proto_item_append_text(item, "": Slot:0x%x/0x%x, Interval:%u-%u, PLLWin:%u, Send:%u, Clock:%u"",",1
"            u16SlotNr, u16SubslotNr, u32ReservedIntervalBegin, u32ReservedIntervalEnd,",1
"            u32PLLWindow, u32SyncSendFactor, u16SendClockFactor)_",1
    case(2):,1
        /* PTCPTakeoverTimeoutFactor 16 */,1
"                            hf_pn_io_ptcp_takeover_timeout_factor, &u16PTCPTakeoverTimeoutFactor)_",1
        /* PTCPMasterStartupTime 16 */,1
"                            hf_pn_io_ptcp_master_startup_time, &u16PTCPMasterStartupTime)_",1
        /* PTCP_MasterPriority1 */,1
"                            hf_pn_io_ptcp_master_priority_1, &u8MasterPriority1)_",1
        /* PTCP_MasterPriority2 */,1
"                            hf_pn_io_ptcp_master_priority_2, &u8MasterPriority2)_",1
        /* PTCPLengthSubdomainName */,1
"                            hf_pn_io_ptcp_length_subdomain_name, &u8LengthSubdomainName)_",1
        /* PTCPSubdomainName */,1
"        pSubdomainName = (char *)wmem_alloc(wmem_packet_scope(), u8LengthSubdomainName+1)_",1
"        tvb_memcpy(tvb, (guint8 *) pSubdomainName, offset, u8LengthSubdomainName)_",1
        pSubdomainName[u8LengthSubdomainName] = '\0'_,1
"        proto_tree_add_string (tree, hf_pn_io_ptcp_subdomain_name, tvb, offset, u8LengthSubdomainName, pSubdomainName)_",1
        offset += u8LengthSubdomainName_,1
"        proto_item_append_text(item, "": Interval:%u-%u, PLLWin:%u, Send:%u, Clock:%u"",",1
"            u32ReservedIntervalBegin, u32ReservedIntervalEnd,",1
/* dissect the PDIRData block */,1
"dissect_PDIRData_block(tvbuff_t *tvb, int offset,",1
    guint16    u16SlotNr_,1
    guint16    u16SubslotNr_,1
    /* versions decoded are High: 1 and LOW 0..2 */,1
    if (u8BlockVersionHigh != 1 || (u8BlockVersionLow > 2 ) ) {,1
"    proto_item_append_text(item, "": Slot:0x%x/0x%x"",",1
    /* PDIRGlobalData */,1
        /* PDIRFrameData */,1
    } else if (u8BlockVersionLow == 1) {,1
        /* [PDIRFrameData] */,1
        /* PDIRBeginEndData */,1
    }else if (u8BlockVersionLow == 2) {,1
/* dissect the PDIRGlobalData block */,1
"dissect_PDIRGlobalData_block(tvbuff_t *tvb, int offset,",1
    guint32  u32MaxBridgeDelay_,1
    guint32  u32NumberOfPorts_,1
    guint32  u32MaxPortTxDelay_,1
    guint32  u32MaxPortRxDelay_,1
    guint32  u32MaxLineRxDelay_,1
    guint32  u32YellowTime_,1
    guint32  u32Tmp_,1
    /* added blockversion 2 */,1
    if (u8BlockVersionHigh != 1 || (u8BlockVersionLow > 2)) {,1
    /* IRDataID */,1
"                        hf_pn_io_ir_data_id, &uuid)_",1
    if (u8BlockVersionLow <= 2) {,1
        /* MaxBridgeDelay */,1
"                                     hf_pn_io_max_bridge_delay, &u32MaxBridgeDelay)_",1
        /* NumberOfPorts */,1
"                                     hf_pn_io_number_of_ports, &u32NumberOfPorts)_",1
        u32Tmp = u32NumberOfPorts_,1
        while (u32Tmp--) {,1
            /* MaxPortTxDelay */,1
"                                         hf_pn_io_max_port_tx_delay, &u32MaxPortTxDelay)_",1
            /* MaxPortRxDelay */,1
"                                         hf_pn_io_max_port_rx_delay, &u32MaxPortRxDelay)_",1
            if (u8BlockVersionLow >= 2) {,1
                /* MaxLineRxDelay */,1
"                offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep,",1
"                    hf_pn_io_max_line_rx_delay, &u32MaxLineRxDelay)_",1
                /* YellowTime */,1
"                    hf_pn_io_yellowtime, &u32YellowTime)_",1
"        proto_item_append_text(item, "": MaxBridgeDelay:%u, NumberOfPorts:%u"",",1
"                             u32MaxBridgeDelay, u32NumberOfPorts)_",1
/* dissect the PDIRFrameData block */,1
"dissect_PDIRFrameData_block(tvbuff_t *tvb, int offset,",1
    guint32     u32FrameSendOffset_,1
    guint32     u32FrameDataProperties_,1
    guint16     u16DataLength_,1
    guint16     u16ReductionRatio_,1
    guint16     u16Phase_,1
    guint16     u16FrameID_,1
    guint16     u16Ethertype_,1
    guint8      u8RXPort_,1
    guint8      u8FrameDetails_,1
    guint8      u8NumberOfTxPortGroups_,1
    guint8      u8TxPortGroupArray_,1
    guint16     u16TxPortGroupArraySize_,1
    guint16     u16EndOffset_,1
    guint16     n = 0_,1
    /* added low version 1 */,1
    u16EndOffset = offset + u16BodyLength -2_,1
    if (u8BlockVersionLow > 0) {,1
        /* for low version 1 FrameDataProperties is added */,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_frame_data_properties, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_FrameDataProperties)_",1
"                              hf_pn_io_frame_data_properties_forwarding_Mode, &u32FrameDataProperties)_",1
"                              hf_pn_io_frame_data_properties_FastForwardingMulticastMACAdd, &u32FrameDataProperties)_",1
"                              hf_pn_io_frame_data_properties_FragmentMode, &u32FrameDataProperties)_",1
"                              hf_pn_io_frame_data_properties_reserved_1, &u32FrameDataProperties)_",1
        offset =,1
"                              hf_pn_io_frame_data_properties_reserved_2, &u32FrameDataProperties)_",1
    /* dissect all IR frame data */,1
    while (offset < u16EndOffset),1
        proto_item *ir_frame_data_sub_item_,1
        proto_tree *ir_frame_data_tree_,1
        n++_,1
        /* new subtree for each IR frame */,1
"        ir_frame_data_sub_item = proto_tree_add_item(tree, hf_pn_io_ir_frame_data, tvb, offset, 17, ENC_NA)_",1
"        ir_frame_data_tree     = proto_item_add_subtree(ir_frame_data_sub_item, ett_pn_io_ir_frame_data)_",1
        /* FrameSendOffset */,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, ir_frame_data_tree, drep,",1
"                                       hf_pn_io_frame_send_offset, &u32FrameSendOffset)_",1
        /* DataLength */,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ir_frame_data_tree, drep,",1
"                                       hf_pn_io_data_length, &u16DataLength)_",1
        /* ReductionRatio */,1
"                                       hf_pn_io_reduction_ratio, &u16ReductionRatio)_",1
        /* Phase */,1
"                                       hf_pn_io_phase, &u16Phase)_",1
        /* FrameID */,1
"                                       hf_pn_io_frame_id, &u16FrameID)_",1
        /* Ethertype */,1
"                                       hf_pn_io_ethertype, &u16Ethertype)_",1
        /* RxPort */,1
"        offset = dissect_dcerpc_uint8(tvb, offset, pinfo, ir_frame_data_tree, drep,",1
"                                      hf_pn_io_rx_port, &u8RXPort)_",1
        /* FrameDetails */,1
"        sub_item = proto_tree_add_item(ir_frame_data_tree, hf_pn_io_frame_details, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_frame_defails)_",1
"        dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep,",1
"                             hf_pn_io_frame_details_sync_frame, &u8FrameDetails)_",1
"                             hf_pn_io_frame_details_meaning_frame_send_offset, &u8FrameDetails)_",1
"                             hf_pn_io_frame_details_reserved, &u8FrameDetails)_",1
        /* TxPortGroup */,1
"        u8NumberOfTxPortGroups = tvb_get_guint8(tvb, offset)_",1
"        sub_item = proto_tree_add_uint(ir_frame_data_tree, hf_pn_io_nr_of_tx_port_groups,",1
"                             tvb, offset, 1, u8NumberOfTxPortGroups)_",1
        if ((u8NumberOfTxPortGroups > 21) || ((u8NumberOfTxPortGroups & 0x1) !=1)) {,1
"            expert_add_info(pinfo, sub_item, &ei_pn_io_nr_of_tx_port_groups)_",1
        /* TxPortArray */,1
        u16TxPortGroupArraySize =  (u8NumberOfTxPortGroups + 7 / 8)_,1
"        sub_item = proto_tree_add_item(ir_frame_data_tree, hf_pn_io_TxPortGroupProperties,",1
"                             tvb, offset, u16TxPortGroupArraySize, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_GroupProperties)_",1
        while (u16TxPortGroupArraySize > 0),1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit0, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit1, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit2, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit3, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit4, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit5, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit6, &u8TxPortGroupArray)_",1
"            dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_TxPortGroupProperties_bit7, &u8TxPortGroupArray)_",1
            offset+=1_,1
            u16TxPortGroupArraySize --_,1
        /* align to next dataset */,1
"        offset = dissect_pn_align4(tvb, offset, pinfo, ir_frame_data_tree)_",1
"        proto_item_append_text(ir_frame_data_tree, "": Offset:%u, Len:%u, Ratio:%u, Phase:%u, FrameID:0x%04x"",",1
"                               u32FrameSendOffset, u16DataLength, u16ReductionRatio, u16Phase, u16FrameID)_",1
"    proto_item_append_text(item, "": Frames:%u"", n)_",1
"dissect_PDIRBeginEndData_block(tvbuff_t *tvb, int offset,",1
    guint16 u16StartOfRedFrameID_,1
    guint16 u16EndOfRedFrameID_,1
    guint32 u32NumberOfPorts_,1
    guint32 u32NumberOfAssignments_,1
    guint32 u32NumberOfPhases_,1
    guint32 u32RedOrangePeriodBegin_,1
    guint32 u32OrangePeriodBegin_,1
    guint32 u32GreenPeriodBegin_,1
    guint16 u16TXPhaseAssignment_,1
    guint16 u16RXPhaseAssignment_,1
    guint32 u32SubStart_,1
    guint32 u32Tmp_,1
    guint32 u32Tmp2_,1
    guint32 u32TxRedOrangePeriodBegin[0x11] = {0}_,1
    guint32 u32TxOrangePeriodBegin [0x11]   = {0}_,1
    guint32 u32TxGreenPeriodBegin [0x11]    = {0}_,1
    guint32 u32RxRedOrangePeriodBegin[0x11] = {0}_,1
    guint32 u32RxOrangePeriodBegin [0x11]   = {0}_,1
    guint32 u32RxGreenPeriodBegin [0x11]    = {0}_,1
    guint32 u32PortIndex_,1
"                    hf_pn_io_start_of_red_frame_id, &u16StartOfRedFrameID)_",1
"                    hf_pn_io_end_of_red_frame_id, &u16EndOfRedFrameID)_",1
"                        hf_pn_io_number_of_ports, &u32NumberOfPorts)_",1
    u32Tmp2 = u32NumberOfPorts_,1
    while (u32Tmp2--) {,1
        proto_item *ir_begin_end_port_sub_item_,1
        proto_tree *ir_begin_end_port_tree_,1
        /* new subtree for each Port */,1
"        ir_begin_end_port_sub_item = proto_tree_add_item(tree, hf_pn_io_ir_begin_end_port, tvb, offset, 0, ENC_NA)_",1
"        ir_begin_end_port_tree = proto_item_add_subtree(ir_begin_end_port_sub_item, ett_pn_io_ir_begin_end_port)_",1
        u32SubStart = offset_,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, ir_begin_end_port_tree, drep,",1
"                            hf_pn_io_number_of_assignments, &u32NumberOfAssignments)_",1
        u32Tmp = u32NumberOfAssignments_,1
        u32PortIndex = 0_,1
        if (u32Tmp <= 0x10),1
            while (u32Tmp--) {,1
                /* TXBeginEndAssignment */,1
"                offset = dissect_dcerpc_uint32(tvb, offset, pinfo, ir_begin_end_port_tree, drep,",1
"                                               hf_pn_io_red_orange_period_begin_tx, &u32RedOrangePeriodBegin)_",1
                u32TxRedOrangePeriodBegin[u32PortIndex] = u32RedOrangePeriodBegin_,1
"                                               hf_pn_io_orange_period_begin_tx, &u32OrangePeriodBegin)_",1
                u32TxOrangePeriodBegin[u32PortIndex]= u32OrangePeriodBegin_,1
"                                               hf_pn_io_green_period_begin_tx, &u32GreenPeriodBegin)_",1
                u32TxGreenPeriodBegin[u32PortIndex] = u32GreenPeriodBegin_,1
                /* RXBeginEndAssignment */,1
"                                               hf_pn_io_red_orange_period_begin_rx, &u32RedOrangePeriodBegin)_",1
                u32RxRedOrangePeriodBegin[u32PortIndex] = u32RedOrangePeriodBegin_,1
"                                               hf_pn_io_orange_period_begin_rx, &u32OrangePeriodBegin)_",1
                u32RxOrangePeriodBegin[u32PortIndex]= u32OrangePeriodBegin_,1
"                                               hf_pn_io_green_period_begin_rx, &u32GreenPeriodBegin)_",1
                u32RxGreenPeriodBegin[u32PortIndex] = u32GreenPeriodBegin_,1
                u32PortIndex++_,1
"                            hf_pn_io_number_of_phases, &u32NumberOfPhases)_",1
        u32Tmp = u32NumberOfPhases_,1
                proto_item *ir_begin_tx_phase_sub_item_,1
                proto_tree *ir_begin_tx_phase_tree_,1
                /* new subtree  for TXPhaseAssignment */,1
"                ir_begin_tx_phase_sub_item = proto_tree_add_item(ir_begin_end_port_tree,",1
"                                      hf_pn_ir_tx_phase_assignment, tvb, offset, 0, ENC_NA)_",1
"                ir_begin_tx_phase_tree     = proto_item_add_subtree(ir_begin_tx_phase_sub_item, ett_pn_io_ir_tx_phase)_",1
                /* bit 0..3 */,1
"                dissect_dcerpc_uint16(tvb, offset, pinfo, ir_begin_tx_phase_tree, drep,",1
"                                      hf_pn_io_tx_phase_assignment_begin_value, &u16TXPhaseAssignment)_",1
                /* bit 4..7 */,1
"                                      hf_pn_io_tx_phase_assignment_orange_begin, &u16TXPhaseAssignment)_",1
                /* bit 8..11 */,1
"                                      hf_pn_io_tx_phase_assignment_end_reserved, &u16TXPhaseAssignment)_",1
                /* bit 12..15 */,1
"                offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ir_begin_tx_phase_tree, drep,",1
"                                      hf_pn_io_tx_phase_assignment_reserved, &u16TXPhaseAssignment)_",1
"                proto_item_append_text(ir_begin_tx_phase_sub_item,",1
"                                      "": 0x%x, RedOrangePeriodBegin: %d, OrangePeriodBegin: %d, GreenPeriodBegin: %d"",",1
"                                      u16TXPhaseAssignment,",1
"                                      u32TxRedOrangePeriodBegin[u16TXPhaseAssignment & 0x0F],",1
"                                      u32TxOrangePeriodBegin[(u16TXPhaseAssignment & 0x0F0) >> 4],",1
                                      u32TxGreenPeriodBegin[(u16TXPhaseAssignment & 0x0F00)>> 8])_,1
                /* new subtree  for RXPhaseAssignment */,1
"                                      hf_pn_ir_rx_phase_assignment, tvb, offset, 0, ENC_NA)_",1
"                ir_begin_tx_phase_tree     = proto_item_add_subtree(ir_begin_tx_phase_sub_item, ett_pn_io_ir_rx_phase)_",1
"                                      hf_pn_io_tx_phase_assignment_begin_value, &u16RXPhaseAssignment)_",1
"                                      hf_pn_io_tx_phase_assignment_orange_begin, &u16RXPhaseAssignment)_",1
"                                      hf_pn_io_tx_phase_assignment_end_reserved, &u16RXPhaseAssignment)_",1
"                                      hf_pn_io_tx_phase_assignment_reserved, &u16RXPhaseAssignment)_",1
"                                      u16RXPhaseAssignment,",1
"                                      u32RxRedOrangePeriodBegin[u16RXPhaseAssignment & 0x0F],",1
"                                      u32RxOrangePeriodBegin[(u16RXPhaseAssignment & 0x0F0) >> 4],",1
                                      u32RxGreenPeriodBegin[(u16RXPhaseAssignment & 0x0F00)>> 8])_,1
"        proto_item_append_text(ir_begin_end_port_sub_item, "": Assignments:%u, Phases:%u"",",1
"            u32NumberOfAssignments, u32NumberOfPhases)_",1
"        proto_item_set_len(ir_begin_end_port_sub_item, offset - u32SubStart)_",1
"    proto_item_append_text(item, "": StartOfRedFrameID: 0x%x, EndOfRedFrameID: 0x%x, Ports: %u"",",1
"        u16StartOfRedFrameID, u16EndOfRedFrameID, u32NumberOfPorts)_",1
    return offset+u16BodyLength_,1
/* dissect the DiagnosisData block */,1
"dissect_DiagnosisData_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint8 *drep _U_, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow,",1
    guint16 u16ChannelNumber_,1
        body_length-=4_,1
"                    hf_pn_io_slot_nr, &u16SlotNr)_",1
"                    hf_pn_io_subslot_nr, &u16SubslotNr)_",1
    /* ChannelNumber got new ranges: 0..0x7FFF the source is a channel as specified by the manufacturer */,1
    /* fetch u16ChannelNumber */,1
    u16ChannelNumber =  ((drep[0] & DREP_LITTLE_ENDIAN),1
"                            ? tvb_get_letohs(tvb, offset)",1
"                            : tvb_get_ntohs(tvb, offset))_",1
"        sub_item = proto_tree_add_item(tree,hf_pn_io_channel_number, tvb, offset, 2, DREP_ENC_INTEGER(drep))_",1
        if (u16ChannelNumber < 0x8000){ /*  0..0x7FFF the source is a channel  as specified by the manufacturer */,1
"             proto_item_append_text(sub_item, "" channel number of the diagnosis source"")_",1
"            if (u16ChannelNumber == 0x8000) /* 0x8000 the whole submodule is the source, */",1
"                proto_item_append_text(sub_item, "" (whole) Submodule"")_",1
"                proto_item_append_text(sub_item, "" reserved"")_",1
    offset = offset +2_ /* Advance behind ChannelNumber */,1
    /* ChannelProperties */,1
"    offset = dissect_ChannelProperties(tvb, offset, pinfo, tree, item, drep)_",1
    body_length-=8_,1
    /* UserStructureIdentifier */,1
    u16UserStructureIdentifier = ((drep[0] & DREP_LITTLE_ENDIAN),1
"                                        ? tvb_get_letohs(tvb, offset)",1
"                                        : tvb_get_ntohs(tvb, offset))_",1
    if (u16UserStructureIdentifier > 0x7FFF){,1
"                                       hf_pn_io_user_structure_identifier, &u16UserStructureIdentifier)_",1
    { /* range 0x0 to 0x7fff is manufacturer specific */,1
"                                       hf_pn_io_user_structure_identifier_manf, &u16UserStructureIdentifier)_",1
"    proto_item_append_text(item, "", USI:0x%x"", u16UserStructureIdentifier)_",1
    body_length-=2_,1
"        offset = dissect_AlarmUserStructure(tvb, offset, pinfo, tree, item, drep,",1
"            &body_length, u16UserStructureIdentifier)_",1
"dissect_ARProperties(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint8 *drep _U_)",1
    guint32     u32ARProperties_,1
    guint8      startupMode_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_ar_properties, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_ar_properties)_",1
"                        hf_pn_io_ar_properties_pull_module_alarm_allowed, &u32ARProperties)_",1
"                        hf_pn_io_arproperties_StartupMode, &u32ARProperties)_",1
    startupMode = (guint8)((u32ARProperties >> 30) & 0x01)_,1
    /* Advanced startup mode */,1
    if (startupMode),1
"            hf_pn_io_ar_properties_combined_object_container_with_advanced_startupmode, &u32ARProperties)_",1
    /* Legacy startup mode */,1
"            hf_pn_io_ar_properties_combined_object_container_with_legacy_startupmode, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_reserved, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_achnowledge_companion_ar, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_companion_ar, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_device_access, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_reserved_1, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_data_rate, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_parametrization_server, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_supervisor_takeover_allowed, &u32ARProperties)_",1
"                        hf_pn_io_ar_properties_state, &u32ARProperties)_",1
/* dissect the IOCRProperties */,1
"dissect_IOCRProperties(tvbuff_t *tvb, int offset,",1
    guint32     u32IOCRProperties_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_iocr_properties, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_iocr_properties)_",1
"                    hf_pn_io_iocr_properties_full_subframe_structure, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_distributed_subframe_watchdog, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_fast_forwarding_mac_adr, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_reserved_3, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_reserved_2, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_media_redundancy, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_reserved_1, &u32IOCRProperties)_",1
"                    hf_pn_io_iocr_properties_rtclass, &u32IOCRProperties)_",1
/* dissect the ARData block */,1
"dissect_ARData_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint8 *drep _U_, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow, guint16 u16BlockLength)",1
    guint16     u16NumberOfARs_,1
    guint16     u16NumberofEntries_,1
    e_guid_t    aruuid_,1
    e_guid_t    uuid_,1
    guint16     u16ARType_,1
    char       *pStationName_,1
    guint16     u16NameLength_,1
    guint16     u16NumberOfIOCRs_,1
    guint16     u16IOCRType_,1
    guint16     u16CycleCounter_,1
    guint8      u8DataStatus_,1
    guint8      u8TransferStatus_,1
    proto_item *ds_item_,1
    proto_tree *ds_tree_,1
    guint16     u16UDPRTPort_,1
    guint16     u16AlarmCRType_,1
    guint16     u16LocalAlarmReference_,1
    guint16     u16RemoteAlarmReference_,1
    proto_item *iocr_item_,1
    proto_tree *iocr_tree_,1
    proto_item *ar_item_,1
    proto_tree *ar_tree_,1
    guint32     u32IOCRStart_,1
    gint32      i32EndOffset_,1
    guint32     u32ARDataStart_,1
    /* added BlockversionLow == 1  */,1
    i32EndOffset = offset + u16BlockLength_,1
"                    hf_pn_io_number_of_ars, &u16NumberOfARs)_",1
    /* BlockversionLow:  0 */,1
    while (u16NumberOfARs--) {,1
"            ar_item = proto_tree_add_item(tree, hf_pn_io_ar_data, tvb, offset, 0, ENC_NA)_",1
"            ar_tree = proto_item_add_subtree(ar_item, ett_pn_io_ar_data)_",1
            u32ARDataStart = offset_,1
"            offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, ar_tree, drep,",1
"                            hf_pn_io_ar_uuid, &aruuid)_",1
"            proto_item_append_text(ar_item, ""ARUUID:%s"", guid_to_str(wmem_packet_scope(), (const e_guid_t*) &aruuid))_",1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep,",1
"                        hf_pn_io_ar_type, &u16ARType)_",1
"            offset = dissect_ARProperties(tvb, offset, pinfo, ar_tree, item, drep)_",1
"        offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, ar_tree, drep,",1
"                         hf_pn_io_cminitiator_objectuuid, &uuid)_",1
"                        hf_pn_io_station_name_length, &u16NameLength)_",1
"        pStationName = (char *)wmem_alloc(wmem_packet_scope(), u16NameLength+1)_",1
"        tvb_memcpy(tvb, (guint8 *) pStationName, offset, u16NameLength)_",1
        pStationName[u16NameLength] = '\0'_,1
"            proto_tree_add_string (ar_tree, hf_pn_io_cminitiator_station_name, tvb, offset, u16NameLength, pStationName)_",1
        offset += u16NameLength_,1
"                        hf_pn_io_number_of_iocrs, &u16NumberOfIOCRs)_",1
        while (u16NumberOfIOCRs--) {,1
"            iocr_item = proto_tree_add_item(ar_tree, hf_pn_io_iocr_tree, tvb, offset, 0, ENC_NA)_",1
"            iocr_tree = proto_item_add_subtree(iocr_item, ett_pn_io_iocr)_",1
            u32IOCRStart = offset_,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, iocr_tree, drep,",1
"                            hf_pn_io_iocr_type, &u16IOCRType)_",1
"            offset = dissect_IOCRProperties(tvb, offset, pinfo, iocr_tree, drep)_",1
"                            hf_pn_io_frame_id, &u16FrameID)_",1
"            proto_item_append_text(iocr_item, "": FrameID:0x%x"", u16FrameID)_",1
            /* add cycle counter */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, iocr_tree, drep,",1
"                            hf_pn_io_cycle_counter, &u16CycleCounter)_",1
"        u8DataStatus = tvb_get_guint8(tvb, offset)_",1
"        u8TransferStatus = tvb_get_guint8(tvb, offset+1)_",1
            /* add data status subtree */,1
"            ds_item = proto_tree_add_uint_format(iocr_tree, hf_pn_io_data_status,",1
"                tvb, offset, 1, u8DataStatus,",1
"                ""DataStatus: 0x%02x (Frame: %s and %s, Provider: %s and %s)"",",1
"                u8DataStatus,",1
"                (u8DataStatus & 0x04) ? ""Valid"" : ""Invalid"",",1
"                (u8DataStatus & 0x01) ? ""Primary"" : ""Backup"",",1
"                (u8DataStatus & 0x20) ? ""Ok"" : ""Problem"",",1
"                (u8DataStatus & 0x10) ? ""Run"" : ""Stop"")_",1
"            ds_tree = proto_item_add_subtree(ds_item, ett_pn_io_data_status)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_res67, tvb, offset, 1, u8DataStatus)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_ok, tvb, offset, 1, u8DataStatus)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_operate, tvb, offset, 1, u8DataStatus)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_res3, tvb, offset, 1, u8DataStatus)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_valid, tvb, offset, 1, u8DataStatus)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_res1, tvb, offset, 1, u8DataStatus)_",1
"            proto_tree_add_uint(ds_tree, hf_pn_io_data_status_primary, tvb, offset, 1, u8DataStatus)_",1
            /* add transfer status */,1
            if (u8TransferStatus) {,1
"                proto_tree_add_uint_format(iocr_tree, hf_pn_io_transfer_status, tvb,",1
"                offset, 1, u8TransferStatus,",1
"                ""TransferStatus: 0x%02x (ignore this frame)"", u8TransferStatus)_",1
"                ""TransferStatus: 0x%02x (OK)"", u8TransferStatus)_",1
"                            hf_pn_io_cminitiator_udprtport, &u16UDPRTPort)_",1
"                            hf_pn_io_cmresponder_udprtport, &u16UDPRTPort)_",1
"            proto_item_set_len(iocr_item, offset - u32IOCRStart)_",1
        /* AlarmCRType */,1
"                        hf_pn_io_alarmcr_type, &u16AlarmCRType)_",1
        /* LocalAlarmReference */,1
"                        hf_pn_io_localalarmref, &u16LocalAlarmReference)_",1
        /* RemoteAlarmReference */,1
"                        hf_pn_io_remotealarmref, &u16RemoteAlarmReference)_",1
        /* ParameterServerObjectUUID */,1
"                            hf_pn_io_parameter_server_objectuuid, &uuid)_",1
        /* StationNameLength */,1
        /* ParameterServerStationName */,1
"            proto_tree_add_string (ar_tree, hf_pn_io_parameter_server_station_name, tvb, offset, u16NameLength, pStationName)_",1
"                        hf_pn_io_number_of_apis, &u16NumberOfAPIs)_",1
        if (u16NumberOfAPIs > 0) {,1
"                offset = dissect_dcerpc_uint32(tvb, offset, pinfo, ar_tree, drep,",1
"                hf_pn_io_api, &u32Api)_",1
"            proto_item_set_len(ar_item, offset - u32ARDataStart)_",1
    {    /* BlockversionLow == 1 */,1
        while (u16NumberOfARs--) {,1
            /*ARUUID */,1
"            offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_ar_uuid, &aruuid)_",1
            /* CMInitiatorObjectUUID */,1
"            offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_cminitiator_objectuuid, &uuid)_",1
            /* ParameterServerObjectUUID */,1
"            offset = dissect_dcerpc_uuid_t(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_parameter_server_objectuuid, &uuid)_",1
            /* ARProperties*/,1
            /* ARType*/,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_ar_type, &u16ARType)_",1
            /* AlarmCRType */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_alarmcr_type, &u16AlarmCRType)_",1
            /* LocalAlarmReference */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_localalarmref, &u16LocalAlarmReference)_",1
            /* RemoteAlarmReference */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_remotealarmref, &u16RemoteAlarmReference)_",1
            /* InitiatorUDPRTPort*/,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_cminitiator_udprtport, &u16UDPRTPort)_",1
            /* ResponderUDPRTPort*/,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_cmresponder_udprtport, &u16UDPRTPort)_",1
            /* CMInitiatorStationName*/,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_station_name_length, &u16NameLength)_",1
"            pStationName = (char *)wmem_alloc(wmem_packet_scope(), u16NameLength+1)_",1
"            tvb_memcpy(tvb, (guint8 *) pStationName, offset, u16NameLength)_",1
            pStationName[u16NameLength] = '\0'_,1
            offset += u16NameLength_,1
            /** align padding! **/,1
"            offset = dissect_pn_align4(tvb, offset, pinfo, ar_tree)_",1
            /* StationNameLength */,1
            if (u16NameLength != 0) {,1
                /* ParameterServerStationName */,1
"                pStationName = (char *)wmem_alloc(wmem_packet_scope(), u16NameLength+1)_",1
"                tvb_memcpy(tvb, (guint8 *) pStationName, offset, u16NameLength)_",1
                pStationName[u16NameLength] = '\0'_,1
"                proto_tree_add_string (ar_tree, hf_pn_io_parameter_server_station_name, tvb, offset, u16NameLength, pStationName)_",1
                offset += u16NameLength_,1
            { /* display no name present */,1
"                proto_tree_add_string (ar_tree, hf_pn_io_parameter_server_station_name, tvb, offset, u16NameLength, "" <no ParameterServerStationName present>"")_",1
            /* NumberOfIOCRs*/,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_number_of_iocrs, &u16NumberOfIOCRs)_",1
            /* align to next 32 bit */,1
"            offset = dissect_pn_padding(tvb, offset, pinfo, ar_tree, 2)_",1
            while (u16NumberOfIOCRs--) {,1
"                iocr_item = proto_tree_add_item(ar_tree, hf_pn_io_iocr_tree, tvb, offset, 0, ENC_NA)_",1
"                iocr_tree = proto_item_add_subtree(iocr_item, ett_pn_io_iocr)_",1
                u32IOCRStart = offset_,1
                /* IOCRProperties*/,1
"                offset = dissect_IOCRProperties(tvb, offset, pinfo, iocr_tree, drep)_",1
                /* IOCRType*/,1
"                offset = dissect_dcerpc_uint16(tvb, offset, pinfo, iocr_tree, drep, hf_pn_io_iocr_type, &u16IOCRType)_",1
                /* FrameID*/,1
"                offset = dissect_dcerpc_uint16(tvb, offset, pinfo, iocr_tree, drep, hf_pn_io_frame_id, &u16FrameID)_",1
"                proto_item_append_text(iocr_item, "": FrameID:0x%x"", u16FrameID)_",1
                /* add cycle counter */,1
"                offset = dissect_dcerpc_uint16(tvb, offset, pinfo, iocr_tree, drep,",1
"                    hf_pn_io_cycle_counter, &u16CycleCounter)_",1
"                u8DataStatus = tvb_get_guint8(tvb, offset)_",1
"                u8TransferStatus = tvb_get_guint8(tvb, offset+1)_",1
                /* add data status subtree */,1
"                ds_item = proto_tree_add_uint_format(iocr_tree, hf_pn_io_data_status,",1
"                    tvb, offset, 1, u8DataStatus,",1
"                    ""DataStatus: 0x%02x (Frame: %s and %s, Provider: %s and %s)"",",1
"                    u8DataStatus,",1
"                    (u8DataStatus & 0x04) ? ""Valid"" : ""Invalid"",",1
"                    (u8DataStatus & 0x01) ? ""Primary"" : ""Backup"",",1
"                    (u8DataStatus & 0x20) ? ""Ok"" : ""Problem"",",1
"                    (u8DataStatus & 0x10) ? ""Run"" : ""Stop"")_",1
"                ds_tree = proto_item_add_subtree(ds_item, ett_pn_io_data_status)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_res67, tvb, offset, 1, u8DataStatus)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_ok, tvb, offset, 1, u8DataStatus)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_operate, tvb, offset, 1, u8DataStatus)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_res3, tvb, offset, 1, u8DataStatus)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_valid, tvb, offset, 1, u8DataStatus)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_res1, tvb, offset, 1, u8DataStatus)_",1
"                proto_tree_add_uint(ds_tree, hf_pn_io_data_status_primary, tvb, offset, 1, u8DataStatus)_",1
                offset++_,1
                /* add transfer status */,1
                if (u8TransferStatus) {,1
"                    proto_tree_add_uint_format(iocr_tree, hf_pn_io_transfer_status, tvb,",1
"                        offset, 1, u8TransferStatus,",1
"                        ""TransferStatus: 0x%02x (ignore this frame)"", u8TransferStatus)_",1
"                        ""TransferStatus: 0x%02x (OK)"", u8TransferStatus)_",1
"                proto_item_set_len(iocr_item, offset - u32IOCRStart)_",1
            /* NumberOfAPIs */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_number_of_apis, &u16NumberOfAPIs)_",1
            if (u16NumberOfAPIs > 0) {,1
"                offset = dissect_dcerpc_uint32(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_api, &u32Api)_",1
            /* get the number of subblocks an dissect them */,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, ar_tree, drep, hf_pn_io_number_of_ARDATAInfo, &u16NumberofEntries)_",1
            while ((offset < i32EndOffset) && (u16NumberofEntries > 0)) {,1
"                offset = dissect_a_block(tvb, offset, pinfo, ar_tree, drep)_",1
                u16NumberofEntries--_,1
/* dissect the APIData block */,1
"dissect_APIData_block(tvbuff_t *tvb, int offset,",1
    guint16 u16NumberOfAPIs_,1
/* dissect the SLRData block */,1
"dissect_SRLData_block(tvbuff_t *tvb, int offset,",1
    guint16 RedundancyInfo_,1
    /* bit 0 ..1  EndPoint1 and EndPoint2*/,1
"    dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_RedundancyInfo, &RedundancyInfo)_",1
    /* bit 2 .. 15 reserved */,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_RedundancyInfo_reserved, &RedundancyInfo)_",1
/* dissect the LogData block */,1
"dissect_LogData_block(tvbuff_t *tvb, int offset,",1
    guint64  u64ActualLocaltimeStamp_,1
    guint16  u16NumberOfLogEntries_,1
    guint64  u64LocaltimeStamp_,1
    guint32  u32EntryDetail_,1
    dcerpc_info        di_ /* fake dcerpc_info struct */,1
    dcerpc_call_value  call_data_,1
    di.conformant_run = 0_,1
    /* we need di->call_data->flags.NDR64 == 0 */,1
    call_data.flags = 0_,1
    di.call_data = &call_data_,1
"    di.dcerpc_procedure_name = """"_",1
    /* ActualLocalTimeStamp */,1
"    offset = dissect_dcerpc_uint64(tvb, offset, pinfo, tree, &di, drep,",1
"                    hf_pn_io_actual_local_time_stamp, &u64ActualLocaltimeStamp)_",1
    /* NumberOfLogEntries */,1
"                    hf_pn_io_number_of_log_entries, &u16NumberOfLogEntries)_",1
    while (u16NumberOfLogEntries--) {,1
        /* LocalTimeStamp */,1
"        offset = dissect_dcerpc_uint64(tvb, offset, pinfo, tree, &di, drep,",1
"                        hf_pn_io_local_time_stamp, &u64LocaltimeStamp)_",1
        /* ARUUID */,1
"                        hf_pn_io_ar_uuid, &aruuid)_",1
        /* PNIOStatus */,1
"        offset = dissect_PNIO_status(tvb, offset, pinfo, tree, drep)_",1
        /* EntryDetail */,1
"                        hf_pn_io_entry_detail, &u32EntryDetail)_",1
/* dissect the FS Hello block */,1
"dissect_FSHello_block(tvbuff_t *tvb, int offset,",1
    guint32 u32FSHelloMode_,1
    guint32 u32FSHelloInterval_,1
    guint32 u32FSHelloRetry_,1
    guint32 u32FSHelloDelay_,1
    /* FSHelloMode */,1
"                        hf_pn_io_fs_hello_mode, &u32FSHelloMode)_",1
    /* FSHelloInterval */,1
"                        hf_pn_io_fs_hello_interval, &u32FSHelloInterval)_",1
    /* FSHelloRetry */,1
"                        hf_pn_io_fs_hello_retry, &u32FSHelloRetry)_",1
    /* FSHelloDelay */,1
"                        hf_pn_io_fs_hello_delay, &u32FSHelloDelay)_",1
"    proto_item_append_text(item, "": Mode:%s, Interval:%ums, Retry:%u, Delay:%ums"",",1
"        val_to_str(u32FSHelloMode, pn_io_fs_hello_mode_vals, ""0x%x""),",1
"        u32FSHelloInterval, u32FSHelloRetry, u32FSHelloDelay)_",1
/* dissect the FS Parameter block */,1
"dissect_FSParameter_block(tvbuff_t *tvb, int offset,",1
    guint32 u32FSParameterMode_,1
    e_guid_t FSParameterUUID_,1
    /* FSParameterMode */,1
"                        hf_pn_io_fs_parameter_mode, &u32FSParameterMode)_",1
    /* FSParameterUUID */,1
"                        hf_pn_io_fs_parameter_uuid, &FSParameterUUID)_",1
"    proto_item_append_text(item, "": Mode:%s"",",1
"        val_to_str(u32FSParameterMode, pn_io_fs_parameter_mode_vals, ""0x%x""))_",1
/* dissect the FSUDataAdjust block */,1
"dissect_PDInterfaceFSUDataAdjust_block(tvbuff_t *tvb, int offset,",1
    u16BodyLength -= 2_,1
    /* sub blocks */,1
/* dissect the ARFSUDataAdjust block */,1
"dissect_ARFSUDataAdjust_block(tvbuff_t *tvb, int offset,",1
static const char *,1
"decode_ARType_spezial(guint16 ARType, guint16 ARAccess)",1
    if (ARType == 0x0001),1
"        return (""IO Controller AR"")_",1
    else if (ARType == 0x0003),1
"        return(""IO Controller AR"")_",1
    else if (ARType == 0x0010),1
"        return(""IO Controller AR (RT_CLASS_3)"")_",1
    else if (ARType == 0x0020),1
"        return(""IO Controller AR (sysred/CiR)"")_",1
    else if (ARType == 0x0006),1
        if (ARAccess) /*TRUE */,1
"            return(""DeviceAccess AR"")_",1
"            return(""IO Supervisor AR"")_",1
"        return(""reserved"")_",1
/* dissect the ARBlockReq */,1
"dissect_ARBlockReq_block(tvbuff_t *tvb, int offset,",1
    pnio_ar_t ** ar),1
    guint16    u16ARType_,1
    guint32    u32ARProperties_,1
    e_guid_t   aruuid_,1
    e_guid_t   uuid_,1
    guint16    u16SessionKey_,1
    guint8     mac[6]_,1
    guint16    u16TimeoutFactor_,1
    guint16    u16UDPRTPort_,1
    guint16    u16NameLength_,1
    char      *pStationName_,1
    pnio_ar_t *par_,1
    guint16             u16ArNumber_,1
    guint16             u16ArResource_,1
    guint16             u16ArReserved_,1
    proto_item          *sub_item_selector_,1
    proto_tree          *sub_tree_selector_,1
    conversation_t      *conversation_,1
    apduStatusSwitch    *apdu_status_switch = NULL_,1
    u32ARProperties = ((drep[0] & DREP_LITTLE_ENDIAN),1
"            ? tvb_get_letohl (tvb, offset + 2 + 16 +2 + 6 +12)",1
"            : tvb_get_ntohl (tvb, offset + 2 + 16 +2 + 6 +12))_",1
    u16ARType = ((drep[0] & DREP_LITTLE_ENDIAN),1
"                ? tvb_get_letohs (tvb, offset)",1
"                : tvb_get_ntohs (tvb, offset))_",1
"        proto_tree_add_string_format(tree, hf_pn_io_artype_req, tvb, offset, 2,",1
"                        ""ARType"", ""ARType: (0x%04x) %s "",",1
"                        u16ARType, decode_ARType_spezial(u16ARType, u32ARProperties))_",1
    offset = offset + 2_,1
    if (u16ARType == 0x0020),1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_ar_uuid, tvb, offset, 16, ENC_NA)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_ar_info)_",1
"        proto_tree_add_item(sub_tree, hf_pn_io_ar_discriminator, tvb, offset, 6, ENC_NA)_",1
        offset += 6_,1
"        proto_tree_add_item(sub_tree, hf_pn_io_ar_configid, tvb, offset, 8, ENC_NA)_",1
        offset += 8_,1
"        sub_item_selector = proto_tree_add_item(sub_tree, hf_pn_io_ar_selector, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"        sub_tree_selector = proto_item_add_subtree(sub_item_selector, ett_pn_io_ar_info)_",1
"        dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree_selector, drep, hf_pn_io_ar_arnumber, &u16ArNumber)_",1
"        dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree_selector, drep, hf_pn_io_ar_arresource, &u16ArResource)_",1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree_selector, drep, hf_pn_io_ar_arreserved, &u16ArReserved)_",1
"        /* When ARType==IOCARSR, then find or create conversation for this frame */",1
        if (!pinfo->fd->flags.visited) {,1
            /* Get current conversation endpoints using MAC addresses */,1
"            conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_UDP, 0, 0, 0)_",1
            if (conversation == NULL) {,1
"                /* If conversation is null, then create new conversation */",1
                /* Connect Request is sent by controller and not by device. */,1
                /* All conversations are based on Controller MAC as address */,1
"                conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_UDP, 0, 0, 0)_",1
            /* Try to get apdu status switch information from the conversation */,1
"            apdu_status_switch = (apduStatusSwitch*)conversation_get_proto_data(conversation, proto_pn_io_apdu_status)_",1
"            /* If apdu status switch is null, then fill it*/",1
"            /* If apdu status switch is not null, then update it*/",1
            if (apdu_status_switch == NULL) {,1
                /* apdu status switch information is valid for whole file*/,1
"                apdu_status_switch = wmem_new0(wmem_file_scope(), apduStatusSwitch)_",1
                apdu_status_switch->dl_src = conversation->key_ptr->addr1_,1
                apdu_status_switch->dl_dst = conversation->key_ptr->addr2_,1
                apdu_status_switch->isRedundancyActive = TRUE_,1
"                conversation_add_proto_data(conversation, proto_pn_io_apdu_status, apdu_status_switch)_",1
            else {,1
"            hf_pn_io_ar_uuid, &aruuid)_",1
"    offset = dissect_pn_mac(tvb, offset, pinfo, tree,",1
"                        hf_pn_io_cminitiator_macadd, mac)_",1
"                        hf_pn_io_cminitiator_objectuuid, &uuid)_",1
"    offset = dissect_ARProperties(tvb, offset, pinfo, tree, item, drep)_",1
"                        hf_pn_io_cminitiator_activitytimeoutfactor, &u16TimeoutFactor)_   /* XXX - special values */",1
"                        hf_pn_io_cminitiator_udprtport, &u16UDPRTPort)_",1
"    pStationName = (char *)wmem_alloc(wmem_packet_scope(), u16NameLength+1)_",1
"    tvb_memcpy(tvb, (guint8 *) pStationName, offset, u16NameLength)_",1
    pStationName[u16NameLength] = '\0'_,1
"    proto_tree_add_string (tree, hf_pn_io_cminitiator_station_name, tvb, offset, u16NameLength, pStationName)_",1
    offset += u16NameLength_,1
"    proto_item_append_text(item, "": %s, Session:%u, MAC:%02x:%02x:%02x:%02x:%02x:%02x, Port:0x%x, Station:%s"",",1
"        decode_ARType_spezial(u16ARType, u32ARProperties),",1
"        u16SessionKey,",1
"        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],",1
"        u16UDPRTPort,",1
        pStationName)_,1
"    par = pnio_ar_find_by_aruuid(pinfo, &aruuid)_",1
    if (par == NULL) {,1
        par = pnio_ar_new(&aruuid)_,1
"        memcpy( (void *) (&par->controllermac), mac, sizeof(par->controllermac))_",1
        par->arType = u16ARType_ /* store AR-type for filter generation */,1
"        /*strncpy( (char *) (&par->controllername), pStationName, sizeof(par->controllername))_*/",1
"        /*expert_add_info_format(pinfo, item, PI_UNDECODED, PI_WARN, ""ARBlockReq: AR already existing!"")_*/",1
    *ar = par_,1
/* dissect the ARBlockRes */,1
"dissect_ARBlockRes_block(tvbuff_t *tvb, int offset,",1
"                        hf_pn_io_ar_uuid, &uuid)_",1
"                        hf_pn_io_cmresponder_macadd, mac)_",1
"                        hf_pn_io_cmresponder_udprtport, &u16UDPRTPort)_",1
"    proto_item_append_text(item, "": %s, Session:%u, MAC:%02x:%02x:%02x:%02x:%02x:%02x, Port:0x%x"",",1
"        val_to_str(u16ARType, pn_io_ar_type, ""0x%x""),",1
        u16UDPRTPort)_,1
"    par = pnio_ar_find_by_aruuid(pinfo, &uuid)_",1
    if (par != NULL) {,1
"        memcpy( (void *) (&par->devicemac), mac, sizeof(par->controllermac))_",1
/* dissect the IOCRBlockReq */,1
"dissect_IOCRBlockReq_block(tvbuff_t *tvb, int offset,",1
    pnio_ar_t *ar),1
    guint16     u16IOCRReference_,1
    guint16     u16LT_,1
    guint16     u16SendClockFactor_,1
    guint16     u16Sequence_,1
    guint16     u16WatchdogFactor_,1
    guint16     u16DataHoldFactor_,1
    guint16     u16IOCRTagHeader_,1
    guint8      mac[6]_,1
    guint16     u16NumberOfIODataObjects_,1
    guint16     u16IODataObjectFrameOffset_,1
    guint16     u16NumberOfIOCS_,1
    guint16     u16IOCSFrameOffset_,1
    proto_item *api_item_,1
    proto_tree *api_tree_,1
    guint32     u32ApiStart_,1
    guint16     u16Tmp_,1
    conversation_t    *conversation_,1
    stationInfo       *station_info = NULL_,1
    iocsObject        *iocs_object_,1
    iocsObject        *cmp_iocs_object_,1
    ioDataObject      *io_data_object_,1
    ioDataObject      *cmp_io_data_object_,1
    wmem_list_frame_t *frame_,1
    wmem_list_t       *iocs_list_,1
"                        hf_pn_io_iocr_type, &u16IOCRType)_",1
"                        hf_pn_io_iocr_reference, &u16IOCRReference)_",1
"                        hf_pn_io_lt, &u16LT)_",1
"        offset = dissect_IOCRProperties(tvb, offset, pinfo, tree, drep)_",1
"                        hf_pn_io_data_length, &u16DataLength)_",1
"                        hf_pn_io_frame_id, &u16FrameID)_",1
"                        hf_pn_io_send_clock_factor, &u16SendClockFactor)_",1
"                        hf_pn_io_reduction_ratio, &u16ReductionRatio)_",1
"                        hf_pn_io_phase, &u16Phase)_",1
"                        hf_pn_io_sequence, &u16Sequence)_",1
"                        hf_pn_io_frame_send_offset, &u32FrameSendOffset)_",1
"                        hf_pn_io_watchdog_factor, &u16WatchdogFactor)_",1
"                        hf_pn_io_data_hold_factor, &u16DataHoldFactor)_",1
"                        hf_pn_io_iocr_tag_header, &u16IOCRTagHeader)_",1
"                        hf_pn_io_iocr_multicast_mac_add, mac)_",1
"    proto_item_append_text(item, "": %s, Ref:0x%x, Len:%u, FrameID:0x%x, Clock:%u, Ratio:%u, Phase:%u APIs:%u"",",1
"        val_to_str(u16IOCRType, pn_io_iocr_type, ""0x%x""),",1
"        u16IOCRReference, u16DataLength, u16FrameID,",1
"        u16SendClockFactor, u16ReductionRatio, u16Phase, u16NumberOfAPIs)_",1
"        api_item = proto_tree_add_item(tree, hf_pn_io_api_tree, tvb, offset, 0, ENC_NA)_",1
"        api_tree = proto_item_add_subtree(api_item, ett_pn_io_api)_",1
        u32ApiStart = offset_,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep,",1
        /* NumberOfIODataObjects */,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep,",1
"                            hf_pn_io_number_of_io_data_objects, &u16NumberOfIODataObjects)_",1
        /* Set global Variant for Number of IO Data Objects */,1
        /* Notice: Handle Input & Output seperate!!! */,1
"            conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
"                /* Create new conversation, if no ""Ident OK"" frame as been dissected yet!",1
"                 * Need to switch dl_src & dl_dst, as Connect Request is sent by controller and not by device.",1
                 * All conversations are based on Device MAC as addr1 */,1
"                conversation = conversation_new(pinfo->num, &pinfo->dl_dst, &pinfo->dl_src, PT_NONE, 0, 0, 0)_",1
"            station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp)_",1
            if (station_info == NULL) {,1
"                station_info = wmem_new0(wmem_file_scope(), stationInfo)_",1
                init_pnio_rtc1_station(station_info)_,1
"                conversation_add_proto_data(conversation, proto_pn_dcp, station_info)_",1
                station_info->ioDataObjectNr = u16NumberOfIODataObjects_,1
        u16Tmp = u16NumberOfIODataObjects_,1
        while (u16Tmp--) {,1
"            sub_item = proto_tree_add_item(api_tree, hf_pn_io_io_data_object, tvb, offset, 0, ENC_NA)_",1
"            sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_io_data_object)_",1
            u32SubStart = offset_,1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,",1
            /* Subslotnumber */,1
"                                hf_pn_io_subslot_nr, &u16SubslotNr)_",1
            /* IODataObjectFrameOffset */,1
"                                hf_pn_io_io_data_object_frame_offset, &u16IODataObjectFrameOffset)_",1
"            proto_item_append_text(sub_item, "": Slot: 0x%x, Subslot: 0x%x FrameOffset: %u"",",1
"                u16SlotNr, u16SubslotNr, u16IODataObjectFrameOffset)_",1
"            proto_item_set_len(sub_item, offset - u32SubStart)_",1
            if (!pinfo->fd->flags.visited && station_info != NULL) {,1
"                io_data_object = wmem_new0(wmem_file_scope(), ioDataObject)_",1
                io_data_object->slotNr = u16SlotNr_,1
                io_data_object->subSlotNr = u16SubslotNr_,1
                io_data_object->frameOffset = u16IODataObjectFrameOffset_,1
                /* initial - Will be added later with Write Request */,1
                io_data_object->f_dest_adr = 0_,1
                io_data_object->f_par_crc1 = 0_,1
                io_data_object->f_src_adr = 0_,1
                io_data_object->f_crc_seed = FALSE_,1
                io_data_object->f_crc_len = 0_,1
                /* Reset as a PNIO Connect Request of a known module appears */,1
                io_data_object->last_sb_cb = 0_,1
                io_data_object->lastToggleBit = 0_,1
                if (u16IOCRType == PN_INPUT_CR) {,1
                    iocs_list = station_info->ioobject_data_in_,1
                    iocs_list = station_info->ioobject_data_out_,1
                for (frame = wmem_list_head(iocs_list)_ frame != NULL_ frame = wmem_list_frame_next(frame)) {,1
                    cmp_io_data_object = (ioDataObject*)wmem_list_frame_data(frame)_,1
                    if (cmp_io_data_object->slotNr == u16SlotNr && cmp_io_data_object->subSlotNr == u16SubslotNr) {,1
                        /* Found identical existing object */,1
                if (frame == NULL) {,1
                    /* new io_object data incoming */,1
"                    wmem_list_append(iocs_list, io_data_object)_",1
        /* NumberOfIOCS */,1
"                            hf_pn_io_number_of_iocs, &u16NumberOfIOCS)_",1
        /* Set global Vairant for NumberOfIOCS */,1
            if (station_info != NULL) {,1
                station_info->iocsNr = u16NumberOfIOCS_,1
        u16Tmp = u16NumberOfIOCS_,1
"            sub_item = proto_tree_add_item(api_tree, hf_pn_io_io_cs, tvb, offset, 0, ENC_NA)_",1
"            sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_io_cs)_",1
            /* IOCSFrameOffset */,1
"                                hf_pn_io_iocs_frame_offset, &u16IOCSFrameOffset)_",1
"                u16SlotNr, u16SubslotNr, u16IOCSFrameOffset)_",1
            if (!pinfo->fd->flags.visited) {,1
                if (station_info != NULL) {,1
                    if (u16IOCRType == PN_INPUT_CR) {,1
                        iocs_list = station_info->iocs_data_in_,1
                    else {,1
                        iocs_list = station_info->iocs_data_out_,1
                    for (frame = wmem_list_head(iocs_list)_ frame != NULL_ frame = wmem_list_frame_next(frame)) {,1
                        cmp_iocs_object = (iocsObject*)wmem_list_frame_data(frame)_,1
                        if (cmp_iocs_object->slotNr == u16SlotNr && cmp_iocs_object->subSlotNr == u16SubslotNr) {,1
                            /* Found identical existing object */,1
                        },1
                    if (frame == NULL) {,1
                        /* new iocs_object data incoming */,1
"                        iocs_object = wmem_new(wmem_file_scope(), iocsObject)_",1
                        iocs_object->slotNr = u16SlotNr_,1
                        iocs_object->subSlotNr = u16SubslotNr_,1
                        iocs_object->frameOffset = u16IOCSFrameOffset_,1
"                        wmem_list_append(iocs_list, iocs_object)_",1
"        proto_item_append_text(api_item, "": 0x%x, NumberOfIODataObjects: %u NumberOfIOCS: %u"",",1
"            u32Api, u16NumberOfIODataObjects, u16NumberOfIOCS)_",1
"        proto_item_set_len(api_item, offset - u32ApiStart)_",1
    if (ar != NULL) {,1
        switch (u16IOCRType) {,1
        case(1): /* Input CR */,1
            if (ar->inputframeid != 0 && ar->inputframeid != u16FrameID) {,1
"                expert_add_info_format(pinfo, item, &ei_pn_io_frame_id, ""IOCRBlockReq: input frameID changed from %u to %u!"", ar->inputframeid, u16FrameID)_",1
            ar->inputframeid = u16FrameID_,1
        case(2): /* Output CR */,1
            /* will usually contain 0xffff here because the correct framid will be given in the connect.Cnf */,1
            if (ar->outputframeid != 0 && ar->outputframeid != u16FrameID) {,1
"                expert_add_info_format(pinfo, item, &ei_pn_io_frame_id, ""IOCRBlockReq: output frameID changed from %u to %u!"", ar->outputframeid, u16FrameID)_",1
            ar->outputframeid = u16FrameID_,1
"            expert_add_info_format(pinfo, item, &ei_pn_io_iocr_type, ""IOCRBlockReq: IOCRType %u undecoded!"", u16IOCRType)_",1
"        expert_add_info_format(pinfo, item, &ei_pn_io_ar_info_not_found, ""IOCRBlockReq: no corresponding AR found!"")_",1
/* dissect the AlarmCRBlockReq */,1
"dissect_AlarmCRBlockReq_block(tvbuff_t *tvb, int offset,",1
    guint32     u32AlarmCRProperties_,1
    guint16     u16RTATimeoutFactor_,1
    guint16     u16RTARetries_,1
    guint16     u16MaxAlarmDataLength_,1
    guint16     u16AlarmCRTagHeaderHigh_,1
    guint16     u16AlarmCRTagHeaderLow_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_alarmcr_properties, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_alarmcr_properties)_",1
"                        hf_pn_io_alarmcr_properties_reserved, &u32AlarmCRProperties)_",1
"                        hf_pn_io_alarmcr_properties_transport, &u32AlarmCRProperties)_",1
"                        hf_pn_io_alarmcr_properties_priority, &u32AlarmCRProperties)_",1
"                        hf_pn_io_rta_timeoutfactor, &u16RTATimeoutFactor)_",1
"                        hf_pn_io_rta_retries, &u16RTARetries)_",1
"                        hf_pn_io_maxalarmdatalength, &u16MaxAlarmDataLength)_",1
"                        hf_pn_io_alarmcr_tagheaderhigh, &u16AlarmCRTagHeaderHigh)_",1
"                        hf_pn_io_alarmcr_tagheaderlow, &u16AlarmCRTagHeaderLow)_",1
"    proto_item_append_text(item, "": %s, LT:0x%x, TFactor:%u, Retries:%u, Ref:0x%x, Len:%u Tag:0x%x/0x%x"",",1
"        val_to_str(u16AlarmCRType, pn_io_alarmcr_type, ""0x%x""),",1
"        u16LT, u16RTATimeoutFactor, u16RTARetries, u16LocalAlarmReference, u16MaxAlarmDataLength,",1
"        u16AlarmCRTagHeaderHigh, u16AlarmCRTagHeaderLow)_",1
        if (ar->controlleralarmref != 0xffff && ar->controlleralarmref != u16LocalAlarmReference) {,1
"            expert_add_info_format(pinfo, item, &ei_pn_io_localalarmref, ""AlarmCRBlockReq: local alarm ref changed from %u to %u!"", ar->controlleralarmref, u16LocalAlarmReference)_",1
        ar->controlleralarmref = u16LocalAlarmReference_,1
"        expert_add_info_format(pinfo, item, &ei_pn_io_ar_info_not_found, ""AlarmCRBlockReq: no corresponding AR found!"")_",1
/* dissect the AlarmCRBlockRes */,1
"dissect_AlarmCRBlockRes_block(tvbuff_t *tvb, int offset,",1
    guint16 u16AlarmCRType_,1
    guint16 u16LocalAlarmReference_,1
    guint16 u16MaxAlarmDataLength_,1
"    proto_item_append_text(item, "": %s, Ref:0x%04x, MaxDataLen:%u"",",1
"        u16LocalAlarmReference, u16MaxAlarmDataLength)_",1
        if (ar->devicealarmref != 0xffff && ar->devicealarmref != u16LocalAlarmReference) {,1
"            expert_add_info_format(pinfo, item, &ei_pn_io_localalarmref, ""AlarmCRBlockRes: local alarm ref changed from %u to %u!"", ar->devicealarmref, u16LocalAlarmReference)_",1
        ar->devicealarmref = u16LocalAlarmReference_,1
"        expert_add_info_format(pinfo, item, &ei_pn_io_ar_info_not_found, ""AlarmCRBlockRes: no corresponding AR found!"")_",1
/* dissect the ARServerBlock */,1
"dissect_ARServerBlock(tvbuff_t *tvb, int offset,",1
    char    *pStationName_,1
"    guint16  u16NameLength, u16padding_",1
    /* Padding to next 4 byte allignment in this block */,1
    u16padding = (u16NameLength-2) & 0x3_,1
    if (u16padding >0),1
"        offset = dissect_pn_padding(tvb, offset, pinfo, tree, u16padding)_",1
/* dissect the IOCRBlockRes */,1
"dissect_IOCRBlockRes_block(tvbuff_t *tvb, int offset,",1
    guint16 u16IOCRType_,1
    guint16 u16IOCRReference_,1
    guint16 u16FrameID_,1
"    proto_item_append_text(item, "": %s, Ref:0x%04x, FrameID:0x%04x"",",1
"        u16IOCRReference, u16FrameID)_",1
"                expert_add_info_format(pinfo, item, &ei_pn_io_frame_id, ""IOCRBlockRes: input frameID changed from %u to %u!"", ar->inputframeid, u16FrameID)_",1
"                expert_add_info_format(pinfo, item, &ei_pn_io_frame_id, ""IOCRBlockRes: output frameID changed from %u to %u!"", ar->outputframeid, u16FrameID)_",1
"            expert_add_info_format(pinfo, item, &ei_pn_io_iocr_type, ""IOCRBlockRes: IOCRType %u undecoded!"", u16IOCRType)_",1
"        expert_add_info_format(pinfo, item, &ei_pn_io_ar_info_not_found, ""IOCRBlockRes: no corresponding AR found!"")_",1
/* dissect the MCRBlockReq */,1
"dissect_MCRBlockReq_block(tvbuff_t *tvb, int offset,",1
    guint16  u16IOCRReference_,1
    guint32  u32AddressResolutionProperties_,1
    guint16  u16MCITimeoutFactor_,1
    guint16  u16NameLength_,1
"                        hf_pn_io_address_resolution_properties, &u32AddressResolutionProperties)_",1
"                        hf_pn_io_mci_timeout_factor, &u16MCITimeoutFactor)_",1
"    proto_tree_add_string (tree, hf_pn_io_provider_station_name, tvb, offset, u16NameLength, pStationName)_",1
"    proto_item_append_text(item, "", CRRef:%u, Properties:0x%x, TFactor:%u, Station:%s"",",1
"        u16IOCRReference, u32AddressResolutionProperties, u16MCITimeoutFactor, pStationName)_",1
/* dissect the SubFrameBlock */,1
"dissect_SubFrameBlock_block(tvbuff_t *tvb, int offset,",1
    guint32     u32SubFrameData_,1
    /* IOCRReference */,1
    /* CMInitiatorMACAdd */,1
    /* SubFrameData n*32 */,1
    u16BodyLength -= 10_,1
    u16Tmp = u16BodyLength_,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_subframe_data, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_subframe_data)_",1
        /* 31-16 reserved_2 */,1
"                            hf_pn_io_subframe_data_reserved2, &u32SubFrameData)_",1
        /* 15- 8 DataLength */,1
"                            hf_pn_io_subframe_data_length, &u32SubFrameData)_",1
        /*    7 reserved_1 */,1
"                            hf_pn_io_subframe_data_reserved1, &u32SubFrameData)_",1
        /*  6-0 Position */,1
"                            hf_pn_io_subframe_data_position, &u32SubFrameData)_",1
"        proto_item_append_text(sub_item, "", Length:%u, Pos:%u"",",1
"            (u32SubFrameData & 0x0000FF00) >> 8, u32SubFrameData & 0x0000007F)_",1
    } while (u16Tmp -= 4)_,1
"    proto_item_append_text(item, "", CRRef:%u, %u*Data"",",1
"        u16IOCRReference, u16BodyLength/4)_",1
/* dissect the (PD)SubFrameBlock  0x022B */,1
"dissect_PDSubFrameBlock_block(tvbuff_t *tvb, int offset,",1
    guint32 u32SFIOCRProperties_,1
    guint32 u32SubFrameData_,1
    guint16 u16RemainingLength_,1
    /* FrameID */,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_frame_id, &u16FrameID)_",1
    /* SFIOCRProperties */,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_SFIOCRProperties, tvb, offset, PD_SUB_FRAME_BLOCK_FIOCR_PROPERTIES_LENGTH, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_SFIOCRProperties)_",1
"    /*    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties, &u32SFIOCRProperties)_ */",1
    /* Bit 31: SFIOCRProperties.SFCRC16 */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties_SFCRC16, &u32SFIOCRProperties)_",1
    /* Bit 30: SFIOCRProperties.DFPRedundantPathLayout */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties_DFPRedundantPathLayout, &u32SFIOCRProperties)_",1
    /* Bit 29: SFIOCRProperties.DFPRedundantPathLayout */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties_DFPType, &u32SFIOCRProperties)_",1
    /* Bit 28 - 29: SFIOCRProperties.reserved_2 */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties_reserved_2, &u32SFIOCRProperties)_",1
    /* Bit 24 - 27: SFIOCRProperties.reserved_1 */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties_reserved_1, &u32SFIOCRProperties)_",1
    /* Bit 16 - 23: SFIOCRProperties.DFPmode */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_SFIOCRProperties_DFPmode, &u32SFIOCRProperties)_",1
    /*  Bit 8 - 15: SFIOCRProperties.RestartFactorForDistributedWD */,1
    /*      0x00           Mandatory    No restart delay necessary,1
            0x01 - 0x09    Optional    Less than 1 s restart delay,1
            0x0A - 0x50    Mandatory    1 s to 8 s restart delay,1
            0x51 - 0xFF    Optional    More than 8 s restart delay */,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_RestartFactorForDistributedWD, &u32SFIOCRProperties)_",1
    /*  bit 0..7 SFIOCRProperties.DistributedWatchDogFactor */,1
"    offset = /* it is the last one, so advance! */",1
"        dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_DistributedWatchDogFactor, &u32SFIOCRProperties)_",1
    /* SubframeData */,1
    u16RemainingLength = u16BodyLength - PD_SUB_FRAME_BLOCK_FIOCR_PROPERTIES_LENGTH - PD_SUB_FRAME_BLOCK_FRAME_ID_LENGTH_,1
    while (u16RemainingLength >= PD_SUB_FRAME_BLOCK_SUB_FRAME_DATA_LENGTH),1
"        guint8 Position,",1
               DataLength_,1
        /* Bit 0 - 6: SubframeData.Position */,1
"        dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_subframe_data_position, &u32SubFrameData)_",1
        /* Bit 7: SubframeData.reserved_1 */,1
"        dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_subframe_reserved1, &u32SubFrameData)_",1
        /* Bit 8 - 15: SubframeData.dataLength */,1
"        dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_subframe_data_length, &u32SubFrameData)_",1
        /* Bit 16 - 31: SubframeData.reserved_2 */,1
"            dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_subframe_reserved2, &u32SubFrameData)_",1
        Position  = (guint8) (u32SubFrameData & 0x7F)_       /* the lower 6 bits */,1
        DataLength =(guint8) ((u32SubFrameData >>8) & 0x0ff)_ /* bit 8 to 15 */,1
"        proto_item_append_text(sub_item, "", Length:%u (0x%x), Pos:%u"",",1
"            DataLength,DataLength, Position)_",1
        u16RemainingLength = u16RemainingLength - 4_,1
/* dissect the IRInfoBlock */,1
"dissect_IRInfoBlock_block(tvbuff_t *tvb, int offset,",1
    guint16 u16BodyLength _U_),1
    guint16  u16NumberOfIOCR_,1
    guint16  u16SubframeOffset_,1
    guint32  u32SubframeData_,1
    e_guid_t IRDataUUID_,1
"                        hf_pn_io_IRData_uuid, &IRDataUUID)_",1
    /* Numbers of IOCRs */,1
"                        hf_pn_io_number_of_iocrs, &u16NumberOfIOCR)_",1
    while (u16NumberOfIOCR--),1
    {   /* IOCRReference */,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_iocr_reference, &u16IOCRReference)_",1
        /* SubframeOffset 16 */,1
"        offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_iocr_SubframeOffset, &u16SubframeOffset)_",1
        /* SubframeData  32 */,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep, hf_pn_io_iocr_SubframeData, &u32SubframeData)_",1
/* dissect the SRInfoBlock */,1
"dissect_SRInfoBlock_block(tvbuff_t *tvb, int offset,",1
    guint16 u16RedundancyDataHoldFactor_,1
    guint32 u32sr_properties_,1
    guint8 u8SRPropertiesMode_,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_RedundancyDataHoldFactor, &u16RedundancyDataHoldFactor)_",1
"    u32sr_properties = tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN)_",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_sr_properties, tvb, offset, 4, ENC_BIG_ENDIAN)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_sr_properties)_",1
    u8SRPropertiesMode = (guint8)((u32sr_properties >> 2) & 0x01)_,1
    /* SRProperties.InputValidOnBackupAR with SRProperties.Mode == 1 */,1
    if (u8SRPropertiesMode),1
"            hf_pn_io_sr_properties_InputValidOnBackupAR_with_SRProperties_Mode_1, &u32sr_properties)_",1
    /* SRProperties.InputValidOnBackupAR with SRProperties.Mode == 0 */,1
"            hf_pn_io_sr_properties_InputValidOnBackupAR_with_SRProperties_Mode_0, &u32sr_properties)_",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_sr_properties_Reserved_1, &u32sr_properties)_",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_sr_properties_Mode, &u32sr_properties)_",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_sr_properties_Reserved_2, &u32sr_properties)_",1
"    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_sr_properties_Reserved_3, &u32sr_properties)_",1
/* dissect the RSInfoBlock */,1
"dissect_RSInfoBlock_block(tvbuff_t *tvb, int offset,",1
"    guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow, guint16 u16BodyLength _U_)",1
    guint32 u32RSProperties_,1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep, hf_pn_io_rs_properties, &u32RSProperties)_",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep, hf_pn_io_rs_properties_alarm_transport, &u32RSProperties)_",1
"    dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep, hf_pn_io_rs_properties_reserved1, &u32RSProperties)_",1
"    offset = dissect_dcerpc_uint32(tvb, offset, pinfo, tree, drep, hf_pn_io_rs_properties_reserved2, &u32RSProperties)_",1
/* dissect the PDIRSubframeData block  0x022a */,1
"dissect_PDIRSubframeData_block(tvbuff_t *tvb, int offset,",1
    guint16     u16NumberOfSubframeBlocks_,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_NumberOfSubframeBlocks, &u16NumberOfSubframeBlocks)_",1
    while (u16NumberOfSubframeBlocks --),1
    {   /* dissect the Subframe Block  */,1
"        offset = dissect_a_block(tvb, offset, pinfo, /*sub_*/tree, drep)_",1
"dissect_ARVendorBlockReq_block(tvbuff_t *tvb, int offset,",1
    guint16 APStructureIdentifier_,1
    guint32 gu32API_,1
    guint32 guDataBytes_,1
    APStructureIdentifier = ((drep[0] & DREP_LITTLE_ENDIAN),1
    gu32API = ((drep[0] & DREP_LITTLE_ENDIAN),1
"                ? tvb_get_letohl(tvb, offset + 2)",1
"                : tvb_get_ntohl (tvb, offset + 2))_",1
    if (tree),1
        if (gu32API == 0),1
            if (APStructureIdentifier <0x8000),1
"                proto_tree_add_item(tree, hf_pn_io_arvendor_strucidentifier_if0_low, tvb, offset, 2, DREP_ENC_INTEGER(drep))_",1
                if (APStructureIdentifier > 0x8000),1
"                    proto_tree_add_item(tree, hf_pn_io_arvendor_strucidentifier_if0_high, tvb, offset, 2, DREP_ENC_INTEGER(drep))_",1
                else /* APStructureIdentifier == 0x8000 */,1
"                    proto_tree_add_item(tree, hf_pn_io_arvendor_strucidentifier_if0_is8000, tvb, offset, 2, DREP_ENC_INTEGER(drep))_",1
"            proto_tree_add_item(tree, hf_pn_io_arvendor_strucidentifier_not0, tvb, offset, 2, DREP_ENC_INTEGER(drep))_",1
"        proto_tree_add_item(tree, hf_pn_io_api, tvb, offset + 2, 4, DREP_ENC_INTEGER(drep))_",1
    if (u16BodyLength < 6 ),1
        return offset_ /* there are no user bytes! */,1
    guDataBytes = u16BodyLength - 6_,1
"    dissect_pn_user_data(tvb, offset, pinfo, tree, guDataBytes, ""Data "")_",1
/* dissect the DataDescription */,1
"dissect_DataDescription(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, ioDataObject *tmp_io_data_object)",1
    guint16     u16DataDescription_,1
    guint16     u16SubmoduleDataLength_,1
    guint8      u8LengthIOCS_,1
    guint8      u8LengthIOPS_,1
    wmem_list_t       *ioobject_list_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_data_description_tree, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_data_description)_",1
    /* DataDescription */,1
"                    hf_pn_io_data_description, &u16DataDescription)_",1
    /* SubmoduleDataLength */,1
"                    hf_pn_io_submodule_data_length, &u16SubmoduleDataLength)_",1
"    offset = dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep,",1
"                    hf_pn_io_length_iocs, &u8LengthIOCS)_",1
"                    hf_pn_io_length_iops, &u8LengthIOPS)_",1
"    proto_item_append_text(sub_item, "": %s, SubmoduleDataLength: %u, LengthIOCS: %u, u8LengthIOPS: %u"",",1
"        val_to_str(u16DataDescription, pn_io_data_description, ""(0x%x)""),",1
"        u16SubmoduleDataLength, u8LengthIOCS, u8LengthIOPS)_",1
    /* Save new data for IO Data Objects */,1
        /* Get current conversation endpoints using MAC addresses */,1
"        conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
        if (conversation == NULL) {,1
"            conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
"        station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp)_",1
        if (station_info != NULL) {,1
            if (u16DataDescription == PN_INPUT_DATADESCRITPION) {,1
                /* INPUT HANDLING */,1
                ioobject_list = station_info->ioobject_data_in_,1
                /* OUTPUT HANDLING */,1
                ioobject_list = station_info->ioobject_data_out_,1
            for (frame = wmem_list_head(ioobject_list)_ frame != NULL_ frame = wmem_list_frame_next(frame)) {,1
                io_data_object = (ioDataObject*)wmem_list_frame_data(frame)_,1
                if (io_data_object->slotNr == tmp_io_data_object->slotNr && io_data_object->subSlotNr == tmp_io_data_object->subSlotNr) {,1
                    /* Write additional data from dissect_ExpectedSubmoduleBlockReq_block() to corresponding io_data_object */,1
                    io_data_object->moduleIdentNr = tmp_io_data_object->moduleIdentNr_,1
                    io_data_object->subModuleIdentNr = tmp_io_data_object->subModuleIdentNr_,1
                    io_data_object->length = u16SubmoduleDataLength_,1
"                    io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), tmp_io_data_object->moduleNameStr)_",1
                    io_data_object->profisafeSupported = tmp_io_data_object->profisafeSupported_,1
                    io_data_object->discardIOXS = tmp_io_data_object->discardIOXS_,1
                    io_data_object->amountInGSDML = tmp_io_data_object->amountInGSDML_,1
                    io_data_object->fParameterIndexNr = tmp_io_data_object->fParameterIndexNr_,1
/* dissect the ExpectedSubmoduleBlockReq */,1
"dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *tvb, int offset,",1
    guint16     u16ModuleProperties_,1
    guint16     u16SubmoduleProperties_,1
    proto_item *submodule_item_,1
    proto_tree *submodule_tree_,1
    /* Variable for the search of gsd file */,1
"    const char vendorIdStr[] = ""VendorID=\""""_",1
"    const char deviceIdStr[] = ""DeviceID=\""""_",1
"    const char moduleStr[] = ""ModuleIdentNumber=\""""_",1
"    const char subModuleStr[] = ""SubmoduleIdentNumber=\""""_",1
"    const char profisafeStr[] = ""PROFIsafeSupported=\""true\""""_",1
"    const char fParameterStr[] = ""<F_ParameterRecordDataItem""_",1
"    const char fParameterIndexStr[] = ""Index=""_",1
"    const char moduleNameInfo[] = ""<Name""_",1
"    const char moduleValueInfo[] = ""Value=\""""_",1
    guint16  searchVendorID = 0_,1
    guint16  searchDeviceID = 0_,1
    gboolean vendorMatch_,1
    gboolean deviceMatch_,1
    stationInfo    *station_info = NULL_,1
"    ioDataObject   *io_data_object = NULL_ /* Used to transfer data to fct. ""dissect_DataDescription()"" */",1
    /* Variable for the search of GSD-file */,1
    guint32  read_vendor_id_,1
    guint32  read_device_id_,1
    guint32  read_module_id_,1
    guint32  read_submodule_id_,1
    gboolean gsdmlFoundFlag_,1
    gchar   tmp_moduletext[MAX_NAMELENGTH]_,1
    gchar   *convertStr_      /* GSD-file search */,1
"    gchar   *pch_             /* helppointer, to save temp. the found Networkpath of GSD-file */",1
    gchar   *puffer_          /* used for fgets() during GSD-file search */,1
    gchar   *temp_            /* used for fgets() during GSD-file search */,1
    gchar   *diropen = NULL_  /* saves the final networkpath to open for GSD-files */,1
    GDir    *dir_,1
    FILE    *fp = NULL_       /* filepointer */,1
    const gchar *filename_    /* saves the found GSD-file name */,1
    /* Helppointer initial */,1
"    convertStr = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_NAMELENGTH)_",1
    convertStr[0] = '\0'_,1
"    pch = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH)_",1
    pch[0] = '\0'_,1
"    puffer = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH)_",1
    puffer[0] = '\0'_,1
"    temp = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH)_",1
    temp[0] = '\0'_,1
    /* Initial */,1
"    io_data_object = wmem_new0(wmem_file_scope(), ioDataObject)_",1
    io_data_object->profisafeSupported = FALSE_,1
"    io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown"")_",1
    vendorMatch = FALSE_,1
    deviceMatch = FALSE_,1
    gsdmlFoundFlag = FALSE_,1
    /* Get current conversation endpoints using MAC addresses */,1
"    conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
"        conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
"    station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp)_",1
    if (station_info != NULL) {,1
        station_info->gsdFound = FALSE_,1
        station_info->gsdPathLength = FALSE_,1
        /* Set searchVendorID and searchDeviceID for GSDfile search */,1
        searchVendorID = station_info->u16Vendor_id_,1
        searchDeviceID = station_info->u16Device_id_,1
        /* Use the given GSD-file networkpath of the PNIO-Preference */,1
        if(pnio_ps_networkpath[0] != '\0') {   /* check the length of the given networkpath (array overflow protection) */,1
            station_info->gsdPathLength = TRUE_,1
"            if ((dir = g_dir_open(pnio_ps_networkpath, 0, NULL)) != NULL) {",1
                /* Find all GSD-files within directory */,1
                while ((filename = g_dir_read_name(dir)) != NULL) {,1
                    /* ---- complete the path to open a GSD-file ---- */,1
"                    diropen = wmem_strdup_printf(wmem_packet_scope(), ""%s"" G_DIR_SEPARATOR_S ""%s"", pnio_ps_networkpath, filename)_",1
                    /* ---- Open the found GSD-file  ---- */,1
"                    fp = ws_fopen(diropen, ""r"")_",1
                    if(fp != NULL) {,1
                        /* ---- Get VendorID & DeviceID ---- */,1
"                        while(pn_fgets(puffer, MAX_LINE_LENGTH, fp) != NULL) {",1
                            /* ----- VendorID ------ */,1
"                            if((strstr(puffer, vendorIdStr)) != NULL) {",1
"                                memset (convertStr, 0, sizeof(*convertStr))_",1
"                                pch = strstr(puffer, vendorIdStr)_",1
"                                if (pch!= NULL && sscanf(pch, ""VendorID=\""%[^\""]"", convertStr) == 1) {",1
"                                    read_vendor_id = (guint32) strtoul (convertStr, NULL, 0)_",1
                                    if(read_vendor_id == searchVendorID) {,1
                                        vendorMatch = TRUE_        /* found correct VendorID */,1
                                    },1
                                },1
                            },1
                            /* ----- DeviceID ------ */,1
"                            if((strstr(puffer, deviceIdStr)) != NULL) {",1
"                                memset(convertStr, 0, sizeof(*convertStr))_",1
"                                pch = strstr(puffer, deviceIdStr)_",1
"                                if (pch != NULL && sscanf(pch, ""DeviceID=\""%[^\""]"", convertStr) == 1) {",1
"                                    read_device_id = (guint32)strtoul(convertStr, NULL, 0)_",1
                                    if(read_device_id == searchDeviceID) {,1
                                        deviceMatch = TRUE_        /* found correct DeviceID */,1
                        fclose(fp)_,1
                        fp = NULL_,1
                        if(vendorMatch && deviceMatch) {,1
                            break_        /* Found correct GSD-file! -> Break the searchloop */,1
                        else {,1
                            /* Couldn't find the correct GSD-file to the corresponding device */,1
                            vendorMatch = FALSE_,1
                            deviceMatch = FALSE_,1
                            gsdmlFoundFlag = FALSE_,1
"                            diropen = """"_           /* reset array for next search */",1
                g_dir_close(dir)_,1
            /* ---- Found the correct GSD-file -> set Flag and save the completed path ---- */,1
            if(vendorMatch && deviceMatch) {,1
                gsdmlFoundFlag = TRUE_,1
                station_info->gsdFound = TRUE_,1
"                station_info->gsdLocation = wmem_strdup(wmem_file_scope(), diropen)_",1
                /* Copy searchpath to array for a detailed output message in cyclic data dissection */,1
"                station_info->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" G_DIR_SEPARATOR_S ""*.xml"", pnio_ps_networkpath)_",1
        else {,1
            /* will be used later on in cyclic RTC1 data dissection for detailed output message */,1
            station_info->gsdPathLength = FALSE_,1
        /* ModuleIdentNumber */,1
        /* ModuleProperties */,1
"                            hf_pn_io_module_properties, &u16ModuleProperties)_",1
        /* NumberOfSubmodules */,1
"        proto_item_append_text(api_item, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"",",1
"            u32Api, u16SlotNr, u32ModuleIdentNumber, u16ModuleProperties, u16NumberOfSubmodules)_",1
"        proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules)_",1
        while (u16NumberOfSubmodules--) {,1
"            sub_item = proto_tree_add_item(api_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA)_",1
"            sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule)_",1
            /* SubmoduleIdentNumber */,1
"            offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,",1
"                            hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber)_",1
            /* SubmoduleProperties */,1
"            submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_properties, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"            submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_properties)_",1
"            dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,",1
"                            hf_pn_io_submodule_properties_reserved, &u16SubmoduleProperties)_",1
"                            hf_pn_io_submodule_properties_discard_ioxs, &u16SubmoduleProperties)_",1
"                            hf_pn_io_submodule_properties_reduce_output_submodule_data_length, &u16SubmoduleProperties)_",1
"                            hf_pn_io_submodule_properties_reduce_input_submodule_data_length, &u16SubmoduleProperties)_",1
"                            hf_pn_io_submodule_properties_shared_input, &u16SubmoduleProperties)_",1
"            offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,",1
"                            hf_pn_io_submodule_properties_type, &u16SubmoduleProperties)_",1
            io_data_object->slotNr = u16SlotNr_,1
            io_data_object->subSlotNr = u16SubslotNr_,1
            io_data_object->moduleIdentNr = u32ModuleIdentNumber_,1
            io_data_object->subModuleIdentNr = u32SubmoduleIdentNumber_,1
            io_data_object->discardIOXS = u16SubmoduleProperties & 0x0020_,1
"            /* Search the moduleID and subModuleID, find if PROFIsafe and also search for F-Par. Indexnumber",1
             * ---------------------------------------------------------------------------------------------,1
             * Speical case: Module has several ModuleIdentNr. in one GSD-file,1
"             * Also with the given parameters of wireshark, some modules were completely equal. For this",1
"             * special case a compromise for this problem has been made, to set the module name will",1
             * be more generally displayed.,1
"             * Also this searchloop will find the F-Parameter Indexnumber, so that Wireshark is able to",1
"             * dissect those F-Parameters correctly, as this index can change between the vendors.",1
             */,1
            io_data_object->amountInGSDML = 0_,1
            io_data_object->fParameterIndexNr = 0_,1
            io_data_object->profisafeSupported = FALSE_,1
            if (diropen != NULL) {,1
"                fp = ws_fopen(diropen, ""r"")_",1
                fp = NULL_,1
            if(fp != NULL && gsdmlFoundFlag) {,1
"                fseek(fp, 0, SEEK_SET)_",1
                /* Find Indexnumber for fParameter */,1
"                while(pn_fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {",1
"                    if((strstr(temp, fParameterStr)) != NULL) {",1
"                        memset (convertStr, 0, sizeof(*convertStr))_",1
"                        pch = strstr(temp, fParameterIndexStr)_",1
"                        if (pch != NULL && sscanf(pch, ""Index=\""%[^\""]"", convertStr) == 1) {",1
"                            io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0)_",1
                        break_    /* found Indexnumber -> break search loop */,1
"                memset (temp, 0, sizeof(*temp))_",1
"                fseek(fp, 0, SEEK_SET)_                /* Set filepointer to the beginning */",1
"                    if((strstr(temp, moduleStr)) != NULL) {                         /* find the String ""ModuleIdentNumber="" */",1
"                        pch = strstr(temp, moduleStr)_                              /* search for ""ModuleIdentNumber=\"""" within GSD-file */",1
"                        if (pch != NULL && sscanf(pch, ""ModuleIdentNumber=\""%[^\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */",1
"                            read_module_id = (guint32)strtoul(convertStr, NULL, 0)_     /* Change numeric string --> unsigned long_ read_module_id contains the Value of the ModuleIdentNumber */",1
"                            /* If the found ModuleID matches with the wanted ModuleID, search for the Submodule and break */",1
                            if (read_module_id == io_data_object->moduleIdentNr) {,1
                                ++io_data_object->amountInGSDML_    /* Save the amount of same (!) Module- & SubmoduleIdentNr in one GSD-file */,1
"                                while(pn_fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {",1
"                                    if((strstr(temp, moduleNameInfo)) != NULL) {                    /* find the String ""<Name"" for the TextID */",1
                                        long filePosRecord_,1
"                                        if (sscanf(temp, ""%*s TextId=\""%[^\""]"", tmp_moduletext) != 1)        /* saves the correct TextId for the next searchloop */",1
                                            break_,1
                                        filePosRecord = ftell(fp)_            /* save the current position of the filepointer (Offset) */,1
"                                        /* ftell() may return -1 for error, don't move fp in this case */",1
                                        if (filePosRecord >= 0) {,1
"                                            while (pn_fgets(temp, MAX_LINE_LENGTH, fp) != NULL && io_data_object->amountInGSDML == 1) {",1
                                                /* Find a String with the saved TextID and with a fitting value for it in the same line. This value is the name of the Module! */,1
"                                                if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) {",1
"                                                    pch = strstr(temp, moduleValueInfo)_",1
"                                                    if (pch != NULL && sscanf(pch, ""Value=\""%[^\""]"", io_data_object->moduleNameStr) == 1)",1
                                                        break_    /* Found the name of the module */,1
                                                },1
                                            },1
"                                            fseek(fp, filePosRecord, SEEK_SET)_    /* set filepointer to the correct TextID */",1
                                        },1
                                    /* Search for Submoduleidentnumber in GSD-file */,1
"                                    if((strstr(temp, subModuleStr)) != NULL) {",1
"                                        memset (convertStr, 0, sizeof(*convertStr))_",1
"                                        pch = strstr(temp, subModuleStr)_",1
"                                        if (pch != NULL && sscanf(pch, ""SubmoduleIdentNumber=\""%[^\""]"", convertStr) == 1) {",1
"                                            read_submodule_id = (guint32) strtoul (convertStr, NULL, 0)_    /* read_submodule_id contains the Value of the SubModuleIdentNumber */",1
"                                            /* Find ""PROFIsafeSupported"" flag of the module in GSD-file */",1
                                            if(read_submodule_id == io_data_object->subModuleIdentNr) {,1
"                                                if((strstr(temp, profisafeStr)) != NULL) {",1
                                                    io_data_object->profisafeSupported = TRUE_   /* flag is in the same line as SubmoduleIdentNr */,1
                                                    break_,1
                                                else {    /* flag is not in the same line as Submoduleidentnumber -> search for it */,1
"                                                    while(pn_fgets(temp, MAX_LINE_LENGTH, fp) != NULL) {",1
"                                                        if((strstr(temp, profisafeStr)) != NULL) {",1
                                                            io_data_object->profisafeSupported = TRUE_,1
                                                            break_    /* Found the PROFIsafeSupported flag of the module */,1
                                                        },1
"                                                        else if((strstr(temp, "">"")) != NULL) {",1
                                                            break_,1
                                                    },1
                                            break_    /* Found the PROFIsafe Module */,1
                fclose(fp)_,1
            switch (u16SubmoduleProperties & 0x03) {,1
            case(0x00): /* no input and no output data (one Input DataDescription Block follows) */,1
"                offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object)_",1
            case(0x01): /* input data (one Input DataDescription Block follows) */,1
            case(0x02): /* output data (one Output DataDescription Block follows) */,1
            case(0x03): /* input and output data (one Input and one Output DataDescription Block follows) */,1
            default: /* will not execute because of the line preceding the switch */,1
"            proto_item_append_text(sub_item, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"",",1
"                u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleProperties)_",1
/* dissect the ModuleDiffBlock */,1
"dissect_ModuleDiffBlock_block(tvbuff_t *tvb, int offset,",1
    guint16     u16ModuleState_,1
    guint16     u16SubmoduleState_,1
    stationInfo       *station_info_,1
    moduleDiffInfo    *module_diff_info_,1
    moduleDiffInfo    *cmp_module_diff_info_,1
"                            hf_pn_io_number_of_modules, &u16NumberOfModules)_",1
"        proto_item_append_text(api_item, "": %u, Modules: %u"",",1
"            u32Api, u16NumberOfModules)_",1
"        proto_item_append_text(item, "", Modules:%u"", u16NumberOfModules)_",1
"            module_item = proto_tree_add_item(api_tree, hf_pn_io_module_tree, tvb, offset, 0, ENC_NA)_",1
            /* ModuleState */,1
"                                hf_pn_io_module_state, &u16ModuleState)_",1
"                                hf_pn_io_number_of_submodules, &u16NumberOfSubmodules)_",1
"            proto_item_append_text(module_item, "": Slot 0x%x, Ident: 0x%x State: %s Submodules: %u"",",1
"                u16SlotNr, u32ModuleIdentNumber,",1
"                val_to_str(u16ModuleState, pn_io_module_state, ""(0x%x)""),",1
                u16NumberOfSubmodules)_,1
                /* Get current conversation endpoints using MAC addresses */,1
"                conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
                if (conversation == NULL) {,1
"                    conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0)_",1
"                station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp)_",1
                    for (frame = wmem_list_head(station_info->diff_module)_ frame != NULL_ frame = wmem_list_frame_next(frame)) {,1
                        cmp_module_diff_info = (moduleDiffInfo*)wmem_list_frame_data(frame)_,1
                        if (cmp_module_diff_info->slotNr == u16SlotNr) {,1
                        /* new diffModuleInfo data incoming */,1
"                        module_diff_info = wmem_new(wmem_file_scope(), moduleDiffInfo)_",1
                        module_diff_info->slotNr = u16SlotNr_,1
                        module_diff_info->modulID = u32ModuleIdentNumber_,1
"                        wmem_list_append(station_info->diff_module, module_diff_info)_",1
"            proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules)_",1
"                sub_item = proto_tree_add_item(module_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA)_",1
"                sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule)_",1
                u32SubStart = offset_,1
                /* Subslotnumber */,1
"                offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep,",1
"                offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep,",1
                /* SubmoduleState */,1
"                submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_state, tvb, offset, 2, ENC_BIG_ENDIAN)_",1
"                submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_state)_",1
"                dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,",1
"                                hf_pn_io_submodule_state_format_indicator, &u16SubmoduleState)_",1
                if (u16SubmoduleState & 0x8000) {,1
"                    dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,",1
"                                    hf_pn_io_submodule_state_ident_info, &u16SubmoduleState)_",1
"                                    hf_pn_io_submodule_state_ar_info, &u16SubmoduleState)_",1
"                                    hf_pn_io_submodule_state_diag_info, &u16SubmoduleState)_",1
"                                    hf_pn_io_submodule_state_maintenance_demanded, &u16SubmoduleState)_",1
"                                    hf_pn_io_submodule_state_maintenance_required, &u16SubmoduleState)_",1
"                                    hf_pn_io_submodule_state_qualified_info, &u16SubmoduleState)_",1
"                    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep,",1
"                                    hf_pn_io_submodule_state_add_info, &u16SubmoduleState)_",1
"                                    hf_pn_io_submodule_state_detail, &u16SubmoduleState)_",1
"                proto_item_append_text(sub_item, "": Subslot 0x%x, IdentNumber: 0x%x, State: 0x%x"",",1
"                    u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleState)_",1
"                proto_item_set_len(sub_item, offset - u32SubStart)_",1
            } /* NumberOfSubmodules */,1
"            proto_item_set_len(module_item, offset - u32ModuleStart)_",1
/* dissect the IsochronousModeData block */,1
"dissect_IsochronousModeData_block(tvbuff_t *tvb, int offset,",1
    guint16 u16ControllerApplicationCycleFactor_,1
    guint16 u16TimeDataCycle_,1
    guint32 u32TimeIOInput_,1
    guint32 u32TimeIOOutput_,1
    guint32 u32TimeIOInputValid_,1
    guint32 u32TimeIOOutputValid_,1
    /* ControllerApplicationCycleFactor */,1
"                        hf_pn_io_controller_appl_cycle_factor, &u16ControllerApplicationCycleFactor)_",1
    /* TimeDataCycle */,1
"                        hf_pn_io_time_data_cycle, &u16TimeDataCycle)_",1
    /* TimeIOInput (ns) */,1
"                        hf_pn_io_time_io_input, &u32TimeIOInput)_",1
    /* TimeIOOutput (ns) */,1
"                        hf_pn_io_time_io_output, &u32TimeIOOutput)_",1
    /* TimeIOInputValid (ns) */,1
"                        hf_pn_io_time_io_input_valid, &u32TimeIOInputValid)_",1
    /* TimeIOOutputValid (ns) */,1
"                        hf_pn_io_time_io_output_valid, &u32TimeIOOutputValid)_",1
    return offset+1_,1
/* dissect the MultipleBlockHeader block */,1
"dissect_MultipleBlockHeader_block(tvbuff_t *tvb, int offset,",1
    guint32   u32Api_,1
"                    hf_pn_io_api, &u32Api)_",1
"    proto_item_append_text(item, "": Api:0x%x Slot:%u Subslot:0x%x"",",1
"    new_tvb = tvb_new_subset_length(tvb, offset, u16BodyLength-10)_",1
"    offset = dissect_blocks(new_tvb, 0, pinfo, tree, drep)_",1
    /*offset += u16BodyLength_*/,1
/* dissect Combined Object Container Content block */,1
"dissect_COContainerContent_block(tvbuff_t *tvb, int offset,",1
"    guint16 u16Index, guint32 *u32RecDataLen, pnio_ar_t **ar)",1
    guint32    u32Api_,1
    if(u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) {,1
"        hf_pn_io_index, &u16Index)_",1
"    proto_item_append_text(item, "": Api:0x%x Slot:%u Subslot:0x%x Index:0x%x"",",1
"        u32Api, u16SlotNr, u16SubslotNr, u16Index)_",1
    if(u16Index != 0x80B0) {,1
"        offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, u32RecDataLen, ar)_",1
static const gchar *,1
indexReservedForProfiles(guint16 u16Index),1
"    /* ""reserved for profiles"" */",1
    if (u16Index >= 0xb000 && u16Index <= 0xbfff) {,1
"        return ""Reserved for Profiles (subslot specific)""_",1
    if (u16Index >= 0xd000 && u16Index <= 0xdfff) {,1
"        return ""Reserved for Profiles (slot specific)""_",1
    if (u16Index >= 0xec00 && u16Index <= 0xefff) {,1
"        return ""Reserved for Profiles (AR specific)""_",1
    if (u16Index >= 0xf400 && u16Index <= 0xf7ff) {,1
"        return ""Reserved for Profiles (API specific)""_",1
    if (u16Index >= 0xfc00 /* up to 0xffff */) {,1
"        return ""Reserved for Profiles (device specific)""_",1
/* dissect the RecordDataReadQuery block */,1
"dissect_RecordDataReadQuery_block(tvbuff_t *tvb, int offset,",1
"    guint16 u16Index, guint16 u16BodyLength)",1
    const gchar *userProfile_,1
    /* user specified format? */,1
    if (u16Index < 0x8000) {,1
"        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, u16BodyLength, ""User Specified Data"")_",1
"    /* ""reserved for profiles""? */",1
    userProfile = indexReservedForProfiles(u16Index)_,1
    if (userProfile != NULL) {,1
"        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, u16BodyLength, userProfile)_",1
"    return dissect_pn_undecoded(tvb, offset, pinfo, tree, u16BodyLength)_",1
/* dissect the RS_GetEvent block */,1
"dissect_RS_GetEvent_block(tvbuff_t *tvb, int offset,",1
"    guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow)",1
"    offset = dissect_RS_EventInfo(tvb, offset, pinfo, tree, drep)_",1
/* dissect the RS_AdjustControl */,1
"dissect_RS_AdjustControl(tvbuff_t *tvb, int offset,",1
    guint16 u16SoEMaxScanDelay_,1
    guint8 u8SoEAdjustSpecifierReserved_,1
    guint8 u8SoEAdjustSpecifierIndicent_,1
    case(0xc010): /* SoE_DigitalInputObserver */,1
        /* ChannelNumber */,1
"            hf_pn_io_channel_number, &u16ChannelNumber)_",1
        /* SoE_MaxScanDelay */,1
"            hf_pn_io_soe_max_scan_delay, &u16SoEMaxScanDelay)_",1
        /* SoE_AdjustSpecifier */,1
"        sub_item = proto_tree_add_item(tree, hf_pn_io_soe_adjust_specifier, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_soe_adjust_specifier)_",1
"            hf_pn_io_soe_adjust_specifier_reserved, &u8SoEAdjustSpecifierReserved)_",1
"            hf_pn_io_soe_adjust_specifier_incident, &u8SoEAdjustSpecifierIndicent)_",1
        /* Padding 2 + 2 + 1 = 5 */,1
        /* Therefore we need 3 byte padding to make the block u32 aligned */,1
"        offset = dissect_pn_padding(tvb, offset, pinfo, tree, 3)_",1
"        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, *u16RSBodyLength, ""UserData"")_",1
/* dissect the RS_AdjustBlock */,1
"dissect_RS_AdjustBlock(tvbuff_t *tvb, int offset,",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_rs_adjust_block, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_adjust_block)_",1
    /* RS_AdjustControl */,1
"    offset = dissect_RS_AdjustControl(tvb, offset, pinfo, sub_tree, drep,",1
/* dissect the RS_AdjustInfo */,1
"dissect_RS_AdjustInfo(tvbuff_t *tvb, int offset,",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_rs_adjust_info, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_rs_adjust_info)_",1
"        offset = dissect_RS_AdjustBlock(tvb, offset, pinfo, sub_tree, drep)_",1
/* dissect the RS_AdjustObserver block */,1
"dissect_RS_AdjustObserver_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_RS_AdjustInfo(tvb, offset, pinfo, tree, drep)_",1
"dissect_RS_AckInfo(tvbuff_t *tvb, int offset,",1
    guint16 u16RSSpecifierSequenceNumber_,1
/* dissect the RS_AckEvent block */,1
"dissect_RS_AckEvent_block(tvbuff_t *tvb, int offset,",1
"    offset = dissect_RS_AckInfo(tvb, offset, pinfo, tree, drep)_",1
/* dissect one PN-IO block (depending on the block type) */,1
"dissect_block(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, guint16 *u16Index, guint32 *u32RecDataLen, pnio_ar_t **ar)",1
    guint16     u16BlockType_,1
    guint16     u16BlockLength_,1
    guint8      u8BlockVersionHigh_,1
    guint8      u8BlockVersionLow_,1
    guint16     u16BodyLength_,1
    proto_item *header_item_,1
    proto_tree *header_tree_,1
    gint        remainingBytes_,1
"    /* from here, we only have big endian (network byte ordering)!!! */",1
    drep[0] &= ~DREP_LITTLE_ENDIAN_,1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_block, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_block)_",1
"    header_item = proto_tree_add_item(sub_tree, hf_pn_io_block_header, tvb, offset, 6, ENC_NA)_",1
"    header_tree = proto_item_add_subtree(header_item, ett_pn_io_block_header)_",1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, header_tree, drep,",1
"                        hf_pn_io_block_type, &u16BlockType)_",1
"                        hf_pn_io_block_length, &u16BlockLength)_",1
"    offset = dissect_dcerpc_uint8(tvb, offset, pinfo, header_tree, drep,",1
"                        hf_pn_io_block_version_high, &u8BlockVersionHigh)_",1
"                        hf_pn_io_block_version_low, &u8BlockVersionLow)_",1
"    proto_item_append_text(header_item, "": Type=%s, Length=%u(+4), Version=%u.%u"",",1
"        val_to_str(u16BlockType, pn_io_block_type, ""Unknown (0x%04x)""),",1
"        u16BlockLength, u8BlockVersionHigh, u8BlockVersionLow)_",1
"    proto_item_set_text(sub_item, ""%s"",",1
"        val_to_str(u16BlockType, pn_io_block_type, ""Unknown (0x%04x)""))_",1
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"",",1
"        val_to_str(u16BlockType, pn_io_block_type, ""Unknown""))_",1
"    /* block length is without type and length fields, but with version field */",1
    u16BodyLength = u16BlockLength - 2_,1
"    remainingBytes = tvb_reported_length_remaining(tvb, offset)_",1
    if (remainingBytes < 0),1
        remainingBytes = 0_,1
    if (remainingBytes +2 < u16BodyLength),1
"        proto_item_append_text(sub_item, "" Block_Length: %d greater than remaining Bytes, trying with Blocklen = remaining (%d)"", u16BodyLength, remainingBytes)_",1
        u16BodyLength = remainingBytes_,1
    switch (u16BlockType) {,1
    case(0x0001):,1
    case(0x0002):,1
"        dissect_AlarmNotification_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
            u16BodyLength)_,1
    case(0x0008):,1
"        dissect_IODWriteReqHeader_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
"            u16Index, u32RecDataLen, ar)_",1
    case(0x0009):,1
"        dissect_IODReadReqHeader_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0010):,1
"        dissect_DiagnosisData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0012):   /* ExpectedIdentificationData */,1
    case(0x0013):   /* RealIdentificationData */,1
"        dissect_IdentificationData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0014):,1
"        dissect_SubstituteValue_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0015):,1
"        dissect_RecordInputDataObjectElement_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0016):,1
"        dissect_RecordOutputDataObjectElement_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    /*   0x0017 reserved */,1
    case(0x0018):,1
"        dissect_ARData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0019):,1
"        dissect_LogData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x001A):,1
"        dissect_APIData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x001B):,1
"        dissect_SRLData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0020):,1
"        dissect_IandM0_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0021):,1
"        dissect_IandM1_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0022):,1
"        dissect_IandM2_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0023):,1
"        dissect_IandM3_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0024):,1
"        dissect_IandM4_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0025):,1
"        dissect_IandM5_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh,u8BlockVersionLow)_",1
    case(0x0030):,1
"        dissect_IandM0FilterData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0031):,1
    case(0x0032):,1
    case(0x0034):,1
"        dissect_IandM5Data_block(tvb, offset, pinfo, sub_tree, sub_item, drep)_",1
    case(0x0035):,1
"        dissect_AssetManagementData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0036):,1
"        dissect_AM_FullInformation_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0037):,1
"        dissect_AM_HardwareOnlyInformation_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0038):,1
"        dissect_AM_FirmwareOnlyInformation_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0101):,1
"        dissect_ARBlockReq_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
            ar)_,1
    case(0x0102):,1
"        dissect_IOCRBlockReq_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
            *ar)_,1
    case(0x0103):,1
"        dissect_AlarmCRBlockReq_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0104):,1
"        dissect_ExpectedSubmoduleBlockReq_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0106):,1
"        dissect_MCRBlockReq_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0107):,1
"        dissect_SubFrameBlock_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0108):,1
    case(0x8108):,1
"        dissect_ARVendorBlockReq_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0109):,1
"        dissect_IRInfoBlock_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x010A):,1
"        dissect_SRInfoBlock_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x010C):,1
"        dissect_RSInfoBlock_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0110):,1
    case(0x0111):,1
    case(0x0112):,1
    case(0x0113):,1
    case(0x0114):,1
    case(0x0116):,1
    case(0x0117):,1
"        dissect_ControlConnect_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, ar)_",1
    case(0x0118):,1
"        dissect_ControlBlockPrmBegin(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength, ar)_",1
    case(0x0119):,1
"        dissect_SubmoduleListBlock(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength, ar)_",1
    case(0x0200): /* PDPortDataCheck */,1
"        dissect_PDPortData_Check_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0201):,1
"        dissect_PDevData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0202): /*dissect_PDPortData_Adjust_block */,1
"        dissect_PDPortData_Adjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0203):,1
"        dissect_PDSyncData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0204):,1
"        dissect_IsochronousModeData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0205):,1
"        dissect_PDIRData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0206):,1
"        dissect_PDIRGlobalData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0207):,1
"        dissect_PDIRFrameData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0208):,1
"        dissect_PDIRBeginEndData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x0209):,1
"        dissect_AdjustDomainBoundary_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x020A):,1
"        dissect_CheckPeers_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x020B):,1
"        dissect_CheckLineDelay_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x020C):,1
"        dissect_CheckMAUType_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x020E):,1
"        dissect_AdjustMAUType_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x020F):,1
"        dissect_PDPortDataReal_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0210):,1
"        dissect_AdjustMulticastBoundary_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0211):,1
"        dissect_PDInterfaceMrpDataAdjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0212):,1
"        dissect_PDInterfaceMrpDataReal_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0213):,1
"        dissect_PDInterfaceMrpDataCheck_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0214):,1
    case(0x0215):,1
"        dissect_PDPortMrpData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0216):,1
"        dissect_MrpManagerParams_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0217):,1
"        dissect_MrpClientParams_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0218):,1
"        dissect_MrpRTModeManagerData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0219):,1
"        dissect_MrpRingStateData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x021A):,1
"        dissect_MrpRTStateData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x021B):,1
"        dissect_AdjustPortState_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x021C):,1
"        dissect_CheckPortState_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x021D):,1
"        dissect_MrpRTModeClientData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x021E):,1
"        dissect_CheckSyncDifference_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x021F):,1
"        dissect_CheckMAUTypeDifference_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0220):,1
"        dissect_PDPortFODataReal_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0221):,1
"        dissect_FiberOpticManufacturerSpecific_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0222):,1
"        dissect_PDPortFODataAdjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0223):,1
"        dissect_PDPortFODataCheck_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0226):,1
"        dissect_AdjustPreambleLength_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0228):,1
"        dissect_FiberOpticDiagnosisInfo_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x022A):,1
"        dissect_PDIRSubframeData_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x022B):,1
"        dissect_PDSubFrameBlock_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0230):,1
    case(0x0231):,1
"        dissect_MrpInstanceDataAdjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0232):,1
"        dissect_MrpInstanceDataReal_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0233):,1
"        dissect_MrpInstanceDataCheck_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0240):,1
"        dissect_PDInterfaceDataReal_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0250):,1
"        dissect_PDInterfaceAdjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0251):,1
"        dissect_PDPortStatistic_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0400):,1
"        dissect_MultipleBlockHeader_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0401):,1
"        dissect_COContainerContent_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, *u16Index, u32RecDataLen, ar)_",1
    case(0x0500):,1
"        dissect_RecordDataReadQuery_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, *u16Index, u16BodyLength)_",1
    case(0x0600):,1
"        dissect_FSHello_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0601):,1
"        dissect_FSParameter_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0608):,1
"        dissect_PDInterfaceFSUDataAdjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x010B):,1
    case(0x0609):,1
"        dissect_ARFSUDataAdjust_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, u16BodyLength)_",1
    case(0x0900):,1
"        dissect_RS_AdjustObserver_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0901):,1
"        dissect_RS_GetEvent_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0902):,1
"        dissect_RS_AckEvent_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x0f00) :,1
"        dissect_Maintenance_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x8001):,1
    case(0x8002):,1
"        dissect_Alarm_ack_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x8008):,1
"        dissect_IODWriteResHeader_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x8009):,1
"        dissect_IODReadResHeader_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow,",1
    case(0x8101):,1
"        dissect_ARBlockRes_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, ar)_",1
    case(0x8102):,1
"        dissect_IOCRBlockRes_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, *ar)_",1
    case(0x8103):,1
"        dissect_AlarmCRBlockRes_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow, *ar)_",1
    case(0x8104):,1
"        dissect_ModuleDiffBlock_block(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x8106):,1
"        dissect_ARServerBlock(tvb, offset, pinfo, sub_tree, sub_item, drep, u8BlockVersionHigh, u8BlockVersionLow)_",1
    case(0x8110):,1
    case(0x8111):,1
    case(0x8112):,1
    case(0x8113):,1
    case(0x8114):,1
    case(0x8116):,1
    case(0x8117):,1
    case(0x8118):,1
"        dissect_pn_undecoded(tvb, offset, pinfo, sub_tree, u16BodyLength)_",1
/* dissect any PN-IO block */,1
"dissect_a_block(tvbuff_t *tvb, int offset,",1
"        pnio_ar_info(tvb, pinfo, tree, ar)_",1
/* dissect any number of PN-IO blocks */,1
"dissect_blocks(tvbuff_t *tvb, int offset,",1
    while (tvb_captured_length(tvb) > (guint) offset) {,1
        u16Index++_,1
/* dissect a PN-IO (DCE-RPC) request header */,1
"dissect_IPNIO_rqst_header(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep)",1
    guint32     u32ArgsMax_,1
    guint32     u32ArgsLen_,1
    guint32     u32MaxCount_,1
    guint32     u32Offset_,1
    guint32     u32ArraySize_,1
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO-CM"")_",1
    /* args_max */,1
"    offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,",1
"                        hf_pn_io_args_max, &u32ArgsMax)_",1
    /* args_len */,1
"                        hf_pn_io_args_len, &u32ArgsLen)_",1
"    sub_item = proto_tree_add_item(tree, hf_pn_io_array, tvb, offset, 0, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io)_",1
    /* RPC array header */,1
"    offset = dissect_ndr_uint32(tvb, offset, pinfo, sub_tree, di, drep,",1
"                        hf_pn_io_array_max_count, &u32MaxCount)_",1
"                        hf_pn_io_array_offset, &u32Offset)_",1
"                        hf_pn_io_array_act_count, &u32ArraySize)_",1
"    proto_item_append_text(sub_item, "": Max: %u, Offset: %u, Size: %u"",",1
"        u32MaxCount, u32Offset, u32ArraySize)_",1
/* dissect a PN-IO (DCE-RPC) response header */,1
"dissect_IPNIO_resp_header(tvbuff_t *tvb, int offset,",1
/* dissect a PN-IO request */,1
"dissect_IPNIO_rqst(tvbuff_t *tvb, int offset,",1
"    offset = dissect_IPNIO_rqst_header(tvb, offset, pinfo, tree, di, drep)_",1
/* dissect a PN-IO response */,1
"dissect_IPNIO_resp(tvbuff_t *tvb, int offset,",1
"    offset = dissect_IPNIO_resp_header(tvb, offset, pinfo, tree, di, drep)_",1
/* dissect a PROFIDrive parameter request */,1
"dissect_ProfiDriveParameterRequest(tvbuff_t *tvb, int offset,",1
    guint8      request_reference_,1
    guint8      request_id_,1
    guint8      do_id_,1
    guint8      no_of_parameters_,1
    guint8      addr_idx_,1
    proto_item *profidrive_item_,1
    proto_tree *profidrive_tree_,1
"    profidrive_item = proto_tree_add_item(tree, hf_pn_io_block, tvb, offset, 0, ENC_NA)_",1
"    profidrive_tree = proto_item_add_subtree(profidrive_item, ett_pn_io_profidrive_parameter_request)_",1
"    proto_item_set_text(profidrive_item, ""PROFIDrive Parameter Request: "")_",1
"    offset = dissect_dcerpc_uint8(tvb, offset, pinfo, profidrive_tree, drep,",1
"                        hf_pn_io_profidrive_request_reference, &request_reference)_",1
"                        hf_pn_io_profidrive_request_id, &request_id)_",1
"                        hf_pn_io_profidrive_do_id, &do_id)_",1
"                        hf_pn_io_profidrive_no_of_parameters, &no_of_parameters)_",1
"    proto_item_append_text(profidrive_item, ""ReqRef:0x%02x, ReqId:%s, DO:%u, NoOfParameters:%u"",",1
"        request_reference, val_to_str(request_id, pn_io_profidrive_request_id_vals, ""Unknown""),",1
"        do_id, no_of_parameters)_",1
"    col_add_fstr(pinfo->cinfo, COL_INFO, ""PROFIDrive Write Request, ReqRef:0x%02x, %s DO:%u"",",1
"            request_reference,",1
"            request_id==0x01 ? ""Read"" :",1
"            request_id==0x02 ? ""Change"" :",1
"                               """",",1
            do_id)_,1
    /* Parameter address list */,1
    for(addr_idx=0_ addr_idx<no_of_parameters_ addr_idx++) {,1
        guint8 attribute_,1
        guint8 no_of_elems_,1
        guint16 parameter_,1
        guint16 idx_,1
"        sub_item = proto_tree_add_item(profidrive_tree, hf_pn_io_block, tvb, offset, 0, ENC_NA)_",1
"        sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_profidrive_parameter_address)_",1
"        proto_item_set_text(sub_item, ""Parameter Address %u: "", addr_idx+1)_",1
"                            hf_pn_io_profidrive_param_attribute, &attribute)_",1
"                            hf_pn_io_profidrive_param_no_of_elems, &no_of_elems)_",1
"                            hf_pn_io_profidrive_param_number, &parameter)_",1
"                            hf_pn_io_profidrive_param_subindex, &idx)_",1
"        proto_item_append_text(sub_item, ""Attr:%s, Elems:%u, Parameter:%u, Index:%u"",",1
"            val_to_str(attribute, pn_io_profidrive_attribute_vals, ""Unknown""), no_of_elems,",1
"            parameter, idx)_",1
            if (no_of_elems>1) {,1
"                col_append_fstr(pinfo->cinfo, COL_INFO, "", P%d[%d..%d]"", parameter, idx, idx+no_of_elems-1)_",1
"                col_append_fstr(pinfo->cinfo, COL_INFO, "", P%d[%d]"", parameter, idx)_",1
    /* in case of change request parameter value list */,1
    if (request_id == 0x02) {,1
        for(addr_idx=0_ addr_idx<no_of_parameters_ addr_idx++) {,1
            guint8 format_,1
            guint8 no_of_vals_,1
            proto_item *sub_item_,1
            proto_tree *sub_tree_,1
"            sub_item = proto_tree_add_item(profidrive_tree, hf_pn_io_block, tvb, offset, 0, ENC_NA)_",1
"            sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_profidrive_parameter_value)_",1
"            proto_item_set_text(sub_item, ""Parameter Value %u: "", addr_idx+1)_",1
"            offset = dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep,",1
"                                hf_pn_io_profidrive_param_format, &format)_",1
"                                hf_pn_io_profidrive_param_no_of_values, &no_of_vals)_",1
"            proto_item_append_text(sub_item, ""Format:%s, NoOfVals:%u"",",1
"                val_to_str(format, pn_io_profidrive_format_vals, ""Unknown""), no_of_vals)_",1
            while (no_of_vals--),1
"                offset = dissect_profidrive_value(tvb, offset, pinfo, sub_tree, drep, format)_",1
"dissect_ProfiDriveParameterResponse(tvbuff_t *tvb, int offset,",1
    guint8      response_id_,1
"    profidrive_tree = proto_item_add_subtree(profidrive_item, ett_pn_io_profidrive_parameter_response)_",1
"    proto_item_set_text(profidrive_item, ""PROFIDrive Parameter Response: "")_",1
"                        hf_pn_io_profidrive_response_id, &response_id)_",1
"    proto_item_append_text(profidrive_item, ""ReqRef:0x%02x, RspId:%s, DO:%u, NoOfParameters:%u"",",1
"        request_reference, val_to_str(response_id, pn_io_profidrive_response_id_vals, ""Unknown""),",1
"    col_add_fstr(pinfo->cinfo, COL_INFO, ""PROFIDrive Read Response, ReqRef:0x%02x, RspId:%s"",",1
"                           request_reference,",1
"                           val_to_str(response_id, pn_io_profidrive_response_id_vals, ""Unknown response""))_",1
"dissect_RecordDataRead(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, guint16 u16Index, guint32 u32RecDataLen)",1
    pnio_ar_t   *ar = NULL_,1
"        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, u32RecDataLen, ""User Specified Data"")_",1
    /* profidrive parameter access response */,1
    if (u16Index == 0xb02e || u16Index == 0xb02f) {,1
"        return dissect_ProfiDriveParameterResponse(tvb, offset, pinfo, tree, drep)_",1
"        offset = dissect_pn_user_data(tvb, offset, pinfo, tree, u32RecDataLen, userProfile)_",1
    /* see: pn_io_index */,1
    /* single block only */,1
    switch (u16Index) {,1
    case(0x8010):   /* Maintenance required in channel coding for one subslot */,1
    case(0x8011):   /* Maintenance demanded in channel coding for one subslot */,1
    case(0x8012):   /* Maintenance required in all codings for one subslot */,1
    case(0x8013):   /* Maintenance demanded in all codings for one subslot */,1
    case(0x801e):   /* SubstituteValues for one subslot */,1
    case(0x8028):   /* RecordInputDataObjectElement for one subslot */,1
    case(0x8029):   /* RecordOutputDataObjectElement for one subslot */,1
    case(0x8050):   /* PDInterfaceMrpDataReal for one subslot */,1
    case(0x8051):   /* PDInterfaceMrpDataCheck for one subslot */,1
    case(0x8052):   /* PDInterfaceMrpDataAdjust for one subslot */,1
    case(0x8053):   /* PDPortMrpDataAdjust for one subslot */,1
    case(0x8054):   /* PDPortMrpDataReal for one subslot */,1
    case(0x8060):   /* PDPortFODataReal for one subslot */,1
    case(0x8061):   /* PDPortFODataCheck for one subslot */,1
    case(0x8062):   /* PDPortFODataAdjust for one subslot */,1
    case(0x8070):   /* PDNCDataCheck for one subslot */,1
    case(0x8071):   /* PDPortStatistic for one subslot */,1
    case(0x8080):   /* PDInterfaceDataReal */,1
    case(0x8090):   /* PDInterfaceFSUDataAdjust */,1
    case(0x80CF):   /* RS_AdjustObserver */,1
    case(0xaff0):   /* I&M0 */,1
    case(0xaff1):   /* I&M1 */,1
    case(0xaff2):   /* I&M2 */,1
    case(0xaff3):   /* I&M3 */,1
    case(0xaff4):   /* I&M4 */,1
    case(0xaff5):   /* I&M5 */,1
    case(0xaff6):   /* I&M6 */,1
    case(0xaff7):   /* I&M7 */,1
    case(0xaff8):   /* I&M8 */,1
    case(0xaff9):   /* I&M9 */,1
    case(0xaffa):   /* I&M10 */,1
    case(0xaffb):   /* I&M11 */,1
    case(0xaffc):   /* I&M12 */,1
    case(0xaffd):   /* I&M13 */,1
    case(0xaffe):   /* I&M14 */,1
    case(0xafff):   /* I&M15 */,1
    case(0xc010):   /* Maintenance required in channel coding for one slot */,1
    case(0xc011):   /* Maintenance demanded in channel coding for one slot */,1
    case(0xc012):   /* Maintenance required in all codings for one slot */,1
    case(0xc013):   /* Maintenance demanded in all codings for one slot */,1
    case(0xe002):   /* ModuleDiffBlock for one AR */,1
    case(0xe010):   /* Maintenance required in channel coding for one AR */,1
    case(0xe011):   /* Maintenance demanded in channel coding for one AR */,1
    case(0xe012):   /* Maintenance required in all codings for one AR */,1
    case(0xe013):   /* Maintenance demanded in all codings for one AR */,1
    case(0xf010):   /* Maintenance required in channel coding for one API */,1
    case(0xf011):   /* Maintenance demanded in channel coding for one API */,1
    case(0xf012):   /* Maintenance required in all codings for one API */,1
    case(0xf013):   /* Maintenance demanded in all codings for one API */,1
    case(0xf020):   /* ARData for one API */,1
    case(0xf820):   /* ARData */,1
    case(0xf821):   /* APIData */,1
    case(0xf830):   /* LogData */,1
    case(0xf831):   /* PDevData */,1
    case(0xf880) : /* AssetManagementData */,1
    case(0xf840):   /* I&M0FilterData */,1
            int end_offset = offset + u32RecDataLen_,1
            if (end_offset > offset),1
"                offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
    case(0xB050):,1
    case(0xB051):,1
    case(0xB060):,1
    case(0xB061):,1
"       offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
    /*** multiple blocks possible ***/,1
    case(0x8000):   /* ExpectedIdentificationData for one subslot */,1
    case(0x8001):   /* RealIdentificationData for one subslot */,1
    case(0x800a):   /* Diagnosis in channel decoding for one subslot */,1
    case(0x800b):   /* Diagnosis in all codings for one subslot */,1
"    case(0x800c):   /* Diagnosis, Maintenance, Qualified and Status for one subslot */",1
    case(0x802a):   /* PDPortDataReal */,1
    case(0x802b):   /* PDPortDataCheck */,1
    case(0x802d):   /* Expected PDSyncData for one subslot with SyncID value 0 for PTCPoverRTA */,1
    case(0x802e):   /* Expected PDSyncData for one subslot with SyncID value 0 for PTCPoverRTC */,1
    case(0x802f):   /* PDPortDataAdjust */,1
    case(0x8030):   /* IsochronousModeData for one subslot */,1
    case(0x8031):   /* Expected PDSyncData for one subslot with SyncID value 1 */,1
    case(0x8032):,1
    case(0x8033):,1
    case(0x8034):,1
    case(0x8035):,1
    case(0x8036):,1
    case(0x8037):,1
    case(0x8038):,1
    case(0x8039):,1
    case(0x803a):,1
    case(0x803b):,1
    case(0x803c):,1
    case(0x803d):,1
    case(0x803e):,1
    case(0x803f):,1
    case(0x8040):   /* Expected PDSyncData for one subslot with SyncID value 2 ... 30 */,1
    case(0x8041):,1
    case(0x8042):,1
    case(0x8043):,1
    case(0x8044):,1
    case(0x8045):,1
    case(0x8046):,1
    case(0x8047):,1
    case(0x8048):,1
    case(0x8049):,1
    case(0x804a):,1
    case(0x804b):,1
    case(0x804c):,1
    case(0x804d):,1
    case(0x804e):,1
    case(0x804f):   /* Expected PDSyncData for one subslot with SyncID value 31 */,1
    case(0x8072):    /* PDPortStatistic for one subslot */,1
    case(0xc000):   /* ExpectedIdentificationData for one slot */,1
    case(0xc001):   /* RealIdentificationData for one slot */,1
    case(0xc00a):   /* Diagnosis in channel coding for one slot */,1
    case(0xc00b):   /* Diagnosis in all codings for one slot */,1
"    case(0xc00c):   /* Diagnosis, Maintenance, Qualified and Status for one slot */",1
    case(0xe000):   /* ExpectedIdentificationData for one AR */,1
    case(0xe001):   /* RealIdentificationData for one AR */,1
    case(0xe00a):   /* Diagnosis in channel decoding for one AR */,1
    case(0xe00b):   /* Diagnosis in all codings for one AR */,1
"    case(0xe00c):   /* Diagnosis, Maintenance, Qualified and Status for one AR */",1
    case(0xe030):   /* IsochronousModeData for one AR */,1
    case(0xE060):   /* RS_GetEvent (using RecordDataRead service) */,1
    case(0xf000):   /* RealIdentificationData for one API */,1
    case(0xf00a):   /* Diagnosis in channel decoding for one API */,1
    case(0xf00b):   /* Diagnosis in all codings for one API */,1
"    case(0xf00c):   /* Diagnosis, Maintenance, Qualified and Status for one API */",1
"    case(0xf80c):   /* Diagnosis, Maintenance, Qualified and Status for one device */",1
    case(0xf841):   /* PDRealData */,1
    case(0xf842):   /* PDExpectedData */,1
"        offset = dissect_pn_undecoded(tvb, offset, pinfo, tree, u32RecDataLen)_",1
/* dissect a PN-IO read response */,1
"dissect_IPNIO_Read_resp(tvbuff_t *tvb, int offset,",1
    guint16    u16Index      = 0_,1
    guint32    u32RecDataLen = 0_,1
    pnio_ar_t *ar            = NULL_,1
    /* IODReadHeader */,1
    /* RecordDataRead */,1
    if (u32RecDataLen != 0) {,1
"        offset = dissect_RecordDataRead(tvb, offset, pinfo, tree, drep, u16Index, u32RecDataLen)_",1
/* F-Parameter record data object */,1
"dissect_ProfiSafeParameterRequest(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, guint16 u16Index, wmem_list_frame_t *frame)",1
    proto_item *f_item_,1
    proto_tree *f_tree_,1
    proto_item *flags1_item_,1
    proto_tree *flags1_tree_,1
    proto_item *flags2_item_,1
    proto_tree *flags2_tree_,1
    guint16     src_addr_,1
    guint16     dst_addr_,1
    guint16     wd_time_,1
    guint16     par_crc_,1
    guint32     ipar_crc = 0_,1
    guint8      prm_flag1_,1
    guint8      prm_flag1_chck_seq_,1
    guint8      prm_flag1_chck_ipar_,1
    guint8      prm_flag1_sil_,1
    guint8      prm_flag1_crc_len_,1
    guint8      prm_flag1_crc_seed_,1
    guint8      prm_flag1_reserved_,1
    guint8      prm_flag2_,1
    guint8      prm_flag2_reserved_,1
    guint8      prm_flag2_f_block_id_,1
    guint8      prm_flag2_f_par_version_,1
    wmem_list_frame_t *frame_out_,1
"    f_item = proto_tree_add_item(tree, hf_pn_io_block, tvb, offset, 0, ENC_NA)_",1
"    f_tree = proto_item_add_subtree(f_item, ett_pn_io_profisafe_f_parameter)_",1
"    proto_item_set_text(f_item, ""F-Parameter: "")_",1
"    flags1_item = proto_tree_add_item(f_tree, hf_pn_io_ps_f_prm_flag1, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
"    flags1_tree = proto_item_add_subtree(flags1_item, ett_pn_io_profisafe_f_parameter_prm_flag1)_",1
    /* dissection of F_Prm_Flag1 */,1
"    dissect_dcerpc_uint8(tvb, offset, pinfo, flags1_tree, drep,",1
"        hf_pn_io_ps_f_prm_flag1_chck_seq, &prm_flag1_chck_seq)_",1
"        hf_pn_io_ps_f_prm_flag1_chck_ipar, &prm_flag1_chck_ipar)_",1
"        hf_pn_io_ps_f_prm_flag1_sil, &prm_flag1_sil)_",1
"        hf_pn_io_ps_f_prm_flag1_crc_len, &prm_flag1_crc_len)_",1
"        hf_pn_io_ps_f_prm_flag1_crc_seed, &prm_flag1_crc_seed)_",1
"        hf_pn_io_ps_f_prm_flag1_reserved, &prm_flag1_reserved)_",1
    prm_flag1 = prm_flag1_chck_seq|prm_flag1_chck_ipar|prm_flag1_sil|prm_flag1_crc_len|prm_flag1_crc_seed|prm_flag1_reserved_,1
    offset++_,1
"    flags2_item = proto_tree_add_item(f_tree, hf_pn_io_ps_f_prm_flag2, tvb, offset, 1, ENC_BIG_ENDIAN)_",1
"    flags2_tree = proto_item_add_subtree(flags2_item, ett_pn_io_profisafe_f_parameter_prm_flag2)_",1
    /* dissection of F_Prm_Flag2 */,1
"    dissect_dcerpc_uint8(tvb, offset, pinfo, flags2_tree, drep,",1
"        hf_pn_io_ps_f_prm_flag2_reserved, &prm_flag2_reserved)_",1
"        hf_pn_io_ps_f_prm_flag2_f_block_id, &prm_flag2_f_block_id)_",1
"        hf_pn_io_ps_f_prm_flag2_f_par_version, &prm_flag2_f_par_version)_",1
    prm_flag2 = prm_flag2_reserved|prm_flag2_f_block_id|prm_flag2_f_par_version_,1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, f_item, drep,",1
"                    hf_pn_io_ps_f_src_adr, &src_addr)_",1
"                    hf_pn_io_ps_f_dest_adr, &dst_addr)_",1
"                    hf_pn_io_ps_f_wd_time, &wd_time)_",1
    /* Dissection for F_iPar_CRC: see F_Prm_Flag2 -> F_Block_ID */,1
    if( (prm_flag2_f_block_id & 0x08) && !(prm_flag2_f_block_id & 0x20) ) {,1
"        offset = dissect_dcerpc_uint32(tvb, offset, pinfo, f_item, drep,",1
"                        hf_pn_io_ps_f_ipar_crc, &ipar_crc)_",1
"                    hf_pn_io_ps_f_par_crc, &par_crc)_",1
    /* Differniate between ipar_crc and no_ipar_crc */,1
    if( (prm_flag2_f_block_id & 0x08) && !(prm_flag2_f_block_id & 0x20) ) {    /* include ipar_crc display */,1
"        col_append_fstr(pinfo->cinfo, COL_INFO,",1
"                        "", F-Parameter record, prm_flag1:0x%02x, prm_flag2:0x%02x, src:0x%04x,""",1
"                         "" dst:0x%04x, wd_time:%d, ipar_crc:0x%04x, crc:0x%04x"",",1
"                        prm_flag1, prm_flag2, src_addr, dst_addr, wd_time, ipar_crc, par_crc)_",1
"        proto_item_append_text(f_item, ""prm_flag1:0x%02x, prm_flag2:0x%02x, src:0x%04x, dst:0x%04x, wd_time:%d, ipar_crc:0x%04x, par_crc:0x%04x"",",1
"                prm_flag1, prm_flag2, src_addr, dst_addr, wd_time, ipar_crc, par_crc)_",1
    else {    /* exclude ipar_crc display */,1
"                         "" dst:0x%04x, wd_time:%d, crc:0x%04x"",",1
"                        prm_flag1, prm_flag2, src_addr, dst_addr, wd_time, par_crc)_",1
"        proto_item_append_text(f_item, ""prm_flag1:0x%02x, prm_flag2:0x%02x, src:0x%04x, dst:0x%04x, wd_time:%d, par_crc:0x%04x"",",1
"                prm_flag1, prm_flag2, src_addr, dst_addr, wd_time, par_crc)_",1
            if (frame != NULL) {,1
                io_data_object->f_par_crc1 = par_crc_,1
                io_data_object->f_src_adr = src_addr_,1
                io_data_object->f_dest_adr = dst_addr_,1
                io_data_object->f_crc_seed = prm_flag1 & 0x40_,1
                if (!(prm_flag1 & 0x10)) {,1
                    if (prm_flag1 & 0x20) {,1
                        io_data_object->f_crc_len = 4_,1
                    } else {,1
                        io_data_object->f_crc_len = 3_,1
            /* Find same module within output data to saved data */,1
            for (frame_out = wmem_list_head(station_info->ioobject_data_out)_ frame_out != NULL_ frame_out = wmem_list_frame_next(frame_out)) {,1
                io_data_object = (ioDataObject*)wmem_list_frame_data(frame_out)_,1
                if (u16Index == io_data_object->fParameterIndexNr &&    /* Check F-Parameter Indexnumber */,1
                    io_data_object->profisafeSupported &&               /* Arrayelement has to be PS-Module */,1
                    io_data_object->f_par_crc1 == 0) {                  /* Find following object with no f_par_crc1 */,1
                    io_data_object->f_par_crc1 = par_crc_,1
                    io_data_object->f_src_adr = src_addr_,1
                    io_data_object->f_dest_adr = dst_addr_,1
                    io_data_object->f_crc_seed = prm_flag1 & 0x40_,1
                    if (!(prm_flag1 & 0x10)) {,1
                        if (prm_flag1 & 0x20) {,1
                            io_data_object->f_crc_len = 4_,1
                        } else {,1
                            io_data_object->f_crc_len = 3_,1
"dissect_RecordDataWrite(tvbuff_t *tvb, int offset,",1
            /* Search within the entire existing list for current input object data */,1
            for (frame = wmem_list_head(station_info->ioobject_data_in)_ frame != NULL_ frame = wmem_list_frame_next(frame)) {,1
"                    return dissect_ProfiSafeParameterRequest(tvb, offset, pinfo, tree, drep, u16Index, frame)_",1
            /* User clicked another time the frame to see the data -> PROFIsafe data has already been saved,1
             * Check whether the device contains an PROFIsafe supported submodule.,1
                    io_data_object->profisafeSupported) {               /* Arrayelement has to be PS-Module */,1
            for (frame = wmem_list_head(station_info->ioobject_data_out)_ frame != NULL_ frame = wmem_list_frame_next(frame)) {,1
"        return dissect_pn_user_data(tvb, offset, pinfo, tree, u32RecDataLen, ""User Specified Data"")_",1
    /* profidrive parameter request */,1
"        return dissect_ProfiDriveParameterRequest(tvb, offset, pinfo, tree, drep)_",1
    case(0x8020):   /* PDIRSubframeData */,1
    case(0x802b):   /* PDPortDataCheck for one subslot */,1
    case(0x802c):   /* PDirData for one subslot */,1
    case(0x802f):   /* PDPortDataAdjust for one subslot */,1
    case(0x8071):   /* PDInterfaceAdjust */,1
    case(0x80B0):   /* CombinedObjectContainer*/,1
    case(0xe050):   /* FastStartUp data for one AR */,1
    case(0xe061):   /* RS_AckEvent (using RecordDataWrite service) */,1
"dissect_IODWriteReq(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep, pnio_ar_t **ar)",1
    guint16 u16Index = 0_,1
    guint32 u32RecDataLen = 0_,1
    /* IODWriteHeader */,1
"    offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, ar)_",1
    /* IODWriteMultipleReq? */,1
    if (u16Index == 0xe040) {,1
"        while (tvb_captured_length_remaining(tvb, offset) > 0) {",1
"            offset = dissect_IODWriteReq(tvb, offset, pinfo, tree, drep, ar)_",1
"        tvbuff_t *new_tvb = tvb_new_subset_length(tvb, offset, u32RecDataLen)_",1
        /* RecordDataWrite */,1
"        offset += dissect_RecordDataWrite(new_tvb, 0, pinfo, tree, drep, u16Index, u32RecDataLen)_",1
        switch (offset % 4) {,1
            offset += 3_,1
        default: /* will not execute because of the line preceding the switch */,1
/* dissect a PN-IO write request */,1
"dissect_IPNIO_Write_rqst(tvbuff_t *tvb, int offset,",1
    pnio_ar_t *ar = NULL_,1
"    offset = dissect_IODWriteReq(tvb, offset, pinfo, tree, drep, &ar)_",1
"dissect_IODWriteRes(tvbuff_t *tvb, int offset,",1
    /* IODWriteResHeader */,1
    /* IODWriteMultipleRes? */,1
"            offset = dissect_block(tvb, offset, pinfo, tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
/* dissect a PN-IO write response */,1
"dissect_IPNIO_Write_resp(tvbuff_t *tvb, int offset,",1
"    offset = dissect_IODWriteRes(tvb, offset, pinfo, tree, drep)_",1
"/* dissect the IOxS (IOCS, IOPS) field */",1
"dissect_PNIO_IOxS(tvbuff_t *tvb, int offset,",1
"                  packet_info *pinfo _U_, proto_tree *tree, guint8 *drep _U_, int hfindex)",1
        guint8      u8IOxS_,1
        proto_item *ioxs_item_,1
        proto_tree *ioxs_tree_,1
"        u8IOxS = tvb_get_guint8(tvb, offset)_",1
        /* add ioxs subtree */,1
"        ioxs_item = proto_tree_add_uint(tree, hfindex, tvb, offset, 1, u8IOxS)_",1
"        proto_item_append_text(ioxs_item,",1
"                               "" (%s%s)"",",1
"                               (u8IOxS & 0x01) ? ""another IOxS follows "" : """",",1
"                               (u8IOxS & 0x80) ? ""good"" : ""bad"")_",1
"        ioxs_tree = proto_item_add_subtree(ioxs_item, ett_pn_io_ioxs)_",1
"        proto_tree_add_uint(ioxs_tree, hf_pn_io_ioxs_datastate, tvb, offset, 1, u8IOxS)_",1
"        proto_tree_add_uint(ioxs_tree, hf_pn_io_ioxs_instance,  tvb, offset, 1, u8IOxS)_",1
"        proto_tree_add_uint(ioxs_tree, hf_pn_io_ioxs_res14,     tvb, offset, 1, u8IOxS)_",1
"        proto_tree_add_uint(ioxs_tree, hf_pn_io_ioxs_extension, tvb, offset, 1, u8IOxS)_",1
    return offset + 1_,1
/* dissect a PN-IO Cyclic Service Data Unit (on top of PN-RT protocol) */,1
"dissect_PNIO_C_SDU(tvbuff_t *tvb, int offset,",1
"    packet_info *pinfo, proto_tree *tree, guint8 *drep _U_)",1
    proto_tree  *data_tree = NULL_,1
    /* gint iTotalLen    = 0_ */,1
    /* gint iSubFrameLen = 0_ */,1
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO"")_",1
        proto_item *data_item_,1
"        data_item = proto_tree_add_protocol_format(tree, proto_pn_io, tvb, offset, tvb_captured_length(tvb),",1
"            ""PROFINET IO Cyclic Service Data Unit: %u bytes"", tvb_captured_length(tvb))_",1
"        data_tree = proto_item_add_subtree(data_item, ett_pn_io_rtc)_",1
"    /*dissect_dcerpc_uint16(tvb, offset, pinfo, data_tree, drep, hf_pn_io_packedframe_SFCRC, &u16SFCRC)_*/",1
"    if (dissect_CSF_SDU_heur(tvb, pinfo, data_tree, NULL))",1
        return(tvb_captured_length(tvb))_,1
    /* XXX - dissect the remaining data */,1
    /* this will be one or more DataItems followed by an optional GAP and RTCPadding */,1
"    /* as we don't have the required context information to dissect the specific DataItems, */",1
    /* this will be tricky :-( */,1
    /* actual: there may be an IOxS but most case there isn't so better display a data-stream */,1
"    /* offset = dissect_PNIO_IOxS(tvb, offset, pinfo, data_tree, drep, hf_pn_io_ioxs)_        */",1
"    offset = dissect_pn_user_data(tvb, offset, pinfo, tree, tvb_captured_length_remaining(tvb, offset),",1
"        ""User Data (including GAP and RTCPadding)"")_",1
/* dissect a PN-IO RTA PDU (on top of PN-RT protocol) */,1
"dissect_PNIO_RTA(tvbuff_t *tvb, int offset,",1
    guint16     u16AlarmDstEndpoint_,1
    guint16     u16AlarmSrcEndpoint_,1
    guint8      u8PDUType_,1
    guint8      u8PDUVersion_,1
    guint8      u8WindowSize_,1
    guint8      u8Tack_,1
    guint16     u16SendSeqNum_,1
    guint16     u16AckSeqNum_,1
    guint16     u16VarPartLen_,1
    int         start_offset = offset_,1
    guint16     u16Index     = 0_,1
    guint32     u32RecDataLen_,1
    pnio_ar_t  *ar           = NULL_,1
    proto_item *rta_item_,1
    proto_tree *rta_tree_,1
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PNIO-AL"")_",1
"    rta_item = proto_tree_add_protocol_format(tree, proto_pn_io, tvb, offset, tvb_captured_length(tvb),",1
"        ""PROFINET IO Alarm"")_",1
"    rta_tree = proto_item_add_subtree(rta_item, ett_pn_io_rta)_",1
"    offset = dissect_dcerpc_uint16(tvb, offset, pinfo, rta_tree, drep,",1
"                    hf_pn_io_alarm_dst_endpoint, &u16AlarmDstEndpoint)_",1
"                    hf_pn_io_alarm_src_endpoint, &u16AlarmSrcEndpoint)_",1
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", Src: 0x%x, Dst: 0x%x"",",1
"        u16AlarmSrcEndpoint, u16AlarmDstEndpoint)_",1
    /* PDU type */,1
"    sub_item = proto_tree_add_item(rta_tree, hf_pn_io_pdu_type, tvb, offset, 1, ENC_NA)_",1
"    dissect_dcerpc_uint8(tvb, offset, pinfo, sub_tree, drep,",1
"                    hf_pn_io_pdu_type_type, &u8PDUType)_",1
    u8PDUType &= 0x0F_,1
"                    hf_pn_io_pdu_type_version, &u8PDUVersion)_",1
    u8PDUVersion >>= 4_,1
"    proto_item_append_text(sub_item, "", Type: %s, Version: %u"",",1
"        val_to_str(u8PDUType, pn_io_pdu_type, ""Unknown""),",1
        u8PDUVersion)_,1
    /* additional flags */,1
"    sub_item = proto_tree_add_item(rta_tree, hf_pn_io_add_flags, tvb, offset, 1, ENC_NA)_",1
"    sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_add_flags)_",1
"                    hf_pn_io_window_size, &u8WindowSize)_",1
    u8WindowSize &= 0x0F_,1
"                    hf_pn_io_tack, &u8Tack)_",1
    u8Tack >>= 4_,1
"    proto_item_append_text(sub_item, "", Window Size: %u, Tack: %u"",",1
"        u8WindowSize, u8Tack)_",1
"                    hf_pn_io_send_seq_num, &u16SendSeqNum)_",1
"                    hf_pn_io_ack_seq_num, &u16AckSeqNum)_",1
"                    hf_pn_io_var_part_len, &u16VarPartLen)_",1
    switch ( u8PDUType & 0x0F) {,1
    case(1):    /* Data-RTA */,1
"        col_append_str(pinfo->cinfo, COL_INFO, "", Data-RTA"")_",1
"        offset = dissect_block(tvb, offset, pinfo, rta_tree, drep, &u16Index, &u32RecDataLen, &ar)_",1
    case(2):    /* NACK-RTA */,1
"            col_append_str(pinfo->cinfo, COL_INFO, "", NACK-RTA"")_",1
        /* no additional data */,1
    case(3):    /* ACK-RTA */,1
"            col_append_str(pinfo->cinfo, COL_INFO, "", ACK-RTA"")_",1
    case(4):    /* ERR-RTA */,1
"            col_append_str(pinfo->cinfo, COL_INFO, "", ERR-RTA"")_",1
"        offset = dissect_PNIO_status(tvb, offset, pinfo, rta_tree, drep)_",1
"        offset = dissect_pn_undecoded(tvb, offset, pinfo, tree, tvb_captured_length(tvb))_",1
"    proto_item_set_len(rta_item, offset - start_offset)_",1
/* possibly dissect a PN-IO related PN-RT packet */,1
"dissect_PNIO_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",1
    void *data),1
    guint8   drep_data = 0_,1
    guint8  *drep      = &drep_data_,1
    guint8   u8CBAVersion_,1
    /* the sub tvb will NOT contain the frame_id here! */,1
    guint16  u16FrameID = GPOINTER_TO_UINT(data)_,1
    heur_dtbl_entry_t *hdtbl_entry_,1
"     * In case the packet is a protocol encoded in the basic PNIO transport stream,",1
"     * give that protocol a chance to make a heuristic dissection, before we continue",1
     * to dissect it as a normal PNIO packet.,1
"    if (dissector_try_heuristic(heur_pn_subdissector_list, tvb, pinfo, tree, &hdtbl_entry, NULL))",1
"    u8CBAVersion = tvb_get_guint8 (tvb, 0)_",1
    /* is this a (none DFP) PNIO class 3 data packet? */,1
"    /* frame id must be in valid range (cyclic Real-Time, class=3) */",1
    if ((u16FrameID >= 0x0100 && u16FrameID <= 0x06FF) ||   /* RTC3 non redundant */,1
        (u16FrameID >= 0x700 && u16FrameID <= 0x0fff)) {    /* RTC3 redundant */,1
"        dissect_PNIO_C_SDU(tvb, 0, pinfo, tree, drep)_",1
    /* The following range is reserved for following developments */,1
    /* frame id must be in valid range (Reserved) and,1
     * first byte (CBA version field) has to be != 0x11 */,1
    if (u16FrameID >= 0x1000 && u16FrameID <= 0x7fff && u8CBAVersion != 0x11) {,1
    /* is this a PNIO class 1 data packet? */,1
"    /* frame id must be in valid range (cyclic Real-Time, class=1) and",1
    if (u16FrameID >= 0x8000 && u16FrameID < 0xbfff && u8CBAVersion != 0x11) {,1
"        dissect_PNIO_C_SDU_RTC1(tvb, 0, pinfo, tree, drep)_",1
    /* is this a PNIO class 1 (legacy) data packet? */,1
"    /* frame id must be in valid range (cyclic Real-Time, class=1, legacy) and",1
    if (u16FrameID >= 0xc000 && u16FrameID < 0xfbff && u8CBAVersion != 0x11) {,1
    /* is this a PNIO high priority alarm packet? */,1
    if (u16FrameID == 0xfc01) {,1
"        col_set_str(pinfo->cinfo, COL_INFO, ""Alarm High"")_",1
"        dissect_PNIO_RTA(tvb, 0, pinfo, tree, drep)_",1
    /* is this a PNIO low priority alarm packet? */,1
    if (u16FrameID == 0xfe01) {,1
"        col_set_str(pinfo->cinfo, COL_INFO, ""Alarm Low"")_",1
    /* this PN-RT packet doesn't seem to be PNIO specific */,1
pn_io_ar_conv_valid(packet_info *pinfo),1
"    void* profinet_type = p_get_proto_data(pinfo->pool, pinfo, proto_pn_io, 0)_",1
    return ((profinet_type != NULL) && (GPOINTER_TO_UINT(profinet_type) == 10))_,1
static gchar *,1
pn_io_ar_conv_filter(packet_info *pinfo),1
"    pnio_ar_t *ar = (pnio_ar_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_pn_io, 0)_",1
    char      *buf_,1
"    address   controllermac_addr, devicemac_addr_",1
    if ((profinet_type == NULL) || (GPOINTER_TO_UINT(profinet_type) != 10) || (ar == NULL)) {,1
"    set_address(&controllermac_addr, AT_ETHER, 6, ar->controllermac)_",1
"    set_address(&devicemac_addr, AT_ETHER, 6, ar->devicemac)_",1
    buf = g_strdup_printf(,1
"        ""pn_io.ar_uuid == %s || ""                                   /* ARUUID */",1
"        ""(pn_io.alarm_src_endpoint == 0x%x && eth.src == %s) || ""   /* Alarm CR (contr -> dev) */",1
"        ""(pn_io.alarm_src_endpoint == 0x%x && eth.src == %s)"",      /* Alarm CR (dev -> contr) */",1
"         guid_to_str(pinfo->pool, (const e_guid_t*) &ar->aruuid),",1
"        ar->controlleralarmref, address_to_str(pinfo->pool, &controllermac_addr),",1
"        ar->devicealarmref, address_to_str(pinfo->pool, &devicemac_addr))_",1
    return buf_,1
pn_io_ar_conv_data_filter(packet_info *pinfo),1
"    char      *buf, *controllermac_str, *devicemac_str, *guid_str_",1
"    controllermac_str = address_to_str(pinfo->pool, &controllermac_addr)_",1
"    devicemac_str = address_to_str(pinfo->pool, &devicemac_addr)_",1
"    guid_str = guid_to_str(pinfo->pool, (const e_guid_t*) &ar->aruuid)_",1
    if (ar->arType == 0x0010) /* IOCARSingle using RT_CLASS_3 */,1
        buf = g_strdup_printf(,1
"            ""pn_io.ar_uuid == %s || ""                                           /* ARUUID */",1
"            ""(pn_rt.frame_id == 0x%x) || (pn_rt.frame_id == 0x%x) || """,1
"            ""(pn_io.alarm_src_endpoint == 0x%x && eth.src == %s) || ""           /* Alarm CR (contr -> dev) */",1
"            ""(pn_io.alarm_src_endpoint == 0x%x && eth.src == %s)"",              /* Alarm CR (dev -> contr) */",1
"            guid_str,",1
"            ar->inputframeid, ar->outputframeid,",1
"            ar->controlleralarmref, controllermac_str,",1
"            ar->devicealarmref, devicemac_str)_",1
"            ""(pn_rt.frame_id == 0x%x && eth.src == %s && eth.dst == %s) || ""    /* Input CR && dev MAC -> contr MAC */",1
"            ""(pn_rt.frame_id == 0x%x && eth.src == %s && eth.dst == %s) || ""    /* Output CR && contr MAC -> dev MAC */",1
"            ar->inputframeid, devicemac_str, controllermac_str,",1
"            ar->outputframeid, controllermac_str, devicemac_str,",1
/* the PNIO dcerpc interface table */,1
static dcerpc_sub_dissector pn_io_dissectors[] = {,1
"    { 0, ""Connect"",       dissect_IPNIO_rqst,       dissect_IPNIO_resp },",1
"    { 1, ""Release"",       dissect_IPNIO_rqst,       dissect_IPNIO_resp },",1
"    { 2, ""Read"",          dissect_IPNIO_rqst,       dissect_IPNIO_Read_resp },",1
"    { 3, ""Write"",         dissect_IPNIO_Write_rqst, dissect_IPNIO_Write_resp },",1
"    { 4, ""Control"",       dissect_IPNIO_rqst,       dissect_IPNIO_resp },",1
"    { 5, ""Read Implicit"", dissect_IPNIO_rqst,       dissect_IPNIO_Read_resp },",1
"    { 0, NULL, NULL, NULL }",1
pnio_cleanup(void) {,1
    g_list_free(pnio_ars)_,1
    pnio_ars = NULL_,1
proto_register_pn_io (void),1
"    { &hf_pn_io_opnum,",1
"      { ""Operation"", ""pn_io.opnum"",",1
"    { &hf_pn_io_reserved16,",1
"      { ""Reserved"", ""pn_io.reserved16"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x0,",1
"    { &hf_pn_io_array,",1
"      { ""Array"", ""pn_io.array"",",1
"    { &hf_pn_io_status,",1
"      { ""Status"", ""pn_io.status"",",1
"    { &hf_pn_io_args_max,",1
"      { ""ArgsMaximum"", ""pn_io.args_max"",",1
"    { &hf_pn_io_args_len,",1
"      { ""ArgsLength"", ""pn_io.args_len"",",1
"        FT_UINT32, BASE_DEC_HEX, NULL, 0x0,",1
"    { &hf_pn_io_array_max_count,",1
"      { ""MaximumCount"", ""pn_io.array_max_count"",",1
"    { &hf_pn_io_array_offset,",1
"      { ""Offset"", ""pn_io.array_offset"",",1
"    { &hf_pn_io_array_act_count,",1
"      { ""ActualCount"", ""pn_io.array_act_count"",",1
"    { &hf_pn_io_ar_data,",1
"      { ""ARDATA for AR:"", ""pn_io.ar_data"",",1
"        FT_NONE, BASE_NONE, 0x0, 0x0,",1
"    { &hf_pn_io_ar_type,",1
"      { ""ARType"", ""pn_io.ar_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ar_type), 0x0,",1
"    { &hf_pn_io_cminitiator_macadd,",1
"      { ""CMInitiatorMacAdd"", ""pn_io.cminitiator_mac_add"",",1
"        FT_ETHER, BASE_NONE, 0x0, 0x0,",1
"    { &hf_pn_io_cminitiator_objectuuid,",1
"      { ""CMInitiatorObjectUUID"", ""pn_io.cminitiator_uuid"",",1
"        FT_GUID, BASE_NONE, 0x0, 0x0,",1
"        { &hf_pn_io_parameter_server_objectuuid,",1
"          { ""ParameterServerObjectUUID"", ""pn_io.parameter_server_objectuuid"",",1
"            FT_GUID, BASE_NONE, 0x0, 0x0,",1
"    { &hf_pn_io_ar_properties,",1
"      { ""ARProperties"", ""pn_io.ar_properties"",",1
"    { &hf_pn_io_ar_properties_state,",1
"      { ""State"", ""pn_io.ar_properties.state"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_state), 0x00000007,",1
"    { &hf_pn_io_ar_properties_supervisor_takeover_allowed,",1
"      { ""SupervisorTakeoverAllowed"", ""pn_io.ar_properties.supervisor_takeover_allowed"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_supervisor_takeover_allowed), 0x00000008,",1
"    { &hf_pn_io_ar_properties_parametrization_server,",1
"      { ""ParametrizationServer"", ""pn_io.ar_properties.parametrization_server"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_parametrization_server), 0x00000010,",1
"    { &hf_pn_io_artype_req,",1
"        { ""ARType"", ""pn_io.artype_req"",",1
"           FT_STRING, BASE_NONE, NULL, 0x0,",1
"           NULL, HFILL }},",1
"    { &hf_pn_io_ar_properties_companion_ar,",1
"      { ""CompanionAR"", ""pn_io.ar_properties.companion_ar"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_companion_ar), 0x00000600,",1
"    { &hf_pn_io_ar_properties_achnowledge_companion_ar,",1
"      { ""AcknowledgeCompanionAR"", ""pn_io.ar_properties.acknowledge_companion_ar"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_acknowldege_companion_ar), 0x00000800,",1
"    { &hf_pn_io_ar_properties_reserved,",1
"      { ""Reserved"", ""pn_io.ar_properties.reserved"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x1FFFF000,",1
"    { &hf_pn_io_ar_properties_combined_object_container_with_legacy_startupmode,",1
"      { ""CombinedObjectContainer"", ""pn_io.ar_properties.combined_object_container"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_combined_object_container_with_legacy_startupmode), 0x20000000,",1
"    { &hf_pn_io_ar_properties_combined_object_container_with_advanced_startupmode,",1
"    { ""CombinedObjectContainer"", ""pn_io.ar_properties.combined_object_container"",",1
"       FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_combined_object_container_with_advanced_startupmode), 0x20000000,",1
"       NULL, HFILL }",1
"    { &hf_pn_io_arproperties_StartupMode,",1
"      { ""StartupMode"", ""pn_io.ar_properties.StartupMode"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arpropertiesStartupMode), 0x40000000,",1
"    { &hf_pn_io_ar_properties_pull_module_alarm_allowed,",1
"      { ""PullModuleAlarmAllowed"", ""pn_io.ar_properties.pull_module_alarm_allowed"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_pull_module_alarm_allowed), 0x80000000,",1
"    { &hf_pn_RedundancyInfo,",1
"      { ""RedundancyInfo.EndPoint"", ""pn_io.srl_data.redundancyInfo"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_RedundancyInfo), 0x0000003,",1
"    { &hf_pn_RedundancyInfo_reserved,",1
"      { ""RedundancyInfo.reserved"", ""pn_io.srl_data.redundancyInfoReserved"",",1
"        FT_UINT16, BASE_HEX, NULL, 0xFFFFFFFC,",1
"    { &hf_pn_io_number_of_ARDATAInfo,",1
"      { ""ARDataInfo.NumberOfEntries"", ""pn_io.number_of_ARDATAInfo"",",1
"    { &hf_pn_io_cminitiator_activitytimeoutfactor,",1
"      { ""CMInitiatorActivityTimeoutFactor"", ""pn_io.cminitiator_activitytimeoutfactor"",",1
"    },  /* XXX - special values */",1
"    { &hf_pn_io_cminitiator_udprtport,",1
"      { ""CMInitiatorUDPRTPort"", ""pn_io.cminitiator_udprtport"",",1
"    { &hf_pn_io_station_name_length,",1
"      { ""StationNameLength"", ""pn_io.station_name_length"",",1
"        FT_UINT16, BASE_DEC_HEX, NULL, 0x0,",1
"    { &hf_pn_io_cminitiator_station_name,",1
"      { ""CMInitiatorStationName"", ""pn_io.cminitiator_station_name"",",1
"    { &hf_pn_io_parameter_server_station_name,",1
"      { ""ParameterServerStationName"", ""pn_io.parameter_server_station_name"",",1
"    { &hf_pn_io_cmresponder_macadd,",1
"      { ""CMResponderMacAdd"", ""pn_io.cmresponder_macadd"",",1
"    { &hf_pn_io_cmresponder_udprtport,",1
"      { ""CMResponderUDPRTPort"", ""pn_io.cmresponder_udprtport"",",1
"    { &hf_pn_io_number_of_iocrs,",1
"      { ""NumberOfIOCRs"", ""pn_io.number_of_iocrs"",",1
"    { &hf_pn_io_iocr_tree,",1
"      { ""IOCR"", ""pn_io.iocr_tree"",",1
"    { &hf_pn_io_iocr_type,",1
"      { ""IOCRType"", ""pn_io.iocr_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_iocr_type), 0x0,",1
"    { &hf_pn_io_iocr_reference,",1
"      { ""IOCRReference"", ""pn_io.iocr_reference"",",1
"    { &hf_pn_io_iocr_SubframeOffset,",1
"      { ""-> SubframeOffset"", ""pn_io.subframe_offset"",",1
"        FT_UINT8, BASE_DEC_HEX, NULL, 0x0,",1
"    { &hf_pn_io_iocr_SubframeData,",1
"      { ""SubframeData"", ""pn_io.subframe_data"",",1
"    { &hf_pn_io_RedundancyDataHoldFactor,",1
"      { ""RedundancyDataHoldFactor"", ""pn_io.RedundancyDataHoldFactor"",",1
"        FT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(pn_io_RedundancyDataHoldFactor), 0x0,",1
"    { &hf_pn_io_sr_properties,",1
"      { ""SRProperties"", ""pn_io.sr_properties"",",1
"    { &hf_pn_io_sr_properties_InputValidOnBackupAR_with_SRProperties_Mode_0,",1
"      { ""InputValidOnBackupAR"", ""pn_io.sr_properties.InputValidOnBackupAR"",",1
"        FT_BOOLEAN, 32, TFS(&tfs_pn_io_sr_properties_BackupAR_with_SRProperties_Mode_0), 0x01,",1
"    { &hf_pn_io_sr_properties_InputValidOnBackupAR_with_SRProperties_Mode_1,",1
"        FT_BOOLEAN, 32, TFS(&tfs_pn_io_sr_properties_BackupAR_with_SRProperties_Mode_1), 0x01,",1
"    { &hf_pn_io_sr_properties_Reserved_1,",1
"      { ""Reserved_1"", ""pn_io.sr_properties.Reserved_1"",",1
"        FT_BOOLEAN, 32, TFS(&tfs_pn_io_sr_properties_Reserved1), 0x00000002,",1
"    { &hf_pn_io_sr_properties_Mode,",1
"      { ""Mode"", ""pn_io.sr_properties.Mode"",",1
"        FT_BOOLEAN, 32, TFS(&tfs_pn_io_sr_properties_Mode), 0x00000004,",1
"    { &hf_pn_io_sr_properties_Reserved_2,",1
"      { ""Reserved_2"", ""pn_io.sr_properties.Reserved_2"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0000FFF8,",1
"    { &hf_pn_io_sr_properties_Reserved_3,",1
"      { ""Reserved_3"", ""pn_io.sr_properties.Reserved_3"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xFFFF0000,",1
"    { &hf_pn_io_arvendor_strucidentifier_if0_low,",1
"      { ""APStructureIdentifier: Vendor specific"", ""pn_io.structidentifier_api_0_low"",",1
"    { &hf_pn_io_arvendor_strucidentifier_if0_high,",1
"      { ""APStructureIdentifier: Administrative number for common profiles"", ""pn_io.structidentifier_api_0_high"",",1
"    { &hf_pn_io_arvendor_strucidentifier_if0_is8000,",1
"      { ""APStructureIdentifier: Extended identification rules"", ""pn_io.tructidentifier_api_0_is8000"",",1
"    { &hf_pn_io_arvendor_strucidentifier_not0,",1
"    { ""APStructureIdentifier: Administrative number for application profiles"", ""pn_io.tructidentifier_api_not_0"",",1
"    { &hf_pn_io_lt,",1
"      { ""LT"", ""pn_io.lt"",",1
"    { &hf_pn_io_iocr_properties,",1
"      { ""IOCRProperties"", ""pn_io.iocr_properties"",",1
"    { &hf_pn_io_iocr_properties_rtclass,",1
"      { ""RTClass"", ""pn_io.iocr_properties.rtclass"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_iocr_properties_rtclass), 0x0000000F,",1
"    { &hf_pn_io_iocr_properties_reserved_1,",1
"      { ""Reserved1"", ""pn_io.iocr_properties.reserved1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x00000FF0,",1
"    { &hf_pn_io_iocr_properties_media_redundancy,",1
"      { ""MediaRedundancy"", ""pn_io.iocr_properties.media_redundancy"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_iocr_properties_media_redundancy), 0x00000800,",1
"    { &hf_pn_io_iocr_properties_reserved_2,",1
"      { ""Reserved2"", ""pn_io.iocr_properties.reserved2"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x00FFF000,",1
"    { &hf_pn_io_iocr_properties_reserved_3,",1
"      { ""Reserved3"", ""pn_io.iocr_properties.reserved3"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xF000000,",1
"    { &hf_pn_io_iocr_properties_fast_forwarding_mac_adr,",1
"      { ""FastForwardingMACAdr"", ""pn_io.iocr_properties.fast_forwarding_mac_adr"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x20000000,",1
"    { &hf_pn_io_iocr_properties_distributed_subframe_watchdog,",1
"      { ""DistributedSubFrameWatchDog"", ""pn_io.iocr_properties.distributed_subframe_watchdog"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x40000000,",1
"    { &hf_pn_io_iocr_properties_full_subframe_structure,",1
"      { ""FullSubFrameStructure"", ""pn_io.iocr_properties.full_subframe_structure"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x80000000,",1
"    { &hf_pn_io_SFIOCRProperties,",1
"      { ""SFIOCRProperties"", ""pn_io.SFIOCRProperties"",",1
"    { &hf_pn_io_DistributedWatchDogFactor,",1
"      { ""SFIOCRProperties.DistributedWatchDogFactor"", ""pn_io.SFIOCRProperties.DistributedWatchDogFactor"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0FF,",1
"    { &hf_pn_io_RestartFactorForDistributedWD,",1
"      { ""SFIOCRProperties.RestartFactorForDistributedWD"", ""pn_io.SFIOCRProperties.RestartFactorForDistributedWD"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xff00,",1
"    { &hf_pn_io_SFIOCRProperties_DFPmode,",1
"      { ""SFIOCRProperties.DFPmode"", ""pn_io.SFIOCRProperties.DFPmode"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xFF0000,",1
"    { &hf_pn_io_SFIOCRProperties_reserved_1,",1
"      { ""SFIOCRProperties.reserved_1"", ""pn_io.SFIOCRProperties.reserved_1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0F000000,",1
"    { &hf_pn_io_SFIOCRProperties_reserved_2,",1
"      { ""SFIOCRProperties.reserved_2"", ""pn_io.SFIOCRProperties.reserved_2"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x010000000,",1
"    { &hf_pn_io_SFIOCRProperties_DFPType,",1
"      { ""SFIOCRProperties.DFPType"", ""pn_io.SFIOCRProperties.DFPType"",",1
"        FT_UINT32, BASE_HEX,  VALS(pn_io_SFIOCRProperties_DFPType_vals), 0x020000000,",1
"    { &hf_pn_io_SFIOCRProperties_DFPRedundantPathLayout,",1
"      { ""SFIOCRProperties.DFPRedundantPathLayout"", ""pn_io.SFIOCRProperties.DFPRedundantPathLayout"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_DFPRedundantPathLayout_decode), 0x040000000,",1
"    { &hf_pn_io_SFIOCRProperties_SFCRC16,",1
"      { ""SFIOCRProperties.SFCRC16"", ""pn_io.SFIOCRProperties.SFCRC16"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_SFCRC16_Decode), 0x080000000,",1
"    { &hf_pn_io_data_length,",1
"      { ""DataLength"", ""pn_io.data_length"",",1
"    { &hf_pn_io_ir_frame_data,",1
"      { ""Frame data"", ""pn_io.ir_frame_data"",",1
"    { &hf_pn_io_frame_id,",1
"      { ""FrameID"", ""pn_io.frame_id"",",1
"    { &hf_pn_io_send_clock_factor,",1
"      { ""SendClockFactor"", ""pn_io.send_clock_factor"",",1
"    }, /* XXX - special values */",1
"    { &hf_pn_io_reduction_ratio,",1
"      { ""ReductionRatio"", ""pn_io.reduction_ratio"",",1
"    { &hf_pn_io_phase,",1
"      { ""Phase"", ""pn_io.phase"",",1
"    { &hf_pn_io_sequence,",1
"      { ""Sequence"", ""pn_io.sequence"",",1
"    { &hf_pn_io_frame_send_offset,",1
"      { ""FrameSendOffset"", ""pn_io.frame_send_offset"",",1
"    { &hf_pn_io_frame_data_properties,",1
"      { ""FrameDataProperties"", ""pn_io.frame_data_properties"",",1
"    { &hf_pn_io_frame_data_properties_forwarding_Mode,",1
"      { ""ForwardingMode"", ""pn_io.frame_data_properties_forwardingMode"",",1
"        FT_UINT32, BASE_HEX, VALS(hf_pn_io_frame_data_properties_forwardingMode), 0x01,",1
"    { &hf_pn_io_frame_data_properties_FastForwardingMulticastMACAdd,",1
"      { ""FastForwardingMulticastMACAdd"", ""pn_io.frame_data_properties_MulticastMACAdd"",",1
"        FT_UINT32, BASE_HEX, VALS(hf_pn_io_frame_data_properties_FFMulticastMACAdd), 0x06,",1
"    { &hf_pn_io_frame_data_properties_FragmentMode,",1
"      { ""FragmentationMode"", ""pn_io.frame_data_properties_FragMode"",",1
"        FT_UINT32, BASE_HEX, VALS(hf_pn_io_frame_data_properties_FragMode), 0x18,",1
"    { &hf_pn_io_frame_data_properties_reserved_1,",1
"      { ""Reserved_1"", ""pn_io.frame_data.reserved_1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0000FFE0,",1
"    { &hf_pn_io_frame_data_properties_reserved_2,",1
"      { ""Reserved_2"", ""pn_io.frame_data.reserved_2"",",1
"    { &hf_pn_io_watchdog_factor,",1
"      { ""WatchdogFactor"", ""pn_io.watchdog_factor"",",1
"    { &hf_pn_io_data_hold_factor,",1
"      { ""DataHoldFactor"", ""pn_io.data_hold_factor"",",1
"    { &hf_pn_io_iocr_tag_header,",1
"      { ""IOCRTagHeader"", ""pn_io.iocr_tag_header"",",1
"    { &hf_pn_io_iocr_multicast_mac_add,",1
"      { ""IOCRMulticastMACAdd"", ""pn_io.iocr_multicast_mac_add"",",1
"        FT_ETHER, BASE_NONE, NULL, 0x0,",1
"    { &hf_pn_io_number_of_apis,",1
"      { ""NumberOfAPIs"", ""pn_io.number_of_apis"",",1
"    { &hf_pn_io_number_of_io_data_objects,",1
"      { ""NumberOfIODataObjects"", ""pn_io.number_of_io_data_objects"",",1
"    { &hf_pn_io_number_of_iocs,",1
"      { ""NumberOfIOCS"", ""pn_io.number_of_iocs"",",1
"    { &hf_pn_io_iocs_frame_offset,",1
"      { ""IOCSFrameOffset"", ""pn_io.iocs_frame_offset"",",1
"    { &hf_pn_io_alarmcr_type,",1
"      { ""AlarmCRType"", ""pn_io.alarmcr_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_alarmcr_type), 0x0,",1
"    { &hf_pn_io_alarmcr_properties,",1
"      { ""AlarmCRProperties"", ""pn_io.alarmcr_properties"",",1
"    { &hf_pn_io_alarmcr_properties_priority,",1
"      { ""priority"", ""pn_io.alarmcr_properties.priority"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_alarmcr_properties_priority), 0x00000001,",1
"    { &hf_pn_io_alarmcr_properties_transport,",1
"      { ""Transport"", ""pn_io.alarmcr_properties.transport"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_alarmcr_properties_transport), 0x00000002,",1
"    { &hf_pn_io_alarmcr_properties_reserved,",1
"      { ""Reserved"", ""pn_io.alarmcr_properties.reserved"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xFFFFFFFC,",1
"    { &hf_pn_io_rta_timeoutfactor,",1
"      { ""RTATimeoutFactor"", ""pn_io.rta_timeoutfactor"",",1
"    { &hf_pn_io_rta_retries,",1
"      { ""RTARetries"", ""pn_io.rta_retries"",",1
"    },  /* XXX - only values 3 - 15 allowed */",1
"    { &hf_pn_io_localalarmref,",1
"      { ""LocalAlarmReference"", ""pn_io.localalarmref"",",1
"    { &hf_pn_io_remotealarmref,",1
"      { ""RemoteAlarmReference"", ""pn_io.remotealarmref"",",1
"    { &hf_pn_io_maxalarmdatalength,",1
"      { ""MaxAlarmDataLength"", ""pn_io.maxalarmdatalength"",",1
"    },  /* XXX - only values 200 - 1432 allowed */",1
"    { &hf_pn_io_alarmcr_tagheaderhigh,",1
"      { ""AlarmCRTagHeaderHigh"", ""pn_io.alarmcr_tagheaderhigh"",",1
"    },  /* XXX - 16 bitfield! */",1
"    { &hf_pn_io_alarmcr_tagheaderlow,",1
"      { ""AlarmCRTagHeaderLow"", ""pn_io.alarmcr_tagheaderlow"",",1
"    },  /* XXX - 16 bitfield!*/",1
"    { &hf_pn_io_api_tree,",1
"      { ""API"", ""pn_io.api_tree"",",1
"    { &hf_pn_io_module_tree,",1
"      { ""Module"", ""pn_io.module_tree"",",1
"    { &hf_pn_io_submodule_tree,",1
"      { ""Submodule"", ""pn_io.submodule_tree"",",1
"    { &hf_pn_io_io_data_object,",1
"      { ""IODataObject"", ""pn_io.io_data_object"",",1
"    { &hf_pn_io_io_data_object_frame_offset,",1
"        { ""IODataObjectFrameOffset"", ""pn_io.io_data_object.frame_offset"",",1
"    { &hf_pn_io_io_cs,",1
"      { ""IOCS"", ""pn_io.io_cs"",",1
"    { &hf_pn_io_substitutionmode,",1
"      { ""Substitutionmode"", ""pn_io.substitutionmode"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_substitutionmode), 0x0,",1
"    { &hf_pn_io_IRData_uuid,",1
"      { ""IRDataUUID"", ""pn_io.IRData_uuid"",",1
"        FT_GUID, BASE_NONE, NULL, 0x0,",1
"    { &hf_pn_io_ar_uuid,",1
"      { ""ARUUID"", ""pn_io.ar_uuid"",",1
"    { &hf_pn_io_target_ar_uuid,",1
"      { ""TargetARUUID"", ""pn_io.target_ar_uuid"",",1
"    { &hf_pn_io_ar_discriminator,",1
"      { ""Discriminator"", ""pn_io.ar_discriminator"",",1
"    { &hf_pn_io_ar_configid,",1
"      { ""ConfigID"", ""pn_io.ar_configid"",",1
"    { &hf_pn_io_ar_arnumber,",1
"      { ""ARnumber"", ""pn_io.ar_arnumber"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ar_arnumber), 0x0007,",1
"    { &hf_pn_io_ar_arresource,",1
"      { ""ARresource"", ""pn_io.ar_arnumber"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ar_arresource), 0x0018,",1
"    { &hf_pn_io_ar_arreserved,",1
"      { ""ARreserved"", ""pn_io.ar_arreserved"",",1
"        FT_UINT16, BASE_HEX, NULL, 0xFFE0,",1
"    { &hf_pn_io_ar_selector,",1
"      { ""Selector"", ""pn_io.ar_selector"",",1
"    { &hf_pn_io_api,",1
"      { ""API"", ""pn_io.api"",",1
"    { &hf_pn_io_slot_nr,",1
"      { ""SlotNumber"", ""pn_io.slot_nr"",",1
"    { &hf_pn_io_subslot_nr,",1
"      { ""SubslotNumber"", ""pn_io.subslot_nr"",",1
"    { &hf_pn_io_index,",1
"      { ""Index"", ""pn_io.index"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_index), 0x0,",1
"    { &hf_pn_io_seq_number,",1
"      { ""SeqNumber"", ""pn_io.seq_number"",",1
"    { &hf_pn_io_record_data_length,",1
"      { ""RecordDataLength"", ""pn_io.record_data_length"",",1
"    { &hf_pn_io_add_val1,",1
"      { ""AdditionalValue1"", ""pn_io.add_val1"",",1
"    { &hf_pn_io_add_val2,",1
"      { ""AdditionalValue2"", ""pn_io.add_val2"",",1
"    { &hf_pn_io_block_header,",1
"      { ""BlockHeader"", ""pn_io.block_header"",",1
"    { &hf_pn_io_block_type,",1
"      { ""BlockType"", ""pn_io.block_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_block_type), 0x0,",1
"    { &hf_pn_io_block_length,",1
"      { ""BlockLength"", ""pn_io.block_length"",",1
"    { &hf_pn_io_block_version_high,",1
"      { ""BlockVersionHigh"", ""pn_io.block_version_high"",",1
"    { &hf_pn_io_block_version_low,",1
"      { ""BlockVersionLow"", ""pn_io.block_version_low"",",1
"    { &hf_pn_io_sessionkey,",1
"      { ""SessionKey"", ""pn_io.session_key"",",1
"    { &hf_pn_io_control_command,",1
"      { ""ControlCommand"", ""pn_io.control_command"",",1
"    { &hf_pn_io_control_command_reserved,",1
"      { ""ControlBlockProperties.reserved"", ""pn_io.control_properties_reserved"",",1
"    { &hf_pn_io_control_command_prmend,",1
"      { ""PrmEnd"", ""pn_io.control_command.prmend"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0001,",1
"    { &hf_pn_io_control_command_applready,",1
"      { ""ApplicationReady"", ""pn_io.control_command.applready"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0002,",1
"    { &hf_pn_io_control_command_release,",1
"      { ""Release"", ""pn_io.control_command.release"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0004,",1
"    { &hf_pn_io_control_command_done,",1
"      { ""Done"", ""pn_io.control_command.done"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0008,",1
"    { &hf_pn_io_control_command_ready_for_companion,",1
"      { ""ReadyForCompanion"", ""pn_io.control_command.ready_for_companion"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0010,",1
"    { &hf_pn_io_control_command_ready_for_rt_class3,",1
"      { ""ReadyForRT Class 3"", ""pn_io.control_command.ready_for_rt_class3"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0020,",1
"    { &hf_pn_io_control_command_prmbegin,",1
"      { ""PrmBegin"", ""pn_io.control_command.prmbegin"",",1
"        FT_UINT16, BASE_DEC, VALS(pn_io_control_properties_prmbegin_vals), 0x0040,",1
"    { &hf_pn_io_control_command_reserved_7_15,",1
"      { ""ControlBlockProperties.reserved"", ""pn_io.control_properties_reserved_7_15"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x0FF80,",1
"    { &hf_pn_io_control_block_properties,",1
"      { ""ControlBlockProperties"", ""pn_io.control_block_properties"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_control_properties_vals), 0x0,",1
"    { &hf_pn_io_control_block_properties_applready,",1
"      { ""ControlBlockProperties"", ""pn_io.control_block_properties.appl_ready"",",1
"    { &hf_pn_io_control_block_properties_applready0,",1
"      { ""ApplicationReady"", ""pn_io.control_block_properties.appl_ready0"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_control_properties_application_ready_vals), 0x0001,",1
"    { &hf_pn_io_SubmoduleListEntries,",1
"      { ""NumberOfEntries"", ""pn_io.SubmoduleListEntries"",",1
"    { &hf_pn_io_error_code,",1
"      { ""ErrorCode"", ""pn_io.error_code"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_error_code), 0x0,",1
"    { &hf_pn_io_error_decode,",1
"      { ""ErrorDecode"", ""pn_io.error_decode"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_error_decode), 0x0,",1
"    { &hf_pn_io_error_code1,",1
"      { ""ErrorCode1"", ""pn_io.error_code1"",",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code1), 0x0,",1
"    { &hf_pn_io_error_code2,",1
"      { ""ErrorCode2"", ""pn_io.error_code2"",",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2), 0x0,",1
"    { &hf_pn_io_error_code1_pniorw,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code1_pniorw), 0x0,",1
"    { &hf_pn_io_error_code2_pniorw,",1
"      { ""ErrorCode2 for PNIORW is user specified!"", ""pn_io.error_code2"",",1
"    { &hf_pn_io_error_code1_pnio,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code1_pnio), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_1,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_1), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_2,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_2), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_3,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_3), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_4,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_4), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_5,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_5), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_6,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_6), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_7,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_7), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_8,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_8), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_13,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_13), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_20,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_20), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_21,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_21), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_22,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_22), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_23,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_23), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_40,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_40), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_60,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_60), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_61,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_61), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_62,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_62), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_63,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_63), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_64,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_64), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_65,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_65), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_66,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_66), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_70,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_70), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_71,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_71), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_72,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_72), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_73,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_73), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_74,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_74), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_75,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_75), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_76,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_76), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_77,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_77), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_253,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_253), 0x0,",1
"    { &hf_pn_io_error_code2_pnio_255,",1
"        FT_UINT8, BASE_DEC, VALS(pn_io_error_code2_pnio_255), 0x0,",1
"    { &hf_pn_io_block,",1
"      { ""Block"", ""pn_io.block"",",1
"    { &hf_pn_io_alarm_type,",1
"      { ""AlarmType"", ""pn_io.alarm_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_alarm_type), 0x0,",1
"    { &hf_pn_io_alarm_specifier,",1
"      { ""AlarmSpecifier"", ""pn_io.alarm_specifier"",",1
"    { &hf_pn_io_alarm_specifier_sequence,",1
"      { ""SequenceNumber"", ""pn_io.alarm_specifier.sequence"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x07FF,",1
"    { &hf_pn_io_alarm_specifier_channel,",1
"      { ""ChannelDiagnosis"", ""pn_io.alarm_specifier.channel"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x0800,",1
"    { &hf_pn_io_alarm_specifier_manufacturer,",1
"      { ""ManufacturerSpecificDiagnosis"", ""pn_io.alarm_specifier.manufacturer"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x1000,",1
"    { &hf_pn_io_alarm_specifier_submodule,",1
"      { ""SubmoduleDiagnosisState"", ""pn_io.alarm_specifier.submodule"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x2000,",1
"    { &hf_pn_io_alarm_specifier_ardiagnosis,",1
"      { ""ARDiagnosisState"", ""pn_io.alarm_specifier.ardiagnosis"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x8000,",1
"    { &hf_pn_io_alarm_dst_endpoint,",1
"      { ""AlarmDstEndpoint"", ""pn_io.alarm_dst_endpoint"",",1
"    { &hf_pn_io_alarm_src_endpoint,",1
"      { ""AlarmSrcEndpoint"", ""pn_io.alarm_src_endpoint"",",1
"    { &hf_pn_io_pdu_type,",1
"      { ""PDUType"", ""pn_io.pdu_type"",",1
"    { &hf_pn_io_pdu_type_type,",1
"      { ""Type"", ""pn_io.pdu_type.type"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_pdu_type), 0x0F,",1
"    { &hf_pn_io_pdu_type_version,",1
"      { ""Version"", ""pn_io.pdu_type.version"",",1
"        FT_UINT8, BASE_HEX, NULL, 0xF0,",1
"    { &hf_pn_io_add_flags,",1
"      { ""AddFlags"", ""pn_io.add_flags"",",1
"    { &hf_pn_io_window_size,",1
"      { ""WindowSize"", ""pn_io.window_size"",",1
"        FT_UINT8, BASE_DEC, NULL, 0x0F,",1
"    { &hf_pn_io_tack,",1
"      { ""TACK"", ""pn_io.tack"",",1
"    { &hf_pn_io_send_seq_num,",1
"      { ""SendSeqNum"", ""pn_io.send_seq_num"",",1
"    { &hf_pn_io_ack_seq_num,",1
"      { ""AckSeqNum"", ""pn_io.ack_seq_num"",",1
"    { &hf_pn_io_var_part_len,",1
"      { ""VarPartLen"", ""pn_io.var_part_len"",",1
"    { &hf_pn_io_module_ident_number,",1
"      { ""ModuleIdentNumber"", ""pn_io.module_ident_number"",",1
"    { &hf_pn_io_submodule_ident_number,",1
"      { ""SubmoduleIdentNumber"", ""pn_io.submodule_ident_number"",",1
"    { &hf_pn_io_number_of_modules,",1
"      { ""NumberOfModules"", ""pn_io.number_of_modules"",",1
"    { &hf_pn_io_module_properties,",1
"      { ""ModuleProperties"", ""pn_io.module_properties"",",1
"    { &hf_pn_io_module_state,",1
"      { ""ModuleState"", ""pn_io.module_state"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_module_state), 0x0,",1
"    { &hf_pn_io_number_of_submodules,",1
"      { ""NumberOfSubmodules"", ""pn_io.number_of_submodules"",",1
"    { &hf_pn_io_submodule_properties,",1
"      { ""SubmoduleProperties"", ""pn_io.submodule_properties"",",1
"    { &hf_pn_io_submodule_properties_type,",1
"      { ""Type"", ""pn_io.submodule_properties.type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_properties_type), 0x0003,",1
"    { &hf_pn_io_submodule_properties_shared_input,",1
"      { ""SharedInput"", ""pn_io.submodule_properties.shared_input"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_properties_shared_input), 0x0004,",1
"    { &hf_pn_io_submodule_properties_reduce_input_submodule_data_length,",1
"      { ""ReduceInputSubmoduleDataLength"", ""pn_io.submodule_properties.reduce_input_submodule_data_length"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_properties_reduce_input_submodule_data_length), 0x0008,",1
"    { &hf_pn_io_submodule_properties_reduce_output_submodule_data_length,",1
"      { ""ReduceOutputSubmoduleDataLength"", ""pn_io.submodule_properties.reduce_output_submodule_data_length"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_properties_reduce_output_submodule_data_length), 0x0010,",1
"    { &hf_pn_io_submodule_properties_discard_ioxs,",1
"      { ""DiscardIOXS"", ""pn_io.submodule_properties.discard_ioxs"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_properties_discard_ioxs), 0x0020,",1
"    { &hf_pn_io_submodule_properties_reserved,",1
"      { ""Reserved"", ""pn_io.submodule_properties.reserved"",",1
"        FT_UINT16, BASE_HEX, NULL, 0xFFC0,",1
"    { &hf_pn_io_submodule_state,",1
"      { ""SubmoduleState"", ""pn_io.submodule_state"",",1
"    { &hf_pn_io_submodule_state_format_indicator,",1
"      { ""FormatIndicator"", ""pn_io.submodule_state.format_indicator"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_format_indicator), 0x8000,",1
"    { &hf_pn_io_submodule_state_add_info,",1
"      { ""AddInfo"", ""pn_io.submodule_state.add_info"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_add_info), 0x0007,",1
"    { &hf_pn_io_submodule_state_qualified_info,",1
"      { ""QualifiedInfo"", ""pn_io.submodule_state.qualified_info"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_qualified_info), 0x0008,",1
"    { &hf_pn_io_submodule_state_maintenance_required,",1
"      { ""MaintenanceRequired"", ""pn_io.submodule_state.maintenance_required"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_maintenance_required), 0x0010,",1
"    { &hf_pn_io_submodule_state_maintenance_demanded,",1
"      { ""MaintenanceDemanded"", ""pn_io.submodule_state.maintenance_demanded"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_maintenance_demanded), 0x0020,",1
"    { &hf_pn_io_submodule_state_diag_info,",1
"      { ""DiagInfo"", ""pn_io.submodule_state.diag_info"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_diag_info), 0x0040,",1
"    { &hf_pn_io_submodule_state_ar_info,",1
"      { ""ARInfo"", ""pn_io.submodule_state.ar_info"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_ar_info), 0x0780,",1
"    { &hf_pn_io_submodule_state_ident_info,",1
"      { ""IdentInfo"", ""pn_io.submodule_state.ident_info"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_ident_info), 0x7800,",1
"    { &hf_pn_io_submodule_state_detail,",1
"      { ""Detail"", ""pn_io.submodule_state.detail"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_submodule_state_detail), 0x7FFF,",1
"    { &hf_pn_io_data_description_tree,",1
"      { ""DataDescription"", ""pn_io.data_description_tree"",",1
"    { &hf_pn_io_data_description,",1
"      { ""DataDescription"", ""pn_io.data_description"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_data_description), 0x0,",1
"    { &hf_pn_io_submodule_data_length,",1
"      { ""SubmoduleDataLength"", ""pn_io.submodule_data_length"",",1
"    { &hf_pn_io_length_iocs,",1
"      { ""LengthIOCS"", ""pn_io.length_iocs"",",1
"    { &hf_pn_io_length_iops,",1
"      { ""LengthIOPS"", ""pn_io.length_iops"",",1
"    { &hf_pn_io_iocs,",1
"      { ""IOCS"", ""pn_io.ioxs"",",1
"        FT_UINT8, BASE_HEX, NULL, 0x0,",1
"    { &hf_pn_io_iops,",1
"      { ""IOPS"", ""pn_io.ioxs"",",1
"    { &hf_pn_io_ioxs_extension,",1
"      { ""Extension (1:another IOxS follows/0:no IOxS follows)"", ""pn_io.ioxs.extension"",",1
"        FT_UINT8, BASE_HEX, NULL, 0x01,",1
"    { &hf_pn_io_ioxs_res14,",1
"      { ""Reserved (should be zero)"", ""pn_io.ioxs.res14"",",1
"        FT_UINT8, BASE_HEX, NULL, 0x1E,",1
"    { &hf_pn_io_ioxs_instance,",1
"      { ""Instance (only valid, if DataState is bad)"",",1
"        ""pn_io.ioxs.instance"", FT_UINT8, BASE_HEX, VALS(pn_io_ioxs),",1
"        0x60, NULL, HFILL }",1
"    { &hf_pn_io_ioxs_datastate,",1
"      { ""DataState (1:good/0:bad)"", ""pn_io.ioxs.datastate"",",1
"        FT_UINT8, BASE_HEX, NULL, 0x80,",1
"    { &hf_pn_io_address_resolution_properties,",1
"      { ""AddressResolutionProperties"", ""pn_io.address_resolution_properties"",",1
"    { &hf_pn_io_mci_timeout_factor,",1
"      { ""MCITimeoutFactor"", ""pn_io.mci_timeout_factor"",",1
"    { &hf_pn_io_provider_station_name,",1
"      { ""ProviderStationName"", ""pn_io.provider_station_name"",",1
"    { &hf_pn_io_user_structure_identifier,",1
"      { ""UserStructureIdentifier"", ""pn_io.user_structure_identifier"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_user_structure_identifier), 0x0,",1
"    { &hf_pn_io_user_structure_identifier_manf,",1
"      { ""UserStructureIdentifier manufacturer specific"", ""pn_io.user_structure_identifier_manf"",",1
"    { &hf_pn_io_ar_properties_reserved_1,",1
"        { ""Reserved_1"", ""pn_io.ar_properties.reserved_1"",",1
"           FT_UINT32, BASE_HEX, NULL, 0x000000E0,",1
"    { &hf_pn_io_ar_properties_device_access,",1
"        { ""DeviceAccess"", ""pn_io.ar_properties.device_access"",",1
"          FT_UINT32, BASE_HEX, VALS(pn_io_arproperties_DeviceAccess), 0x00000100,",1
"          NULL, HFILL }},",1
"    { &hf_pn_io_subframe_data,",1
"      { ""SubFrameData"", ""pn_io.subframe_data"",",1
"    { &hf_pn_io_subframe_reserved2,",1
"      { ""Reserved1"", ""pn_io.subframe_data.reserved2"",",1
"    { &hf_pn_io_subframe_data_length,",1
"      { ""DataLength"", ""pn_io.subframe_data.data_length"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0000FF00,",1
"    { &hf_pn_io_subframe_reserved1,",1
"      { ""Reserved1"", ""pn_io.subframe_data.reserved1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x00000080,",1
"    { &hf_pn_io_subframe_data_position,",1
"      { ""DataPosition"", ""pn_io.subframe_data.position"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0000007F,",1
"    { &hf_pn_io_subframe_data_reserved1,",1
"      { ""Reserved1"", ""pn_io.subframe_data.reserved_1"",",1
"    { &hf_pn_io_subframe_data_reserved2,",1
"      { ""Reserved1"", ""pn_io.subframe_data.reserved_2"",",1
"    { &hf_pn_io_channel_number,",1
"      { ""ChannelNumber"", ""pn_io.channel_number"",",1
"    { &hf_pn_io_channel_properties,",1
"      { ""ChannelProperties"", ""pn_io.channel_properties"",",1
"    { &hf_pn_io_channel_properties_type,",1
"      { ""Type"", ""pn_io.channel_properties.type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_channel_properties_type), 0x00FF,",1
"    { &hf_pn_io_channel_properties_accumulative,",1
"      { ""Accumulative"", ""pn_io.channel_properties.accumulative"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_channel_properties_accumulative_vals), 0x0100,",1
"    { &hf_pn_io_NumberOfSubframeBlocks,",1
"      { ""NumberOfSubframeBlocks"", ""pn_io.NumberOfSubframeBlocks"",",1
"    { &hf_pn_io_channel_properties_maintenance,",1
"      { ""Maintenance (Severity)"", ""pn_io.channel_properties.maintenance"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_channel_properties_maintenance), 0x0600,",1
"      { &hf_pn_io_channel_properties_specifier,",1
"        { ""Specifier"", ""pn_io.channel_properties.specifier"",",1
"          FT_UINT16, BASE_HEX, VALS(pn_io_channel_properties_specifier), 0x1800,",1
"          NULL, HFILL }",1
"      },",1
"    { &hf_pn_io_channel_properties_direction,",1
"      { ""Direction"", ""pn_io.channel_properties.direction"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_channel_properties_direction), 0xE000,",1
"    { &hf_pn_io_channel_error_type,",1
"      { ""ChannelErrorType"", ""pn_io.channel_error_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_channel_error_type), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type0"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8000,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type0800"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8000), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8001,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8001"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8001), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8002,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8002"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8002), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8003,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8003"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8003), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8004,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8004"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8004), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8005,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8005"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8005), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8007,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8007"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8007), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x8008,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type8008"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x8008), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x800A,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type800A"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x800A), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x800B,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type800B"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x800B), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type0x800C,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type800C"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_ext_channel_error_type0x800C), 0x0,",1
"    { &hf_pn_io_ext_channel_error_type,",1
"      { ""ExtChannelErrorType"", ""pn_io.ext_channel_error_type"",",1
"    { &hf_pn_io_ext_channel_add_value,",1
"      { ""ExtChannelAddValue"", ""pn_io.ext_channel_add_value"",",1
"    { &hf_pn_io_ptcp_subdomain_id,",1
"      { ""PTCPSubdomainID"", ""pn_io.ptcp_subdomain_id"",",1
"    { &hf_pn_io_ir_data_id,",1
"      { ""IRDataID"", ""pn_io.ir_data_id"",",1
"    { &hf_pn_io_max_bridge_delay,",1
"      { ""MaxBridgeDelay"", ""pn_io.max_bridge_delay"",",1
"    { &hf_pn_io_number_of_ports,",1
"      { ""NumberOfPorts"", ""pn_io.number_of_ports"",",1
"    { &hf_pn_io_max_port_tx_delay,",1
"      { ""MaxPortTxDelay"", ""pn_io.max_port_tx_delay"",",1
"    { &hf_pn_io_max_port_rx_delay,",1
"      { ""MaxPortRxDelay"", ""pn_io.max_port_rx_delay"",",1
"   { &hf_pn_io_max_line_rx_delay,",1
"     { ""MaxLineRxDelay"", ""pn_io.max_line_rx_delay"",",1
"       FT_UINT32, BASE_DEC, NULL, 0x0,",1
"   },",1
"   { &hf_pn_io_yellowtime,",1
"     { ""YellowTime"", ""pn_io.yellowtime"",",1
"    { &hf_pn_io_reserved_interval_begin,",1
"      { ""ReservedIntervalBegin"", ""pn_io.reserved_interval_begin"",",1
"    { &hf_pn_io_reserved_interval_end,",1
"      { ""ReservedIntervalEnd"", ""pn_io.reserved_interval_end"",",1
"    { &hf_pn_io_pllwindow,",1
"      { ""PLLWindow"", ""pn_io.pllwindow"",",1
"    { &hf_pn_io_sync_send_factor,",1
"      { ""SyncSendFactor"", ""pn_io.sync_send_factor"",",1
"    { &hf_pn_io_sync_properties,",1
"      { ""SyncProperties"", ""pn_io.sync_properties"",",1
"    { &hf_pn_io_sync_frame_address,",1
"      { ""SyncFrameAddress"", ""pn_io.sync_frame_address"",",1
"    { &hf_pn_io_ptcp_timeout_factor,",1
"      { ""PTCPTimeoutFactor"", ""pn_io.ptcp_timeout_factor"",",1
"    { &hf_pn_io_ptcp_takeover_timeout_factor,",1
"      { ""PTCPTakeoverTimeoutFactor"", ""pn_io.ptcp_takeover_timeout_factor"",",1
"    { &hf_pn_io_ptcp_master_startup_time,",1
"      { ""PTCPMasterStartupTime"", ""pn_io.ptcp_master_startup_time"",",1
"    { &hf_pn_io_ptcp_master_priority_1,",1
"      { ""PTCP_MasterPriority1"", ""pn_io.ptcp_master_priority_1"",",1
"    { &hf_pn_io_ptcp_master_priority_2,",1
"      { ""PTCP_MasterPriority2"", ""pn_io.ptcp_master_priority_2"",",1
"    { &hf_pn_io_ptcp_length_subdomain_name,",1
"      { ""PTCPLengthSubdomainName"", ""pn_io.ptcp_length_subdomain_name"",",1
"    { &hf_pn_io_ptcp_subdomain_name,",1
"      { ""PTCPSubdomainName"", ""pn_io.ptcp_subdomain_name"",",1
"    { &hf_pn_io_MultipleInterfaceMode_NameOfDevice,",1
"      { ""MultipleInterfaceMode.NameOfDevice"", ""pn_io.MultipleInterfaceMode_NameOfDevice"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_MultipleInterfaceMode_NameOfDevice), 0x01,",1
"    { &hf_pn_io_MultipleInterfaceMode_reserved_1,",1
"      { ""MultipleInterfaceMode.Reserved_1"", ""pn_io.MultipleInterfaceMode_reserved_1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xFFFE,",1
"    { &hf_pn_io_MultipleInterfaceMode_reserved_2,",1
"      { ""MultipleInterfaceMode.Reserved_2"", ""pn_io.MultipleInterfaceMode_reserved_2"",",1
"    { &hf_pn_io_pdportstatistic_counter_status,",1
"      { ""CounterStatus"", ""pn_io.CounterStatus"",",1
"    { &hf_pn_io_pdportstatistic_counter_status_ifInOctets,",1
"      { ""CounterStatus.ifInOctets"", ""pn_io.CounterStatus.ifInOctets"",",1
"        FT_BOOLEAN, 16, TFS(&pn_io_pdportstatistic_counter_status_ifInOctets), 0x0001,",1
"    { &hf_pn_io_pdportstatistic_counter_status_ifOutOctets,",1
"      { ""CounterStatus.ifOutOctets"", ""pn_io.CounterStatus.ifOutOctets"",",1
"        FT_BOOLEAN, 16, TFS(&pn_io_pdportstatistic_counter_status_ifOutOctets), 0x0002,",1
"         NULL, HFILL }",1
"    { &hf_pn_io_pdportstatistic_counter_status_ifInDiscards,",1
"      { ""CounterStatus.ifInDiscards"", ""pn_io.CounterStatus.ifInDiscards"",",1
"        FT_BOOLEAN, 16, TFS(&pn_io_pdportstatistic_counter_status_ifInDiscards), 0x0004,",1
"    { &hf_pn_io_pdportstatistic_counter_status_ifOutDiscards,",1
"      { ""CounterStatus.ifOutDiscards"", ""pn_io.CounterStatus.ifOutDiscards"",",1
"        FT_BOOLEAN, 16, TFS(&pn_io_pdportstatistic_counter_status_ifOutDiscards), 0x0008,",1
"    { &hf_pn_io_pdportstatistic_counter_status_ifInErrors,",1
"      { ""CounterStatus.ifInErrors"", ""pn_io.CounterStatus.ifInErrors"",",1
"        FT_BOOLEAN, 16, TFS(&pn_io_pdportstatistic_counter_status_ifInErrors), 0x0010,",1
"    { &hf_pn_io_pdportstatistic_counter_status_ifOutErrors,",1
"      { ""CounterStatus.ifOutErrors"", ""pn_io.CounterStatus.ifOutErrors"",",1
"        FT_BOOLEAN, 16, TFS(&pn_io_pdportstatistic_counter_status_ifOutErrors), 0x0020,",1
"    { &hf_pn_io_pdportstatistic_counter_status_reserved,",1
"      { ""CounterStatus.Reserved"", ""pn_io.CounterStatus.Reserved"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_pdportstatistic_counter_status_reserved), 0xFFC0,",1
"    { &hf_pn_io_pdportstatistic_ifInOctets,",1
"      { ""ifInOctets"", ""pn_io.ifInOctets"",",1
"    { &hf_pn_io_pdportstatistic_ifOutOctets,",1
"      { ""ifOutOctets"", ""pn_io.ifOutOctets"",",1
"    { &hf_pn_io_pdportstatistic_ifInDiscards,",1
"      { ""ifInDiscards"", ""pn_io.ifInDiscards"",",1
"    { &hf_pn_io_pdportstatistic_ifOutDiscards,",1
"      { ""ifOutDiscards"", ""pn_io.ifOutDiscards"",",1
"    { &hf_pn_io_pdportstatistic_ifInErrors,",1
"      { ""ifInErrors"", ""pn_io.ifInErrors"",",1
"    { &hf_pn_io_pdportstatistic_ifOutErrors,",1
"      { ""ifOutErrors"", ""pn_io.ifOutErrors"",",1
"    { &hf_pn_io_domain_boundary,",1
"      { ""DomainBoundary"", ""pn_io.domain_boundary"",",1
"    { &hf_pn_io_domain_boundary_ingress,",1
"      { ""DomainBoundaryIngress"", ""pn_io.domain_boundary.ingress"",",1
"    { &hf_pn_io_domain_boundary_egress,",1
"      { ""DomainBoundaryEgress"", ""pn_io.domain_boundary.egress"",",1
"    { &hf_pn_io_multicast_boundary,",1
"      { ""MulticastBoundary"", ""pn_io.multicast_boundary"",",1
"    { &hf_pn_io_adjust_properties,",1
"      { ""AdjustProperties"", ""pn_io.adjust_properties"",",1
"    { &hf_pn_io_PreambleLength,",1
"      { ""Preamble Length"", ""pn_io.preamble_length"",",1
"        FT_UINT16, BASE_DEC_HEX, VALS(pn_io_preamble_length), 0x0,",1
"    { &hf_pn_io_mau_type,",1
"      { ""MAUType"", ""pn_io.mau_type"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_mau_type), 0x0,",1
"    { &hf_pn_io_mau_type_mode,",1
"      { ""MAUTypeMode"", ""pn_io.mau_type_mode"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_mau_type_mode), 0x0,",1
"    { &hf_pn_io_port_state,",1
"      { ""PortState"", ""pn_io.port_state"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_port_state), 0x0,",1
"    { &hf_pn_io_line_delay,",1
"      { ""LineDelay"", ""pn_io.line_delay"",",1
"        ""LineDelay in nanoseconds"", HFILL }",1
"    { &hf_pn_io_line_delay_value,",1
"      { ""LineDelayValue"", ""pn_io.line_delay_value"",",1
"        FT_UINT32, BASE_DEC | BASE_RANGE_STRING, RVALS(pn_io_line_delay_value), 0x7FFFFFFF,",1
"    { &hf_pn_io_cable_delay_value,",1
"      { ""CableDelayValue"", ""pn_io.cable_delay_value"",",1
"         FT_UINT32, BASE_DEC | BASE_RANGE_STRING, RVALS(pn_io_cable_delay_value), 0x7FFFFFFF,",1
"    { &hf_pn_io_line_delay_format_indicator,",1
"      { ""LineDelayFormatIndicator"", ""pn_io.line_delay_format_indicator"",",1
"        ""LineDelay FormatIndicator"", HFILL }",1
"    { &hf_pn_io_number_of_peers,",1
"      { ""NumberOfPeers"", ""pn_io.number_of_peers"",",1
"    { &hf_pn_io_length_peer_port_id,",1
"      { ""LengthPeerPortID"", ""pn_io.length_peer_port_id"",",1
"    { &hf_pn_io_peer_port_id,",1
"      { ""PeerPortID"", ""pn_io.peer_port_id"",",1
"    { &hf_pn_io_length_peer_chassis_id,",1
"      { ""LengthPeerChassisID"", ""pn_io.length_peer_chassis_id"",",1
"    { &hf_pn_io_peer_chassis_id,",1
"      { ""PeerChassisID"", ""pn_io.peer_chassis_id"",",1
"    { &hf_pn_io_length_own_chassis_id,",1
"      { ""LengthOwnChassisID"", ""pn_io.length_own_chassis_id"",",1
"    { &hf_pn_io_own_chassis_id,",1
"      { ""OwnChassisID"", ""pn_io.own_chassis_id"",",1
"    { &hf_pn_io_length_own_port_id,",1
"      { ""LengthOwnPortID"", ""pn_io.length_own_port_id"",",1
"    { &hf_pn_io_own_port_id,",1
"      { ""OwnPortID"", ""pn_io.own_port_id"",",1
"    { &hf_pn_io_peer_macadd,",1
"      { ""PeerMACAddress"", ""pn_io.peer_macadd"",",1
"    { &hf_pn_io_macadd,",1
"      { ""MACAddress"", ""pn_io.macadd"",",1
"    { &hf_pn_io_media_type,",1
"      { ""MediaType"", ""pn_io.media_type"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_media_type), 0x0,",1
"    { &hf_pn_io_ethertype,",1
"      { ""Ethertype"", ""pn_io.ethertype"",",1
"    { &hf_pn_io_rx_port,",1
"      { ""RXPort"", ""pn_io.rx_port"",",1
"    { &hf_pn_io_frame_details,",1
"      { ""FrameDetails"", ""pn_io.frame_details"",",1
"    { &hf_pn_io_frame_details_sync_frame,",1
"      { ""SyncFrame"", ""pn_io.frame_details.sync_frame"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_frame_details_sync_master_vals), 0x03,",1
"    { &hf_pn_io_frame_details_meaning_frame_send_offset,",1
"      { ""Meaning"", ""pn_io.frame_details.meaning_frame_send_offset"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_frame_details_meaning_frame_send_offset_vals), 0x0C,",1
"    { &hf_pn_io_frame_details_reserved,",1
"      { ""Reserved"", ""pn_io.frame_details.reserved"",",1
"    { &hf_pn_io_nr_of_tx_port_groups,",1
"      { ""NumberOfTxPortGroups"", ""pn_io.nr_of_tx_port_groups"",",1
"    { &hf_pn_io_TxPortGroupProperties,",1
"      { ""TxPortGroupProperties"", ""pn_io.tx_port_properties"",",1
"    { &hf_pn_io_TxPortGroupProperties_bit0,",1
"      { ""TxPortLocal"", ""pn_io.tx_port_properties_bit_0"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x01,",1
"    { &hf_pn_io_TxPortGroupProperties_bit1,",1
"      { ""TxPort_1"", ""pn_io.tx_port_properties_bit_1"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x02,",1
"    { &hf_pn_io_TxPortGroupProperties_bit2,",1
"      { ""TxPort_2"", ""pn_io.tx_port_properties_bit_2"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x04,",1
"    { &hf_pn_io_TxPortGroupProperties_bit3,",1
"      { ""TxPort_3"", ""pn_io.tx_port_properties_bit_3"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x08,",1
"    { &hf_pn_io_TxPortGroupProperties_bit4,",1
"      { ""TxPort_4"", ""pn_io.tx_port_properties_bit_4"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x10,",1
"    { &hf_pn_io_TxPortGroupProperties_bit5,",1
"      { ""TxPort_5"", ""pn_io.tx_port_properties_bit_5"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x20,",1
"    { &hf_pn_io_TxPortGroupProperties_bit6,",1
"      { ""TxPort_6"", ""pn_io.tx_port_properties_bit_6"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x40,",1
"    { &hf_pn_io_TxPortGroupProperties_bit7,",1
"      { ""TxPort_7"", ""pn_io.tx_port_properties_bit_7"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_txgroup_state), 0x80,",1
"    { &hf_pn_io_start_of_red_frame_id,",1
"      { ""StartOfRedFrameID"", ""pn_io.start_of_red_frame_id"",",1
"    { &hf_pn_io_end_of_red_frame_id,",1
"      { ""EndOfRedFrameID"", ""pn_io.end_of_red_frame_id"",",1
"    { &hf_pn_io_ir_begin_end_port,",1
"      { ""Port"", ""pn_io.ir_begin_end_port"",",1
"    { &hf_pn_io_number_of_assignments,",1
"      { ""NumberOfAssignments"", ""pn_io.number_of_assignments"",",1
"    { &hf_pn_io_number_of_phases,",1
"      { ""NumberOfPhases"", ""pn_io.number_of_phases"",",1
"    { &hf_pn_io_red_orange_period_begin_tx,",1
"      { ""RedOrangePeriodBegin [TX]"", ""pn_io.red_orange_period_begin_tx"",",1
"    { &hf_pn_io_orange_period_begin_tx,",1
"      { ""OrangePeriodBegin [TX]"", ""pn_io.orange_period_begin_tx"",",1
"    { &hf_pn_io_green_period_begin_tx,",1
"      { ""GreenPeriodBegin [TX]"", ""pn_io.green_period_begin_tx"",",1
"    { &hf_pn_io_red_orange_period_begin_rx,",1
"      { ""RedOrangePeriodBegin [RX]"", ""pn_io.red_orange_period_begin_rx"",",1
"    { &hf_pn_io_orange_period_begin_rx,",1
"      { ""OrangePeriodBegin [RX]"", ""pn_io.orange_period_begin_rx"",",1
"    { &hf_pn_io_green_period_begin_rx,",1
"      { ""GreenPeriodBegin [RX]"", ""pn_io.green_period_begin_rx"",",1
"    { &hf_pn_ir_tx_phase_assignment,",1
"      { ""TXPhaseAssignment"", ""pn_io.tx_phase_assignment_sub"",",1
"    { &hf_pn_io_tx_phase_assignment_begin_value,",1
"      { ""AssignedValueForReservedBegin"", ""pn_io.tx_phase_assignment_begin_value"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0F,",1
"    { &hf_pn_io_tx_phase_assignment_orange_begin,",1
"      { ""AssignedValueForOrangeBegin"", ""pn_io.tx_phase_assignment_orange_begin"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0F0,",1
"    { &hf_pn_io_tx_phase_assignment_end_reserved,",1
"      { ""AssignedValueForReservedEnd"", ""pn_io.tx_phase_assignment_end_reserved"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0F00,",1
"    { &hf_pn_io_tx_phase_assignment_reserved,",1
"      { ""Reserved should be 0"", ""pn_io.tx_phase_assignment_reserved"",",1
"        FT_UINT16, BASE_DEC, NULL, 0x0F000,",1
"    { &hf_pn_ir_rx_phase_assignment,",1
"      { ""RXPhaseAssignment"", ""pn_io.rx_phase_assignment_sub"",",1
"    { &hf_pn_io_slot,",1
"      { ""Slot"", ""pn_io.slot"",",1
"    { &hf_pn_io_subslot,",1
"      { ""Subslot"", ""pn_io.subslot"",",1
"    { &hf_pn_io_number_of_slots,",1
"      { ""NumberOfSlots"", ""pn_io.number_of_slots"",",1
"    { &hf_pn_io_number_of_subslots,",1
"      { ""NumberOfSubslots"", ""pn_io.number_of_subslots"",",1
"    { &hf_pn_io_maintenance_required_power_budget,",1
"      { ""MaintenanceRequiredPowerBudget"", ""pn_io.maintenance_required_power_budget"",",1
"    { &hf_pn_io_maintenance_demanded_power_budget,",1
"      { ""MaintenanceDemandedPowerBudget"", ""pn_io.maintenance_demanded_power_budget"",",1
"    { &hf_pn_io_error_power_budget,",1
"      { ""ErrorPowerBudget"", ""pn_io.error_power_budget"",",1
"    { &hf_pn_io_fiber_optic_type,",1
"      { ""FiberOpticType"", ""pn_io.fiber_optic_type"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_fiber_optic_type), 0x0,",1
"    { &hf_pn_io_fiber_optic_cable_type,",1
"      { ""FiberOpticCableType"", ""pn_io.fiber_optic_cable_type"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_fiber_optic_cable_type), 0x0,",1
"    { &hf_pn_io_controller_appl_cycle_factor,",1
"      { ""ControllerApplicationCycleFactor"", ""pn_io.controller_appl_cycle_factor"",",1
"    { &hf_pn_io_time_data_cycle,",1
"      { ""TimeDataCycle"", ""pn_io.time_data_cycle"",",1
"    { &hf_pn_io_time_io_input,",1
"      { ""TimeIOInput"", ""pn_io.time_io_input"",",1
"    { &hf_pn_io_time_io_output,",1
"      { ""TimeIOOutput"", ""pn_io.time_io_output"",",1
"    { &hf_pn_io_time_io_input_valid,",1
"      { ""TimeIOInputValid"", ""pn_io.time_io_input_valid"",",1
"    { &hf_pn_io_time_io_output_valid,",1
"      { ""TimeIOOutputValid"", ""pn_io.time_io_output_valid"",",1
"    { &hf_pn_io_maintenance_status,",1
"      { ""MaintenanceStatus"", ""pn_io.maintenance_status"",",1
"    { &hf_pn_io_maintenance_status_required,",1
"      { ""Required"", ""pn_io.maintenance_status_required"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0001,",1
"    { &hf_pn_io_maintenance_status_demanded,",1
"      { ""Demanded"", ""pn_io.maintenance_status_demanded"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0002,",1
"    { &hf_pn_io_vendor_id_high,",1
"      { ""VendorIDHigh"", ""pn_io.vendor_id_high"",",1
"    { &hf_pn_io_vendor_id_low,",1
"      { ""VendorIDLow"", ""pn_io.vendor_id_low"",",1
"    { &hf_pn_io_vendor_block_type,",1
"      { ""VendorBlockType"", ""pn_io.vendor_block_type"",",1
"    { &hf_pn_io_order_id,",1
"      { ""OrderID"", ""pn_io.order_id"",",1
"    { &hf_pn_io_im_serial_number,",1
"      { ""IMSerialNumber"", ""pn_io.im_serial_number"",",1
"    { &hf_pn_io_im_hardware_revision,",1
"      { ""IMHardwareRevision"", ""pn_io.im_hardware_revision"",",1
      /* XXX - better use a simple char here -> vals */,1
"    { &hf_pn_io_im_revision_prefix,",1
"      { ""IMRevisionPrefix"", ""pn_io.im_revision_prefix"",",1
"        FT_CHAR, BASE_HEX, VALS(pn_io_im_revision_prefix_vals), 0x0,",1
"    { &hf_pn_io_im_sw_revision_functional_enhancement,",1
"      { ""IMSWRevisionFunctionalEnhancement"", ""pn_io.im_sw_revision_functional_enhancement"",",1
"    { &hf_pn_io_im_revision_bugfix,",1
"      { ""IM_SWRevisionBugFix"", ""pn_io.im_revision_bugfix"",",1
"    { &hf_pn_io_im_sw_revision_internal_change,",1
"      { ""IMSWRevisionInternalChange"", ""pn_io.im_sw_revision_internal_change"",",1
"    { &hf_pn_io_im_revision_counter,",1
"      { ""IMRevisionCounter"", ""pn_io.im_revision_counter"",",1
"    { &hf_pn_io_im_profile_id,",1
"      { ""IMProfileID"", ""pn_io.im_profile_id"",",1
"    { &hf_pn_io_im_profile_specific_type,",1
"      { ""IMProfileSpecificType"", ""pn_io.im_profile_specific_type"",",1
"    { &hf_pn_io_im_version_major,",1
"      { ""IMVersionMajor"", ""pn_io.im_version_major"",",1
"    { &hf_pn_io_im_version_minor,",1
"      { ""IMVersionMinor"", ""pn_io.im_version_minor"",",1
"    { &hf_pn_io_im_supported,",1
"      { ""IM_Supported"", ""pn_io.im_supported"",",1
"    { &hf_pn_io_im_numberofentries,",1
"      { ""NumberOfEntries"", ""pn_io.im_numberofentries"",",1
"    { &hf_pn_io_im_annotation,",1
"      { ""IM Annotation"", ""pn_io.im_annotation"",",1
"    { &hf_pn_io_im_order_id,",1
"      { ""IM Order ID"", ""pn_io.im_order_id"",",1
"    { &hf_pn_io_number_of_ars,",1
"      { ""NumberOfARs"", ""pn_io.number_of_ars"",",1
"    { &hf_pn_io_cycle_counter,",1
"      { ""CycleCounter"", ""pn_io.cycle_counter"",",1
"    { &hf_pn_io_data_status,",1
"      { ""DataStatus"", ""pn_io.ds"",",1
"        FT_UINT8, BASE_HEX, 0, 0x0,",1
"    { &hf_pn_io_data_status_res67,",1
"      { ""Reserved (should be zero)"", ""pn_io.ds_res67"",",1
"        FT_UINT8, BASE_HEX, 0, 0xc0,",1
"    { &hf_pn_io_data_status_ok,",1
"      { ""StationProblemIndicator (1:Ok/0:Problem)"", ""pn_io.ds_ok"",",1
"        FT_UINT8, BASE_HEX, 0, 0x20,",1
"    { &hf_pn_io_data_status_operate,",1
"      { ""ProviderState (1:Run/0:Stop)"", ""pn_io.ds_operate"",",1
"        FT_UINT8, BASE_HEX, 0, 0x10,",1
"    { &hf_pn_io_data_status_res3,",1
"      { ""Reserved (should be zero)"", ""pn_io.ds_res3"",",1
"        FT_UINT8, BASE_HEX, 0, 0x08,",1
"    { &hf_pn_io_data_status_valid,",1
"      { ""DataValid (1:Valid/0:Invalid)"", ""pn_io.ds_valid"",",1
"        FT_UINT8, BASE_HEX, 0, 0x04,",1
"    { &hf_pn_io_data_status_res1,",1
"      { ""primary AR of a given AR-set is present (0:One/ 1:None)"", ""pn_io.ds_res1"",",1
"        FT_UINT8, BASE_HEX, 0, 0x02,",1
"    { &hf_pn_io_data_status_primary,",1
"      { ""State (1:Primary/0:Backup)"", ""pn_io.ds_primary"",",1
"        FT_UINT8, BASE_HEX, 0, 0x01,",1
"    { &hf_pn_io_transfer_status,",1
"      { ""TransferStatus"", ""pn_io.transfer_status"",",1
"    { &hf_pn_io_actual_local_time_stamp,",1
"      { ""ActualLocalTimeStamp"", ""pn_io.actual_local_time_stamp"",",1
"        FT_UINT64, BASE_DEC, NULL, 0x0,",1
"    { &hf_pn_io_local_time_stamp,",1
"      { ""LocalTimeStamp"", ""pn_io.local_time_stamp"",",1
"    { &hf_pn_io_number_of_log_entries,",1
"      { ""NumberOfLogEntries"", ""pn_io.number_of_log_entries"",",1
"    { &hf_pn_io_entry_detail,",1
"      { ""EntryDetail"", ""pn_io.entry_detail"",",1
"    { &hf_pn_io_ip_address,",1
"      { ""IPAddress"", ""pn_io.ip_address"",",1
"        FT_IPv4, BASE_NONE, NULL, 0x0,",1
"    { &hf_pn_io_subnetmask,",1
"      { ""Subnetmask"", ""pn_io.subnetmask"",",1
"    { &hf_pn_io_standard_gateway,",1
"      { ""StandardGateway"", ""pn_io.standard_gateway"",",1
"    { &hf_pn_io_mrp_domain_uuid,",1
"      { ""MRP_DomainUUID"", ""pn_io.mrp_domain_uuid"",",1
"    { &hf_pn_io_mrp_role,",1
"      { ""MRP_Role"", ""pn_io.mrp_role"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_mrp_role_vals), 0x0,",1
"    { &hf_pn_io_mrp_length_domain_name,",1
"      { ""MRP_LengthDomainName"", ""pn_io.mrp_length_domain_name"",",1
"    { &hf_pn_io_mrp_domain_name,",1
"      { ""MRP_DomainName"", ""pn_io.mrp_domain_name"",",1
"    { &hf_pn_io_mrp_instances,",1
"      { ""NumberOfMrpInstances"", ""pn_io.mrp_Number_MrpInstances"",",1
"    { &hf_pn_io_mrp_instance,",1
"      { ""Mrp_Instance"", ""pn_io.mrp_MrpInstance"",",1
"        FT_UINT8, BASE_DEC,  VALS(pn_io_mrp_instance_no), 0x0,",1
"    { &hf_pn_io_mrp_prio,",1
"      { ""MRP_Prio"", ""pn_io.mrp_prio"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_mrp_prio_vals), 0x0,",1
"    { &hf_pn_io_mrp_topchgt,",1
"      { ""MRP_TOPchgT"", ""pn_io.mrp_topchgt"",",1
"        ""time base 10ms"", HFILL }",1
"    { &hf_pn_io_mrp_topnrmax,",1
"      { ""MRP_TOPNRmax"", ""pn_io.mrp_topnrmax"",",1
"        ""number of iterations"", HFILL }",1
"    { &hf_pn_io_mrp_tstshortt,",1
"      { ""MRP_TSTshortT"", ""pn_io.mrp_tstshortt"",",1
"        ""time base 1 ms"", HFILL }",1
"    { &hf_pn_io_mrp_tstdefaultt,",1
"      { ""MRP_TSTdefaultT"", ""pn_io.mrp_tstdefaultt"",",1
"        ""time base 1ms"", HFILL }",1
"    { &hf_pn_io_mrp_tstnrmax,",1
"      { ""MRP_TSTNRmax"", ""pn_io.mrp_tstnrmax"",",1
"        ""number of outstanding test indications causes ring failure"", HFILL }",1
"    { &hf_pn_io_mrp_check,",1
"      { ""MRP_Check"", ""pn_io.mrp_check"",",1
"    { &hf_pn_io_mrp_check_mrm,",1
"      { ""MRP_Check.MediaRedundancyManager"", ""pn_io.mrp_check.mrm"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_mrp_mrm_on), 0x01,",1
"    { &hf_pn_io_mrp_check_mrpdomain,",1
"      { ""MRP_Check.MRP_DomainUUID"", ""pn_io.mrp_check.domainUUID"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_mrp_checkUUID), 0x02,",1
"    { &hf_pn_io_mrp_check_reserved_1,",1
"      { ""MRP_Check.reserved_1"", ""pn_io.mrp_check_reserved_1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0FFFFFC,",1
"    { &hf_pn_io_mrp_check_reserved_2,",1
"      { ""MRP_Check.reserved_2"", ""pn_io.mrp_check_reserved_2"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x0FF000000,",1
"    { &hf_pn_io_mrp_rtmode,",1
"      { ""MRP_RTMode"", ""pn_io.mrp_rtmode"",",1
"    { &hf_pn_io_mrp_rtmode_rtclass12,",1
"      { ""RTClass1_2"", ""pn_io.mrp_rtmode.class1_2"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_mrp_rtmode_rtclass12_vals), 0x00000001,",1
"    { &hf_pn_io_mrp_rtmode_rtclass3,",1
"      { ""RTClass1_3"", ""pn_io.mrp_rtmode.class3"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_mrp_rtmode_rtclass3_vals), 0x00000002,",1
"    { &hf_pn_io_mrp_rtmode_reserved1,",1
"      { ""Reserved_1"", ""pn_io.mrp_rtmode.reserved_1"",",1
"        FT_UINT32, BASE_HEX, NULL, 0x00fffffc,",1
"    { &hf_pn_io_mrp_rtmode_reserved2,",1
"      { ""Reserved_2"", ""pn_io.mrp_rtmode.reserved_2"",",1
"        FT_UINT32, BASE_HEX, NULL, 0xff000000,",1
"    { &hf_pn_io_mrp_lnkdownt,",1
"      { ""MRP_LNKdownT"", ""pn_io.mrp_lnkdownt"",",1
"        ""Link down Interval in ms"", HFILL }",1
"    { &hf_pn_io_mrp_lnkupt,",1
"      { ""MRP_LNKupT"", ""pn_io.mrp_lnkupt"",",1
"        ""Link up Interval in ms"", HFILL }",1
"    { &hf_pn_io_mrp_lnknrmax,",1
"      { ""MRP_LNKNRmax"", ""pn_io.mrp_lnknrmax"",",1
"    { &hf_pn_io_mrp_version,",1
"      { ""MRP_Version"", ""pn_io.mrp_version"",",1
"    { &hf_pn_io_substitute_active_flag,",1
"      { ""SubstituteActiveFlag"", ""pn_io.substitute_active_flag"",",1
"    { &hf_pn_io_length_data,",1
"      { ""LengthData"", ""pn_io.length_data"",",1
"    { &hf_pn_io_mrp_ring_state,",1
"      { ""MRP_RingState"", ""pn_io.mrp_ring_state"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_mrp_ring_state_vals), 0x0,",1
"    { &hf_pn_io_mrp_rt_state,",1
"      { ""MRP_RTState"", ""pn_io.mrp_rt_state"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_mrp_rt_state_vals), 0x0,",1
"    { &hf_pn_io_im_tag_function,",1
"      { ""IM_Tag_Function"", ""pn_io.im_tag_function"",",1
"    { &hf_pn_io_im_tag_location,",1
"      { ""IM_Tag_Location"", ""pn_io.im_tag_location"",",1
"    { &hf_pn_io_im_date,",1
"      { ""IM_Date"", ""pn_io.im_date"",",1
"    { &hf_pn_io_im_descriptor,",1
"      { ""IM_Descriptor"", ""pn_io.im_descriptor"",",1
"    { &hf_pn_io_fs_hello_mode,",1
"      { ""FSHelloMode"", ""pn_io.fs_hello_mode"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_fs_hello_mode_vals), 0x0,",1
"    { &hf_pn_io_fs_hello_interval,",1
"      { ""FSHelloInterval"", ""pn_io.fs_hello_interval"",",1
"        ""ms before conveying a second DCP_Hello.req"", HFILL }",1
"    { &hf_pn_io_fs_hello_retry,",1
"      { ""FSHelloRetry"", ""pn_io.fs_hello_retry"",",1
"    { &hf_pn_io_fs_hello_delay,",1
"      { ""FSHelloDelay"", ""pn_io.fs_hello_delay"",",1
"    { &hf_pn_io_fs_parameter_mode,",1
"      { ""FSParameterMode"", ""pn_io.fs_parameter_mode"",",1
"        FT_UINT32, BASE_HEX, VALS(pn_io_fs_parameter_mode_vals), 0x0,",1
"    { &hf_pn_io_fs_parameter_uuid,",1
"      { ""FSParameterUUID"", ""pn_io.fs_parameter_uuid"",",1
"    { &hf_pn_io_check_sync_mode,",1
"      { ""CheckSyncMode"", ""pn_io.check_sync_mode"",",1
"    { &hf_pn_io_check_sync_mode_reserved,",1
"      { ""Reserved"", ""pn_io.check_sync_mode.reserved"",",1
"        FT_UINT16, BASE_HEX, NULL, 0xFFFC,",1
"    { &hf_pn_io_check_sync_mode_sync_master,",1
"      { ""SyncMaster"", ""pn_io.check_sync_mode.sync_master"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x0002,",1
"    { &hf_pn_io_check_sync_mode_cable_delay,",1
"      { ""CableDelay"", ""pn_io.check_sync_mode.cable_delay"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x0001,",1
    /* PROFIsafe F-Parameter */,1
"    { &hf_pn_io_ps_f_prm_flag1,",1
"      { ""F_Prm_Flag1"", ""pn_io.ps.f_prm_flag1"",",1
"    { &hf_pn_io_ps_f_prm_flag1_chck_seq,",1
"      { ""F_Check_SeqNr"", ""pn_io.ps.f_prm_flag1.f_check_seqnr"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_check_seqnr), 0x01,",1
"    { &hf_pn_io_ps_f_prm_flag1_chck_ipar,",1
"      { ""F_Check_iPar"", ""pn_io.ps.f_prm_flag1.f_check_ipar"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_check_ipar), 0x02,",1
"    { &hf_pn_io_ps_f_prm_flag1_sil,",1
"      { ""F_SIL"", ""pn_io.ps.f_prm_flag1.f_sil"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_sil), 0xc,",1
"    { &hf_pn_io_ps_f_prm_flag1_crc_len,",1
"      { ""F_CRC_Length"", ""pn_io.ps.f_prm_flag1.f_crc_len"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_crc_len), 0x30,",1
"    { &hf_pn_io_ps_f_prm_flag1_crc_seed,",1
"        { ""F_CRC_Seed"", ""pn_io.ps.f_prm_flag1.f_crc_seed"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_crc_seed), 0x40,",1
"    { &hf_pn_io_ps_f_prm_flag1_reserved,",1
"      { ""Reserved"", ""pn_io.ps.f_prm_flag1.reserved"",",1
"    { &hf_pn_io_ps_f_prm_flag2,",1
"      { ""F_Prm_Flag2"", ""pn_io.ps.f_prm_flag2"",",1
"    { &hf_pn_io_ps_f_prm_flag2_reserved,",1
"      { ""Reserved"", ""pn_io.ps.f_prm_flag2.reserved"",",1
"        FT_UINT8, BASE_HEX, NULL, 0x07,",1
"    { &hf_pn_io_ps_f_prm_flag2_f_block_id,",1
"      { ""F_Block_ID"", ""pn_io.ps.f_prm_flag2.f_block_id"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_block_id), 0x38,",1
"    { &hf_pn_io_ps_f_prm_flag2_f_par_version,",1
"      { ""F_Par_Version"", ""pn_io.ps.f_prm_flag2.f_par_version"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_f_par_version), 0xC0,",1
"    { &hf_pn_io_ps_f_wd_time,",1
"      { ""F_WD_Time"", ""pn_io.ps.f_wd_time"",",1
"    { &hf_pn_io_ps_f_ipar_crc,",1
"        { ""F_iPar_CRC"", ""pn_io.ps.f_ipar_crc"",",1
"    { &hf_pn_io_ps_f_par_crc,",1
"        { ""F_Par_CRC"", ""pn_io.ps.f_par_crc"",",1
"    { &hf_pn_io_ps_f_dest_adr,",1
"        { ""F_Dest_Add"", ""pn_io.ps.f_dest_add"",",1
"    { &hf_pn_io_ps_f_src_adr,",1
"        { ""F_Source_Add"", ""pn_io.ps.f_source_add"",",1
    /* profidrive parameter access */,1
"    { &hf_pn_io_profidrive_request_reference,",1
"      { ""RequestReference"", ""pn_io.profidrive.parameter.request_reference"",",1
"    { &hf_pn_io_profidrive_request_id,",1
"      { ""RequestID"", ""pn_io.profidrive.parameter.request_id"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_profidrive_request_id_vals), 0x0,",1
"    { &hf_pn_io_profidrive_do_id,",1
"      { ""DO"", ""pn_io.profidrive.parameter.do"",",1
"    { &hf_pn_io_profidrive_no_of_parameters,",1
"      { ""NoOfParameters"", ""pn_io.profidrive.parameter.no_of_parameters"",",1
"    { &hf_pn_io_profidrive_param_attribute,",1
"      { ""Attribute"", ""pn_io.profidrive.parameter.attribute"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_profidrive_attribute_vals), 0x0,",1
"    { &hf_pn_io_profidrive_param_no_of_elems,",1
"      { ""NoOfElements"", ""pn_io.profidrive.parameter.no_of_elems"",",1
"    { &hf_pn_io_profidrive_param_number,",1
"      { ""Parameter"", ""pn_io.profidrive.parameter.number"",",1
"    { &hf_pn_io_profidrive_param_subindex,",1
"      { ""Index"", ""pn_io.profidrive.parameter.index"",",1
"    { &hf_pn_io_profidrive_response_id,",1
"      { ""ResponseID"", ""pn_io.profidrive.parameter.response_id"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_profidrive_response_id_vals), 0x0,",1
"    { &hf_pn_io_profidrive_param_format,",1
"      { ""Format"", ""pn_io.profidrive.parameter.format"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_profidrive_format_vals), 0x0,",1
"    { &hf_pn_io_profidrive_param_no_of_values,",1
"      { ""NoOfValues"", ""pn_io.profidrive.parameter.no_of_values"",",1
"    { &hf_pn_io_profidrive_param_value_byte,",1
"      { ""Value"", ""pn_io.profidrive.parameter.value_b"",",1
"    { &hf_pn_io_profidrive_param_value_word,",1
"      { ""Value"", ""pn_io.profidrive.parameter.value_w"",",1
"    { &hf_pn_io_profidrive_param_value_dword,",1
"      { ""Value"", ""pn_io.profidrive.parameter.value_dw"",",1
"    { &hf_pn_io_profidrive_param_value_float,",1
"      { ""Value"", ""pn_io.profidrive.parameter.value_float"",",1
"        FT_FLOAT, BASE_NONE, NULL, 0x0,",1
"    { &hf_pn_io_profidrive_param_value_string,",1
"      { ""Value"", ""pn_io.profidrive.parameter.value_str"",",1
"    { &hf_pn_io_rs_alarm_info_reserved_8_15,",1
"      { ""RSAlarmInfo.Reserved2"", ""pn_io.rs_alarm_info_reserved_8_15"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x0FF00,",1
"    { &hf_pn_io_rs_alarm_info_reserved_0_7,",1
"      { ""RSAlarmInfo.Reserved1"", ""pn_io.rs_alarm_info_reserved_0_7"",",1
"        FT_UINT16, BASE_HEX, NULL, 0x000FF,",1
"    { &hf_pn_io_rs_alarm_info,",1
"        { ""RS Alarm Info"", ""pn_io.rs_alarm_info"",",1
"          FT_UINT16, BASE_HEX, NULL, 0x0,",1
"    { &hf_pn_io_rs_event_info,",1
"        { ""RS Event Info"", ""pn_io.rs_event_info"",",1
"          FT_NONE, BASE_NONE, NULL, 0x0,",1
"    { &hf_pn_io_rs_event_block,",1
"        { ""RS Event Block"", ""pn_io.rs_event_block"",",1
"    { &hf_pn_io_rs_adjust_block,",1
"        { ""RS Adjust Block"", ""pn_io.rs_adjust_block"",",1
"    { &hf_pn_io_rs_event_data_extension,",1
"        { ""RS Event Data Extension"", ""pn_io.rs_event_data_extension"",",1
"    { &hf_pn_io_number_of_rs_event_info,",1
"        { ""RSEventInfo.NumberOfEntries"", ""pn_io.number_of_rs_event_info"",",1
"          FT_UINT16, BASE_DEC, NULL, 0x0,",1
"    { &hf_pn_io_rs_block_type,",1
"        { ""RS Block Type"", ""pn_io.rs_block_type"",",1
"          FT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(pn_io_rs_block_type), 0x0,",1
"    { &hf_pn_io_rs_block_length,",1
"        { ""RS Block Length"", ""pn_io.rs_block_length"",",1
"    { &hf_pn_io_rs_specifier,",1
"        { ""RS_Specifier"", ""pn_io.rs_specifier"",",1
"    { &hf_pn_io_rs_specifier_sequence,",1
"        { ""RS_Specifier.SequenceNumber"", ""pn_io.rs_specifier.sequence"",",1
"          FT_UINT16, BASE_HEX, NULL, 0x07FF,",1
"    { &hf_pn_io_rs_specifier_reserved,",1
"        { ""RS_Specifier.Reserved"", ""pn_io.rs_specifier_reserved"",",1
"          FT_UINT16, BASE_HEX, NULL, 0x3800,",1
"    { &hf_pn_io_rs_specifier_specifier,",1
"        { ""RS_Specifier.Specifier"", ""pn_io.rs_specifier.specifier"",",1
"          FT_UINT16, BASE_HEX, VALS(pn_io_rs_specifier_specifier), 0xC000,",1
"    { &hf_pn_io_rs_time_stamp,",1
"      { ""RS_TimeStamp"", ""pn_io.rs_time_stamp"",",1
"    { &hf_pn_io_rs_time_stamp_status,",1
"        { ""RS_TimeStamp.Status"", ""pn_io.rs_time_stamp.status"",",1
"          FT_UINT16, BASE_HEX, VALS(pn_io_rs_time_stamp_status), 0x0003,",1
"    { &hf_pn_io_rs_time_stamp_value,",1
"        { ""RS_TimeStamp.Value"", ""pn_io.rs_time_stamp.value"",",1
"          FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,",1
"    { &hf_pn_io_rs_minus_error,",1
"        { ""RS_MinusError"", ""pn_io.rs_minus_error"",",1
"    { &hf_pn_io_rs_plus_error,",1
"        { ""RS_PlusError"", ""pn_io.rs_plus_error"",",1
"    { &hf_pn_io_rs_extension_block_type,",1
"        { ""RS_ExtensionBlockType"", ""pn_io.rs_extension_block_type"",",1
"          FT_UINT8, BASE_HEX, NULL, 0x0,",1
"    { &hf_pn_io_rs_extension_block_length,",1
"        { ""RS_ExtensionBlockLength"", ""pn_io.rs_extension_block_length"",",1
"    { &hf_pn_io_rs_reason_code,",1
"        { ""RS_ReasonCode"", ""pn_io.rs_reason_code"",",1
"          FT_UINT32, BASE_HEX, NULL, 0x0,",1
"    { &hf_pn_io_rs_reason_code_reason,",1
"        { ""RS_ReasonCode.Reason"", ""pn_io.rs_reason_code.reason"",",1
"          FT_UINT32, BASE_HEX, VALS(pn_io_rs_reason_code_reason), 0x0000FFFF,",1
"    { &hf_pn_io_rs_reason_code_detail,",1
"        { ""RS_ReasonCode.Detail"", ""pn_io.rs_reason_code.detail"",",1
"          FT_UINT32, BASE_HEX, VALS(pn_io_rs_reason_code_detail), 0xFFFF0000,",1
"    { &hf_pn_io_rs_domain_identification,",1
"        { ""RS_DomainIdentification"", ""pn_io.rs_domain_identification"",",1
"          FT_BYTES, BASE_NONE, NULL, 0x0,",1
"    { &hf_pn_io_rs_master_identification,",1
"        { ""RS_MasterIdentification"", ""pn_io.rs_master_identification"",",1
"    { &hf_pn_io_soe_digital_input_current_value,",1
"        { ""SoE_DigitalInputCurrentValue"", ""pn_io.soe_digital_input_current_value"",",1
"    { &hf_pn_io_soe_digital_input_current_value_value,",1
"        { ""SoE_DigitalInputCurrentValue.Value"", ""pn_io.soe_digital_input_current_value.value"",",1
"          FT_UINT16, BASE_HEX, VALS(pn_io_soe_digital_input_current_value_value), 0x0001,",1
"    { &hf_pn_io_soe_digital_input_current_value_reserved,",1
"        { ""SoE_DigitalInputCurrentValue.Reserved"", ""pn_io.soe_digital_input_current_value.reserved"",",1
"          FT_UINT16, BASE_HEX, NULL, 0xFFFE,",1
"    { &hf_pn_io_am_device_identification,",1
"        { ""AM_DeviceIdentification"", ""pn_io.am_device_identification"",",1
"          FT_UINT64, BASE_HEX, NULL, 0x0,",1
"    { &hf_pn_io_am_device_identification_device_sub_id,",1
"        { ""AM_DeviceIdentification.DeviceSubID"", ""pn_io.am_device_identification.device_sub_id"",",1
"          FT_UINT64, BASE_HEX, NULL, 0x000000000000FFFF,",1
"    { &hf_pn_io_am_device_identification_device_id,",1
"        { ""AM_DeviceIdentification.DeviceID"", ""pn_io.am_device_identification.device_id"",",1
"          FT_UINT64, BASE_HEX, NULL, 0x00000000FFFF0000,",1
"    { &hf_pn_io_am_device_identification_vendor_id,",1
"        { ""AM_DeviceIdentification.VendorID"", ""pn_io.am_device_identification.vendor_id"",",1
"          FT_UINT64, BASE_HEX, NULL, 0x0000FFFF00000000,",1
"    { &hf_pn_io_am_device_identification_organization,",1
"        { ""AM_DeviceIdentification.Organization"", ""pn_io.am_device_identification.organization"",",1
"          FT_UINT64, BASE_HEX, NULL, 0xFFFF000000000000,",1
"    { &hf_pn_io_rs_adjust_info,",1
"        { ""RS Adjust Info"", ""pn_io.rs_adjust_info"",",1
"    { &hf_pn_io_soe_max_scan_delay,",1
"        { ""SoE_MaxScanDelay"", ""pn_io.soe_max_scan_delay"",",1
"    { &hf_pn_io_soe_adjust_specifier,",1
"        { ""SoE_AdjustSpecifier"", ""pn_io.soe_adjust_specifier"",",1
"    { &hf_pn_io_soe_adjust_specifier_reserved,",1
"        { ""SoE_AdjustSpecifier.Reserved"", ""pn_io.soe_adjust_specifier.reserved"",",1
"          FT_UINT8, BASE_HEX, NULL, 0x3F,",1
"    { &hf_pn_io_soe_adjust_specifier_incident,",1
"        { ""SoE_AdjustSpecifier.Incident"", ""pn_io.soe_adjust_specifier.incident"",",1
"          FT_UINT8, BASE_HEX, VALS(pn_io_soe_adjust_specifier_incident), 0xC0,",1
"    { &hf_pn_io_rs_properties,",1
"        { ""RSProperties"", ""pn_io.rs_properties"",",1
"    { &hf_pn_io_rs_properties_alarm_transport,",1
"          FT_UINT32, BASE_HEX, VALS(pn_io_rs_properties_alarm_transport), 0x00000001,",1
"    { &hf_pn_io_rs_properties_reserved1,",1
"        { ""RSProperties.Reserved1"", ""pn_io.rs_properties.reserved1"",",1
"          FT_UINT32, BASE_HEX, NULL, 0x00FFFFFE,",1
"    { &hf_pn_io_rs_properties_reserved2,",1
"        { ""RSProperties.Reserved2"", ""pn_io.rs_properties.reserved2"",",1
"          FT_UINT32, BASE_HEX, NULL, 0xFF000000,",1
"    { &hf_pn_io_asset_management_info,",1
"      { ""Asset Management Info"", ""pn_io.asset_management_info"",",1
"    { &hf_pn_io_number_of_asset_management_info,",1
"      { ""AssetManagementInfo.NumberOfEntries"", ""pn_io.number_of_asset_management_info"",",1
"    { &hf_pn_io_im_uniqueidentifier,",1
"      { ""IM_UniqueIdentifier"", ""pn_io.IM_UniqueIdentifier"",",1
"    { &hf_pn_io_am_location_structure,",1
"      { ""AM_Location.Structure"", ""pn_io.am_location.structure"",",1
"         FT_UINT8, BASE_HEX, VALS(pn_io_am_location_structure_vals), 0x0,",1
"    { &hf_pn_io_am_location,",1
"      { ""AM_Location"", ""pn_io.am_location"",",1
"    { &hf_pn_io_am_location_level_0,",1
"      { ""AM_Location Level 0"", ""pn_io.am_location.level_0"",",1
"        FT_UINT16, BASE_HEX | BASE_RANGE_STRING, RVALS(pn_io_am_location_level_vals), 0x0,",1
"    { &hf_pn_io_am_location_level_1,",1
"      { ""AM_Location Level 1"", ""pn_io.am_location.level_1"",",1
"    { &hf_pn_io_am_location_level_2,",1
"      { ""AM_Location Level 2"", ""pn_io.am_location.level_2"",",1
"    { &hf_pn_io_am_location_level_3,",1
"      { ""AM_Location Level 3"", ""pn_io.am_location.level_3"",",1
"    { &hf_pn_io_am_location_level_4,",1
"      { ""AM_Location Level 4"", ""pn_io.am_location.level_4"",",1
"    { &hf_pn_io_am_location_level_5,",1
"      { ""AM_Location Level 5"", ""pn_io.am_location.level_5"",",1
"    { &hf_pn_io_am_location_level_6,",1
"      { ""AM_Location Level 6"", ""pn_io.am_location.level_6"",",1
"    { &hf_pn_io_am_location_level_7,",1
"      { ""AM_Location Level 7"", ""pn_io.am_location.level_7"",",1
"    { &hf_pn_io_am_location_level_8,",1
"      { ""AM_Location Level 8"", ""pn_io.am_location.level_8"",",1
"    { &hf_pn_io_am_location_level_9,",1
"      { ""AM_Location Level 9"", ""pn_io.am_location.level_9"",",1
"    { &hf_pn_io_am_location_level_10,",1
"      { ""AM_Location Level 10"", ""pn_io.am_location.level_10"",",1
"    { &hf_pn_io_am_location_level_11,",1
"      { ""AM_Location Level 11"", ""pn_io.am_location.level_11"",",1
"    { &hf_pn_io_am_location_reserved1,",1
"      { ""Reserved 1"", ""pn_io.am_location.reserved1"",",1
"        FT_UINT8, BASE_HEX, VALS(pn_io_am_location_reserved_vals), 0x0,",1
"    { &hf_pn_io_am_location_reserved2,",1
"      { ""Reserved 2"", ""pn_io.am_location.reserved2"",",1
"        FT_UINT16, BASE_HEX, VALS(pn_io_am_location_reserved_vals), 0x0,",1
"    { &hf_pn_io_am_location_reserved3,",1
"      { ""Reserved 3"", ""pn_io.am_location.reserved3"",",1
"    { &hf_pn_io_am_location_reserved4,",1
"      { ""Reserved 3"", ""pn_io.am_location.reserved4"",",1
"    { &hf_pn_io_am_software_revision,",1
"      { ""AM Software Revision"", ""pn_io.am_software_revision"",",1
"    { &hf_pn_io_am_hardware_revision,",1
"      { ""AM Hardware Revision"", ""pn_io.am_hardware_revision"",",1
"    { &hf_pn_io_am_type_identification,",1
"      { ""AM Type Identification"", ""pn_io.am_type_identification"",",1
"        &ett_pn_io,",1
"        &ett_pn_io_block,",1
"        &ett_pn_io_block_header,",1
"        &ett_pn_io_status,",1
"        &ett_pn_io_rtc,",1
"        &ett_pn_io_rta,",1
"        &ett_pn_io_pdu_type,",1
"        &ett_pn_io_add_flags,",1
"        &ett_pn_io_control_command,",1
"        &ett_pn_io_ioxs,",1
"        &ett_pn_io_api,",1
"        &ett_pn_io_data_description,",1
"        &ett_pn_io_module,",1
"        &ett_pn_io_submodule,",1
"        &ett_pn_io_io_data_object,",1
"        &ett_pn_io_io_cs,",1
"        &ett_pn_io_ar_properties,",1
"        &ett_pn_io_iocr_properties,",1
"        &ett_pn_io_submodule_properties,",1
"        &ett_pn_io_alarmcr_properties,",1
"        &ett_pn_io_submodule_state,",1
"        &ett_pn_io_channel_properties,",1
"        &ett_pn_io_slot,",1
"        &ett_pn_io_subslot,",1
"        &ett_pn_io_maintenance_status,",1
"        &ett_pn_io_data_status,",1
"        &ett_pn_io_iocr,",1
"        &ett_pn_io_mrp_rtmode,",1
"        &ett_pn_io_control_block_properties,",1
"        &ett_pn_io_check_sync_mode,",1
"        &ett_pn_io_ir_frame_data,",1
"        &ett_pn_FrameDataProperties,",1
"        &ett_pn_io_ar_info,",1
"        &ett_pn_io_ar_data,",1
"        &ett_pn_io_ir_begin_end_port,",1
"        &ett_pn_io_ir_tx_phase,",1
"        &ett_pn_io_ir_rx_phase,",1
"        &ett_pn_io_subframe_data,",1
"        &ett_pn_io_SFIOCRProperties,",1
"        &ett_pn_io_frame_defails,",1
"        &ett_pn_io_profisafe_f_parameter,",1
"        &ett_pn_io_profisafe_f_parameter_prm_flag1,",1
"        &ett_pn_io_profisafe_f_parameter_prm_flag2,",1
"        &ett_pn_io_profidrive_parameter_request,",1
"        &ett_pn_io_profidrive_parameter_response,",1
"        &ett_pn_io_profidrive_parameter_address,",1
"        &ett_pn_io_profidrive_parameter_value,",1
"        &ett_pn_io_GroupProperties,",1
"        &ett_pn_io_rs_alarm_info,",1
"        &ett_pn_io_rs_event_info,",1
"        &ett_pn_io_rs_event_block,",1
"        &ett_pn_io_rs_adjust_block,",1
"        &ett_pn_io_rs_event_data_extension,",1
"        &ett_pn_io_rs_specifier,",1
"        &ett_pn_io_rs_time_stamp,",1
"        &ett_pn_io_am_device_identification,",1
"        &ett_pn_io_rs_reason_code,",1
"        &ett_pn_io_soe_digital_input_current_value,",1
"        &ett_pn_io_rs_adjust_info,",1
"        &ett_pn_io_soe_adjust_specifier,",1
"        &ett_pn_io_asset_management_info,",1
"        &ett_pn_io_asset_management_block,",1
"        &ett_pn_io_am_location,",1
"        &ett_pn_io_sr_properties,",1
"        &ett_pn_io_line_delay,",1
        &ett_pn_io_counter_status,1
"        { &ei_pn_io_block_version, { ""pn_io.block_version.not_implemented"", PI_UNDECODED, PI_WARN, ""Block version not implemented yet!"", EXPFILL }},",1
"        { &ei_pn_io_error_code1, { ""pn_io.error_code1.expert"", PI_UNDECODED, PI_WARN, ""Unknown ErrorCode1"", EXPFILL }},",1
"        { &ei_pn_io_error_code2, { ""pn_io.error_code2.expert"", PI_UNDECODED, PI_WARN, ""Unknown ErrorDecode"", EXPFILL }},",1
"        { &ei_pn_io_ar_info_not_found, { ""pn_io.ar_info_not_found"", PI_UNDECODED, PI_NOTE, ""IODWriteReq: AR information not found!"", EXPFILL }},",1
"        { &ei_pn_io_block_length, { ""pn_io.block_length.invalid"", PI_UNDECODED, PI_WARN, ""Block length invalid!"", EXPFILL }},",1
"        { &ei_pn_io_unsupported, { ""pn_io.profidrive.parameter.format.invalid"", PI_UNDECODED, PI_WARN, ""Unknown Fomatvalue"", EXPFILL }},",1
"        { &ei_pn_io_mrp_instances, { ""pn_io.mrp_Number_MrpInstances.invalid"", PI_UNDECODED, PI_WARN, ""Number of MrpInstances invalid"", EXPFILL }},",1
"        { &ei_pn_io_frame_id, { ""pn_io.frame_id.changed"", PI_UNDECODED, PI_WARN, ""FrameID changed"", EXPFILL }},",1
"        { &ei_pn_io_iocr_type, { ""pn_io.iocr_type.unknown"", PI_UNDECODED, PI_WARN, ""IOCRType undecoded!"", EXPFILL }},",1
"        { &ei_pn_io_localalarmref, { ""pn_io.localalarmref.changed"", PI_UNDECODED, PI_WARN, ""AlarmCRBlockReq: local alarm ref changed"", EXPFILL }},",1
"        { &ei_pn_io_nr_of_tx_port_groups, { ""pn_io.nr_of_tx_port_groups.not_allowed"", PI_PROTOCOL, PI_WARN, ""Not allowed value of NumberOfTxPortGroups"", EXPFILL }},",1
    module_t *pnio_module_,1
    expert_module_t* expert_pn_io_,1
"    proto_pn_io = proto_register_protocol (""PROFINET IO"", ""PNIO"", ""pn_io"")_",1
    /* Register by name */,1
"    register_dissector(""pnio"", dissect_PNIO_heur, proto_pn_io)_",1
    /* Created to remove Decode As confusion */,1
"    proto_pn_io_device = proto_register_protocol_in_name_only(""PROFINET IO (Device)"", ""PNIO (Device Interface)"", ""pn_io_device"", proto_pn_io, FT_PROTOCOL)_",1
"    proto_pn_io_controller = proto_register_protocol_in_name_only(""PROFINET IO (Controller)"", ""PNIO (Controller Interface)"", ""pn_io_controller"", proto_pn_io, FT_PROTOCOL)_",1
"    proto_pn_io_supervisor = proto_register_protocol_in_name_only(""PROFINET IO (Supervisor)"", ""PNIO (Supervisor Interface)"", ""pn_io_supervisor"", proto_pn_io, FT_PROTOCOL)_",1
"    proto_pn_io_parameterserver = proto_register_protocol_in_name_only(""PROFINET IO (Parameter Server)"", ""PNIO (Parameter Server Interface)"", ""pn_io_parameterserver"", proto_pn_io, FT_PROTOCOL)_",1
"    proto_pn_io_implicitar = proto_register_protocol_in_name_only(""PROFINET IO (Implicit Ar)"", ""PNIO (Implicit Ar)"", ""pn_io_implicitar"", proto_pn_io, FT_PROTOCOL)_",1
"    proto_pn_io_apdu_status = proto_register_protocol_in_name_only(""PROFINET IO (Apdu Status)"", ""PNIO (Apdu Status)"", ""pn_io_apdu_status"", proto_pn_io, FT_PROTOCOL)_",1
"    proto_register_field_array (proto_pn_io, hf, array_length (hf))_",1
"    proto_register_subtree_array (ett, array_length (ett))_",1
    expert_pn_io = expert_register_protocol(proto_pn_io)_,1
"    expert_register_field_array(expert_pn_io, ei, array_length(ei))_",1
    /* Register preferences */,1
"    pnio_module = prefs_register_protocol(proto_pn_io, NULL)_",1
"    prefs_register_bool_preference(pnio_module, ""pnio_ps_selection"",",1
"        ""Enable detailed PROFIsafe dissection"",",1
"        ""Whether the PNIO dissector is allowed to use detailed PROFIsafe dissection of cyclic data frames"",",1
        &pnio_ps_selection)_,1
"    prefs_register_directory_preference(pnio_module, ""pnio_ps_networkpath"",",1
"        ""Configuration GSD-File Networkpath"",                 /* Title */",1
"        ""Select your Networkpath to your GSD-Files."",         /* Descreption */",1
        &pnio_ps_networkpath)_                                /* Variable to save the GSD-File networkpath */,1
    /* subdissector code */,1
"    register_dissector(""pn_io"", dissect_PNIO_heur, proto_pn_io)_",1
"    heur_pn_subdissector_list = register_heur_dissector_list(""pn_io"", proto_pn_io)_",1
    /* Initialise RTC1 dissection */,1
    init_pn_io_rtc1(proto_pn_io)_,1
    /* Cleanup functions of PNIO protocol */,1
    register_cleanup_routine(pnio_cleanup)_,1
"    register_conversation_filter(""pn_io"", ""PN-IO AR"", pn_io_ar_conv_valid, pn_io_ar_conv_filter)_",1
"    register_conversation_filter(""pn_io"", ""PN-IO AR (with data)"", pn_io_ar_conv_valid, pn_io_ar_conv_data_filter)_",1
proto_reg_handoff_pn_io (void),1
    /* Register the protocols as dcerpc */,1
"    dcerpc_init_uuid (proto_pn_io_device, ett_pn_io, &uuid_pn_io_device, ver_pn_io_device, pn_io_dissectors, hf_pn_io_opnum)_",1
"    dcerpc_init_uuid (proto_pn_io_controller, ett_pn_io, &uuid_pn_io_controller, ver_pn_io_controller, pn_io_dissectors, hf_pn_io_opnum)_",1
"    dcerpc_init_uuid (proto_pn_io_supervisor, ett_pn_io, &uuid_pn_io_supervisor, ver_pn_io_supervisor, pn_io_dissectors, hf_pn_io_opnum)_",1
"    dcerpc_init_uuid (proto_pn_io_parameterserver, ett_pn_io, &uuid_pn_io_parameterserver, ver_pn_io_parameterserver, pn_io_dissectors, hf_pn_io_opnum)_",1
"    dcerpc_init_uuid (proto_pn_io_implicitar, ett_pn_io, &uuid_pn_io_implicitar, ver_pn_io_implicitar, pn_io_dissectors, hf_pn_io_opnum)_",1
"    heur_dissector_add(""pn_rt"", dissect_PNIO_heur, ""PROFINET IO"", ""pn_io_pn_rt"", proto_pn_io, HEURISTIC_ENABLE)_",1
 * Editor modelines,1
 * Local Variables:,1
 * ex: set shiftwidth=4 tabstop=8 expandtab:,1
"		{ ""IPv4 Address"", ""h248.package_threegiptra.ipv4trans"",",0
-- Is this the desired behavior?,0
    fi,0
		tvbuff_t   *payload_tvb_,0
"		    FT_FRAMENUM, BASE_NONE, NULL, 0x0,",0
"		    FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0,",0
 * to int representation in string_to_base().,0
"    {""LOCAL"", ABSOLUTE_TIME_LOCAL},        /* for backward compatibility */",0
"    {""UTC"", ABSOLUTE_TIME_UTC},            /* for backward compatibility */",0
%ABSOLUTE_TIME_BASES%,0
"        $bases_table .= ""\t[\""$1\""] = $num,  -- $5\n""_",0
static const guint8 hsdsch_macdflow_id_mac_content_map[] = {,1
    /* Get data of header excluding the first byte */,0
    payload_length = (frame_length - payload_index) - 2_,0
"    /* Expecting specific lengths: 24 for downlink frames, 26 for uplink frames */",0
            (nargs >= WSLUA_OPTARG_ProtoField_new_VALUESTRING) &&,0
"          /* TODO: handle LDPC FEC (info_n->has_fec && info_n->fec == 1), it changes the rounding",1
"            /* TODO - ext field (ext_len != (payload_length - 6)) len doesn't match actual len... that isn't illegal, but is perhaps worth noting */",0
"            ti->setData(col_traffic_, Qt::UserRole, qVariantFromValue(points))_",0
"  ti = proto_tree_add_item(tree, hf_ieee80211_vht_mcsset, tvb, offset, 8, ENC_NA)_",1
"  oid_add_from_string(""ISO assigned OIDs, USA"",                                                     ""1.2.840"")_",0
"  oid_add_from_string(""Manage DSA IT LDAPv3 control"",                                               ""2.16.840.1.113730.3.4.2"")_",1
"            wmem_register_callback(wmem_file_scope(), dof_sessions_destroy_cb, ccm_data)_",1
	smb_key[0] = key[0] >> 1_,1
	smb_key[1] = ((key[0] & 0x01) << 6) | (key[1] >> 2)_,1
	smb_key[2] = ((key[1] & 0x03) << 5) | (key[2] >> 3)_,1
	smb_key[3] = ((key[2] & 0x07) << 4) | (key[3] >> 4)_,1
	smb_key[4] = ((key[3] & 0x0F) << 3) | (key[4] >> 5)_,1
	smb_key[5] = ((key[4] & 0x1F) << 2) | (key[5] >> 6)_,1
	smb_key[6] = ((key[5] & 0x3F) << 1) | (key[6] >> 7)_,1
	smb_key[7] = key[6] & 0x7F_,1
	for (i = 0_i < 8_i++) {,1
		smb_key[i] = (smb_key[i ]<< 1)_,1
"WS_DLL_PUBLIC void ws_des_ecb_buffer_smb(guint8 *output, const guint8 *buffer, const guint8 *key)_",1
                    switch (ccm_data->protocol_id),0
"        gcry_cipher_encrypt(cipher_state, ptct, ptct_len, NULL, 0)_",0
                    gcry_cipher_close(ccm_data->cipher_data)_,1
                        gcry_cipher_close(ekey)_,1
                            gcry_cipher_close(ekey)_,1
                                gcry_cipher_close(ekey)_,1
"                            encryptInPlace(DOF_PROTOCOL_TEP, rijndael_handle, ticket + 16, 16)_",1
"print(""/* Generated by tools/make-tls-ct-logids.py, Last-Modified %s */"" %",0
	g_assert(fv->ftype->ftype == FT_ABSOLUTE_TIME ||,1
  guint32	vht_mimo_,0
    pos = 0_,0
              scidx = scidx + 3_,0
    switch (nchan_width) {,0
        case 0:		/* No Grouping */,0
"            case -6:	/* DC subcarriers, skip -4 to 4*/",0
        /* FALLTHROUGH */,0
			fv->ftype->ftype == FT_REL_OID)_,0
             * treated as success.),0
    myfilehandler.read = fh_read,0
#define IEEE80211_RADIOTAP_TS_SPOS_SHIFT		4,1
#define IEEE80211_RADIOTAP_TS_SPOS_ACQ			0x1,1
#define IEEE80211_RADIOTAP_TS_FLG_ACCURACY		0x02,1
"    { IEEE80211_RADIOTAP_TS_UNIT_MSEC, ""msec"" },",1
"    { IEEE80211_RADIOTAP_TS_SPOS_MPDU, ""first MPDU bit/symbol"" },",1
        case IEEE80211_RADIOTAP_TIMESTAMP:,1
"                        tvb, offset, 8, ENC_LITTLE_ENDIAN)_",0
"                    tvb, offset + 10, 1, ENC_LITTLE_ENDIAN)_",1
"        {&hf_radiotap_present_timestamp,",1
"        {&hf_radiotap_timestamp,",1
      /* Bug 11130: Check if it's the only DT1 */,0
          /* FALL THROUGH */,0
        /* FALL THROUGH */,0
            /* FALL THROUGH */,0
   ...,1
   fun:g_dir_open,1
   fun:g_hash_table_new_full,0
    tree->root      = NULL_,0
    if ((free_keys) && (node->key != NULL)) {,0
"    wmem_free(tree->allocator, tree)_",0
" count_nodes(const void *key _U_, void *value _U_, void *userdata)",0
    guint count_ /* number of items stored */,0
    if (!node) {,0
"        new_node = create_node(tree->allocator, NULL, GUINT_TO_POINTER(key),",0
"                CREATE_DATA(func, data), WMEM_NODE_COLOR_BLACK, is_subtree)_",0
        tree->root = new_node_,0
        tree->count = 1_,0
        return new_node_,0
guint32,0
        /* Check profile diretory before personal configuration */,0
                gint real_value_length = current_offset - value_offset_,1
"                    authorization_info->uri = wmem_strndup(wmem_packet_scope(), (const gchar*)tvb_memdup(wmem_packet_scope(), tvb, real_value_offset, real_value_length), real_value_length)_",0
"    gcry_md_write(md5_handle, "":"", 1)_",1
"    bytes_to_hexstr(ha1, gcry_md_read(md5_handle, 0), 16)_",0
"    if (!strncmp(response, authorization_info->response, 32)) {",1
authorization_user_t * sip_get_authorization(sip_authorization_t * authorization_info)_,0
"                    authorization_info->response = wmem_strndup(wmem_packet_scope(), tvb_get_ptr(tvb, real_value_offset, real_value_length), real_value_length)_",0
    for (i = 0_ i < len_ i++) {,0
"        { &ei_sip_authorization_invalid, { ""sip.authorization.invalid"", PI_SECURITY, PI_WARN, ""Invalid authorization reponse for known credentials"", EXPFILL }}",1
    if ( (authorization_info->qop == NULL) || ,0
"    if (strcmp(authorization_info->qop, ""auth"") || ",0
"      offset = dissect_bt_dht_nodes( 0, tvb, pinfo, sub_tree, offset, &val, ""Value"" )_",0
"      offset = dissect_bt_dht_nodes( key, tvb, pinfo, sub_tree, offset, &val, ""Value"" )_",1
			 * frees up the entry.),0
"	if (setsockopt (*sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, (socklen_t)sizeof(timeout)) < 0) {",0
"		g_warning(""Can't set socket option SO_RCVTIMEO: %s"", strerror(errno))_",0
		goto cleanup_setup_listener_,0
	int clientlen = sizeof(clientaddr)_,0
						wchar_t *errmsg = NULL_,0
						int err = WSAGetLastError()_,0
"						FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,",0
"							NULL, err,",0
"							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),",0
"							(LPWSTR)&errmsg, 0, NULL)_",0
"						g_warning(""Error in recvfrom: %S (err=%d)"", errmsg, err)_",0
"    res_rcv = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &socket_timeout, sizeof(socket_timeout))_",0
			 * Yes.  Remove the entry from the by-name hash table,0
        input_filename = g_strdup(argv[optind])_,0
static const value_string svhdx_vhdset_information_type_vals[] = {,0
    qDeleteAll(recent_captures_)_,1
    this->cleanup()_,0
  destroy_print_stream(args->stream)_,0
    destroy_print_stream(print_args_.stream)_,1
"    output          = (output_text *)wmem_alloc(wmem_epan_scope(), sizeof *output)_",0
"  args = (print_args_t *)g_object_get_data(G_OBJECT(win), PRINT_ARGS_KEY)_",0
    win32_cleanup_file()_,0
"{byte}            { if (parse_token(T_BYTE, yytext) != EXIT_SUCCESS) return EXIT_FAILURE_ }",0
"{offset}          { if (parse_token(T_OFFSET, yytext) != EXIT_SUCCESS) return EXIT_FAILURE_ }",0
[ \t]             _ /* ignore whitespace */,0
    return sizeof(buf) + 1_,0
"    res_rcv = setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char *) &socket_timeout, sizeof(socket_timeout))_",0
  col_cleanup(&cfile.cinfo)_,1
        /* Indent to correct level */,0
        for (i = -1_ i < pdata->level_ i++) {,0
"            fputs(""  "", pdata->fh)_",0
"            fprintf(pdata->fh, ""\"", %"" G_GINT32_MODIFIER ""d"", fi->start)_",0
"            fprintf(pdata->fh, "", %"" G_GINT32_MODIFIER ""d"", fi->length)_",0
"            fprintf(pdata->fh, "", %"" G_GUINT64_FORMAT, fi->hfinfo->bitmask)_",0
        for (i = -3_ i < pdata->level_ i++) {,0
"    cmd = ""cat "" + filename + ""| text2pcap "" + "" - "" + output_pcap_file",0
"    cmd = 'echo ""' + hexstring + '"" | xxd -r -p  | od -Ax -tx1 >>' + output_file",1
"    print ""Generated "" + sys.argv[0] + "".tmp""",0
                /* Indent to the correct level */,0
        /* Indent to the correct level */,0
  case WRITE_JSON_RAW:,0
    write_json_finale(stdout)_,0
extern const gchar* dtd_location(Dtd_PreParse_scanner_state_t* state)_,1
    QString plcHoldText = placeholderText()_,1
    if ( ! isValidText(plcHoldText) ),1
static GHashTable * _interface_for_ifname = NULL_,1
/* get a list of all available extcap tools */,0
"    newsca = wmem_new(wmem_epan_scope(), stat_cmd_arg)_",0
	ui_info.title = new_stat_tap->title_   /* construct this from the protocol info? */,0
#define TAG_DMG_BSS_PARAMETER_CHANGE 152  /* IEEE Std 802.11ad */,0
#define TAG_BEAMLINK_MAINTENANCE     169  /* IEEE Std 802.11ad */,0
  int tag_len = tvb_reported_length(tvb)_,0
      if (tag_len < 3),0
"    { 32769,   ""Darwin DPEB ID"" },",0
"    { 32770,   ""Darwin Service Class"" },",0
  wtap_cleanup()_,0
    wtap_cleanup()_,0
"      { ""Flags"", ""roofnet.flags"",",0
"      { ""Extensions"", prefix "".sct.sct_length"",                         \",0
static int hf_skinny_response_in	= -1_,1
"  ti = proto_tree_add_item(tree, hf_value, tvb, offset, value_len, ENC_ASCII | ENC_NA)_",0
"      expert_add_info_format(pinfo, ti, &ef_separator_not_found, ""Null byte not found"")_",0
    if (opcode == PROTOCOL_BINARY_CMD_OBSERVE) {,0
"  xattr_size = tvb_get_guint32(tvb, offset ,ENC_BIG_ENDIAN)_",0
"        proto_tree_add_bits_item(tree, hf_rohc_var_len, tvb, bit_offset, 3, ENC_BIG_ENDIAN)_",1
    if (ext_type != 0xc0) {,0
"                FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x20,",1
"                FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x04,",1
"                FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x02,",1
"                FT_UINT8, BASE_DEC, VALS(rohc_mode_vals), 0xc0,",1
"                FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x10,",1
"                FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x08,",1
"                FT_BOOLEAN, 8, TFS(&tfs_set_notset), 0x80,",1
            if (ext3_flags_value & 0x20) {,1
  g_free(cfile.filename)_,0
            wtap_cleanup()_,0
    epan_free(cfile.epan)_,0
"      /* We don't really have to cleanup here, but it's a convenient way to test",0
       * start-up and shut-down of the epan library without any UI-specific,0
       * cruft getting in the way. Makes the results of running,0
       * $ ./tools/valgrind-wireshark -n,0
"    g_array_free(blocktype_list[WTAP_BLOCK_NG_SECTION]->options, TRUE)_",1
"	g_array_free(encap_table_arr, TRUE)_",0
"    g_array_free(blocktype_list[WTAP_BLOCK_IF_STATS]->options, TRUE)_",0
"		g_ptr_array_free(small_buffers, TRUE)_",0
"snmp_usm_priv_des(snmp_usm_params_t* p _U_, tvbuff_t* encryptedData _U_, packet_info *pinfo _U_, gchar const** error _U_)",0
/* If you want to be able to decrypt or Check Authentication of ESP packets you MUST define this : */,0
"	/* initialize libgcrypt (beware, it won't be thread-safe) */",0
#if !defined(HAVE_LIBGNUTLS),0
"{ 8192,8192,        ""PDN_CONNECTION_REJECTION"" },",0
  } /* end struct size guard */,0
"  cursor = ptvcursor_new(skinny_tree, tvb, offset)_",0
static dissector_handle_t xml_handle_,1
"    const static unsigned int bw_map[] = { 0, 1, 4, 11 }_",0
"                rate_phy1 = tvb_get_letohl(tvb, offset)_",0
              {,0
 * Patches received from QCA,0
"                  tvb_get_letohl(tvb, offset)_",0
"    int mcs, base, pream_type, disp_rate, bw, sgi, ldpc, stbc, groupid, su_ppdu = 0, txbf_",0
            //bw = 20 << ((rate_phy1 >> 13) & 0x3)_,1
} else {,1
"  result = wmem_alloc(wmem_packet_scope(), SHORT_STR)_",0
"            	mactime = tvb_get_guint32(tvb, offset, byte_order)_",1
"                    proto_item_append_text(ti_did, "" 0x%x"", tvb_get_letohl(tvb, offset))_",0
"                  /* ignore guint32 rate_phy3 */ tvb_get_letohl(tvb, offset)_",1
"    { &hf_ieee80211_prism_did_sig_a1,",1
"	proto_tree_add_uint(tree, hf_mswsp_ctablecolumn_statused, tvb, offset, 1, used)_",0
"	proto_tree_add_uint(tree, hf_mswsp_ctablecolumn_lenused, tvb, offset, 1, used)_",0
"	type = tvb_get_guint8(tvb, offset)_",1
"	ccAlias = tvb_get_letohl(tvb, offset)_",0
"	idColumn = tvb_get_letohl(tvb, offset)_",0
/** Retrieves a list of keys inside the map,0
"        /* Not really a remove, but set data to NULL to mark node with is_removed */",0
"int_compare(gconstpointer a, gconstpointer b)",0
    for (i=0_ i<10_ i++) {,0
    if (((gint)len - (gint)ignored_bytes) <= 0) {,0
"    value = wmem_map_lookup(sid_buffer_to_sid_id, &lookup_key)_",0
"            packet->sender_sid = (dof_2009_1_pdu_19_sid)wmem_memdup(wmem_file_scope(), &lookup_key, length)_",0
    /* we use a stack with the names to avoid recurring infinitelly */,0
    proto_item *sub_item _U__,0
    proto_tree *gfi_sub_tree _U__,0
        proto_tree *gfi_sub_tree _U__,0
    guint32 status = 0_,0
    gboolean    is_tls13 = session->version == TLSV1DOT3_VERSION_,0
"          { ""LE Encryption"",                               ""btcommon.eir_ad.le_features.encryption"",",0
 * behavior automatic depending on the number of items?,0
"    gtk_label_set_width_chars (GTK_LABEL (label), 120)_",1
"    /* Parse list (note missing check for end of vector, ssl_add_vector below",0
"                       hf->hf.hs_ext_key_share_key_exchange_length, 1, 0xffff)) {",1
    gchar **value_display_strings = (gchar **)g_malloc0((1 + g_list_length(paths)) * sizeof (gchar *))_,0
typedef unsigned long long ulong64_,0
       (y)[1] = (unsigned char)(((x)>>8)&255)_ (y)[0] = (unsigned char)((x)&255)_ },0
           ((unsigned long)((y)[0] & 255))_ },0
"#define ROR(x, y) ( ((((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)((y)&31)) | ((unsigned long)(x)<<(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)",0
    p[0] = (guint8)(v >> 56)_,1
	volatile tap_listener_t *elem_lq_,0
	volatile tap_dissector_t *elem_dl_,0
"		commandline = g_utf8_to_utf16(""sharkd.exe -"", -1, NULL, NULL, NULL)_",0
Moshe Kaplan <me@moshekaplan.com> Your Name <you@example.com>,1
"        proto_tree_add_bitmask(extras_tree, tvb, offset, hf_meta_options, ett_extras_flags, extra_flags,",0
  if (basic_param_set_len%4) {,0
        goto clean_exit_,0
          exit_status = INVALID_OPTION_,0
          exit_status = INVALID_EXPORT_,0
            goto clean_exit_,0
            exit_status = INVALID_OPTION_,0
    exit_status = INVALID_OPTION_,0
    if( dtd_data->proto_root ) {,0
"    wmem_map_insert(xml_ns.elements, root_element->name, root_element)_",0
    destroy_dtd_data(dtd_data)_,0
"        int *hfp = (int *)wmem_alloc(wmem_epan_scope(), sizeof(int))_",0
    xmlpi_xml_ns->elements = NULL_,0
        // g_free(root_name)_,0
    /* the name of this namespace */,0
"    xml_ns_t *ns = (xml_ns_t *)wmem_alloc(wmem_epan_scope(), sizeof(xml_ns_t))_",1
"    wmem_strconcat(wmem_epan_scope(), s, name, NULL)_",1
"    unknown_ns.elements = xml_ns.elements = wmem_map_new(wmem_epan_scope(), g_str_hash, g_str_equal)_",0
#include <epan/geoip_db.h>,0
"ncp_hash_insert(conversation_t *conversation, guint8 nw_sequence,",0
"Additionally TOOLTIP and PLACEHOLDER may be provided, which will give the user an",0
"    proto_aruba_erm_type0 = proto_register_protocol_in_name_only(""Aruba Networks encapsulated remote mirroring - PCAP (Type 0)"", ""ARUBA ERM PCAP (Type 0)"", ""aruba_erm_type0"", proto_aruba_erm, FT_PROTOCOL)_",0
"            proto_tree_add_item(tree, hf_bthci_cmd_all_phys_tx, tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"            proto_tree_add_item(tree, hf_bthci_cmd_tx_phys_1m, tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"            proto_tree_add_item(tree, hf_bthci_cmd_rx_phys_1m, tvb, offset, 1, ENC_LITTLE_ENDIAN)_",0
"            FT_UINT8, BASE_HEX, VALS(cmd_le_host_no_pref_vals), 0x1,",0
"            proto_tree_add_item(tree, hf_bthci_cmd_phy_options, tvb, offset, 2, ENC_LITTLE_ENDIAN)_",0
		fflush(stdout)_,0
 * @param record_id The identifier for this record within the current packet.,1
"          /* XXX: this seems unused, remove? */",0
 * @param line A pointer to the input string,0
"    map->table     = wmem_alloc0_array(map->allocator, wmem_map_item_t*, CAPACITY(map))_",0
    map->count     = 0_,0
    if (map->table != NULL) {,0
  if (seq_length) {,0
"        g_string_append_printf(joined_str, ""\""%s\"""", str)_",0
	guint idx = 0_,0
		guint new_idx_,0
    QString value_,1
    for (int i = 0_ ui->enumListWidget->selectedItems().count() > i_ ++i) {,1
        QListWidgetItem *eli = ui->enumListWidget->selectedItems()[i]_,1
"        if (i) value.append("" "")_",1
        value.append(eli->data(Qt::UserRole).toString())_,1
    ui->valueLineEdit->setText(value)_,1
		if (!PINFO_FD_VISITED(pinfo) || (transfer_info->req == NULL)) {,0
"		fprintf(stderr, ""cannot go to background, sharkd will run in foreground"")_",0
"			fprintf(stderr, ""cannot accept()\n"")_",0
		ui,0
	@LIBSMI_LDFLAGS@,0
" * it under the terms of the GNU Affero General Public License, version 3,",0
"    if (!g_file_test(flat_file, G_FILE_TEST_IS_REGULAR)) {",0
        QMessageBox messageBox_,0
"        messageBox.critical(0, ""Error"", QString(""Can't find file: "") + flat_file)_",0
        goto clean_all_,0
open_url:,0
    QDesktopServices::openUrl(QUrl(interface_help_qs))_,0
        QDesktopServices::openUrl(help_url)_,0
/* packet-icall.c,1
/* packet-netrix.c,1
"					proto_tree_add_expert_format(icall_header_tree, pinfo, &ei_icall_unexpected_record, tvb, identifier_start, data_offset - identifier_start, ""Unexpected record %d with value %s"", record_identifier, record_data)_",1
	packet-icall.c		\,0
			ett = ett_icall_unknown_,0
"		col_clear(pinfo->cinfo,COL_INFO)_",0
"	{0x0009027C, ""FSCTL_GET_INTEGRITY_INFORMATION""},",0
"    matches, ~   Does the protocol or text string match the given Perl",0
"WS_DLL_PUBLIC guint prefs_get_uint_value(pref_t *pref, pref_source_t source)_",1
set(WIRESHARK_CUSTOM_QT_SRCS,0
    tvb_free(tvb_trailer_signature)_,0
	guint			dns_name_len_,0
	guint            dns_name_len_,0
"  compr_len = get_dns_name(tvb, offset, max_len, 0, &name, &name_len)_",0
	g_slist_free(shutdown_routines)_,0
"          { ""RSSI (dBm)"", ""bthci_evt.le_rssi"",",0
        /* Check GSE constraints on the BB header per 9.2.1 of ETSI TS 102 771 */,0
"        if (BIT_IS_SET(matype1, DVB_S2_BB_NPD_POS)) {",0
        new_off += bb_data_len_,0
 *  ETSI TS 102 771 - Digital Video Broadcasting (DVB)_ Generic Stream Encapsulation (GSE) implementation guidelines,0
"                ""Packetized Generic Stream Data"", HFILL}",0
  register int m_,0
"      msa = proto_tree_add_item(ti, hf_ieee80211_vht_membership_status_array, tvb,",0
              if (sta_info & 0x1000),0
"        {""User Position Array"",""wlan.vht.user_position_array"",",0
"        {""Membership Status Field"",""wlan.vht.membership_status_array.field"",",0
"        {""User Position Field"",""wlan.vht.user_position_array.field"",",0
"                bar_mtid_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, 0, ett_block_ack, NULL, ""Per TID Info"")_",1
    proto_item *rf_infot                     = NULL_,0
    tvbuff_t   	*next_tvb_,0
"	mgmt_byte = tvb_get_guint8(tvb, offset+1)_",0
"    proto_tree 	*ft, *flags_tree         = NULL_",0
    ifg_info   	*p_ifg_info_,0
"	vw_chanflags = tvb_get_letohs(tvb, offset)_",0
        if (plcp_type == 0x03)		/*** If the frame is VHT type ***/,0
			/* Skip to second byte of VHT-SIG-A1 */,0
"        { 261,		WTAP_ENCAP_IXVERIWAVE },",0
    case WTAP_ENCAP_IXVERIWAVE:,0
"          { ""Reserved"", ""pcep.obj.bu.eeserved"",",0
"          { ""Type"", ""pcep.obj.bu.bytype"",",0
        if (cf->state == FILE_READ_DONE && cf->current_frame) {  /* Bug 12973 - guard against NULL cf->current_frame value */,0
"        proto_tree_add_item(sub_tree, hf_svhdx_tunnel_scsi_cdb, tvb, offset, cdb_length, ENC_NA)_",0
					NVME_FABRIC_CMD_SIZE)_,0
"			 * |_ Unnecessary byte, skip it.",0
"			if ( tvb_get_ntohl(tvb, offset+(sep=2)) == 0x4f726163",0
"				proto_tree_add_item(data_tree, hf_tns_data_opi_version2_vsnum, tvb, offset, 4, sep == 2 ? ENC_BIG_ENDIAN : ENC_LITTLE_ENDIAN)_",0
#ifdef HAVE_LIBGCRYPT,0
#ifdef HAVE_LIBGNUTLS,0
void uat_init(void)_,1
void uat_init(void) {,0
    all_uats = g_ptr_array_new()_,0
    if (uat->reset_cb) {,1
        uat->reset_cb()_,1
"    g_ptr_array_free(all_uats,TRUE)_",1
"            geoip_db_post_update_cb,",1
    /* Clean the uats */,1
  if (dtls_key_hash),0
      g_hash_table_destroy(dtls_key_hash)_,0
    if (ssl_key_hash),0
        g_hash_table_destroy(ssl_key_hash)_,0
    g_hash_table_destroy(ssl_key_hash)_,1
        if (u->from_profile) {,0
"        uat = (uat_t *)g_ptr_array_index(all_uats, i)_",1
    g_free(uat->help)_,0
    g_free(uat->name)_,0
    g_free(uat->filename)_,0
    *uat->user_ptr = NULL_,0
    *uat->nrows_p = 0_,0
"    g_array_free(uat->user_data, TRUE)_",0
"    g_array_free(uat->raw_data, TRUE)_",0
"    g_array_free(uat->valid_data, TRUE)_",0
    for ( i = 0 _ uat->fields[i].title _ i++ ) {,0
        g_free(uat->fields[i].priv)_,0
 * Used to free the memory allocated by uat_new.,1
"    g_ptr_array_remove(all_uats,uat)_",0
    uat->user_data->data = NULL_,1
    // },1
 * Used to free previously allocated memory.,0
    /*  struct {,1
"    { & name .hf.hs_ext_psk_identity_identity_len,                      \",0
"        FT_NONE, BASE_NONE, NULL, 0x0,                                  \",0
	mudurl \,0
"	range = wmem_new(wmem_epan_scope(), range_t*)_",0
"   dst = (range_t *)wmem_alloc(scope, range_size)_",0
static const value_string pri_vals[] = {,0
static const value_string pri_vals_7[] = {,0
static const value_string pri_vals_6[] = {,0
static const value_string pri_vals_5[] = {,0
"    col_add_lstr(cinfo, COL_INFO,",0
"  proto_tree * data, * member_",0
"    proto_tree_add_item(tree, hf_isakmp_key_exch_dh_group, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
  if (isakmp_version == 1) {,0
"  proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset + 1, 3, ENC_NA)_",0
enum alerts_source {,0
        break_ /* XXX expert info? */,0
  if( lem.rule == NULL ) {,1
			    },0
    offset += 1_ /* Reserved */,0
"         * we won't find cmd in done q, so allocate a dummy ctx for doing",0
"    proto_nvme_rdma = proto_register_protocol(""NVM Express Fabrics RDMA"",",1
DISSECTOR_INCLUDES = \,0
"    cm_priv_tvb = tvb_new_subset_length(tvb, 36, 56)_",0
    if (attr == 0),0
"            { ""Reserved"", ""nvme-rdma.cqe.sqhd"",",0
#define NVME_AQ_OPC_DELETE_SQ        0x0,0
        cmd_key[1].key = NULL_,0
/* Code to actually dissect the packets */,0
"            ti = proto_tree_add_none_format(rule_tree, hf_snort_rule_port_var, tvb, 0, 0, ""Port Var: ($%s -> %s)"",",0
"    return proto_tree_add_bitmask_value_with_flags(tree, tvb, offset,",1
"  RFC5497_TLV_VALIDITY_TIME = 1,",0
  return tlv_decoded_value_item_,0
  case RFC5497_TLV_VALIDITY_TIME:,0
  case RFC7181_MSGTLV_MPR_WILLING:,0
"  g_snprintf(valstr, sizeof(valstr), ""%u * C"", uncompress_time(val8))_",0
      const char* valstr = (tlvCat == TLV_CAT_MESSAGE),0
"    prefs_register_obsolete_preference(transum_module, ""tsumenabled"")_",0
    new_string = (char *) malloc( strlen(fullname) + 1 )_,0
"    tpltname = pathsearch(lemp->argv0,templatename,0)_",0
    }    ,0
"			proto_tree_add_string_format_value(data_tree, is_request ? hf_tns_data_sns_cli_vers : hf_tns_data_sns_srv_vers,",0
"			proto_tree_add_item(data_tree, hf_tns_data_sns_srvcnt, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"			""Client Version"", ""tns.data_sns.cli_vers"", FT_STRING, BASE_NONE,",0
"dissect_rtp_hdr_ext_ed137(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_ )",0
"dissect_rtp_hdr_ext_ed137a(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_ )",0
"   { 1, ""Backplane"" },",0
"   cip_byte,",0
"			offset += dissect_om2k_negotiation_record1(tvb, offset, tree)_",0
            proto_item_append_text(proto_tree_add_item(,1
            proto_tree_add_uint_format_value(,1
"                    tree, hf_usb_i1d3_requested_integration_time, tvb,",0
"            guint firmver_size = tvb_strsize(tvb, 2)_",1
               isn't a unique identifier to determine subdissector */,0
"    rpc_handler = find_dissector_add_dependency(""rpc"", proto_rpcordma)_",0
	packet-eapol.h      \,0
	guint16 protocol_,0
	ethertype_data.etype = protocol_,0
"	ethertype_handle = find_dissector_add_dependency(""ethertype"", proto_homepna)_",0
set(PROJECT_MAJOR_VERSION 1),0
            if (base != SEP_NONE && (base < SEP_DOT || base > SEP_SPACE)) {,0
        if (base != SEP_NONE && (base < SEP_DOT || base > SEP_SPACE)) {,0
"        luaL_argerror(L,idx,""must be a table"")_",0
    if (prot_type == 1) {,0
"                                proto_tree_add_item(tree, hf_diameter_3gpp_ran_nas_cause_value, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
    return length_,0
                offset += 1_,0
"                proto_tree_add_item(tree, hf_gtpv2_ran_nas_cause_value, tvb, offset, length - offset, ENC_BIG_ENDIAN)_",0
    if (prot_type == 1),0
"    proto_tree_add_item(tree, hf_diameter_3gpp_ran_nas_cause_value, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
"        { &hf_diameter_3gpp_ran_nas_cause_type, ",0
"# Setup development environment on Redhat and derivatives such as Centos, Fedora, openSUSE",0
for op in $@,0
	[ $? -eq 0 ] || return 1,1
"echo ""gtk3 is unavailable""",0
"echo ""perl-Pod-Html is unavailable""",0
        ma_window_size_ = new_ma_size_,0
        <string>&lt_html&gt_&lt_head/&gt_&lt_body&gt_&lt_p&gt_Allow ACKs as well as data packets to be selected by clicking on the graph&lt_/p&gt_&lt_/body&gt_&lt_/html&gt_</string>,0
                seq.append(ackno)_,1
    Q_UNUSED(state)_,1
        <string>select ACKs</string>,1
            seq.append(ackno)_,0
            tput_time.append(rel_time[oldest] + ma_window_size_)_,0
        double dtime = ma_window_size__,0
            graph_update_timer_->stop()_,1
    if (graph_update_timer_) {,1
"            FT_UINT8, BASE_HEX, NULL, 0x0,",0
"            FT_UINT16, BASE_HEX, NULL, 0x0,",0
"          { ""Duration"", ""bthci_cmd.max_extended_advertising_events"",",0
            /* Remember the value and add it to tree */,0
    if (matcher->api_key < 0 || matcher->api_key >= ((kafka_api_key_t) array_length(kafka_apis))) {,0
"kafka_add_unsupported_api_key_expert_info(packet_info *pinfo, proto_item *ti, kafka_query_response_t *matcher)",0
"                                   ""Unsupported API version."")_",0
"            tvb_memcpy(tvb, &udp.checksum, offset, sizeof(udp.checksum))_",0
"            proto_tree_add_checksum(tree, tvb, offset, hf_6lowpan_udp_checksum, -1, NULL, pinfo, 0, ENC_BIG_ENDIAN, PROTO_CHECKSUM_NO_FLAGS)_",0
"        memcpy(LOWPAN_NHDR_DATA(nhdr), &udp, sizeof(struct udp_hdr))_",0
"               dissector = dissector_get_uint_handle( subdissector_symbol_table, segment )_",0
"   subdissector_symbol_table = register_dissector_table(""cip.data_segment.iface"",",1
﻿include::attributes.asciidoc[],0
* Added support for dissectors to include a unit name natively in their hf field.,0
"      ptvcursor_add(cursor, hf_homeplug_av_bcn_hm, 1, ENC_BIG_ENDIAN)_",0
"      ptvcursor_add(cursor, hf_homeplug_av_bcn_num_slots, 1, ENC_BIG_ENDIAN)_",0
"      ptvcursor_add_no_advance(cursor, hf_homeplug_av_bcn_hoip, 1, ENC_BIG_ENDIAN)_",0
"      ptvcursor_add(cursor, hf_homeplug_av_dtei, 1, ENC_BIG_ENDIAN)_",0
"      ptvcursor_add(cursor, hf_homeplug_av_ppb, 1, ENC_BIG_ENDIAN)_",0
"         { ""Non-coordinating networks reported"", ""homeplug_av.bcn.ncnr"",",0
"         { ""Network Power Save Mode"", ""homeplug_av.bcn.npsm"",",0
"         { ""Hand-Off in progress"", ""homeplug_av.bcn.hoip"",",0
"         { ""RTS Broadcast Flag"", ""homeplug_av.bcn.rtsbf"",",0
"         { ""Resuable SNID?"", ""homeplug_av.bcn.rsf"",",0
gui.layout_type: 3,0
arg {number=0}{call=--delay}{display=Time delay}{tooltip=Time delay between packages},0
"  {type=integer}{range=1,15}{required=true}",0
arg {number=1}{call=--message}{display=Message}{tooltip=Package message content},0
  {type=string},0
arg {number=2}{call=--verify}{display=Verify}{tooltip=Verify package content},0
  {type=boolflag},0
arg {number=3}{call=--remote}{display=Remote Channel}{tooltip=Remote Channel Selector},0
  {type=selector},0
arg {number=4}{call=--server}{display=IP address for log server}{type=string},0
#ifdef Q_OS_MAC,0
"#if defined(Q_OS_MAC) && (QT_VERSION > QT_VERSION_CHECK(5, 0, 0))",1
"            on_actionViewFullScreen_triggered(!this->isFullScreen()),",0
    if (checked) {,0
    main_ui_->actionViewFullScreen->setShortcut(QKeySequence::FullScreen)_,0
"   <property name=""shortcut"">",0
    <string>F11</string>,0
S<[ B<--full-screen> ]>,0
     <height>23</height>,0
    ui->outputDeviceComboBox->setCurrentIndex(ui->outputDeviceComboBox->findText(default_out_name))_,0
gboolean *detected_tcp_svc = NULL_,0
        clear_rrpd(&rrpd_list[i])_,0
    out_rrpd->c2s = in_rrpd->c2s_,0
"    temp_string = wmem_alloc(NULL, SIZEOF_TEMP_STRING)_",0
"    wmem_free(NULL, summary)_",0
#define ETH_TYPE_IPV6 0x86dd,0
#ifndef _PACKET_GSMTAP_H,0
#define GSMTAP_BURST_CDMA_CODE          0x10	/* WiMAX CDMA Code Attribute burst */,1
#define GSMTAP_CHANNEL_UNKNOWN    0x00,0
#define GSMTAP_ARFCN_F_UPLINK		0x4000,0
            unix_ts = g_date_time_to_unix(datetime)_,0
Franklin Mathieu <franklinmathieu@gmail.com> Snaipe <franklinmathieu@gmail.com>,0
                        else,0
    format.setSampleRate(audio_out_rate_)_,0
    format.setSampleSize(sample_bytes_ * 8)_ // bits,0
    if (!cur_out_device.isFormatSupported(format)) {,1
    mouseMoved(NULL)_,0
    const guint8 *ph_,1
value_string_ext tns_data_oci_subfuncs_ext = VALUE_STRING_EXT_INIT(tns_data_oci_subfuncs)_,0
"	{1,	""Logon to Oracle""},",0
		proto_tree *df_tree = NULL_,0
			if ( data_tree ),0
"			""Call ID"", ""tns.data_piggyback.id"", FT_UINT8, BASE_HEX,",0
"        sub_item = proto_tree_add_item(st, hf_btsmp_public_key_x, tvb, offset, 32, ENC_NA)_",1
"        sub_item = proto_tree_add_item(st, hf_btsmp_public_key_y, tvb, offset, 32, ENC_NA)_",1
    if (param & 0x01) {,0
					AC_MSG_ERROR([macOS builds should use Qt5]),0
        // Do not attempt to recognize protocols.,0
  guint32 profiles_end = offset + profiles_length_,0
"                                      hf_ssh_hostkey_ecdsa_curve_id, hf_ssh_hostkey_ecdsa_curve_id_length)_",0
"    // foundation: between 1 and 32 ""ICE chars"" (ALPHA / DIGIT / ""+"" / ""/"")",1
"      expert_add_info(pinfo, epath_item, &ei_proto_ext_network)_",0
"          expert_add_info(pinfo, epath_item, &ei_proto_ext_network)_",0
"{ SUBMESSAGE_PAD,                       ""PAD"" },",0
  if (print_tree != NULL) {,0
"  if ((init_progfile_dir_error = init_progfile_dir(argv[0], main))) {",0
"		POD2HTML=""perl-Pod-Html""",0
"         * direction, because it could be another different",0
        case RDMA_MSG:,0
        eo_free_entry(entry)_,0
"    col_packet_,",0
            return QString().setNum(entry_->pkt_num)_,0
        eo_ti->entry()_,0
    export_object_gui_reset_cb reset_cb_ /* function to parse parameters of optional arguments of tap string */,0
"void MainWindow::addExportObjectsMenuItem(gpointer data, gpointer user_data)",1
    export_action->setEnabled(false)_,1
Export all objects within a protocol.,0
	export_object.c	\,1
        entry = (export_object_entry_t *)g_malloc(sizeof(export_object_entry_t))_,1
        entry->filename = g_strdup(g_path_get_basename(eo_info->filename))_,1
		entry->filename = g_strdup(g_path_get_basename(eo_info->filename))_,0
  entry->filename = g_strdup(g_path_get_basename(eo_info->filename))_,0
            return eo_,0
"        out_str = g_string_append_c(out_str, HEXTOASCII(LONIBBLE(*tmp_ptr)))_",1
"typedef export_object_entry_t* (*export_object_object_list_get_entry_cb)(void* gui_data, int row)_",0
    export_object_object_list_add_entry_cb add_entry_ //GUI specific handler for adding an object entry,0
WS_DLL_PUBLIC register_eo_t* get_eo_by_name(const char* name)_,0
"WS_DLL_PUBLIC GString *eo_massage_str(const gchar *in_str, gsize maxlen, int dup)_",1
	export_object_ui.c		\,1
	export_object_ui.h		\,1
"        eo_iterate_tables(list_exportobject_protocol, NULL)_",0
"            fprintf(stderr, ""Failed to create export objects output directory! %s\n"", save_in_path)_",0
    /* Used to get tshark to link this file */,0
#define LONGOPT_EXPORT_OBJECTS  5001,1
"            open_failure_alert_box(save_as_filename, errno, TRUE)_",0
				do {,0
	exportobjects_tap_ui.h		\,0
"	TAP_NAME,",0
"			proto_tree_add_item(e_tree, hf_bootp_option125_length, tvb, optoff, 1, ENC_NA)_",0
"	subopt_len = tvb_get_guint8(tvb, suboptoff)_",0
"        { &hf_bootp_option125_length,",0
    if (audio_output_) {,1
        if (FALSE && pcap_opts->pcap_h != NULL) {,0
"    connect(&rtp_player_dialog, SIGNAL(goToPacket(int)), this, SIGNAL(goToPacket(int)))_",0
          {,0
/* Internal flag for tracking concatenated frames */,0
     necessary to generate protocol tree items. */,0
"          next_tvb =  tvb_new_subset_remaining(tvb, hdrlen)_",0
"              call_dissector (docsis_handle, next_tvb, pinfo, tree)_",0
.cproject,0
"        ""Enabled"",",0
"    length = tvb_get_guint8(tvb, offset+1)_",0
    if (tag_len < length),0
# libgnutls28-dev: Debian jessie,0
"echo ""libgnutls-dev not available""",0
"            ""Resolve SS7 PCs"",",0
static const value_string ietf_6top_command_identifiers[] = {,0
        case IETF_6TOP_RC_ERR_VER:,0
"        { ""Code"",  ""wpan.ietf_ie.6top.code"", FT_UINT8, BASE_HEX, NULL, 0x0,",0
"    sixtop_tree = proto_tree_add_subtree_format(p_inf_elem_tree, tvb, offset, pie_length, ett_ieee802154_p_ie_ietf_6top, NULL, ""6top IE Content"")_",1
"    proto_tree_add_item(sixtop_tree, hf_ieee802154_p_ie_ietf_6top_sfid, tvb, offset + 3, 1, ENC_LITTLE_ENDIAN)_",0
            /* unsupported return code */,0
"     {""Information Request"", ""wlan.20_40_bc"",",0
    if (length < 12) {,0
"        expert_add_info_format(pinfo, tree, &ei_bgp_ls_error,",0
"                ""Link State NLRI length is lower than 12 bytes! (%d)"", length)_",0
        return length_,0
    length -= dissected_length_,0
    if (length > 0 && length < 4) {,0
"                ""Unknown data in Link-State Link NLRI! length = %d bytes"", length)_",0
        return dissected_length_,0
"                col_append_fstr(pinfo->cinfo, COL_INFO, "" [%d bytes GZIPd]"", tvb_reported_length(payload))_",0
"            col_append_fstr(pinfo->cinfo, COL_INFO, "" [%d bytes GZIPd]"", bytes_length)_",0
"    gint16 api_key, min_version, max_version_",0
"            { ""Reserved"",                                  ""bthci_evt.features.reserved"",",0
"execute_process(COMMAND ${GIT_EXECUTABLE} archive HEAD WORKING_DIRECTORY ""${PROJECT_SOURCE_DIR}"" COMMAND tar x -C ""${WS_SOURCE_DIR}"")",0
"execute_process(COMMAND ${GIT_EXECUTABLE} -C ""${CMAKE_SOURCE_DIR}"" describe OUTPUT_VARIABLE GIT_DESCRIBE)",0
"	echo -n ""git_description="" > ${PROJECT_SOURCE_DIR}/version.conf &&",0
        if ( vl_max % 4 == 0) {,0
"dissect_kafka_offset_fetch_response_partition(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,",0
"                                              int start_offset, kafka_api_version_t api_version _U_)",0
                                 kafka_api_version_t api_version _U_),0
"dissect_kafka_offsets_response_partition(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,",0
            /* TODO: decode other response types */,0
"               FT_INT64, BASE_DEC, 0, 0,",0
add_custom_target(dist COMMAND ${CMAKE_MAKE_PROGRAM} package_source),0
"        g_debug(""Can't set socket timeout, using default"")_",0
"    cip_req_info_t *preq_info, proto_item* msp_item, gboolean is_msp_item)_",1
matrix:,1
"    g_snprintf(short_name, len, ""%s_%s"", proto->loname, listname)_",0
            g_free(short_name)_,0
"        luaL_argerror(L,3,""The heuristic dissector must be a function"")_",0
static const value_string pn_io_am_location_reserved1_vals[] = {,0
"  {2, ""Broadcast initial ranging required.""},",0
"mailto:{wireshark-dev-list-email}[wireshark-dev mailing list], or attach it to your bug report.",0
and updated for VS2013 by mailto:{wsdg-author-email2}[Graham Bloice],0
authors through {wireshark-dev-list-email}.,0
  -l <typenum>           link-layer type number_ default is 1 (Ethernet). See,1
link:{wikipedia-main-url}[Time_zone] and,1
updated by mailto:{wsug-author-email}[Ulf Lamping].,0
    digits[8] = '\0'_,0
    digits[4] = '\0'_,0
    info->seq[0] = info->seq[1] = 0_,0
    //Only TCP stream uses fragments,0
    fragment = (follow_record_t*)fragment_entry->data_,0
        lowest_seq = fragment->seq_,0
"        if( GT_SEQ(lowest_seq, fragment->seq) ) {",0
            lowest_seq = fragment->seq_,0
"        if( LT_SEQ(fragment->seq, follow_info->seq[is_server]) ) {",0
"            if( GT_SEQ(newseq, follow_info->seq[is_server]) ) {",0
                if ( fragment->data->len > new_pos ) {,0
                follow_info->seq[is_server] += (fragment->data->len - new_pos)_,0
            if( fragment->data->len > 0 ) {,0
"    if( GT_SEQ(acknowledged, lowest_seq) ) {",0
"        follow_record->data = g_byte_array_append(follow_record->data,",0
"    follow_record->data = g_byte_array_append(follow_record->data,",0
"        copy_address(&follow_info->client_ip, &pinfo->src)_",0
    if (follow_info->bytes_written[follow_record->is_server] == 0) {,0
        follow_info->seq[follow_record->is_server] = sequence + length_,0
"    if( LT_SEQ(sequence, follow_info->seq[follow_record->is_server]) ) {",0
"            eo_info->sender_data = (gchar *) tvb_memdup(wmem_packet_scope(), tvb, value_offset, end_offset - value_offset - 2)_",0
"  eo_info = wmem_new(wmem_packet_scope(), imf_eo_t)_",0
"    eo_info->sender_data = ""\0""_",0
 * By Gerald Combs <gerald@xxxxxxxxxxxxx>,0
        .tv_usec = SOCKET_SEND_TIMEOUT_MS * 1000,1
"    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &socket_timeout, sizeof(socket_timeout))_",0
static struct timeval  socket_timeout = {,0
"        .tv_sec = 0,",0
        .tv_usec = 500000,0
"        if(CMAKE_VERSION VERSION_GREATER ""3.0"")",1
		set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ${CCACHE_EXECUTABLE}),0
	endif(CCACHE_EXECUTABLE),1
		COMMAND ${GLIB_COMPILE_RESOURCES} --sourcedir=${CMAKE_SOURCE_DIR} --target=${_outputfile} --generate --manual-register ${CMAKE_CURRENT_SOURCE_DIR}/${_resourcefile},1
"    oxm_length = tvb_get_guint8(tvb, offset + 3)_",0
"        proto_tree_add_item(tree, hf_openflow_v4_oxm_experimenter_value, tvb, offset, oxm_length - 4 , ENC_BIG_ENDIAN)_",0
"  ansi_sub_dissectors = register_dissector_table(""ansi.ssn"", ""ANSI SSN"", proto_tcap, FT_UINT8, BASE_DEC)_",0
            WSLUA_RETURN(1)_ /* The `Int64` object. */,0
"       The range must be 1, 2 or 4 octets long. */",0
            WSLUA_RETURN(1)_ /* The signed integer value */,0
             *    we are missing 5 and 6 byte integers within lua's range,0
"       The range must be 1, 2, 4 or 8 octets long. */",0
        case 0x09: /* LE Generate DHKey Complete */,0
/* TODO */,0
"          { ""Local RPA"",          ""bthci_evt.le_local_rpa"",",0
"		$repo_branch = $version_pref{""tar_repo_branch""}_",1
		if (!($repo_branch =~ /^master/ && $repo_branch =~ /unknown/i)) {,0
	CPackConfig.txt \,1
	git describe >> version.conf && \,1
  while((offset+8)<tvb_reported_length(tvb)) {,0
"            offset, bytes+8, tvb_get_ptr(tvb, offset, bytes),",0
"	LZ4=""liblz4-devel liblz4-1""",1
"	LZ4=""liblz4-devel liblz4""",0
"	LZ4=""lz4-devel liblz4-1_7""",0
asciidoc git git-review perl-podlators libnghttp2-devel libnghttp2,1
%global with_cql_compression 1,0
BuildRequires:	lz4-devel,0
Requires:	liblz4-1_7,0
BuildRequires:	lz4,0
Requires:	libz1                                           |Requires:       c-ares,0
"                                ""Large communities:%s"", wmem_strbuf_get_str(comm_strbuf))_",0
"    for (int idx = sourceModel->rowCount()_ it != newDevices.constEnd()_ ++it, idx++)",0
            if ( useDevice ),0
    if (dynamic_cast<InterfaceTreeCacheModel*>(sourceModel()) != 0),0
    if ( newDevices.size() > 0 ),1
    while ( it != newDevices.constEnd() ),0
"            QMap<InterfaceTreeColumns, QVariant>::const_iterator data_it = dataField->constBegin()_",1
        storage->remove(idx)_,0
        delete dataField_,0
interface_t * InterfaceTreeCacheModel::lookup(const QModelIndex &index) const,0
"    /* Handle all fields, which will have to be displayed for new devices. Only pipes",1
"    memset(&(device->if_info), 0, sizeof(if_info_t))_",0
      <number>1</number>,0
        QList<QLineEdit *> items = parent->findChildren<QLineEdit*>()_,1
        if ( items.count() > 0 ),1
"    void draw(address *bssid, int num_packets) {",0
"    queried_offset = tvb_find_guint8 (tvb, value_offset, line_end_offset - value_offset, ',')_",0
"        queried_offset = tvb_ws_mempbrk_pattern_guint8(tvb, par_name_end_offset, line_end_offset - par_name_end_offset, &pbrk_quotes, &c)_",0
"        }else if(c=='""'){",0
"create_capture_dissector_handle_with_name(capture_dissector_t dissector,",0
"  line = wmem_strndup(wmem_packet_scope(), tvb_get_ptr(tvb, offset, linelen), linelen)_",0
"    if (hid == 0x08 && !ws_strtou32(hval, NULL, &cd->content_length)) {",0
"      proto_tree_add_expert(ajp13_tree, pinfo, &ei_ajp14_content_length_invalid,",0
"        tvb, pos, hval_len)_",0
		errno = EINVAL_,0
  gint32            num_,0
    marked_row = 0_,1
"    if (name != NULL && ws_strtoi32(gtk_tree_model_get_string_from_iter(model, &iter), NULL, &num) &&",1
"  ws_strtoi32(gtk_tree_path_to_string(path), NULL, &indx)_",1
"          ws_strtoi32(str_b, NULL, &int_b)_",1
"    buf = _fcvt(x, 0, &dec, &sig)_",0
"	buf = _fcvt(x, 0, &dec, &sig)_",0
	proto_item  *pi_,1
"	prefs_register_uint_preference(quakeworld_module, ""udp.port"",",0
"					""QuakeWorld Server UDP Port"",",0
"					""Set the UDP port for the QuakeWorld Server"",",0
"    proto_iperf2 = proto_register_protocol(""iPerf2 Packet Data"", ""iPerf2"", ""iperf2"")_",0
	packet-iperf.c		\,0
#define IPERF2_PORT 5001,1
proto_register_iperf2(void),0
"            { ""iPerf2 sequence"", ""iperf2.udp.sequence"", FT_UINT32, BASE_DEC,",0
    if (tree) { /* we are being asked for details */,0
"        proto_tree_add_item(client_tree, hf_iperf2_mwinband, tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"                prefStorage[&prefs.capture_devices_pmode]  << QString(""%1(%2)"").arg(device.name).arg(value ? 1 : 0)_",1
"        *key = qstring_strdup(it.value().join("",""))_",0
"            return QString(""-"")_",0
                    return html_escape(cfilter)_,0
    emit commitData(spinBox)_,0
"                        item = proto_tree_add_ipv6(tree_item->tree, hfid, tvbr->tvb->ws_tvb, tvbr->offset, tvbr->len, &ipv6)_",0
"                        memcpy(&addr.bytes, (const guint8*) checkAddress(L,1)->data, 16)_",0
"        setText(duration_col_, QDateTime::fromTime_t(nstime_to_sec(&(call_info_->stop_fd->abs_ts)) - nstime_to_sec(&(call_info_->start_fd->abs_ts))).toUTC().toString(""hh:mm:ss""))_",0
        call_info_(call_info),0
                        call_info_->protocol_name : voip_protocol_name[call_info_->protocol])_,0
    bool mTimeOfDay_,0
"		/* The RHS should be FT_BYTES, but a character is just a",0
"    if (cl && ws_strtou32(hval, NULL, &cl)) {",0
"            expert_add_info(pinfo, ti, &ei_catapult_dct2000_string_invalid)_",0
"                    flag_tree = proto_item_add_subtree(ti_opt, ett_icmpv6_rpl_flag_metric)_",0
"                            flag_tree = proto_item_add_subtree(ti_opt, ett_icmpv6_rpl_metric_nsa_object)_",0
                            do {,0
"                                ti_opt = proto_tree_add_item(icmp6opt_tree, hf_icmpv6_rpl_opt_metric_ne_object, tvb, opt_offset, 2, ENC_NA)_",0
"        { &hf_icmpv6_rpl_opt_metric_type,",0
                guint8 metric_len_,0
"            if (!zbee_gp_security_parse_key(rec->string, rec->key, rec->byte_order)) {",0
"        if (memcmp(gp_uat_key_records[i].key, empty_key, ZBEE_SEC_CONST_KEYSIZE) == 0) {",0
"                AMQP_INCREMENT(offset, size + 2, length)_",0
"                AMQP_INCREMENT(offset, array_size, length)_",0
    gint idx_,0
	@LIBSMI_LDFLAGS@		\,0
"            combobox->setItemText(new_index, data)_",0
"        combobox->setItemText(combobox->currentIndex(), data)_",1
"        g_log(LOG_DOMAIN_CAPTURE, G_LOG_LEVEL_MESSAGE, ""Capture Interface List failed, error %d, %s (%s)!"",",1
"              *err, primary_msg ? primary_msg : ""no message"",",1
"              secondary_msg ? secondary_msg : ""no secondary message"")_",1
        if (err_str) {,1
            *err_str = primary_msg_,1
            g_free(primary_msg)_,1
        g_free(secondary_msg)_,1
static const value_string session_states[] = {,0
            GChecksum *hash  = g_checksum_new(G_CHECKSUM_SHA512)_,0
            local_offset += 4_  /* skip qpn + reserved */,1
" - CMAKE_GTK_OPTS=""BUILD_wireshark_gtk=ON""""",0
"                interface_t device = g_array_index(global_capture_opts.all_ifaces, interface_t, row)_",1
                if ( col == IFTREE_COL_HIDDEN ),1
    void()_,1
            if ( QString(prefs.capture_device).compare(deviceName) == 0 ),1
            return true_,1
            flags = Qt::ItemIsEnabled | Qt::ItemIsUserCheckable_,0
"    if ( ( dataField = storage->value(row, 0) ) == 0 )",1
                dataField->remove(col)_,1
    if ( ( role == Qt::DisplayRole && editableColumns.contains(col) ) ||,0
            if ( dataField->keys().contains(col) ),1
"                return dataField->value(col, QVariant())_",1
#include <QIdentityProxyModel.h>,1
                if ( device.if_info.type == IF_EXTCAP ),1
"                return QString(tr(""Show""))_",1
"static const guint8 kafka_xerial_header[8] = {0x82, 0x53, 0x4e, 0x41, 0x50, 0x50, 0x59, 0x00}_",0
        QItemSelectionRange selection = (QItemSelectionRange) (*it)_,1
    if (app_id == ZBEE_ZCL_GP_APP_ID_DEFAULT) {,0
    app_id = (options & ZBEE_ZCL_GP_PROXY_TBL_OPT_APP_ID) >> ws_ctz(ZBEE_ZCL_GP_PROXY_TBL_OPT_APP_ID)_,0
"	extcap_help_add_option(extcap_conf, ""--version"", ""print the version"")_",0
"	{ ""debug"", optional_argument, NULL, EXTCAP_OPT_DEBUG} \",0
"    extcap_help_add_option(extcap, ""--version"", ""print tool version"")_",0
"                if (!prefs_set_range_value(pref, value, &module->prefs_changed))",0
	AC_WIRESHARK_PUSH_FLAGS,0
INCLUDE(FindPkgConfig),0
"echo ""                         Use SNAPPY : $have_snappy""",0
    http_tcp_range = range_copy(*http_tcp_ports->varp.range)_,0
				message_length= (guint32)orig_size_,0
"            code_valid = ws_strtou32(code_str, NULL, &code)_",0
"        if (!ws_strtou16(p, NULL, ftp_port)) {",0
                *ftp_port_len = (guint)(--e - p)_,0
"    col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", (cap & IEEE802154_CMD_CINFO_DEVICE_TYPE) ? tfs_cinfo_device_type.true_string : tfs_cinfo_device_type.false_string)_",0
"    zdp_parse_node_desc(tree, NULL, ett_zbee_zdp_node, tvb, &offset, version)_",0
        if (pinfo && ver_flags) {,1
 * CQL V4 reference: https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v5.spec,0
"  HINTS ""${NGHTTP2_HINTS}/include""",0
"  HINTS ""${NGHTTP2_HINTS}/lib""",0
        DISSECTOR_ASSERT(message_id == 0xFE)_,0
 *@param pinfo pointer to packet information fields (unused).,0
    guint8               ie_length_,0
    tvbuff_t  *volatile  payload_tvb_,0
            case IEEE802154_PAYLOAD_IE_IANA_6TOPGROUPID:,0
"                proto_tree_add_item(mq_tree, hf_mq_pmo_resolvqmgr , tvb, offset + 80, 48, p_mq_parm->mq_str_enc)_",0
"        const char* string_text = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + string_size_field_len, string_size, string_encoding)_",0
"    total_len = tvb_reported_length_remaining(tvb, offset)_",1
        gchar* str_,0
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""HL7"")_",1
            pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT_,0
    if (segment_len == -1) {,0
            if (field_number < 9) {,0
"	BGP-LS extensions for Segment Routing, draft-gredler-idr-bgp-ls-segment-routing-ext-01",0
"/* as per Health Level Seven, Version 2.6, appendix A */",0
gint,0
static const hl7_msg_type _U_ hl7_msg_types[] = {,0
"tvb_find_guint16(tvbuff_t *tvb, const gint offset, const gint maxlength,",0
"    { 0x7F12,               ""TLS 1.3 (draft 18)"" },",0
"    { 0x00, NULL }",0
"parse_string_field(proto_tree *tree, int hf, packet_info *pinfo, tvbuff_t *tvb, int offset, int* next_offset, int* linelen)",0
"    if (!ws_strtoi32(tvb_get_string_enc(wmem_packet_scope(), tvb, tag->value_offset,",0
"        if (!ws_strtoi32(tvb_get_string_enc(wmem_packet_scope(), tvb, offset,",0
# https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=12997,1
"   {0x06, FALSE, 8, 7, ""Connection Timeouts"", cip_uint, &hf_conn_mgr_conn_timouts, NULL},",0
"      att_item = proto_tree_add_uint_format_value(tree, hf_cip_attribute16,",0
"	gint len = tvb_find_guint8(tvb, offset, maxlength, needle1)_",0
	do {,0
"    QString stats_tables = ""<html><head><style>td{vertical-align:bottom_}</style></head><body>\n""_",0
"	COMPILE_FLAGS ""${LEMON_COMPILE_FLAGS}""",0
#include <valgrind/callgrind.h>,0
#ifdef HAVE_EXTCAP,0
        ui->interfaceTree->resizeColumnToContents(proxyModel->mapSourceToColumn(IFTREE_COL_EXTCAP))_,0
"     * or to determine size here and set it. 50 is bigger then the biggest icon, so for now, this",0
"    ui->interfaceTree->setColumnWidth(proxyModel->mapSourceToColumn(IFTREE_COL_EXTCAP), one_em * 3)_",1
"    return index(newIndex.row(), _columns.indexOf((InterfaceTreeColumns) sourceIndex.column()))_",1
		gint32 val = 0_,0
		else {,0
    proto_tree		*ext_tree_tft_,0
    guint16     	length_,1
"	if (!tvb_bytes_exist(tvb, offset, comprlen)) {",0
		return NULL_,0
	compr = (guint8 *)g_malloc(comprlen)_,0
				g_free(compr)_,0
	g_free(compr)_,0
The command must be able to produce a PCAP stream written to STDOUT. Like the one produced by,1
"wireshark(1), tshark(1), dumpcap(1), extcap(4)",0
	if (capture_command) {,1
A custom remote capture command that produces the remote stream that is shown in Wireshark.,1
    QItemSelection mySelection = proxyModel->mapSelectionFromSource(sourceSelection)_,0
    if ( sourceModel->updateSelectedDevices(sourceSelection) ),1
"    return InterfaceTreeModel::data(index(idx, col), Qt::DisplayRole)_",0
            if ( !selectIndex.isValid() ),0
"    foreach(QItemSelectionRange selection, sourceSelection)",0
    pRSTimeStamp[12] = '\0'_,0
        pRSDomainIdentification[u8LengthRSDomainIdentification] = '\0'_,0
        pRSMasterIdentification[u8LengthRSMasterIdentification] = '\0'_,0
            pRSTimeStamp[12] = '\0'_,0
static const value_string pn_io_rs_block_type[] = {,0
        /* XXX - dissect remaining user structures of [AlarmItem] */,0
"        if (!strcmp(uats->port, ""0"") && !strcmp(uats->port, ""any"") && ws_strtou16(uats->port, NULL, &port)) {",1
        /* Port to subprotocol mapping */,0
"        if (ws_strtou16(uats->port, NULL, &port)) {",0
	_U_,0
"QVariant InterfaceTreeModel::data(const QModelIndex &index _U_, int role _U_) const",1
	interface_sort_filter_model.h				\,1
        proxyModel->toggleIfType(ifType.toInt())_,1
    _filterHidden = true_,0
    bool hasHiddenTypes = hiddenTypes.size() > 0_,1
    buttonLayout->addWidget(button)_,1
"        button->setProperty(prop.toStdString().c_str(), content)_",1
                .arg(html_escape(device.addresses))_,1
"        ""Display the given interfaces in the startup list"",",1
    if (QString(prop).compare(QString(BTN_IFTYPE_PROPERTY)) == 0),1
    prefs.gui_interfaces_hide_types = g_strdup(new_pref.toStdString().c_str())_,1
                .arg(html_escape(QString(device.addresses)))_,1
                .arg(html_escape(QString(cfilter)))_,1
    delete(sourceModel)_,1
    buttonLayout->takeAt(0)_,0
            if ( selectIndex.row() < 0 ),1
        if ( selectIndex.row() >= 0 ),1
"        pref.append(QString(""%1,"").arg(i))_",1
    if (! filteredTypes.contains(device.if_info.type) ),0
    void resetPreferenceData()_,1
    return count <= 1 ? 1 : count_,1
    return ((int) IFTREE_COL_MAX)_,1
"        return QString("""")_",1
"        tt_str.replace('\n', "", "")_",1
                .arg(cfilter)_,1
         <string>&lt_html&gt_&lt_head/&gt_&lt_body&gt_&lt_p&gt_List of available capture interfaces&lt_/p&gt_&lt_/body&gt_&lt_/html&gt_</string>,1
"                this->main_welcome_->getInterfaceFrame(), SLOT(interfaceListChanged()))_*/",1
"				proto_tree_add_uint(user_info_tree, hf_user_info_terminal_speed,",1
"			if (!ws_strtou32(str, NULL, &term_len)) {",1
   if (size > 4),0
"set_source_files_properties(jsmn.c PROPERTIES COMPILE_FLAGS ""-DJSMN_STRICT"")",0
	-DJSMN_STRICT	\,1
	ws_mempbrk.c	\,0
"#include ""jsmn.h""",0
void jsmn_init(jsmn_parser *parser)_,0
"						if (ws_strtou64(format_text(line, tokenlen), NULL, &t.secs)) {",0
						},0
"						// t.secs = atoi(format_text (line, tokenlen))_",0
	/* allocation */,0
"dissect_lldp_chassis_id(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, ",0
"        pn_lldp_column_info->chassis_id_mac = wmem_strdup(wmem_file_scope(), strPtr)_",0
"            pn_lldp_column_info->chassis_id_locally_assigned = wmem_strdup(wmem_file_scope(), strPtr)_",0
docbook/release-notes.asciidoc# CMakeLists.txt,0
#define HSMS_TCP_PORT 5000,0
        for(unsigned int counter=0_ counter<length_ counter++),0
"    return dissect_secs_variable(tvb, pinfo, tree, data, &offset)_",0
    if (pType != PTYPE_SECS),0
"dissect_secs_message(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree _U_, void *data _U_, int offset)",0
"dissect_hsms_message(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree _U_, void *data _U_)",0
"dissect_hsms(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_, void *data _U_)",0
// 0        =>  SECS-II Encoding,0
// 1-127    =>  Reserved for subsidiary standards,0
        if (byte2 != 0) // byte2 must be zero,0
        if (byte3 != 0) // byte3 must be zero,0
    /* header = 10 bytes */,0
    // 11-127   =>  Reserved for subsidiary standards,0
"static gint8 get_value_length(const guint32 val, const value_length *vl)_",0
static gint8,0
"get_value_length(const guint32 val, const value_length *vl)",0
    gint i = 0_,0
    if(vl) {,0
        while (vl[i].length >= 0) {,0
            if (vl[i].value == val) {,0
                return(vl[i].length)_,0
            i++_,0
    return -1_,0
static const value_string ptype_names[] = {,0
"    { 0, ""SECS"" },",0
    switch (sType),1
 * protocol. */,0
    // add the formatcode/length bytes to the item tree,0
    /* Check if first byte describes length) */,0
        len = 1_,0
    if (tvb_reported_length(tvb) > HSMS_MIN_LENGTH),0
    /* Register an example port preference */,0
Frear				<from_wireshark[AT]frear.com>,0
        /* \todo filename should be converted to UTF-8. */,0
#define  PCEP_RP_RESERVED               0xFFC000,0
"	sidlist_len = tvb_get_letohl(tvb, offset)_",1
"	getinfo_offset = tvb_get_letohs(tvb, offset)_",1
"	getinfo_size = tvb_get_letohl(tvb, offset)_",1
"    { BGP_EXT_COM_COST_POI_ORIGIN,  ""\""Lowest Origin code\"" step"" },",0
/* EIGRP external protocol numbering - retaken from packet-eigrp.c */,0
                found = TRUE_,0
                counter++_,1
"        url = user_guide_url(""ChExtcapOptions.html"")_",0
		/* Shows at minimum 6 entries at most desktops */,1
class ExtcapOptionsDialog : public QDialog,0
    <height>400</height>,1
    	workingDir = QFileInfo(filename).dir()_,1
"		workingDir.absolutePath(), tr(""All Files (*.*)""))_",1
    	textBox->setText(filename)_,1
"        return result.join(',')_",0
    void on_extcap_options_finished(int result)_,1
"        } else if (g_ascii_strcasecmp(v->value, ""selector"") == 0) {",1
		QVariant data = boxSelection->currentData()_,0
#define PUBLISH_MSG_TYPE       2,0
"  { NAK_MSG_TYPE,            ""Error"" },",0
"  hartip_tcp_handle = new_create_dissector_handle(dissect_hartip_tcp, proto_hartip)_",0
"    { SSL_HND_HELLO_EXT_ELLIPTIC_CURVES, ""elliptic_curves"" }, /* RFC 4492 */",0
"      ""Wlan Identity Prefix"", ""eap.identity.wlan.prefix"",",1
"          memcpy( encr_iv + encr_iv_offset + key_info->encr_spec->salt_len, iv, iv_len )_",0
    case LOCATOR_KIND_DTLS: {,0
"		{ &hf_nfs4_offload_statuses, {",0
"@Checksum Errors@eth.fcs.status==""Bad"" || ip.checksum.status==""Bad"" || tcp.checksum.status==""Bad"" || udp.checksum.status==""Bad"" || sctp.checksum.status==""Bad"" || mstp.checksum.status==""Bad"" || cdp.checksum.status==""Bad"" || edp.checksum.status==""Bad"" || wlan.fcs.status==""Bad"" || stt.checksum.status==""Bad""@[4718,10030,11796][63479,34695,34695]",0
  [Checksum Status: Good (1)],0
static int hf_checksum_crc32c  = -1_,1
"      proto_tree_add_checksum(udp_tree, tvb, offset + 6, hfi_udp_checksum.id, hfi_udp_checksum_status.id, NULL, pinfo, 0, ENC_BIG_ENDIAN, PROTO_CHECKSUM_NOT_PRESENT)_",0
"						proto_item_append_text(ti, "" [incorrect, should be 0x%08x]"", computed_checksum)_",0
 *128,0
                if (ke_modes_length) {,0
                if (auth_modes_length) {,0
		if (pkt_len > (tvb_reported_length(tvb) + offset)) {,1
    return 4_,0
  if (isakmp_version <= 1) {,0
"/* out: *headerlen, *optlen, *subtree, *attr_item, *attr_type */",0
"        packet = wmem_alloc0(wmem_file_scope(), sizeof(dof_packet_data))_",0
    g_assert_not_reached()_,0
"	EXTCAP_BASE_OPTIONS,",1
static void help(const char* binname),0
				case 11:,1
"	*sockfd = socket(AF_INET, SOCK_DGRAM, 0)_",0
"AC_ARG_ENABLE(udpdump,",0
"	AC_HELP_STRING( [--enable-udpdump],",0
"		[build udpdump @<:@default=no@:>@]),",0
"	[],[enable_udpdump=no])",0
"if test ""x$have_extcap"" != xyes_ then",0
"	AC_MSG_RESULT([no, extcap disabled])",0
	enable_udpdump=no,0
"elif test ""x$enable_udpdump"" = ""xyes"" _ then",0
	AC_MSG_RESULT(yes),0
else,0
	AC_MSG_RESULT(no),0
	int i_,0
S<[ B<--help> ]>,1
S<[ B<--version> ]>,1
S<[ B<--extcap-interfaces> ]>,1
S<[ B<--extcap-dlts> ]>,1
S<[ B<--extcap-interface>=E<lt>interfaceE<gt> ]>,1
S<[ B<--extcap-config> ]>,1
S<[ B<--capture> ]>,1
S<[ B<--fifo>=E<lt>path to file or pipeE<gt> ]>,1
	for (i = 0_ i < argc_ i++),0
"	if (!payload || !g_ascii_strcasecmp(payload, """"))",1
                ret = EXIT_CODE_GENERIC_,1
                return EXIT_CODE_GENERIC_,1
    gint32   length_,0
    guint16                api_level_,0
                return EXIT_FAILURE_,1
"    if (!ws_strtoi32(buffer + 4, &length) || length < 0)",1
"        if (!ws_strtou16(response, &api_level)) {",0
"                if (!ws_strtou64(response, &val) || val == 0) {",1
	g_strfreev(parts)_,1
"				g_warning(""Invalid paramets maxbytes: %s (max value is %u)"",",1
"		""^[\\dA-Z]{8,8}:\\s+([\\dA-Z]{2,8})\\s+([\\dA-Z]{2,8}){0,1}\\s+([\\dA-Z]{2,8}){0,1}\\s+([\\dA-Z]{2,8}){0,1}.*"",",1
"			if (!ws_strtou32(*part, &value))",0
"			if (!ws_strtou16(optarg, &remote_port)) {",1
"			if (!ws_strtou64(optarg, &count))",1
"    if (!ws_strtou64(buffer + 4, &length))",0
"            response = adb_send_and_read(sock, adb_hcidump_version, helpful_packet, sizeof(helpful_packet), &data_length)_",0
"            *bt_local_tcp_port = (unsigned short) g_ascii_strtoull(optarg, NULL, 10)_",1
"			if (ws_strtou64(optarg, &count) != EXIT_SUCCESS)",1
    if (center_freq != -1),0
"        err_str_ = tr(""Unable to save RTP data."")_",0
        err_str_ = QString(err_msg)_,0
			exit(1)_,0
"      if (!ws_strtoi32(csec, NULL, &num)) {",1
      csec[csec_len - 1] = '\0'_,0
      if (csec_len > 0 && csec_len <= 9) {,0
"  { 0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 }_",0
"	proto_tree_add_item(tree, hf_nfs_fh_pd_flags, tvb, offset + 4, 4, flags & PD_FLAGS_MASK)_",0
"	proto_tree_add_uint(tree, hf_nfs_fh_pd_version, tvb, offset + 8, 2, (guint16)(flags & PD_VERSION_MASK))_",0
"	proto_tree_add_uint64(tree, hf_nfs_fh_pd_inum, tvb, offset + 10, 8, inum)_",0
"            opcode = tvb_get_letohs(tvb, offset)_",1
"        ret = g_hash_table_insert(ifaces, g_strdup(interface->call), interface)_",0
"static gboolean interfaces_cb(const gchar *extcap, const gchar *ifname _U_, gchar *output, void *data,",0
        added_to_hash_list = FALSE_,0
static int proto_can = -1_,0
	int * can_flags[] = {,1
	int * can_flags_fd[] = {,0
"	{ LINUX_SLL_P_CANFD,	""CANFD"" },",0
static dissector_handle_t socketcan_bigendian_handle_,0
"		&hf_canfd_brsflag,",0
"		col_append_str(pinfo->cinfo, COL_INFO, ""   (Remote Transmission Request)"")_",0
	if (canfd_flags & CANFD_USE),0
"	while(g_hash_table_iter_next(&iter, &pkey, NULL))",0
"	if(g_hash_table_lookup_extended(table, ptr, NULL, &pdata))",0
    const char *prefval = _argument->pref_valptr ? *_argument->pref_valptr : NULL_,1
"                                  ""Extension (t=%u,l=%u): %s"", ext_type, ext_len, val_to_str(ext_type,",0
/* packet-ssl-utils.c,0
 * ssl manipulation functions,0
 * By Paolo Abeni <paolo.abeni@email.com>,0
" * Copyright (c) 2013, Hauke Mehrtens <hauke@hauke-m.de>",0
" * Copyright (c) 2014, Peter Wu <peter@lekensteyn.nl>",0
#define ZLIB_CONST,0
#include <zlib.h>,0
#include <errno.h>,0
#include <epan/strutil.h>,0
#include <epan/addr_resolv.h>,0
#include <epan/ipv6.h>,0
#include <wsutil/filesystem.h>,0
#include <wsutil/report_err.h>,0
#include <wsutil/pint.h>,0
#include <ws_version_info.h>,0
"#include ""packet-x509af.h""",0
"#include ""packet-x509if.h""",0
"#include ""packet-ssl-utils.h""",0
"#include ""packet-ssl.h""",0
#if defined(HAVE_LIBGNUTLS) && defined(HAVE_LIBGCRYPT),0
#include <gnutls/abstract.h>,0
/* Lookup tables {{{ */,0
const value_string ssl_version_short_names[] = {,0
"    { SSL_VER_UNKNOWN,      ""SSL"" },",0
"    { SSLV2_VERSION,        ""SSLv2"" },",0
"    { SSLV3_VERSION,        ""SSLv3"" },",0
"    { TLSV1_VERSION,        ""TLSv1"" },",0
"    { TLSV1DOT1_VERSION,    ""TLSv1.1"" },",0
"    { TLSV1DOT2_VERSION,    ""TLSv1.2"" },",0
"    { DTLSV1DOT0_VERSION,   ""DTLSv1.0"" },",0
"    { DTLSV1DOT2_VERSION,   ""DTLSv1.2"" },",0
"    { DTLSV1DOT0_OPENSSL_VERSION, ""DTLS 1.0 (OpenSSL pre 0.9.8f)"" },",0
"    { PCT_VERSION,          ""PCT"" },",0
const value_string ssl_20_msg_types[] = {,0
"    { SSL2_HND_ERROR,               ""Error"" },",0
"    { SSL2_HND_CLIENT_HELLO,        ""Client Hello"" },",0
"    { SSL2_HND_CLIENT_MASTER_KEY,   ""Client Master Key"" },",0
"    { SSL2_HND_CLIENT_FINISHED,     ""Client Finished"" },",0
"    { SSL2_HND_SERVER_HELLO,        ""Server Hello"" },",0
"    { SSL2_HND_SERVER_VERIFY,       ""Server Verify"" },",0
"    { SSL2_HND_SERVER_FINISHED,     ""Server Finished"" },",0
"    { SSL2_HND_REQUEST_CERTIFICATE, ""Request Certificate"" },",0
"    { SSL2_HND_CLIENT_CERTIFICATE,  ""Client Certificate"" },",0
/* http://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml */,0
/* Note: sorted by ascending value so value_string-ext can do a binary search */,0
static const value_string ssl_20_cipher_suites[] = {,0
"    { 0x000000, ""TLS_NULL_WITH_NULL_NULL"" },",0
"    { 0x000001, ""TLS_RSA_WITH_NULL_MD5"" },",0
"    { 0x000002, ""TLS_RSA_WITH_NULL_SHA"" },",0
"    { 0x000003, ""TLS_RSA_EXPORT_WITH_RC4_40_MD5"" },",0
"    { 0x000004, ""TLS_RSA_WITH_RC4_128_MD5"" },",0
"    { 0x000005, ""TLS_RSA_WITH_RC4_128_SHA"" },",0
"    { 0x000006, ""TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5"" },",0
"    { 0x000007, ""TLS_RSA_WITH_IDEA_CBC_SHA"" },",0
"    { 0x000008, ""TLS_RSA_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x000009, ""TLS_RSA_WITH_DES_CBC_SHA"" },",0
"    { 0x00000a, ""TLS_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00000b, ""TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x00000c, ""TLS_DH_DSS_WITH_DES_CBC_SHA"" },",0
"    { 0x00000d, ""TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00000e, ""TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x00000f, ""TLS_DH_RSA_WITH_DES_CBC_SHA"" },",0
"    { 0x000010, ""TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000011, ""TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x000012, ""TLS_DHE_DSS_WITH_DES_CBC_SHA"" },",0
"    { 0x000013, ""TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000014, ""TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x000015, ""TLS_DHE_RSA_WITH_DES_CBC_SHA"" },",0
"    { 0x000016, ""TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000017, ""TLS_DH_anon_EXPORT_WITH_RC4_40_MD5"" },",0
"    { 0x000018, ""TLS_DH_anon_WITH_RC4_128_MD5"" },",0
"    { 0x000019, ""TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x00001a, ""TLS_DH_anon_WITH_DES_CBC_SHA"" },",0
"    { 0x00001b, ""TLS_DH_anon_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00001c, ""SSL_FORTEZZA_KEA_WITH_NULL_SHA"" },",0
"    { 0x00001d, ""SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"" },",0
"    { 0x00001e, ""SSL_FORTEZZA_KEA_WITH_RC4_128_SHA"" },",0
    /* RFC 2712 */,0
"    { 0x00001E, ""TLS_KRB5_WITH_DES_CBC_SHA"" },",0
"    { 0x00001F, ""TLS_KRB5_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000020, ""TLS_KRB5_WITH_RC4_128_SHA"" },",0
"    { 0x000021, ""TLS_KRB5_WITH_IDEA_CBC_SHA"" },",0
"    { 0x000022, ""TLS_KRB5_WITH_DES_CBC_MD5"" },",0
"    { 0x000023, ""TLS_KRB5_WITH_3DES_EDE_CBC_MD5"" },",0
"    { 0x000024, ""TLS_KRB5_WITH_RC4_128_MD5"" },",0
"    { 0x000025, ""TLS_KRB5_WITH_IDEA_CBC_MD5"" },",0
"    { 0x000026, ""TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"" },",0
"    { 0x000027, ""TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"" },",0
"    { 0x000028, ""TLS_KRB5_EXPORT_WITH_RC4_40_SHA"" },",0
"    { 0x000029, ""TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"" },",0
"    { 0x00002A, ""TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"" },",0
"    { 0x00002B, ""TLS_KRB5_EXPORT_WITH_RC4_40_MD5"" },",0
    /* RFC 4785 */,0
"    { 0x00002C, ""TLS_PSK_WITH_NULL_SHA"" },",0
"    { 0x00002D, ""TLS_DHE_PSK_WITH_NULL_SHA"" },",0
"    { 0x00002E, ""TLS_RSA_PSK_WITH_NULL_SHA"" },",0
    /* RFC 5246 */,0
"    { 0x00002f, ""TLS_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000030, ""TLS_DH_DSS_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000031, ""TLS_DH_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000032, ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000033, ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000034, ""TLS_DH_anon_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000035, ""TLS_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x000036, ""TLS_DH_DSS_WITH_AES_256_CBC_SHA"" },",0
"    { 0x000037, ""TLS_DH_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x000038, ""TLS_DHE_DSS_WITH_AES_256_CBC_SHA"" },",0
"    { 0x000039, ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00003A, ""TLS_DH_anon_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00003B, ""TLS_RSA_WITH_NULL_SHA256"" },",0
"    { 0x00003C, ""TLS_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00003D, ""TLS_RSA_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x00003E, ""TLS_DH_DSS_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00003F, ""TLS_DH_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x000040, ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x000041, ""TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x000042, ""TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x000043, ""TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x000044, ""TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x000045, ""TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x000046, ""TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x000047, ""TLS_ECDH_ECDSA_WITH_NULL_SHA"" },",0
"    { 0x000048, ""TLS_ECDH_ECDSA_WITH_RC4_128_SHA"" },",0
"    { 0x000049, ""TLS_ECDH_ECDSA_WITH_DES_CBC_SHA"" },",0
"    { 0x00004A, ""TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00004B, ""TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00004C, ""TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x000060, ""TLS_RSA_EXPORT1024_WITH_RC4_56_MD5"" },",0
"    { 0x000061, ""TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5"" },",0
"    { 0x000062, ""TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA"" },",0
"    { 0x000063, ""TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA"" },",0
"    { 0x000064, ""TLS_RSA_EXPORT1024_WITH_RC4_56_SHA"" },",0
"    { 0x000065, ""TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA"" },",0
"    { 0x000066, ""TLS_DHE_DSS_WITH_RC4_128_SHA"" },",0
"    { 0x000067, ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x000068, ""TLS_DH_DSS_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x000069, ""TLS_DH_RSA_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x00006A, ""TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x00006B, ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x00006C, ""TLS_DH_anon_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00006D, ""TLS_DH_anon_WITH_AES_256_CBC_SHA256"" },",0
"    /* 0x00,0x6E-83 Unassigned  */",0
"    { 0x000084, ""TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x000085, ""TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x000086, ""TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x000087, ""TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x000088, ""TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x000089, ""TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"" },",0
    /* RFC 4279 */,0
"    { 0x00008A, ""TLS_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x00008B, ""TLS_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00008C, ""TLS_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00008D, ""TLS_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00008E, ""TLS_DHE_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x00008F, ""TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000090, ""TLS_DHE_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000091, ""TLS_DHE_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0x000092, ""TLS_RSA_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x000093, ""TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000094, ""TLS_RSA_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x000095, ""TLS_RSA_PSK_WITH_AES_256_CBC_SHA"" },",0
    /* RFC 4162 */,0
"    { 0x000096, ""TLS_RSA_WITH_SEED_CBC_SHA"" },",0
"    { 0x000097, ""TLS_DH_DSS_WITH_SEED_CBC_SHA"" },",0
"    { 0x000098, ""TLS_DH_RSA_WITH_SEED_CBC_SHA"" },",0
"    { 0x000099, ""TLS_DHE_DSS_WITH_SEED_CBC_SHA"" },",0
"    { 0x00009A, ""TLS_DHE_RSA_WITH_SEED_CBC_SHA"" },",0
"    { 0x00009B, ""TLS_DH_anon_WITH_SEED_CBC_SHA"" },",0
    /* RFC 5288 */,0
"    { 0x00009C, ""TLS_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00009D, ""TLS_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00009E, ""TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00009F, ""TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000A0, ""TLS_DH_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000A1, ""TLS_DH_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000A2, ""TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000A3, ""TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000A4, ""TLS_DH_DSS_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000A5, ""TLS_DH_DSS_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000A6, ""TLS_DH_anon_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000A7, ""TLS_DH_anon_WITH_AES_256_GCM_SHA384"" },",0
    /* RFC 5487 */,0
"    { 0x0000A8, ""TLS_PSK_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000A9, ""TLS_PSK_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000AA, ""TLS_DHE_PSK_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000AB, ""TLS_DHE_PSK_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000AC, ""TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x0000AD, ""TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x0000AE, ""TLS_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x0000AF, ""TLS_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x0000B0, ""TLS_PSK_WITH_NULL_SHA256"" },",0
"    { 0x0000B1, ""TLS_PSK_WITH_NULL_SHA384"" },",0
"    { 0x0000B2, ""TLS_DHE_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x0000B3, ""TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x0000B4, ""TLS_DHE_PSK_WITH_NULL_SHA256"" },",0
"    { 0x0000B5, ""TLS_DHE_PSK_WITH_NULL_SHA384"" },",0
"    { 0x0000B6, ""TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x0000B7, ""TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x0000B8, ""TLS_RSA_PSK_WITH_NULL_SHA256"" },",0
"    { 0x0000B9, ""TLS_RSA_PSK_WITH_NULL_SHA384"" },",0
    /* From RFC 5932 */,0
"    { 0x0000BA, ""TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x0000BB, ""TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x0000BC, ""TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x0000BD, ""TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x0000BE, ""TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x0000BF, ""TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x0000C0, ""TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x0000C1, ""TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x0000C2, ""TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x0000C3, ""TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x0000C4, ""TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x0000C5, ""TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    /* 0x00,0xC6-FE Unassigned  */",0
"    { 0x0000FF, ""TLS_EMPTY_RENEGOTIATION_INFO_SCSV"" },",0
"    /* 0x01-BF,* Unassigned  */",0
    /* From RFC 4492 */,0
"    { 0x00c001, ""TLS_ECDH_ECDSA_WITH_NULL_SHA"" },",0
"    { 0x00c002, ""TLS_ECDH_ECDSA_WITH_RC4_128_SHA"" },",0
"    { 0x00c003, ""TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00c004, ""TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00c005, ""TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00c006, ""TLS_ECDHE_ECDSA_WITH_NULL_SHA"" },",0
"    { 0x00c007, ""TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"" },",0
"    { 0x00c008, ""TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00c009, ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00c00a, ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00c00b, ""TLS_ECDH_RSA_WITH_NULL_SHA"" },",0
"    { 0x00c00c, ""TLS_ECDH_RSA_WITH_RC4_128_SHA"" },",0
"    { 0x00c00d, ""TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00c00e, ""TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00c00f, ""TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00c010, ""TLS_ECDHE_RSA_WITH_NULL_SHA"" },",0
"    { 0x00c011, ""TLS_ECDHE_RSA_WITH_RC4_128_SHA"" },",0
"    { 0x00c012, ""TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00c013, ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00c014, ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00c015, ""TLS_ECDH_anon_WITH_NULL_SHA"" },",0
"    { 0x00c016, ""TLS_ECDH_anon_WITH_RC4_128_SHA"" },",0
"    { 0x00c017, ""TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00c018, ""TLS_ECDH_anon_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00c019, ""TLS_ECDH_anon_WITH_AES_256_CBC_SHA"" },",0
    /* RFC 5054 */,0
"    { 0x00C01A, ""TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00C01B, ""TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00C01C, ""TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00C01D, ""TLS_SRP_SHA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00C01E, ""TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00C01F, ""TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00C020, ""TLS_SRP_SHA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00C021, ""TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00C022, ""TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"" },",0
    /* RFC 5589 */,0
"    { 0x00C023, ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00C024, ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00C025, ""TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00C026, ""TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00C027, ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00C028, ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00C029, ""TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00C02A, ""TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00C02B, ""TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00C02C, ""TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00C02D, ""TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00C02E, ""TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00C02F, ""TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00C030, ""TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00C031, ""TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00C032, ""TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"" },",0
    /* RFC 5489 */,0
"    { 0x00C033, ""TLS_ECDHE_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x00C034, ""TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00C035, ""TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x00C036, ""TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0x00C037, ""TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00C038, ""TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00C039, ""TLS_ECDHE_PSK_WITH_NULL_SHA"" },",0
"    { 0x00C03A, ""TLS_ECDHE_PSK_WITH_NULL_SHA256"" },",0
"    { 0x00C03B, ""TLS_ECDHE_PSK_WITH_NULL_SHA384"" },",0
"    /* 0xC0,0x3C-FF Unassigned",0
"            0xC1-FD,* Unassigned",0
"            0xFE,0x00-FD Unassigned",0
"            0xFE,0xFE-FF Reserved to avoid conflicts with widely deployed implementations [Pasi_Eronen]",0
"            0xFF,0x00-FF Reserved for Private Use [RFC5246]",0
            */,0
    /* old numbers used in the beginning,0
     * http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305 */,0
"    { 0x00CC13, ""TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CC14, ""TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CC15, ""TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
    /* http://tools.ietf.org/html/draft-ietf-tls-chacha20-poly1305 */,0
"    { 0x00CCA8, ""TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CCA9, ""TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CCAA, ""TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CCAB, ""TLS_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CCAC, ""TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CCAD, ""TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0x00CCAE, ""TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
    /* http://tools.ietf.org/html/draft-josefsson-salsa20-tls */,0
"    { 0x00E410, ""TLS_RSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E411, ""TLS_RSA_WITH_SALSA20_SHA1"" },",0
"    { 0x00E412, ""TLS_ECDHE_RSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E413, ""TLS_ECDHE_RSA_WITH_SALSA20_SHA1"" },",0
"    { 0x00E414, ""TLS_ECDHE_ECDSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E415, ""TLS_ECDHE_ECDSA_WITH_SALSA20_SHA1"" },",0
"    { 0x00E416, ""TLS_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E417, ""TLS_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0x00E418, ""TLS_ECDHE_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E419, ""TLS_ECDHE_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0x00E41A, ""TLS_RSA_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E41B, ""TLS_RSA_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0x00E41C, ""TLS_DHE_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E41D, ""TLS_DHE_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0x00E41E, ""TLS_DHE_RSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0x00E41F, ""TLS_DHE_RSA_WITH_SALSA20_SHA1"" },",0
    /* these from http://www.mozilla.org/projects/,0
         security/pki/nss/ssl/fips-ssl-ciphersuites.html */,0
"    { 0x00fefe, ""SSL_RSA_FIPS_WITH_DES_CBC_SHA""},",0
"    { 0x00feff, ""SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00ffe0, ""SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x00ffe1, ""SSL_RSA_FIPS_WITH_DES_CBC_SHA""},",0
    /* note that ciphersuites of {0x00????} are TLS cipher suites in,0
     * a sslv2 client hello message_ the ???? above is the two-byte,0
     * tls cipher suite id,0
"    { 0x010080, ""SSL2_RC4_128_WITH_MD5"" },",0
"    { 0x020080, ""SSL2_RC4_128_EXPORT40_WITH_MD5"" },",0
"    { 0x030080, ""SSL2_RC2_128_CBC_WITH_MD5"" },",0
"    { 0x040080, ""SSL2_RC2_128_CBC_EXPORT40_WITH_MD5"" },",0
"    { 0x050080, ""SSL2_IDEA_128_CBC_WITH_MD5"" },",0
"    { 0x060040, ""SSL2_DES_64_CBC_WITH_MD5"" },",0
"    { 0x0700c0, ""SSL2_DES_192_EDE3_CBC_WITH_MD5"" },",0
"    { 0x080080, ""SSL2_RC4_64_WITH_MD5"" },",0
    /* Microsoft's old PCT protocol. These are from Eric Rescorla's,0
"       book ""SSL and TLS"" */",0
"    { 0x800001, ""PCT_SSL_CERT_TYPE | PCT1_CERT_X509"" },",0
"    { 0x800003, ""PCT_SSL_CERT_TYPE | PCT1_CERT_X509_CHAIN"" },",0
"    { 0x810001, ""PCT_SSL_HASH_TYPE | PCT1_HASH_MD5"" },",0
"    { 0x810003, ""PCT_SSL_HASH_TYPE | PCT1_HASH_SHA"" },",0
"    { 0x820001, ""PCT_SSL_EXCH_TYPE | PCT1_EXCH_RSA_PKCS1"" },",0
"    { 0x830004, ""PCT_SSL_CIPHER_TYPE_1ST_HALF | PCT1_CIPHER_RC4"" },",0
"    { 0x842840, ""PCT_SSL_CIPHER_TYPE_2ND_HALF | PCT1_ENC_BITS_40 | PCT1_MAC_BITS_128"" },",0
"    { 0x848040, ""PCT_SSL_CIPHER_TYPE_2ND_HALF | PCT1_ENC_BITS_128 | PCT1_MAC_BITS_128"" },",0
"    { 0x8f8001, ""PCT_SSL_COMPAT | PCT_VERSION_1"" },",0
value_string_ext ssl_20_cipher_suites_ext = VALUE_STRING_EXT_INIT(ssl_20_cipher_suites)_,0
const value_string ssl_extension_curves[] = {,0
"    {  1, ""sect163k1"" },",0
"    {  2, ""sect163r1"" },",0
"    {  3, ""sect163r2"" },",0
"    {  4, ""sect193r1"" },",0
"    {  5, ""sect193r2"" },",0
"    {  6, ""sect233k1"" },",0
"    {  7, ""sect233r1"" },",0
"    {  8, ""sect239k1"" },",0
"    {  9, ""sect283k1"" },",0
"    { 10, ""sect283r1"" },",0
"    { 11, ""sect409k1"" },",0
"    { 12, ""sect409r1"" },",0
"    { 13, ""sect571k1"" },",0
"    { 14, ""sect571r1"" },",0
"    { 15, ""secp160k1"" },",0
"    { 16, ""secp160r1"" },",0
"    { 17, ""secp160r2"" },",0
"    { 18, ""secp192k1"" },",0
"    { 19, ""secp192r1"" },",0
"    { 20, ""secp224k1"" },",0
"    { 21, ""secp224r1"" },",0
"    { 22, ""secp256k1"" },",0
"    { 23, ""secp256r1"" },",0
"    { 24, ""secp384r1"" },",0
"    { 25, ""secp521r1"" },",0
"    { 26, ""brainpoolP256r1"" }, /* RFC 7027 */",0
"    { 27, ""brainpoolP384r1"" }, /* RFC 7027 */",0
"    { 28, ""brainpoolP512r1"" }, /* RFC 7027 */",0
"    { 29, ""ecdh_x25519"" }, /* https://tools.ietf.org/html/draft-ietf-tls-rfc4492bis */",0
"    { 30, ""ecdh_x448"" }, /* https://tools.ietf.org/html/draft-ietf-tls-rfc4492bis */",0
"    { 256, ""ffdhe2048"" }, /* https://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe */",0
"    { 257, ""ffdhe3072"" }, /* https://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe */",0
"    { 258, ""ffdhe4096"" }, /* https://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe */",0
"    { 259, ""ffdhe6144"" }, /* https://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe */",0
"    { 260, ""ffdhe8192"" }, /* https://tools.ietf.org/html/draft-ietf-tls-negotiated-ff-dhe */",0
"    { 0xFF01, ""arbitrary_explicit_prime_curves"" },",0
"    { 0xFF02, ""arbitrary_explicit_char2_curves"" },",0
const value_string ssl_curve_types[] = {,0
"    { 1, ""explicit_prime"" },",0
"    { 2, ""explicit_char2"" },",0
"    { 3, ""named_curve"" },",0
const value_string ssl_extension_ec_point_formats[] = {,0
"    { 0, ""uncompressed"" },",0
"    { 1, ""ansiX962_compressed_prime"" },",0
"    { 2, ""ansiX962_compressed_char2"" },",0
const value_string ssl_20_certificate_type[] = {,0
"    { 0x00, ""N/A"" },",0
"    { 0x01, ""X.509 Certificate"" },",0
const value_string ssl_31_content_type[] = {,0
"    { 20, ""Change Cipher Spec"" },",0
"    { 21, ""Alert"" },",0
"    { 22, ""Handshake"" },",0
"    { 23, ""Application Data"" },",0
"    { 24, ""Heartbeat"" },",0
const value_string ssl_versions[] = {,0
"    { 0xfefd, ""DTLS 1.2"" },",0
"    { 0xfeff, ""DTLS 1.0"" },",0
"    { 0x0100, ""DTLS 1.0 (OpenSSL pre 0.9.8f)"" },",0
"    { 0x0303, ""TLS 1.2"" },",0
"    { 0x0302, ""TLS 1.1"" },",0
"    { 0x0301, ""TLS 1.0"" },",0
"    { 0x0300, ""SSL 3.0"" },",0
"    { 0x0002, ""SSL 2.0"" },",0
/* XXX - would be used if we dissected the body of a Change Cipher Spec,0
   message. */,0
const value_string ssl_31_change_cipher_spec[] = {,0
"    { 1, ""Change Cipher Spec"" },",0
const value_string ssl_31_alert_level[] = {,0
"    { 1, ""Warning"" },",0
"    { 2, ""Fatal"" },",0
const value_string ssl_31_alert_description[] = {,0
"    {   0,  ""Close Notify"" },",0
"    {  10,  ""Unexpected Message"" },",0
"    {  20,  ""Bad Record MAC"" },",0
"    {  21,  ""Decryption Failed"" },",0
"    {  22,  ""Record Overflow"" },",0
"    {  30,  ""Decompression Failure"" },",0
"    {  40,  ""Handshake Failure"" },",0
"    {  41,  ""No Certificate"" },",0
"    {  42,  ""Bad Certificate"" },",0
"    {  43,  ""Unsupported Certificate"" },",0
"    {  44,  ""Certificate Revoked"" },",0
"    {  45,  ""Certificate Expired"" },",0
"    {  46,  ""Certificate Unknown"" },",0
"    {  47,  ""Illegal Parameter"" },",0
"    {  48,  ""Unknown CA"" },",0
"    {  49,  ""Access Denied"" },",0
"    {  50,  ""Decode Error"" },",0
"    {  51,  ""Decrypt Error"" },",0
"    {  60,  ""Export Restriction"" },",0
"    {  70,  ""Protocol Version"" },",0
"    {  71,  ""Insufficient Security"" },",0
"    {  80,  ""Internal Error"" },",0
"    {  86,  ""Inappropriate Fallback"" },",0
"    {  90,  ""User Canceled"" },",0
"    { 100, ""No Renegotiation"" },",0
"    { 110, ""Unsupported Extension"" },",0
"    { 111, ""Certificate Unobtainable"" },",0
"    { 112, ""Unrecognized Name"" },",0
"    { 113, ""Bad Certificate Status Response"" },",0
"    { 114, ""Bad Certificate Hash Value"" },",0
"    { 115, ""Unknown PSK Identity"" },",0
"    { 120, ""No application Protocol"" },",0
const value_string ssl_31_handshake_type[] = {,0
"    { SSL_HND_HELLO_REQUEST,     ""Hello Request"" },",0
"    { SSL_HND_CLIENT_HELLO,      ""Client Hello"" },",0
"    { SSL_HND_SERVER_HELLO,      ""Server Hello"" },",0
"    { SSL_HND_HELLO_VERIFY_REQUEST, ""Hello Verify Request""},",0
"    { SSL_HND_NEWSESSION_TICKET, ""New Session Ticket"" },",0
"    { SSL_HND_CERTIFICATE,       ""Certificate"" },",0
"    { SSL_HND_SERVER_KEY_EXCHG,  ""Server Key Exchange"" },",0
"    { SSL_HND_CERT_REQUEST,      ""Certificate Request"" },",0
"    { SSL_HND_SVR_HELLO_DONE,    ""Server Hello Done"" },",0
"    { SSL_HND_CERT_VERIFY,       ""Certificate Verify"" },",0
"    { SSL_HND_CLIENT_KEY_EXCHG,  ""Client Key Exchange"" },",0
"    { SSL_HND_FINISHED,          ""Finished"" },",0
"    { SSL_HND_CERT_URL,          ""Client Certificate URL"" },",0
"    { SSL_HND_CERT_STATUS,       ""Certificate Status"" },",0
"    { SSL_HND_SUPPLEMENTAL_DATA, ""Supplemental Data"" },",0
"    { SSL_HND_ENCRYPTED_EXTS,    ""Encrypted Extensions"" },",0
const value_string tls_heartbeat_type[] = {,0
"    { 1, ""Request"" },",0
"    { 2, ""Response"" },",0
const value_string tls_heartbeat_mode[] = {,0
"    { 1, ""Peer allowed to send requests"" },",0
"    { 2, ""Peer not allowed to send requests"" },",0
const value_string ssl_31_compression_method[] = {,0
"    {  0, ""null"" },",0
"    {  1, ""DEFLATE"" },",0
"    { 64, ""LZS"" },",0
"/* XXX - would be used if we dissected a Signature, as would be",0
   seen in a server key exchange or certificate verify message. */,0
const value_string ssl_31_key_exchange_algorithm[] = {,0
"    { 0, ""RSA"" },",0
"    { 1, ""Diffie Hellman"" },",0
const value_string ssl_31_signature_algorithm[] = {,0
"    { 0, ""Anonymous"" },",0
"    { 1, ""RSA"" },",0
"    { 2, ""DSA"" },",0
const value_string ssl_31_client_certificate_type[] = {,0
"    { 1, ""RSA Sign"" },",0
"    { 2, ""DSS Sign"" },",0
"    { 3, ""RSA Fixed DH"" },",0
"    { 4, ""DSS Fixed DH"" },",0
    /* GOST certificate types */,0
    /* Section 3.5 of draft-chudov-cryptopro-cptls-04 */,0
"    { 21, ""GOST R 34.10-94"" },",0
"    { 22, ""GOST R 34.10-2001"" },",0
    /* END GOST certificate types */,0
"    { 64, ""ECDSA Sign"" },",0
"    { 65, ""RSA Fixed ECDH"" },",0
"    { 66, ""ECDSA Fixed ECDH"" },",0
"/* XXX - would be used if we dissected exchange keys, as would be",0
   seen in a client key exchange message. */,0
const value_string ssl_31_public_value_encoding[] = {,0
"    { 0, ""Implicit"" },",0
"    { 1, ""Explicit"" },",0
/* Note: sorted by ascending value so value_string_ext fcns can do a binary search */,0
static const value_string ssl_31_ciphersuite[] = {,0
"    /* RFC 2246, RFC 4346, RFC 5246 */",0
"    { 0x0000, ""TLS_NULL_WITH_NULL_NULL"" },",0
"    { 0x0001, ""TLS_RSA_WITH_NULL_MD5"" },",0
"    { 0x0002, ""TLS_RSA_WITH_NULL_SHA"" },",0
"    { 0x0003, ""TLS_RSA_EXPORT_WITH_RC4_40_MD5"" },",0
"    { 0x0004, ""TLS_RSA_WITH_RC4_128_MD5"" },",0
"    { 0x0005, ""TLS_RSA_WITH_RC4_128_SHA"" },",0
"    { 0x0006, ""TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5"" },",0
"    { 0x0007, ""TLS_RSA_WITH_IDEA_CBC_SHA"" },",0
"    { 0x0008, ""TLS_RSA_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x0009, ""TLS_RSA_WITH_DES_CBC_SHA"" },",0
"    { 0x000a, ""TLS_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000b, ""TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x000c, ""TLS_DH_DSS_WITH_DES_CBC_SHA"" },",0
"    { 0x000d, ""TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x000e, ""TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x000f, ""TLS_DH_RSA_WITH_DES_CBC_SHA"" },",0
"    { 0x0010, ""TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x0011, ""TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x0012, ""TLS_DHE_DSS_WITH_DES_CBC_SHA"" },",0
"    { 0x0013, ""TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x0014, ""TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x0015, ""TLS_DHE_RSA_WITH_DES_CBC_SHA"" },",0
"    { 0x0016, ""TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x0017, ""TLS_DH_anon_EXPORT_WITH_RC4_40_MD5"" },",0
"    { 0x0018, ""TLS_DH_anon_WITH_RC4_128_MD5"" },",0
"    { 0x0019, ""TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA"" },",0
"    { 0x001a, ""TLS_DH_anon_WITH_DES_CBC_SHA"" },",0
"    { 0x001b, ""TLS_DH_anon_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x001c, ""SSL_FORTEZZA_KEA_WITH_NULL_SHA"" },",0
"    { 0x001d, ""SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA"" },",0
"#if 0 /* Because it clashes with KRB5, is never used any more, and is safe",0
         to remove according to David Hopwood <david.hopwood@zetnet.co.uk>,0
         of the ietf-tls list */,0
"    { 0x001e, ""SSL_FORTEZZA_KEA_WITH_RC4_128_SHA"" },",0
"    { 0x001E, ""TLS_KRB5_WITH_DES_CBC_SHA"" },",0
"    { 0x001F, ""TLS_KRB5_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x0020, ""TLS_KRB5_WITH_RC4_128_SHA"" },",0
"    { 0x0021, ""TLS_KRB5_WITH_IDEA_CBC_SHA"" },",0
"    { 0x0022, ""TLS_KRB5_WITH_DES_CBC_MD5"" },",0
"    { 0x0023, ""TLS_KRB5_WITH_3DES_EDE_CBC_MD5"" },",0
"    { 0x0024, ""TLS_KRB5_WITH_RC4_128_MD5"" },",0
"    { 0x0025, ""TLS_KRB5_WITH_IDEA_CBC_MD5"" },",0
"    { 0x0026, ""TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"" },",0
"    { 0x0027, ""TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"" },",0
"    { 0x0028, ""TLS_KRB5_EXPORT_WITH_RC4_40_SHA"" },",0
"    { 0x0029, ""TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"" },",0
"    { 0x002A, ""TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"" },",0
"    { 0x002B, ""TLS_KRB5_EXPORT_WITH_RC4_40_MD5"" },",0
"    { 0x002C, ""TLS_PSK_WITH_NULL_SHA"" },",0
"    { 0x002D, ""TLS_DHE_PSK_WITH_NULL_SHA"" },",0
"    { 0x002E, ""TLS_RSA_PSK_WITH_NULL_SHA"" },",0
"    { 0x002F, ""TLS_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0030, ""TLS_DH_DSS_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0031, ""TLS_DH_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0032, ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0033, ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0034, ""TLS_DH_anon_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0035, ""TLS_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x0036, ""TLS_DH_DSS_WITH_AES_256_CBC_SHA"" },",0
"    { 0x0037, ""TLS_DH_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x0038, ""TLS_DHE_DSS_WITH_AES_256_CBC_SHA"" },",0
"    { 0x0039, ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0x003A, ""TLS_DH_anon_WITH_AES_256_CBC_SHA"" },",0
"    { 0x003B, ""TLS_RSA_WITH_NULL_SHA256"" },",0
"    { 0x003C, ""TLS_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x003D, ""TLS_RSA_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x003E, ""TLS_DH_DSS_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x003F, ""TLS_DH_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x0040, ""TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"" },",0
    /* RFC 4132 */,0
"    { 0x0041, ""TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x0042, ""TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x0043, ""TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x0044, ""TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x0045, ""TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    { 0x0046, ""TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA"" },",0
"    /* 0x00,0x60-66 Reserved to avoid conflicts with widely deployed implementations  */",0
    /* --- ??? --- */,0
"    { 0x0060, ""TLS_RSA_EXPORT1024_WITH_RC4_56_MD5"" },",0
"    { 0x0061, ""TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5"" },",0
    /* draft-ietf-tls-56-bit-ciphersuites-01.txt */,0
"    { 0x0062, ""TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA"" },",0
"    { 0x0063, ""TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA"" },",0
"    { 0x0064, ""TLS_RSA_EXPORT1024_WITH_RC4_56_SHA"" },",0
"    { 0x0065, ""TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA"" },",0
"    { 0x0066, ""TLS_DHE_DSS_WITH_RC4_128_SHA"" },",0
    /* --- ??? ---*/,0
"    { 0x0067, ""TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x0068, ""TLS_DH_DSS_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x0069, ""TLS_DH_RSA_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x006A, ""TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x006B, ""TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"" },",0
"    { 0x006C, ""TLS_DH_anon_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x006D, ""TLS_DH_anon_WITH_AES_256_CBC_SHA256"" },",0
    /* draft-chudov-cryptopro-cptls-04.txt */,0
"    { 0x0080,  ""TLS_GOSTR341094_WITH_28147_CNT_IMIT"" },",0
"    { 0x0081,  ""TLS_GOSTR341001_WITH_28147_CNT_IMIT"" },",0
"    { 0x0082,  ""TLS_GOSTR341094_WITH_NULL_GOSTR3411"" },",0
"    { 0x0083,  ""TLS_GOSTR341001_WITH_NULL_GOSTR3411"" },",0
"    { 0x0084, ""TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x0085, ""TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x0086, ""TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x0087, ""TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x0088, ""TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x0089, ""TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"" },",0
"    { 0x008A, ""TLS_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x008B, ""TLS_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x008C, ""TLS_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x008D, ""TLS_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0x008E, ""TLS_DHE_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x008F, ""TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x0090, ""TLS_DHE_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0091, ""TLS_DHE_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0x0092, ""TLS_RSA_PSK_WITH_RC4_128_SHA"" },",0
"    { 0x0093, ""TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0x0094, ""TLS_RSA_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0x0095, ""TLS_RSA_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0x0096, ""TLS_RSA_WITH_SEED_CBC_SHA"" },",0
"    { 0x0097, ""TLS_DH_DSS_WITH_SEED_CBC_SHA"" },",0
"    { 0x0098, ""TLS_DH_RSA_WITH_SEED_CBC_SHA"" },",0
"    { 0x0099, ""TLS_DHE_DSS_WITH_SEED_CBC_SHA"" },",0
"    { 0x009A, ""TLS_DHE_RSA_WITH_SEED_CBC_SHA"" },",0
"    { 0x009B, ""TLS_DH_anon_WITH_SEED_CBC_SHA"" },",0
"    { 0x009C, ""TLS_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x009D, ""TLS_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x009E, ""TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x009F, ""TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00A0, ""TLS_DH_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00A1, ""TLS_DH_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00A2, ""TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00A3, ""TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00A4, ""TLS_DH_DSS_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00A5, ""TLS_DH_DSS_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00A6, ""TLS_DH_anon_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00A7, ""TLS_DH_anon_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00A8, ""TLS_PSK_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00A9, ""TLS_PSK_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00AA, ""TLS_DHE_PSK_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00AB, ""TLS_DHE_PSK_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00AC, ""TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"" },",0
"    { 0x00AD, ""TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"" },",0
"    { 0x00AE, ""TLS_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00AF, ""TLS_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00B0, ""TLS_PSK_WITH_NULL_SHA256"" },",0
"    { 0x00B1, ""TLS_PSK_WITH_NULL_SHA384"" },",0
"    { 0x00B2, ""TLS_DHE_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00B3, ""TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00B4, ""TLS_DHE_PSK_WITH_NULL_SHA256"" },",0
"    { 0x00B5, ""TLS_DHE_PSK_WITH_NULL_SHA384"" },",0
"    { 0x00B6, ""TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0x00B7, ""TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0x00B8, ""TLS_RSA_PSK_WITH_NULL_SHA256"" },",0
"    { 0x00B9, ""TLS_RSA_PSK_WITH_NULL_SHA384"" },",0
"    { 0x00BA, ""TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x00BB, ""TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x00BC, ""TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x00BD, ""TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x00BE, ""TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x00BF, ""TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0x00C0, ""TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x00C1, ""TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x00C2, ""TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x00C3, ""TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x00C4, ""TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"" },",0
"    { 0x00C5, ""TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"" },",0
    /* From RFC 5746 */,0
"    { 0x00FF, ""TLS_EMPTY_RENEGOTIATION_INFO_SCSV"" },",0
    /* From RFC 7507 */,0
"    { 0x5600, ""TLS_FALLBACK_SCSV"" },",0
"    { 0xc001, ""TLS_ECDH_ECDSA_WITH_NULL_SHA"" },",0
"    { 0xc002, ""TLS_ECDH_ECDSA_WITH_RC4_128_SHA"" },",0
"    { 0xc003, ""TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xc004, ""TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0xc005, ""TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0xc006, ""TLS_ECDHE_ECDSA_WITH_NULL_SHA"" },",0
"    { 0xc007, ""TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"" },",0
"    { 0xc008, ""TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xc009, ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0xc00a, ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0xc00b, ""TLS_ECDH_RSA_WITH_NULL_SHA"" },",0
"    { 0xc00c, ""TLS_ECDH_RSA_WITH_RC4_128_SHA"" },",0
"    { 0xc00d, ""TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xc00e, ""TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0xc00f, ""TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0xc010, ""TLS_ECDHE_RSA_WITH_NULL_SHA"" },",0
"    { 0xc011, ""TLS_ECDHE_RSA_WITH_RC4_128_SHA"" },",0
"    { 0xc012, ""TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xc013, ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0xc014, ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0xc015, ""TLS_ECDH_anon_WITH_NULL_SHA"" },",0
"    { 0xc016, ""TLS_ECDH_anon_WITH_RC4_128_SHA"" },",0
"    { 0xc017, ""TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xc018, ""TLS_ECDH_anon_WITH_AES_128_CBC_SHA"" },",0
"    { 0xc019, ""TLS_ECDH_anon_WITH_AES_256_CBC_SHA"" },",0
"    { 0xC01A, ""TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xC01B, ""TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xC01C, ""TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xC01D, ""TLS_SRP_SHA_WITH_AES_128_CBC_SHA"" },",0
"    { 0xC01E, ""TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"" },",0
"    { 0xC01F, ""TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"" },",0
"    { 0xC020, ""TLS_SRP_SHA_WITH_AES_256_CBC_SHA"" },",0
"    { 0xC021, ""TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"" },",0
"    { 0xC022, ""TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"" },",0
"    { 0xC023, ""TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0xC024, ""TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0xC025, ""TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0xC026, ""TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0xC027, ""TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0xC028, ""TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0xC029, ""TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"" },",0
"    { 0xC02A, ""TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"" },",0
"    { 0xC02B, ""TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0xC02C, ""TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0xC02D, ""TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0xC02E, ""TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0xC02F, ""TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0xC030, ""TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0xC031, ""TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"" },",0
"    { 0xC032, ""TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"" },",0
"    { 0xC033, ""TLS_ECDHE_PSK_WITH_RC4_128_SHA"" },",0
"    { 0xC034, ""TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xC035, ""TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"" },",0
"    { 0xC036, ""TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"" },",0
"    { 0xC037, ""TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"" },",0
"    { 0xC038, ""TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384"" },",0
"    { 0xC039, ""TLS_ECDHE_PSK_WITH_NULL_SHA"" },",0
"    { 0xC03A, ""TLS_ECDHE_PSK_WITH_NULL_SHA256"" },",0
"    { 0xC03B, ""TLS_ECDHE_PSK_WITH_NULL_SHA384"" },",0
    /* RFC 6209 */,0
"    { 0xC03C, ""TLS_RSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC03D, ""TLS_RSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC03E, ""TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC03F, ""TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC040, ""TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC041, ""TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC042, ""TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC043, ""TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC044, ""TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC045, ""TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC046, ""TLS_DH_anon_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC047, ""TLS_DH_anon_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC048, ""TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC049, ""TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC04A, ""TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC04B, ""TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC04C, ""TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC04D, ""TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC04E, ""TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC04F, ""TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC050, ""TLS_RSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC051, ""TLS_RSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC052, ""TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC053, ""TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC054, ""TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC055, ""TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC056, ""TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC057, ""TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC058, ""TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC059, ""TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC05A, ""TLS_DH_anon_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC05B, ""TLS_DH_anon_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC05C, ""TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC05D, ""TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC05E, ""TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC05F, ""TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC060, ""TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC061, ""TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC062, ""TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC063, ""TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC064, ""TLS_PSK_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC065, ""TLS_PSK_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC066, ""TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC067, ""TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC068, ""TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC069, ""TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384"" },",0
"    { 0xC06A, ""TLS_PSK_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC06B, ""TLS_PSK_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC06C, ""TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC06D, ""TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC06E, ""TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256"" },",0
"    { 0xC06F, ""TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384"" },",0
"    { 0xC070, ""TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256"" },",0
"    { 0xC071, ""TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384"" },",0
    /* RFC 6367 */,0
"    { 0xC072, ""TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC073, ""TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC074, ""TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC075, ""TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC076, ""TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC077, ""TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC078, ""TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC079, ""TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC07A, ""TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC07B, ""TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC07C, ""TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC07D, ""TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC07E, ""TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC07F, ""TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC080, ""TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC081, ""TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC082, ""TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC083, ""TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC084, ""TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC085, ""TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC086, ""TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC087, ""TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC088, ""TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC089, ""TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC08A, ""TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC08B, ""TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC08C, ""TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC08D, ""TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC08E, ""TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC08F, ""TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC090, ""TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC091, ""TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC092, ""TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"" },",0
"    { 0xC093, ""TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"" },",0
"    { 0xC094, ""TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC095, ""TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC096, ""TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC097, ""TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC098, ""TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC099, ""TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"" },",0
"    { 0xC09A, ""TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"" },",0
"    { 0xC09B, ""TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"" },",0
    /* RFC 6655 */,0
"    { 0xC09C, ""TLS_RSA_WITH_AES_128_CCM"" },",0
"    { 0xC09D, ""TLS_RSA_WITH_AES_256_CCM"" },",0
"    { 0xC09E, ""TLS_DHE_RSA_WITH_AES_128_CCM"" },",0
"    { 0xC09F, ""TLS_DHE_RSA_WITH_AES_256_CCM"" },",0
"    { 0xC0A0, ""TLS_RSA_WITH_AES_128_CCM_8"" },",0
"    { 0xC0A1, ""TLS_RSA_WITH_AES_256_CCM_8"" },",0
"    { 0xC0A2, ""TLS_DHE_RSA_WITH_AES_128_CCM_8"" },",0
"    { 0xC0A3, ""TLS_DHE_RSA_WITH_AES_256_CCM_8"" },",0
"    { 0xC0A4, ""TLS_PSK_WITH_AES_128_CCM"" },",0
"    { 0xC0A5, ""TLS_PSK_WITH_AES_256_CCM"" },",0
"    { 0xC0A6, ""TLS_DHE_PSK_WITH_AES_128_CCM"" },",0
"    { 0xC0A7, ""TLS_DHE_PSK_WITH_AES_256_CCM"" },",0
"    { 0xC0A8, ""TLS_PSK_WITH_AES_128_CCM_8"" },",0
"    { 0xC0A9, ""TLS_PSK_WITH_AES_256_CCM_8"" },",0
"    { 0xC0AA, ""TLS_PSK_DHE_WITH_AES_128_CCM_8"" },",0
"    { 0xC0AB, ""TLS_PSK_DHE_WITH_AES_256_CCM_8"" },",0
    /* RFC 7251 */,0
"    { 0xC0AC, ""TLS_ECDHE_ECDSA_WITH_AES_128_CCM"" },",0
"    { 0xC0AD, ""TLS_ECDHE_ECDSA_WITH_AES_256_CCM"" },",0
"    { 0xC0AE, ""TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8"" },",0
"0xC0,0xAB-FF Unassigned",0
"0xC1-FD,* Unassigned",0
"0xFE,0x00-FD Unassigned",0
"0xFE,0xFE-FF Reserved to avoid conflicts with widely deployed implementations [Pasi_Eronen]",0
"0xFF,0x00-FF Reserved for Private Use [RFC5246]",0
"    { 0xCC13, ""TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCC14, ""TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCC15, ""TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCA8, ""TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCA9, ""TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCAA, ""TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCAB, ""TLS_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCAC, ""TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCAD, ""TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xCCAE, ""TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256"" },",0
"    { 0xE410, ""TLS_RSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE411, ""TLS_RSA_WITH_SALSA20_SHA1"" },",0
"    { 0xE412, ""TLS_ECDHE_RSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE413, ""TLS_ECDHE_RSA_WITH_SALSA20_SHA1"" },",0
"    { 0xE414, ""TLS_ECDHE_ECDSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE415, ""TLS_ECDHE_ECDSA_WITH_SALSA20_SHA1"" },",0
"    { 0xE416, ""TLS_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE417, ""TLS_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0xE418, ""TLS_ECDHE_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE419, ""TLS_ECDHE_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0xE41A, ""TLS_RSA_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE41B, ""TLS_RSA_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0xE41C, ""TLS_DHE_PSK_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE41D, ""TLS_DHE_PSK_WITH_SALSA20_SHA1"" },",0
"    { 0xE41E, ""TLS_DHE_RSA_WITH_ESTREAM_SALSA20_SHA1"" },",0
"    { 0xE41F, ""TLS_DHE_RSA_WITH_SALSA20_SHA1"" },",0
"    { 0xfefe, ""SSL_RSA_FIPS_WITH_DES_CBC_SHA""},",0
"    { 0xfeff, ""SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xffe0, ""SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA"" },",0
"    { 0xffe1, ""SSL_RSA_FIPS_WITH_DES_CBC_SHA""},",0
    /* note that ciphersuites 0xff00 - 0xffff are private */,0
value_string_ext ssl_31_ciphersuite_ext = VALUE_STRING_EXT_INIT(ssl_31_ciphersuite)_,0
const value_string pct_msg_types[] = {,0
"    { PCT_MSG_CLIENT_HELLO,         ""Client Hello"" },",0
"    { PCT_MSG_SERVER_HELLO,         ""Server Hello"" },",0
"    { PCT_MSG_CLIENT_MASTER_KEY,    ""Client Master Key"" },",0
"    { PCT_MSG_SERVER_VERIFY,        ""Server Verify"" },",0
"    { PCT_MSG_ERROR,                ""Error"" },",0
const value_string pct_cipher_type[] = {,0
"    { PCT_CIPHER_DES, ""DES"" },",0
"    { PCT_CIPHER_IDEA, ""IDEA"" },",0
"    { PCT_CIPHER_RC2, ""RC2"" },",0
"    { PCT_CIPHER_RC4, ""RC4"" },",0
"    { PCT_CIPHER_DES_112, ""DES 112 bit"" },",0
"    { PCT_CIPHER_DES_168, ""DES 168 bit"" },",0
const value_string pct_hash_type[] = {,0
"    { PCT_HASH_MD5, ""MD5"" },",0
"    { PCT_HASH_MD5_TRUNC_64, ""MD5_TRUNC_64""},",0
"    { PCT_HASH_SHA, ""SHA""},",0
"    { PCT_HASH_SHA_TRUNC_80, ""SHA_TRUNC_80""},",0
"    { PCT_HASH_DES_DM, ""DES_DM""},",0
const value_string pct_cert_type[] = {,0
"    { PCT_CERT_NONE, ""None"" },",0
"    { PCT_CERT_X509, ""X.509"" },",0
"    { PCT_CERT_PKCS7, ""PKCS #7"" },",0
const value_string pct_sig_type[] = {,0
"    { PCT_SIG_NONE, ""None"" },",0
"    { PCT_SIG_RSA_MD5, ""MD5"" },",0
"    { PCT_SIG_RSA_SHA, ""RSA SHA"" },",0
"    { PCT_SIG_DSA_SHA, ""DSA SHA"" },",0
const value_string pct_exch_type[] = {,0
"    { PCT_EXCH_RSA_PKCS1, ""RSA PKCS#1"" },",0
"    { PCT_EXCH_RSA_PKCS1_TOKEN_DES, ""RSA PKCS#1 Token DES"" },",0
"    { PCT_EXCH_RSA_PKCS1_TOKEN_DES3, ""RSA PKCS#1 Token 3DES"" },",0
"    { PCT_EXCH_RSA_PKCS1_TOKEN_RC2, ""RSA PKCS#1 Token RC-2"" },",0
"    { PCT_EXCH_RSA_PKCS1_TOKEN_RC4, ""RSA PKCS#1 Token RC-4"" },",0
"    { PCT_EXCH_DH_PKCS3, ""DH PKCS#3"" },",0
"    { PCT_EXCH_DH_PKCS3_TOKEN_DES, ""DH PKCS#3 Token DES"" },",0
"    { PCT_EXCH_DH_PKCS3_TOKEN_DES3, ""DH PKCS#3 Token 3DES"" },",0
"    { PCT_EXCH_FORTEZZA_TOKEN, ""Fortezza"" },",0
const value_string pct_error_code[] = {,0
"    { PCT_ERR_BAD_CERTIFICATE, ""PCT_ERR_BAD_CERTIFICATE"" },",0
"    { PCT_ERR_CLIENT_AUTH_FAILED, ""PCT_ERR_CLIENT_AUTH_FAILE"" },",0
"    { PCT_ERR_ILLEGAL_MESSAGE, ""PCT_ERR_ILLEGAL_MESSAGE"" },",0
"    { PCT_ERR_INTEGRITY_CHECK_FAILED, ""PCT_ERR_INTEGRITY_CHECK_FAILED"" },",0
"    { PCT_ERR_SERVER_AUTH_FAILED, ""PCT_ERR_SERVER_AUTH_FAILED"" },",0
"    { PCT_ERR_SPECS_MISMATCH, ""PCT_ERR_SPECS_MISMATCH"" },",0
/* http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#tls-extensiontype-values-1 */,0
const value_string tls_hello_extension_types[] = {,0
"    { SSL_HND_HELLO_EXT_SERVER_NAME, ""server_name"" }, /* RFC 3546 */",0
"    { 1, ""max_fragment_length"" },",0
"    { 2, ""client_certificate_url"" },",0
"    { 3, ""trusted_ca_keys"" },",0
"    { 4, ""truncated_hmac"" },",0
"    { SSL_HND_HELLO_EXT_STATUS_REQUEST, ""status_request"" }, /* RFC 6066 */",0
"    { 6, ""user_mapping"" },  /* RFC 4681 */",0
"    { 7, ""client_authz"" },",0
"    { 8, ""server_authz"" },",0
"    { SSL_HND_HELLO_EXT_CERT_TYPE, ""cert_type"" },  /* RFC 5081 */",0
"    { SSL_HND_HELLO_EXT_ELLIPTIC_CURVES, ""elliptic_curves"" },  /* RFC 4492 */",0
"    { SSL_HND_HELLO_EXT_EC_POINT_FORMATS, ""ec_point_formats"" },  /* RFC 4492 */",0
"    { 12, ""srp"" },  /* RFC 5054 */",0
"    { 13, ""signature_algorithms"" },  /* RFC 5246 */",0
"    { 14, ""use_srtp"" },",0
"    { SSL_HND_HELLO_EXT_HEARTBEAT, ""Heartbeat"" },  /* RFC 6520 */",0
"    { SSL_HND_HELLO_EXT_ALPN, ""Application Layer Protocol Negotiation"" }, /* RFC 7301 */",0
"    { SSL_HND_HELLO_EXT_STATUS_REQUEST_V2, ""status_request_v2"" }, /* RFC 6961 */",0
"    { 18, ""signed_certificate_timestamp"" }, /* RFC 6962 */",0
"    { SSL_HND_HELLO_EXT_CLIENT_CERT_TYPE, ""client_certificate_type"" }, /* RFC 7250 */",0
"    { SSL_HND_HELLO_EXT_SERVER_CERT_TYPE, ""server_certificate_type"" }, /* RFC 7250 */",0
"    { SSL_HND_HELLO_EXT_PADDING, ""Padding"" }, /* RFC7685 */",0
"    { 22, ""encrypt then mac"" }, /* RFC7366 */",0
"    { SSL_HND_HELLO_EXT_EXTENDED_MASTER_SECRET_TYPE, ""Extended Master Secret"" }, /* RFC7627 */",0
"    { 24, ""token binding"" }, /* https://tools.ietf.org/html/draft-ietf-tokbind-negotiation */",0
"    { SSL_HND_HELLO_EXT_SESSION_TICKET, ""SessionTicket TLS"" },  /* RFC 4507 */",0
"    { SSL_HND_HELLO_EXT_NPN, ""next_protocol_negotiation""}, /* http://technotes.googlecode.com/git/nextprotoneg.html */",0
"    { SSL_HND_HELLO_EXT_RENEG_INFO, ""renegotiation_info"" }, /* RFC 5746 */",0
    /* http://tools.ietf.org/html/draft-balfanz-tls-channelid-00,0
       https://twitter.com/ericlaw/status/274237352531083264 */,0
"    { SSL_HND_HELLO_EXT_CHANNEL_ID_OLD, ""channel_id_old"" },",0
    /* http://tools.ietf.org/html/draft-balfanz-tls-channelid-01,0
       https://code.google.com/p/chromium/codesearch#chromium/src/net/third_party/nss/ssl/sslt.h&l=209 */,0
"    { SSL_HND_HELLO_EXT_CHANNEL_ID, ""channel_id"" },",0
const value_string tls_hello_ext_server_name_type_vs[] = {,0
"    { 0, ""host_name"" },",0
/* RFC 5246 7.4.1.4.1 */,0
const value_string tls_hash_algorithm[] = {,0
"    { 0, ""None"" },",0
"    { 1, ""MD5"" },",0
"    { 2, ""SHA1"" },",0
"    { 3, ""SHA224"" },",0
"    { 4, ""SHA256"" },",0
"    { 5, ""SHA384"" },",0
"    { 6, ""SHA512"" },",0
const value_string tls_signature_algorithm[] = {,0
"    { 3, ""ECDSA"" },",0
/* RFC 6091 3.1 */,0
const value_string tls_certificate_type[] = {,0
"    { 0, ""X.509"" },",0
"    { 1, ""OpenPGP"" },",0
"    { SSL_HND_CERT_TYPE_RAW_PUBLIC_KEY, ""Raw Public Key"" }, /* RFC 7250 */",0
const value_string tls_cert_chain_type[] = {,0
"    { SSL_HND_CERT_URL_TYPE_INDIVIDUAL_CERT,    ""Individual Certificates"" },",0
"    { SSL_HND_CERT_URL_TYPE_PKIPATH,            ""PKI Path"" },",0
const value_string tls_cert_status_type[] = {,0
"    { SSL_HND_CERT_STATUS_TYPE_OCSP,            ""OCSP"" },",0
"    { SSL_HND_CERT_STATUS_TYPE_OCSP_MULTI,      ""OCSP Multi"" },",0
/* string_string is inappropriate as it compares strings while,0
" * ""byte strings MUST NOT be truncated"" (RFC 7301) */",0
typedef struct ssl_alpn_protocol {,0
    const guint8    *proto_name_,0
    size_t           proto_name_len_,0
    const char      *dissector_name_,0
} ssl_alpn_protocol_t_,0
/* http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids */,0
static const ssl_alpn_protocol_t ssl_alpn_protocols[] = {,0
"    { ""http/1.1"",   sizeof(""http/1.1""),     ""http"" },",0
"    /* SPDY moves so fast, just 1, 2 and 3 are registered with IANA but there",0
     * already exists 3.1 as of this writing... match the prefix. */,0
"    { ""spdy/"",      sizeof(""spdy/"") - 1,    ""spdy"" },",0
"    { ""stun.turn"",  sizeof(""stun.turn""),    ""turnchannel"" },",0
"    { ""stun.nat-discovery"", sizeof(""stun.nat-discovery""), ""stun"" },",0
    /* draft-ietf-httpbis-http2-16 */,0
"    { ""h2-"",         sizeof(""h2-"") - 1,     ""http2"" }, /* draft versions */",0
"    { ""h2"",          sizeof(""h2""),          ""http2"" }, /* final version */",0
/* Lookup tables }}} */,0
"/* we keep this internal to packet-ssl-utils, as there should be",0
   no need to access it any other way.,0
   This also allows us to hide the dependency on zlib.,0
struct _SslDecompress {,0
    gint compression_,0
    z_stream istream_,0
/* To assist in parsing client/server key exchange messages,0
   0 indicates unknown */,0
gint ssl_get_keyex_alg(gint cipher),0
    /* Map Cipher suite number to Key Exchange algorithm {{{ */,0
    switch(cipher) {,0
    case 0x0017:,0
    case 0x0018:,0
    case 0x0019:,0
    case 0x001a:,0
    case 0x001b:,0
    case 0x0034:,0
    case 0x003a:,0
    case 0x0046:,0
    case 0x006c:,0
    case 0x006d:,0
    case 0x0089:,0
    case 0x009b:,0
    case 0x00a6:,0
    case 0x00a7:,0
    case 0x00bf:,0
    case 0x00c5:,0
    case 0xc084:,0
    case 0xc085:,0
        return KEX_DH_ANON_,0
    case 0x000b:,0
    case 0x000c:,0
    case 0x000d:,0
    case 0x0030:,0
    case 0x0036:,0
    case 0x003e:,0
    case 0x0042:,0
    case 0x0068:,0
    case 0x0085:,0
    case 0x0097:,0
    case 0x00a4:,0
    case 0x00a5:,0
    case 0x00bb:,0
    case 0x00c1:,0
    case 0xc082:,0
    case 0xc083:,0
        return KEX_DH_DSS_,0
    case 0x000e:,0
    case 0x000f:,0
    case 0x0010:,0
    case 0x0031:,0
    case 0x0037:,0
    case 0x003f:,0
    case 0x0043:,0
    case 0x0069:,0
    case 0x0086:,0
    case 0x0098:,0
    case 0x00a0:,0
    case 0x00a1:,0
    case 0x00bc:,0
    case 0x00c2:,0
    case 0xc07e:,0
    case 0xc07f:,0
        return KEX_DH_RSA_,0
    case 0x0011:,0
    case 0x0012:,0
    case 0x0013:,0
    case 0x0032:,0
    case 0x0038:,0
    case 0x0040:,0
    case 0x0044:,0
    case 0x0063:,0
    case 0x0065:,0
    case 0x0066:,0
    case 0x006a:,0
    case 0x0087:,0
    case 0x0099:,0
    case 0x00a2:,0
    case 0x00a3:,0
    case 0x00bd:,0
    case 0x00c3:,0
    case 0xc080:,0
    case 0xc081:,0
        return KEX_DHE_DSS_,0
    case 0x002d:,0
    case 0x008e:,0
    case 0x008f:,0
    case 0x0090:,0
    case 0x0091:,0
    case 0x00aa:,0
    case 0x00ab:,0
    case 0x00b2:,0
    case 0x00b3:,0
    case 0x00b4:,0
    case 0x00b5:,0
    case 0xc090:,0
    case 0xc091:,0
    case 0xc096:,0
    case 0xc097:,0
    case 0xc0a6:,0
    case 0xc0a7:,0
    case 0xc0aa:,0
    case 0xc0ab:,0
    case 0xe41c:,0
    case 0xe41d:,0
        return KEX_DHE_PSK_,0
    case 0x0014:,0
    case 0x0015:,0
    case 0x0016:,0
    case 0x0033:,0
    case 0x0039:,0
    case 0x0045:,0
    case 0x0067:,0
    case 0x006b:,0
    case 0x0088:,0
    case 0x009a:,0
    case 0x009e:,0
    case 0x009f:,0
    case 0x00be:,0
    case 0x00c4:,0
    case 0xc07c:,0
    case 0xc07d:,0
    case 0xc09e:,0
    case 0xc09f:,0
    case 0xc0a2:,0
    case 0xc0a3:,0
    case 0xe41e:,0
    case 0xe41f:,0
        return KEX_DHE_RSA_,0
    case 0xc015:,0
    case 0xc016:,0
    case 0xc017:,0
    case 0xc018:,0
    case 0xc019:,0
        return KEX_ECDH_ANON_,0
    case 0xc001:,0
    case 0xc002:,0
    case 0xc003:,0
    case 0xc004:,0
    case 0xc005:,0
    case 0xc025:,0
    case 0xc026:,0
    case 0xc02d:,0
    case 0xc02e:,0
    case 0xc074:,0
    case 0xc075:,0
    case 0xc088:,0
    case 0xc089:,0
        return KEX_ECDH_ECDSA_,0
    case 0xc00b:,0
    case 0xc00c:,0
    case 0xc00d:,0
    case 0xc00e:,0
    case 0xc00f:,0
    case 0xc029:,0
    case 0xc02a:,0
    case 0xc031:,0
    case 0xc032:,0
    case 0xc078:,0
    case 0xc079:,0
    case 0xc08c:,0
    case 0xc08d:,0
        return KEX_ECDH_RSA_,0
    case 0xc006:,0
    case 0xc007:,0
    case 0xc008:,0
    case 0xc009:,0
    case 0xc00a:,0
    case 0xc023:,0
    case 0xc024:,0
    case 0xc02b:,0
    case 0xc02c:,0
    case 0xc072:,0
    case 0xc073:,0
    case 0xc086:,0
    case 0xc087:,0
    case 0xc0ac:,0
    case 0xc0ad:,0
    case 0xc0ae:,0
    case 0xc0af:,0
    case 0xe414:,0
    case 0xe415:,0
        return KEX_ECDHE_ECDSA_,0
    case 0xc033:,0
    case 0xc034:,0
    case 0xc035:,0
    case 0xc036:,0
    case 0xc037:,0
    case 0xc038:,0
    case 0xc039:,0
    case 0xc03a:,0
    case 0xc03b:,0
    case 0xc09a:,0
    case 0xc09b:,0
    case 0xe418:,0
    case 0xe419:,0
        return KEX_ECDHE_PSK_,0
    case 0xc010:,0
    case 0xc011:,0
    case 0xc012:,0
    case 0xc013:,0
    case 0xc014:,0
    case 0xc027:,0
    case 0xc028:,0
    case 0xc02f:,0
    case 0xc030:,0
    case 0xc076:,0
    case 0xc077:,0
    case 0xc08a:,0
    case 0xc08b:,0
    case 0xe412:,0
    case 0xe413:,0
        return KEX_ECDHE_RSA_,0
    case 0x001e:,0
    case 0x001f:,0
    case 0x0020:,0
    case 0x0021:,0
    case 0x0022:,0
    case 0x0023:,0
    case 0x0024:,0
    case 0x0025:,0
    case 0x0026:,0
    case 0x0027:,0
    case 0x0028:,0
    case 0x0029:,0
    case 0x002a:,0
    case 0x002b:,0
        return KEX_KRB5_,0
    case 0x002c:,0
    case 0x008a:,0
    case 0x008b:,0
    case 0x008c:,0
    case 0x008d:,0
    case 0x00a8:,0
    case 0x00a9:,0
    case 0x00ae:,0
    case 0x00af:,0
    case 0x00b0:,0
    case 0x00b1:,0
    case 0xc064:,0
    case 0xc065:,0
    case 0xc08e:,0
    case 0xc08f:,0
    case 0xc094:,0
    case 0xc095:,0
    case 0xc0a4:,0
    case 0xc0a5:,0
    case 0xc0a8:,0
    case 0xc0a9:,0
    case 0xe416:,0
    case 0xe417:,0
        return KEX_PSK_,0
    case 0x0001:,0
    case 0x0002:,0
    case 0x0003:,0
    case 0x0004:,0
    case 0x0005:,0
    case 0x0006:,0
    case 0x0007:,0
    case 0x0008:,0
    case 0x0009:,0
    case 0x000a:,0
    case 0x002f:,0
    case 0x0035:,0
    case 0x003b:,0
    case 0x003c:,0
    case 0x003d:,0
    case 0x0041:,0
    case 0x0060:,0
    case 0x0061:,0
    case 0x0062:,0
    case 0x0064:,0
    case 0x0084:,0
    case 0x0096:,0
    case 0x009c:,0
    case 0x009d:,0
    case 0x00ba:,0
    case 0x00c0:,0
    case 0xc07a:,0
    case 0xc07b:,0
    case 0xc09c:,0
    case 0xc09d:,0
    case 0xc0a0:,0
    case 0xc0a1:,0
    case 0xe410:,0
    case 0xe411:,0
    case 0xfefe:,0
    case 0xfeff:,0
    case 0xffe0:,0
    case 0xffe1:,0
        return KEX_RSA_,0
    case 0x002e:,0
    case 0x0092:,0
    case 0x0093:,0
    case 0x0094:,0
    case 0x0095:,0
    case 0x00ac:,0
    case 0x00ad:,0
    case 0x00b6:,0
    case 0x00b7:,0
    case 0x00b8:,0
    case 0x00b9:,0
    case 0xc092:,0
    case 0xc093:,0
    case 0xc098:,0
    case 0xc099:,0
    case 0xe41a:,0
    case 0xe41b:,0
        return KEX_RSA_PSK_,0
    case 0xc01a:,0
    case 0xc01d:,0
    case 0xc020:,0
        return KEX_SRP_SHA_,0
    case 0xc01c:,0
    case 0xc01f:,0
    case 0xc022:,0
        return KEX_SRP_SHA_DSS_,0
    case 0xc01b:,0
    case 0xc01e:,0
    case 0xc021:,0
        return KEX_SRP_SHA_RSA_,0
    /* }}} */,0
/* StringInfo structure (len + data) functions {{{ */,0
static gint,0
"ssl_data_alloc(StringInfo* str, size_t len)",0
    str->data = (guchar *)g_malloc(len)_,0
"    /* the allocator can return a null pointer for a size equal to 0,",0
     * and that must be allowed */,0
    if (len > 0 && !str->data),0
        return -1_,0
    str->data_len = (guint) len_,0
"ssl_data_set(StringInfo* str, const guchar* data, guint len)",0
    DISSECTOR_ASSERT(data)_,0
"    memcpy(str->data, data, len)_",0
    str->data_len = len_,0
"ssl_data_realloc(StringInfo* str, guint len)",0
"    str->data = (guchar *)g_realloc(str->data, len)_",0
    if (!str->data),0
static StringInfo *,0
ssl_data_clone(StringInfo *str),0
    StringInfo *cloned_str_,0
"    cloned_str = (StringInfo *) wmem_alloc0(wmem_file_scope(),",0
            sizeof(StringInfo) + str->data_len)_,0
    cloned_str->data = (guchar *) (cloned_str + 1)_,0
"    ssl_data_set(cloned_str, str->data, str->data_len)_",0
    return cloned_str_,0
"ssl_data_copy(StringInfo* dst, StringInfo* src)",0
    if (dst->data_len < src->data_len) {,0
"      if (ssl_data_realloc(dst, src->data_len))",0
"    memcpy(dst->data, src->data, src->data_len)_",0
    dst->data_len = src->data_len_,0
/* from_hex converts |hex_len| bytes of hex data from |in| and sets |*out| to,0
 * the result. |out->data| will be allocated using wmem_file_scope. Returns TRUE on,0
 * success. */,0
"static gboolean from_hex(StringInfo* out, const char* in, gsize hex_len) {",0
    gsize i_,0
    if (hex_len & 1),0
"    out->data = (guchar *)wmem_alloc(wmem_file_scope(), hex_len / 2)_",0
    for (i = 0_ i < hex_len / 2_ i++) {,0
        int a = ws_xton(in[i*2])_,0
        int b = ws_xton(in[i*2 + 1])_,0
        if (a == -1 || b == -1),0
            return FALSE_,0
        out->data[i] = a << 4 | b_,0
    out->data_len = (guint)hex_len / 2_,0
/* StringInfo structure (len + data) functions }}} */,0
/* libgcrypt wrappers for HMAC/message digest operations {{{ */,0
/* hmac abstraction layer */,0
#define SSL_HMAC gcry_md_hd_t,0
static inline gint,0
"ssl_hmac_init(SSL_HMAC* md, const void * key, gint len, gint algo)",0
    gcry_error_t  err_,0
"    const char   *err_str, *err_src_",0
"    err = gcry_md_open(md,algo, GCRY_MD_FLAG_HMAC)_",0
    if (err != 0) {,0
        err_str = gcry_strerror(err)_,0
        err_src = gcry_strsource(err)_,0
"        ssl_debug_printf(""ssl_hmac_init(): gcry_md_open failed %s/%s"", err_str, err_src)_",0
"    gcry_md_setkey (*(md), key, len)_",0
static inline void,0
"ssl_hmac_update(SSL_HMAC* md, const void* data, gint len)",0
"    gcry_md_write(*(md), data, len)_",0
"ssl_hmac_final(SSL_HMAC* md, guchar* data, guint* datalen)",0
    gint  algo_,0
    guint len_,0
    algo = gcry_md_get_algo (*(md))_,0
    len  = gcry_md_get_algo_dlen(algo)_,0
    DISSECTOR_ASSERT(len <= *datalen)_,0
"    memcpy(data, gcry_md_read(*(md), algo), len)_",0
    *datalen = len_,0
ssl_hmac_cleanup(SSL_HMAC* md),0
    gcry_md_close(*(md))_,0
/* message digest abstraction layer*/,0
#define SSL_MD gcry_md_hd_t,0
"ssl_md_init(SSL_MD* md, gint algo)",0
"    err = gcry_md_open(md,algo, 0)_",0
"        ssl_debug_printf(""ssl_md_init(): gcry_md_open failed %s/%s"", err_str, err_src)_",0
"ssl_md_update(SSL_MD* md, guchar* data, gint len)",0
"ssl_md_final(SSL_MD* md, guchar* data, guint* datalen)",0
    gint algo_,0
    gint len_,0
    len = gcry_md_get_algo_dlen (algo)_,0
"    memcpy(data, gcry_md_read(*(md),  algo), len)_",0
ssl_md_cleanup(SSL_MD* md),0
/* md5 /sha abstraction layer */,0
#define SSL_SHA_CTX gcry_md_hd_t,0
#define SSL_MD5_CTX gcry_md_hd_t,0
ssl_sha_init(SSL_SHA_CTX* md),0
"    gcry_md_open(md,GCRY_MD_SHA1, 0)_",0
"ssl_sha_update(SSL_SHA_CTX* md, guchar* data, gint len)",0
"ssl_sha_final(guchar* buf, SSL_SHA_CTX* md)",0
"    memcpy(buf, gcry_md_read(*(md),  GCRY_MD_SHA1),",0
           gcry_md_get_algo_dlen(GCRY_MD_SHA1))_,0
ssl_sha_cleanup(SSL_SHA_CTX* md),0
ssl_md5_init(SSL_MD5_CTX* md),0
"    return gcry_md_open(md,GCRY_MD_MD5, 0)_",0
"ssl_md5_update(SSL_MD5_CTX* md, guchar* data, gint len)",0
"ssl_md5_final(guchar* buf, SSL_MD5_CTX* md)",0
"    memcpy(buf, gcry_md_read(*(md),  GCRY_MD_MD5),",0
           gcry_md_get_algo_dlen(GCRY_MD_MD5))_,0
ssl_md5_cleanup(SSL_MD5_CTX* md),0
/* libgcrypt wrappers for HMAC/message digest operations }}} */,0
/* libgcrypt wrappers for Cipher state manipulation {{{ */,0
"ssl_cipher_setiv(SSL_CIPHER_CTX *cipher, guchar* iv, gint iv_len)",0
    gint ret_,0
    guchar *ivp_,0
    gint i_,0
    gcry_cipher_hd_t c_,0
    c=(gcry_cipher_hd_t)*cipher_,0
"    ssl_debug_printf(""--------------------------------------------------------------------"")_",0
"    for(ivp=c->iv,i=0_ i < iv_len_ i++ )",0
"        ssl_debug_printf(""%d "",ivp[i])_",0
"    ret = gcry_cipher_setiv(*(cipher), iv, iv_len)_",0
    return ret_,0
/* stream cipher abstraction layer*/,0
"ssl_cipher_init(gcry_cipher_hd_t *cipher, gint algo, guchar* sk,",0
"        guchar* iv, gint mode)",0
"    gint gcry_modes[]={GCRY_CIPHER_MODE_STREAM,GCRY_CIPHER_MODE_CBC,GCRY_CIPHER_MODE_CTR,GCRY_CIPHER_MODE_CTR,GCRY_CIPHER_MODE_CTR}_",0
    gint err_,0
    if (algo == -1) {,0
        /* NULL mode */,0
        *(cipher) = (gcry_cipher_hd_t)-1_,0
"    err = gcry_cipher_open(cipher, algo, gcry_modes[mode], 0)_",0
    if (err !=0),0
        return  -1_,0
"    err = gcry_cipher_setkey(*(cipher), sk, gcry_cipher_get_algo_keylen (algo))_",0
    if (err != 0),0
"    err = gcry_cipher_setiv(*(cipher), iv, gcry_cipher_get_algo_blklen (algo))_",0
"ssl_cipher_decrypt(gcry_cipher_hd_t *cipher, guchar * out, gint outl,",0
"                   const guchar * in, gint inl)",0
    if ((*cipher) == (gcry_cipher_hd_t)-1),0
        if (in && inl),0
"            memcpy(out, in, outl < inl ? outl : inl)_",0
"    return gcry_cipher_decrypt ( *(cipher), out, outl, in, inl)_",0
ssl_get_digest_by_name(const gchar*name),0
    return gcry_md_map_name(name)_,0
ssl_get_cipher_by_name(const gchar* name),0
    return gcry_cipher_map_name(name)_,0
ssl_cipher_cleanup(gcry_cipher_hd_t *cipher),0
    if ((*cipher) != (gcry_cipher_hd_t)-1),0
        gcry_cipher_close(*cipher)_,0
    *cipher = NULL_,0
/* libgcrypt wrappers for Cipher state manipulation }}} */,0
/* libgcrypt wrapper to decrypt using a RSA private key {{{ */,0
/* decrypt data with private key. Store decrypted data directly into input,0
 * buffer */,0
"ssl_private_decrypt(const guint len, guchar* data, gcry_sexp_t pk)",0
    gint        rc = 0_,0
"    size_t      decr_len = 0, i = 0_",0
"    gcry_sexp_t s_data = NULL, s_plain = NULL_",0
"    gcry_mpi_t  encr_mpi = NULL, text = NULL_",0
    /* create mpi representation of encrypted data */,0
"    rc = gcry_mpi_scan(&encr_mpi, GCRYMPI_FMT_USG, data, len, NULL)_",0
    if (rc != 0 ) {,0
"        ssl_debug_printf(""pcry_private_decrypt: can't convert data to mpi (size %d):%s\n"",",0
"            len, gcry_strerror(rc))_",0
    /* put the data into a simple list */,0
"    rc = gcry_sexp_build(&s_data, NULL, ""(enc-val(rsa(a%m)))"", encr_mpi)_",0
    if (rc != 0) {,0
"        ssl_debug_printf(""pcry_private_decrypt: can't build encr_sexp:%s\n"",",0
             gcry_strerror(rc))_,0
        decr_len = 0_,0
        goto out_,0
    /* pass it to libgcrypt */,0
"    rc = gcry_pk_decrypt(&s_plain, s_data, pk)_",0
    if (rc != 0),0
"        ssl_debug_printf(""pcry_private_decrypt: can't decrypt key:%s\n"",",0
            gcry_strerror(rc))_,0
    /* convert plain text sexp to mpi format */,0
"    text = gcry_sexp_nth_mpi(s_plain, 0, 0)_",0
    if (! text) {,0
"        ssl_debug_printf(""pcry_private_decrypt: can't convert sexp to mpi\n"")_",0
    /* compute size requested for plaintext buffer */,0
"    rc = gcry_mpi_print(GCRYMPI_FMT_USG, NULL, 0, &decr_len, text)_",0
"        ssl_debug_printf(""pcry_private_decrypt: can't compute decr size:%s\n"",",0
    /* sanity check on out buffer */,0
    if (decr_len > len) {,0
"        ssl_debug_printf(""pcry_private_decrypt: decrypted data is too long ?!? (%"" G_GSIZE_MODIFIER ""u max %d)\n"", decr_len, len)_",0
    /* write plain text to newly allocated buffer */,0
"    rc = gcry_mpi_print(GCRYMPI_FMT_USG, data, len, &decr_len, text)_",0
"        ssl_debug_printf(""pcry_private_decrypt: can't print decr data to mpi (size %"" G_GSIZE_MODIFIER ""u):%s\n"", decr_len, gcry_strerror(rc))_",0
"    ssl_print_data(""decrypted_unstrip_pre_master"", data, decr_len)_",0
    /* strip the padding*/,0
    rc = 0_,0
    for (i = 1_ i < decr_len_ i++) {,0
        if (data[i] == 0) {,0
            rc = (gint) i+1_,0
"    ssl_debug_printf(""pcry_private_decrypt: stripping %d bytes, decr_len %"" G_GSIZE_MODIFIER ""u\n"", rc, decr_len)_",0
    decr_len -= rc_,0
"    memmove(data, data+rc, decr_len)_",0
out:,0
    gcry_sexp_release(s_data)_,0
    gcry_sexp_release(s_plain)_,0
    gcry_mpi_release(encr_mpi)_,0
    gcry_mpi_release(text)_,0
    return (int) decr_len_,0
} /* }}} */,0
#endif /* HAVE_LIBGNUTLS */,0
#else /* ! HAVE_LIBGCRYPT */,0
"ssl_cipher_setiv(SSL_CIPHER_CTX *cipher _U_, guchar* iv _U_, gint iv_len _U_)",0
"    ssl_debug_printf(""ssl_cipher_setiv: impossible without gnutls.\n"")_",0
#endif /* ! HAVE_LIBGCRYPT */,0
#ifdef HAVE_LIBGCRYPT /* Save space if decryption is not enabled. */,0
"/* Digests, Ciphers and Cipher Suites registry {{{ */",0
static const SslDigestAlgo digests[]={,0
"    {""MD5"",     16},",0
"    {""SHA1"",    20},",0
"    {""SHA256"",  32},",0
"    {""SHA384"",  48},",0
"    {""Not Applicable"",  0},",0
#define DIGEST_MAX_SIZE 48,0
/* get index digest index */,0
static const SslDigestAlgo *,0
ssl_cipher_suite_dig(const SslCipherSuite *cs) {,0
    return &digests[cs->dig - DIG_MD5]_,0
static const gchar *ciphers[]={,0
"    ""DES"",",0
"    ""3DES"",",0
"    ""ARCFOUR"", /* libgcrypt does not support rc4, but this should be 100% compatible*/",0
"    ""RFC2268_128"", /* libgcrypt name for RC2 with a 128-bit key */",0
"    ""IDEA"",",0
"    ""AES"",",0
"    ""AES256"",",0
"    ""CAMELLIA128"",",0
"    ""CAMELLIA256"",",0
"    ""SEED"",",0
"    ""*UNKNOWN*""",0
static const SslCipherSuite cipher_suites[]={,0
"    {0x0001,KEX_RSA,         ENC_NULL,        1,  0,  0,DIG_MD5,    MODE_STREAM},   /* TLS_RSA_WITH_NULL_MD5 */",0
"    {0x0002,KEX_RSA,         ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_RSA_WITH_NULL_SHA */",0
"    {0x0003,KEX_RSA,         ENC_RC4,         1,128, 40,DIG_MD5,    MODE_STREAM},   /* TLS_RSA_EXPORT_WITH_RC4_40_MD5 */",0
"    {0x0004,KEX_RSA,         ENC_RC4,         1,128,128,DIG_MD5,    MODE_STREAM},   /* TLS_RSA_WITH_RC4_128_MD5 */",0
"    {0x0005,KEX_RSA,         ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_RSA_WITH_RC4_128_SHA */",0
"    {0x0006,KEX_RSA,         ENC_RC2,         8,128, 40,DIG_MD5,    MODE_CBC   },   /* TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 */",0
"    {0x0007,KEX_RSA,         ENC_IDEA,        8,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_IDEA_CBC_SHA */",0
"    {0x0008,KEX_RSA,         ENC_DES,         8, 64, 40,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_EXPORT_WITH_DES40_CBC_SHA */",0
"    {0x0009,KEX_RSA,         ENC_DES,         8, 64, 64,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_DES_CBC_SHA */",0
"    {0x000A,KEX_RSA,         ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0x000B,KEX_DH_DSS,      ENC_DES,         8, 64, 40,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA */",0
"    {0x000C,KEX_DH_DSS,      ENC_DES,         8, 64, 64,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_DES_CBC_SHA */",0
"    {0x000D,KEX_DH_DSS,      ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA */",0
"    {0x000E,KEX_DH_RSA,      ENC_DES,         8, 64, 40,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA */",0
"    {0x000F,KEX_DH_RSA,      ENC_DES,         8, 64, 64,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_DES_CBC_SHA */",0
"    {0x0010,KEX_DH_RSA,      ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0x0011,KEX_DHE_DSS,     ENC_DES,         8, 64, 40,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA */",0
"    {0x0012,KEX_DHE_DSS,     ENC_DES,         8, 64, 64,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_DES_CBC_SHA */",0
"    {0x0013,KEX_DHE_DSS,     ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA */",0
"    {0x0014,KEX_DHE_RSA,     ENC_DES,         8, 64, 40,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA */",0
"    {0x0015,KEX_DHE_RSA,     ENC_DES,         8, 64, 64,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_DES_CBC_SHA */",0
"    {0x0016,KEX_DHE_RSA,     ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0x0017,KEX_DH_ANON,     ENC_RC4,         1,128, 40,DIG_MD5,    MODE_STREAM},   /* TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 */",0
"    {0x0018,KEX_DH_ANON,     ENC_RC4,         1,128,128,DIG_MD5,    MODE_STREAM},   /* TLS_DH_anon_WITH_RC4_128_MD5 */",0
"    {0x0019,KEX_DH_ANON,     ENC_DES,         8, 64, 40,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA */",0
"    {0x001A,KEX_DH_ANON,     ENC_DES,         8, 64, 64,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_DES_CBC_SHA */",0
"    {0x001B,KEX_DH_ANON,     ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_3DES_EDE_CBC_SHA */",0
"    {0x002C,KEX_PSK,         ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_PSK_WITH_NULL_SHA */",0
"    {0x002D,KEX_DHE_PSK,     ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_DHE_PSK_WITH_NULL_SHA */",0
"    {0x002E,KEX_RSA_PSK,     ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_RSA_PSK_WITH_NULL_SHA */",0
"    {0x002F,KEX_RSA,         ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_AES_128_CBC_SHA */",0
"    {0x0030,KEX_DH_DSS,      ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_AES_128_CBC_SHA */",0
"    {0x0031,KEX_DH_RSA,      ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_AES_128_CBC_SHA */",0
"    {0x0032,KEX_DHE_DSS,     ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_AES_128_CBC_SHA */",0
"    {0x0033,KEX_DHE_RSA,     ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_AES_128_CBC_SHA */",0
"    {0x0034,KEX_DH_ANON,     ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_AES_128_CBC_SHA */",0
"    {0x0035,KEX_RSA,         ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_AES_256_CBC_SHA */",0
"    {0x0036,KEX_DH_DSS,      ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_AES_256_CBC_SHA */",0
"    {0x0037,KEX_DH_RSA,      ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_AES_256_CBC_SHA */",0
"    {0x0038,KEX_DHE_DSS,     ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_AES_256_CBC_SHA */",0
"    {0x0039,KEX_DHE_RSA,     ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_AES_256_CBC_SHA */",0
"    {0x003A,KEX_DH_ANON,     ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_AES_256_CBC_SHA */",0
"    {0x003B,KEX_RSA,         ENC_NULL,        1,  0,  0,DIG_SHA256, MODE_STREAM},   /* TLS_RSA_WITH_NULL_SHA256 */",0
"    {0x003C,KEX_RSA,         ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_RSA_WITH_AES_128_CBC_SHA256 */",0
"    {0x003D,KEX_RSA,         ENC_AES256,     16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_RSA_WITH_AES_256_CBC_SHA256 */",0
"    {0x003E,KEX_DH_DSS,      ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DH_DSS_WITH_AES_128_CBC_SHA256 */",0
"    {0x003F,KEX_DH_RSA,      ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DH_RSA_WITH_AES_128_CBC_SHA256 */",0
"    {0x0040,KEX_DHE_DSS,     ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 */",0
"    {0x0041,KEX_RSA,         ENC_CAMELLIA128,16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_CAMELLIA_128_CBC_SHA */",0
"    {0x0042,KEX_DH_DSS,      ENC_CAMELLIA128,16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA */",0
"    {0x0043,KEX_DH_RSA,      ENC_CAMELLIA128,16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA */",0
"    {0x0044,KEX_DHE_DSS,     ENC_CAMELLIA128,16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA */",0
"    {0x0045,KEX_DHE_RSA,     ENC_CAMELLIA128,16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA */",0
"    {0x0046,KEX_DH_ANON,     ENC_CAMELLIA128,16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA */",0
"    {0x0060,KEX_RSA,         ENC_RC4,         1,128, 56,DIG_MD5,    MODE_STREAM},   /* TLS_RSA_EXPORT1024_WITH_RC4_56_MD5 */",0
"    {0x0061,KEX_RSA,         ENC_RC2,         1,128, 56,DIG_MD5,    MODE_STREAM},   /* TLS_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5 */",0
"    {0x0062,KEX_RSA,         ENC_DES,         8, 64, 56,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA */",0
"    {0x0063,KEX_DHE_DSS,     ENC_DES,         8, 64, 56,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA */",0
"    {0x0064,KEX_RSA,         ENC_RC4,         1,128, 56,DIG_SHA,    MODE_STREAM},   /* TLS_RSA_EXPORT1024_WITH_RC4_56_SHA */",0
"    {0x0065,KEX_DHE_DSS,     ENC_RC4,         1,128, 56,DIG_SHA,    MODE_STREAM},   /* TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA */",0
"    {0x0066,KEX_DHE_DSS,     ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_DHE_DSS_WITH_RC4_128_SHA */",0
"    {0x0067,KEX_DHE_RSA,     ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 */",0
"    {0x0068,KEX_DH_DSS,      ENC_AES256,     16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DH_DSS_WITH_AES_256_CBC_SHA256 */",0
"    {0x0069,KEX_DH_RSA,      ENC_AES256,     16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DH_RSA_WITH_AES_256_CBC_SHA256 */",0
"    {0x006A,KEX_DHE_DSS,     ENC_AES256,     16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 */",0
"    {0x006B,KEX_DHE_RSA,     ENC_AES256,     16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 */",0
"    {0x006C,KEX_DH_ANON,     ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DH_anon_WITH_AES_128_CBC_SHA256 */",0
"    {0x006D,KEX_DH_ANON,     ENC_AES256,     16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DH_anon_WITH_AES_256_CBC_SHA256 */",0
"    {0x0084,KEX_RSA,         ENC_CAMELLIA256,16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_CAMELLIA_256_CBC_SHA */",0
"    {0x0085,KEX_DH_DSS,      ENC_CAMELLIA256,16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA */",0
"    {0x0086,KEX_DH_RSA,      ENC_CAMELLIA256,16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA */",0
"    {0x0087,KEX_DHE_DSS,     ENC_CAMELLIA256,16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA */",0
"    {0x0088,KEX_DHE_RSA,     ENC_CAMELLIA256,16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA */",0
"    {0x0089,KEX_DH_ANON,     ENC_CAMELLIA256,16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA */",0
"    {0x008A,KEX_PSK,         ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_PSK_WITH_RC4_128_SHA */",0
"    {0x008B,KEX_PSK,         ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_PSK_WITH_3DES_EDE_CBC_SHA */",0
"    {0x008C,KEX_PSK,         ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_PSK_WITH_AES_128_CBC_SHA */",0
"    {0x008D,KEX_PSK,         ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_PSK_WITH_AES_256_CBC_SHA */",0
"    {0x008E,KEX_DHE_PSK,     ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_DHE_PSK_WITH_RC4_128_SHA */",0
"    {0x008F,KEX_DHE_PSK,     ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA */",0
"    {0x0090,KEX_DHE_PSK,     ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_PSK_WITH_AES_128_CBC_SHA */",0
"    {0x0091,KEX_DHE_PSK,     ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_PSK_WITH_AES_256_CBC_SHA */",0
"    {0x0092,KEX_RSA_PSK,     ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_RSA_PSK_WITH_RC4_128_SHA */",0
"    {0x0093,KEX_RSA_PSK,     ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA */",0
"    {0x0094,KEX_RSA_PSK,     ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_PSK_WITH_AES_128_CBC_SHA */",0
"    {0x0095,KEX_RSA_PSK,     ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_PSK_WITH_AES_256_CBC_SHA */",0
"    {0x0096,KEX_RSA,         ENC_SEED,       16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_RSA_WITH_SEED_CBC_SHA */",0
"    {0x0097,KEX_DH_DSS,      ENC_SEED,       16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_DSS_WITH_SEED_CBC_SHA */",0
"    {0x0098,KEX_DH_RSA,      ENC_SEED,       16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_RSA_WITH_SEED_CBC_SHA */",0
"    {0x0099,KEX_DHE_DSS,     ENC_SEED,       16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_DSS_WITH_SEED_CBC_SHA */",0
"    {0x009A,KEX_DHE_RSA,     ENC_SEED,       16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DHE_RSA_WITH_SEED_CBC_SHA */",0
"    {0x009B,KEX_DH_ANON,     ENC_SEED,       16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_DH_anon_WITH_SEED_CBC_SHA */",0
"    {0x009C,KEX_RSA,         ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_RSA_WITH_AES_128_GCM_SHA256 */",0
"    {0x009D,KEX_RSA,         ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_RSA_WITH_AES_256_GCM_SHA384 */",0
"    {0x009E,KEX_DHE_RSA,     ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 */",0
"    {0x009F,KEX_DHE_RSA,     ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 */",0
"    {0x00A0,KEX_DH_RSA,      ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DH_RSA_WITH_AES_128_GCM_SHA256 */",0
"    {0x00A1,KEX_DH_RSA,      ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DH_RSA_WITH_AES_256_GCM_SHA384 */",0
"    {0x00A2,KEX_DHE_DSS,     ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 */",0
"    {0x00A3,KEX_DHE_DSS,     ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 */",0
"    {0x00A4,KEX_DH_DSS,      ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DH_DSS_WITH_AES_128_GCM_SHA256 */",0
"    {0x00A5,KEX_DH_DSS,      ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DH_DSS_WITH_AES_256_GCM_SHA384 */",0
"    {0x00A6,KEX_DH_ANON,     ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DH_anon_WITH_AES_128_GCM_SHA256 */",0
"    {0x00A7,KEX_DH_ANON,     ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DH_anon_WITH_AES_256_GCM_SHA384 */",0
"    {0x00A8,KEX_PSK,         ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_PSK_WITH_AES_128_GCM_SHA256 */",0
"    {0x00A9,KEX_PSK,         ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_PSK_WITH_AES_256_GCM_SHA384 */",0
"    {0x00AA,KEX_DHE_PSK,     ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 */",0
"    {0x00AB,KEX_DHE_PSK,     ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 */",0
"    {0x00AC,KEX_RSA_PSK,     ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 */",0
"    {0x00AD,KEX_RSA_PSK,     ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 */",0
"    {0x00AE,KEX_PSK,         ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_PSK_WITH_AES_128_CBC_SHA256 */",0
"    {0x00AF,KEX_PSK,         ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_PSK_WITH_AES_256_CBC_SHA384 */",0
"    {0x00B0,KEX_PSK,         ENC_NULL,        1,  0,  0,DIG_SHA256, MODE_STREAM},   /* TLS_PSK_WITH_NULL_SHA256 */",0
"    {0x00B1,KEX_PSK,         ENC_NULL,        1,  0,  0,DIG_SHA384, MODE_STREAM},   /* TLS_PSK_WITH_NULL_SHA384 */",0
"    {0x00B2,KEX_DHE_PSK,     ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 */",0
"    {0x00B3,KEX_DHE_PSK,     ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 */",0
"    {0x00B4,KEX_DHE_PSK,     ENC_NULL,        1,  0,  0,DIG_SHA256, MODE_STREAM},   /* TLS_DHE_PSK_WITH_NULL_SHA256 */",0
"    {0x00B5,KEX_DHE_PSK,     ENC_NULL,        1,  0,  0,DIG_SHA384, MODE_STREAM},   /* TLS_DHE_PSK_WITH_NULL_SHA384 */",0
"    {0x00B6,KEX_RSA_PSK,     ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 */",0
"    {0x00B7,KEX_RSA_PSK,     ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 */",0
"    {0x00B8,KEX_RSA_PSK,     ENC_NULL,        1,  0,  0,DIG_SHA256, MODE_STREAM},   /* TLS_RSA_PSK_WITH_NULL_SHA256 */",0
"    {0x00B9,KEX_RSA_PSK,     ENC_NULL,        1,  0,  0,DIG_SHA384, MODE_STREAM},   /* TLS_RSA_PSK_WITH_NULL_SHA384 */",0
"    {0x00BA,KEX_RSA,         ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0x00BB,KEX_DH_DSS,      ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0x00BC,KEX_DH_RSA,      ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0x00BD,KEX_DHE_DSS,     ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0x00BE,KEX_DHE_RSA,     ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0x00BF,KEX_DH_ANON,     ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0x00C0,KEX_RSA,         ENC_CAMELLIA256,16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 */",0
"    {0x00C1,KEX_DH_DSS,      ENC_CAMELLIA256,16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 */",0
"    {0x00C2,KEX_DH_RSA,      ENC_CAMELLIA256,16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 */",0
"    {0x00C3,KEX_DHE_DSS,     ENC_CAMELLIA256,16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 */",0
"    {0x00C4,KEX_DHE_RSA,     ENC_CAMELLIA256,16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 */",0
"    {0x00C5,KEX_DH_ANON,     ENC_CAMELLIA256,16,256,256,DIG_SHA256, MODE_CBC   },   /* TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 */",0
"    {0xC001,KEX_ECDH_ECDSA,  ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_ECDH_ECDSA_WITH_NULL_SHA */",0
"    {0xC002,KEX_ECDH_ECDSA,  ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_ECDH_ECDSA_WITH_RC4_128_SHA */",0
"    {0xC003,KEX_ECDH_ECDSA,  ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0xC004,KEX_ECDH_ECDSA,  ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA */",0
"    {0xC005,KEX_ECDH_ECDSA,  ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA */",0
"    {0xC006,KEX_ECDHE_ECDSA, ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_ECDHE_ECDSA_WITH_NULL_SHA */",0
"    {0xC007,KEX_ECDHE_ECDSA, ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_ECDHE_ECDSA_WITH_RC4_128_SHA */",0
"    {0xC008,KEX_ECDHE_ECDSA, ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0xC009,KEX_ECDHE_ECDSA, ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA */",0
"    {0xC00A,KEX_ECDHE_ECDSA, ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA */",0
"    {0xC00B,KEX_ECDH_RSA,    ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_ECDH_RSA_WITH_NULL_SHA */",0
"    {0xC00C,KEX_ECDH_RSA,    ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_ECDH_RSA_WITH_RC4_128_SHA */",0
"    {0xC00D,KEX_ECDH_RSA,    ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0xC00E,KEX_ECDH_RSA,    ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_RSA_WITH_AES_128_CBC_SHA */",0
"    {0xC00F,KEX_ECDH_RSA,    ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_RSA_WITH_AES_256_CBC_SHA */",0
"    {0xC010,KEX_ECDHE_RSA,   ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_ECDHE_RSA_WITH_NULL_SHA */",0
"    {0xC011,KEX_ECDHE_RSA,   ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_ECDHE_RSA_WITH_RC4_128_SHA */",0
"    {0xC012,KEX_ECDHE_RSA,   ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA */",0
"    {0xC013,KEX_ECDHE_RSA,   ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA */",0
"    {0xC014,KEX_ECDHE_RSA,   ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA */",0
"    {0xC015,KEX_ECDH_ANON,   ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_ECDH_anon_WITH_NULL_SHA */",0
"    {0xC016,KEX_ECDH_ANON,   ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_ECDH_anon_WITH_RC4_128_SHA */",0
"    {0xC017,KEX_ECDH_ANON,   ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA */",0
"    {0xC018,KEX_ECDH_ANON,   ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_anon_WITH_AES_128_CBC_SHA */",0
"    {0xC019,KEX_ECDH_ANON,   ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_ECDH_anon_WITH_AES_256_CBC_SHA */",0
"    {0xC023,KEX_ECDHE_ECDSA, ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 */",0
"    {0xC024,KEX_ECDHE_ECDSA, ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 */",0
"    {0xC025,KEX_ECDH_ECDSA,  ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 */",0
"    {0xC026,KEX_ECDH_ECDSA,  ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 */",0
"    {0xC027,KEX_ECDHE_RSA,   ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 */",0
"    {0xC028,KEX_ECDHE_RSA,   ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 */",0
"    {0xC029,KEX_ECDH_RSA,    ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 */",0
"    {0xC02A,KEX_ECDH_RSA,    ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 */",0
"    {0xC02B,KEX_ECDHE_ECDSA, ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 */",0
"    {0xC02C,KEX_ECDHE_ECDSA, ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 */",0
"    {0xC02D,KEX_ECDH_ECDSA,  ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 */",0
"    {0xC02E,KEX_ECDH_ECDSA,  ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 */",0
"    {0xC02F,KEX_ECDHE_RSA,   ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 */",0
"    {0xC030,KEX_ECDHE_RSA,   ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 */",0
"    {0xC031,KEX_ECDH_RSA,    ENC_AES,         4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 */",0
"    {0xC032,KEX_ECDH_RSA,    ENC_AES256,      4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 */",0
"    {0xC033,KEX_ECDHE_PSK,   ENC_RC4,         1,128,128,DIG_SHA,    MODE_STREAM},   /* TLS_ECDHE_PSK_WITH_RC4_128_SHA */",0
"    {0xC034,KEX_ECDHE_PSK,   ENC_3DES,        8,192,192,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA */",0
"    {0xC035,KEX_ECDHE_PSK,   ENC_AES,        16,128,128,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA */",0
"    {0xC036,KEX_ECDHE_PSK,   ENC_AES256,     16,256,256,DIG_SHA,    MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA */",0
"    {0xC037,KEX_ECDHE_PSK,   ENC_AES,        16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 */",0
"    {0xC038,KEX_ECDHE_PSK,   ENC_AES256,     16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 */",0
"    {0xC039,KEX_ECDHE_PSK,   ENC_NULL,        1,  0,  0,DIG_SHA,    MODE_STREAM},   /* TLS_ECDHE_PSK_WITH_NULL_SHA */",0
"    {0xC03A,KEX_ECDHE_PSK,   ENC_NULL,        1,  0,  0,DIG_SHA256, MODE_STREAM},   /* TLS_ECDHE_PSK_WITH_NULL_SHA256 */",0
"    {0xC03B,KEX_ECDHE_PSK,   ENC_NULL,        1,  0,  0,DIG_SHA384, MODE_STREAM},   /* TLS_ECDHE_PSK_WITH_NULL_SHA384 */",0
"    {0xC072,KEX_ECDHE_ECDSA, ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC073,KEX_ECDHE_ECDSA, ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC074,KEX_ECDH_ECDSA,  ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC075,KEX_ECDH_ECDSA,  ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC076,KEX_ECDHE_RSA,   ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC077,KEX_ECDHE_RSA,   ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC078,KEX_ECDH_RSA,    ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC079,KEX_ECDH_RSA,    ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC07A,KEX_RSA,         ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC07B,KEX_RSA,         ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC07C,KEX_DHE_RSA,     ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC07D,KEX_DHE_RSA,     ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC07E,KEX_DH_RSA,      ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC07F,KEX_DH_RSA,      ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC080,KEX_DHE_DSS,     ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC081,KEX_DHE_DSS,     ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC082,KEX_DH_DSS,      ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC083,KEX_DH_DSS,      ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC084,KEX_DH_ANON,     ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC085,KEX_DH_ANON,     ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC086,KEX_ECDHE_ECDSA, ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC087,KEX_ECDHE_ECDSA, ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC088,KEX_ECDH_ECDSA,  ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC089,KEX_ECDH_ECDSA,  ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC08A,KEX_ECDHE_RSA,   ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC08B,KEX_ECDHE_RSA,   ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC08C,KEX_ECDH_RSA,    ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC08D,KEX_ECDH_RSA,    ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC08E,KEX_PSK,         ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC08F,KEX_PSK,         ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC090,KEX_DHE_PSK,     ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC091,KEX_DHE_PSK,     ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC092,KEX_RSA_PSK,     ENC_CAMELLIA128, 4,128,128,DIG_SHA256, MODE_GCM   },   /* TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 */",0
"    {0xC093,KEX_RSA_PSK,     ENC_CAMELLIA256, 4,256,256,DIG_SHA384, MODE_GCM   },   /* TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 */",0
"    {0xC094,KEX_PSK,         ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC095,KEX_PSK,         ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC096,KEX_DHE_PSK,     ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC097,KEX_DHE_PSK,     ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC098,KEX_RSA_PSK,     ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC099,KEX_RSA_PSK,     ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC09A,KEX_ECDHE_PSK,   ENC_CAMELLIA128,16,128,128,DIG_SHA256, MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 */",0
"    {0xC09B,KEX_ECDHE_PSK,   ENC_CAMELLIA256,16,256,256,DIG_SHA384, MODE_CBC   },   /* TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 */",0
"    {0xC09C,KEX_RSA,         ENC_AES,         4,128,128,DIG_NA,     MODE_CCM   },   /* TLS_RSA_WITH_AES_128_CCM */",0
"    {0xC09D,KEX_RSA,         ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM   },   /* TLS_RSA_WITH_AES_256_CCM */",0
"    {0xC09E,KEX_DHE_RSA,     ENC_AES,         4,128,128,DIG_NA,     MODE_CCM   },   /* TLS_DHE_RSA_WITH_AES_128_CCM */",0
"    {0xC09F,KEX_DHE_RSA,     ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM   },   /* TLS_DHE_RSA_WITH_AES_256_CCM */",0
"    {0xC0A0,KEX_RSA,         ENC_AES,         4,128,128,DIG_NA,     MODE_CCM_8 },   /* TLS_RSA_WITH_AES_128_CCM_8 */",0
"    {0xC0A1,KEX_RSA,         ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM_8 },   /* TLS_RSA_WITH_AES_256_CCM_8 */",0
"    {0xC0A2,KEX_DHE_RSA,     ENC_AES,         4,128,128,DIG_NA,     MODE_CCM_8 },   /* TLS_DHE_RSA_WITH_AES_128_CCM_8 */",0
"    {0xC0A3,KEX_DHE_RSA,     ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM_8 },   /* TLS_DHE_RSA_WITH_AES_256_CCM_8 */",0
"    {0xC0A4,KEX_PSK,         ENC_AES,         4,128,128,DIG_NA,     MODE_CCM   },   /* TLS_PSK_WITH_AES_128_CCM */",0
"    {0xC0A5,KEX_PSK,         ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM   },   /* TLS_PSK_WITH_AES_256_CCM */",0
"    {0xC0A6,KEX_DHE_PSK,     ENC_AES,         4,128,128,DIG_NA,     MODE_CCM   },   /* TLS_DHE_PSK_WITH_AES_128_CCM */",0
"    {0xC0A7,KEX_DHE_PSK,     ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM   },   /* TLS_DHE_PSK_WITH_AES_256_CCM */",0
"    {0xC0A8,KEX_PSK,         ENC_AES,         4,128,128,DIG_NA,     MODE_CCM_8 },   /* TLS_PSK_WITH_AES_128_CCM_8 */",0
"    {0xC0A9,KEX_PSK,         ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM_8 },   /* TLS_PSK_WITH_AES_256_CCM_8 */",0
"    {0xC0AA,KEX_DHE_PSK,     ENC_AES,         4,128,128,DIG_NA,     MODE_CCM_8 },   /* TLS_PSK_DHE_WITH_AES_128_CCM_8 */",0
"    {0xC0AB,KEX_DHE_PSK,     ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM_8 },   /* TLS_PSK_DHE_WITH_AES_256_CCM_8 */",0
"    {0xC0AC,KEX_ECDHE_ECDSA, ENC_AES,         4,128,128,DIG_NA,     MODE_CCM   },   /* TLS_ECDHE_ECDSA_WITH_AES_128_CCM */",0
"    {0xC0AD,KEX_ECDHE_ECDSA, ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM   },   /* TLS_ECDHE_ECDSA_WITH_AES_256_CCM */",0
"    {0xC0AE,KEX_ECDHE_ECDSA, ENC_AES,         4,128,128,DIG_NA,     MODE_CCM_8 },   /* TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 */",0
"    {0xC0AF,KEX_ECDHE_ECDSA, ENC_AES256,      4,256,256,DIG_NA,     MODE_CCM_8 },   /* TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 */",0
"    {-1,    0,          0,               0,  0,  0,0,          MODE_STREAM}",0
#define MAX_BLOCK_SIZE 16,0
#define MAX_KEY_SIZE 32,0
const SslCipherSuite *,0
ssl_find_cipher(int num),0
    const SslCipherSuite *c_,0
    for(c=cipher_suites_c->number!=-1_c++){,0
        if(c->number==num){,0
            return c_,0
"    ssl_debug_printf(""ssl_find_cipher: dummy without gnutls. num %d\n"",",0
        num)_,0
"/* Digests, Ciphers and Cipher Suites registry }}} */",0
/* HMAC and the Pseudorandom function {{{ */,0
"tls_hash(StringInfo *secret, StringInfo *seed, gint md,",0
"         StringInfo *out, guint out_len)",0
    /* RFC 2246 5. HMAC and the pseudorandom function,0
     * '+' denotes concatenation.,0
"     * P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +",0
"     *                        HMAC_hash(secret, A(2) + seed) + ...",0
     * A(0) = seed,0
"     * A(i) = HMAC_hash(secret, A(i - 1))",0
    guint8   *ptr_,0
"    guint     left, tocpy_",0
    guint8   *A_,0
"    guint8    _A[DIGEST_MAX_SIZE], tmp[DIGEST_MAX_SIZE]_",0
"    guint     A_l, tmp_l_",0
    SSL_HMAC  hm_,0
    ptr  = out->data_,0
    left = out_len_,0
"    ssl_print_string(""tls_hash: hash secret"", secret)_",0
"    ssl_print_string(""tls_hash: hash seed"", seed)_",0
    /* A(0) = seed */,0
    A = seed->data_,0
    A_l = seed->data_len_,0
    while (left) {,0
"        /* A(i) = HMAC_hash(secret, A(i-1)) */",0
"        ssl_hmac_init(&hm, secret->data, secret->data_len, md)_",0
"        ssl_hmac_update(&hm, A, A_l)_",0
        A_l = sizeof(_A)_ /* upper bound len for hash output */,0
"        ssl_hmac_final(&hm, _A, &A_l)_",0
        ssl_hmac_cleanup(&hm)_,0
        A = _A_,0
"        /* HMAC_hash(secret, A(i) + seed) */",0
"        ssl_hmac_update(&hm, seed->data, seed->data_len)_",0
        tmp_l = sizeof(tmp)_ /* upper bound len for hash output */,0
"        ssl_hmac_final(&hm, tmp, &tmp_l)_",0
        /* ssl_hmac_final puts the actual digest output size in tmp_l */,0
"        tocpy = MIN(left, tmp_l)_",0
"        memcpy(ptr, tmp, tocpy)_",0
        ptr += tocpy_,0
        left -= tocpy_,0
    out->data_len = out_len_,0
"    ssl_print_string(""hash out"", out)_",0
"tls_prf(StringInfo* secret, const gchar *usage,",0
"        StringInfo* rnd1, StringInfo* rnd2, StringInfo* out, guint out_len)",0
"    StringInfo  seed, sha_out, md5_out_",0
    guint8     *ptr_,0
"    StringInfo  s1, s2_",0
"    guint       i,s_l_",0
"    size_t      usage_len, rnd2_len_",0
    gboolean    success = FALSE_,0
    usage_len = strlen(usage)_,0
    rnd2_len = rnd2 ? rnd2->data_len : 0_,0
"    /* initalize buffer for sha, md5 random seed*/",0
"    if (ssl_data_alloc(&sha_out, MAX(out_len, 20)) < 0) {",0
"        ssl_debug_printf(""tls_prf: can't allocate sha out\n"")_",0
"    if (ssl_data_alloc(&md5_out, MAX(out_len, 16)) < 0) {",0
"        ssl_debug_printf(""tls_prf: can't allocate md5 out\n"")_",0
        goto free_sha_,0
"    if (ssl_data_alloc(&seed, usage_len+rnd1->data_len+rnd2_len) < 0) {",0
"        ssl_debug_printf(""tls_prf: can't allocate rnd %d\n"",",0
                         (int) (usage_len+rnd1->data_len+rnd2_len))_,0
        goto free_md5_,0
    ptr=seed.data_,0
"    memcpy(ptr,usage,usage_len)_",0
    ptr+=usage_len_,0
"    memcpy(ptr,rnd1->data,rnd1->data_len)_",0
    if (rnd2_len > 0) {,0
        ptr+=rnd1->data_len_,0
"        memcpy(ptr,rnd2->data,rnd2->data_len)_",0
        /*ptr+=rnd2->data_len_*/,0
    /* initalize buffer for client/server seeds*/,0
    s_l=secret->data_len/2 + secret->data_len%2_,0
"    if (ssl_data_alloc(&s1, s_l) < 0) {",0
"        ssl_debug_printf(""tls_prf: can't allocate secret %d\n"", s_l)_",0
        goto free_seed_,0
"    if (ssl_data_alloc(&s2, s_l) < 0) {",0
"        ssl_debug_printf(""tls_prf: can't allocate secret(2) %d\n"", s_l)_",0
        goto free_s1_,0
"    memcpy(s1.data,secret->data,s_l)_",0
"    memcpy(s2.data,secret->data + (secret->data_len - s_l),s_l)_",0
"    ssl_debug_printf(""tls_prf: tls_hash(md5 secret_len %d seed_len %d )\n"", s1.data_len, seed.data_len)_",0
"    tls_hash(&s1, &seed, ssl_get_digest_by_name(""MD5""), &md5_out, out_len)_",0
"    ssl_debug_printf(""tls_prf: tls_hash(sha)\n"")_",0
"    tls_hash(&s2, &seed, ssl_get_digest_by_name(""SHA1""), &sha_out, out_len)_",0
    for (i = 0_ i < out_len_ i++),0
        out->data[i] = md5_out.data[i] ^ sha_out.data[i]_,0
"    /* success, now store the new meaningful data length */",0
    success = TRUE_,0
"    ssl_print_string(""PRF out"",out)_",0
    g_free(s2.data)_,0
free_s1:,0
    g_free(s1.data)_,0
free_seed:,0
    g_free(seed.data)_,0
free_md5:,0
    g_free(md5_out.data)_,0
free_sha:,0
    g_free(sha_out.data)_,0
    return success_,0
"tls12_prf(gint md, StringInfo* secret, const gchar* usage,",0
"          StringInfo* rnd1, StringInfo* rnd2, StringInfo* out, guint out_len)",0
    StringInfo label_seed_,0
"    size_t     usage_len, rnd2_len_",0
"    if (ssl_data_alloc(&label_seed, usage_len+rnd1->data_len+rnd2_len) < 0) {",0
"        ssl_debug_printf(""tls12_prf: can't allocate label_seed\n"")_",0
"    memcpy(label_seed.data, usage, usage_len)_",0
"    memcpy(label_seed.data+usage_len, rnd1->data, rnd1->data_len)_",0
    if (rnd2_len > 0),0
"        memcpy(label_seed.data+usage_len+rnd1->data_len, rnd2->data, rnd2->data_len)_",0
"    ssl_debug_printf(""tls12_prf: tls_hash(hash_alg %s secret_len %d seed_len %d )\n"", gcry_md_algo_name(md), secret->data_len, label_seed.data_len)_",0
"    tls_hash(secret, &label_seed, md, out, out_len)_",0
    g_free(label_seed.data)_,0
"    ssl_print_string(""PRF out"", out)_",0
"ssl3_generate_export_iv(StringInfo *r1, StringInfo *r2,",0
"                        StringInfo *out, guint out_len)",0
    SSL_MD5_CTX md5_,0
    guint8      tmp[16]_,0
    ssl_md5_init(&md5)_,0
"    ssl_md5_update(&md5,r1->data,r1->data_len)_",0
"    ssl_md5_update(&md5,r2->data,r2->data_len)_",0
"    ssl_md5_final(tmp,&md5)_",0
    ssl_md5_cleanup(&md5)_,0
    DISSECTOR_ASSERT(out_len <= sizeof(tmp))_,0
"    ssl_data_set(out, tmp, out_len)_",0
"    ssl_print_string(""export iv"", out)_",0
"ssl3_prf(StringInfo* secret, const gchar* usage,",0
"         StringInfo* rnd1, StringInfo* rnd2, StringInfo* out, guint out_len)",0
    SSL_MD5_CTX  md5_,0
    SSL_SHA_CTX  sha_,0
    guint        off_,0
"    gint         i = 0,j_",0
    guint8       buf[20]_,0
    for (off = 0_ off < out_len_ off += 16) {,0
        guchar outbuf[16]_,0
"        ssl_debug_printf(""ssl3_prf: sha1_hash(%d)\n"",i)_",0
"        /* A, BB, CCC,  ... */",0
        for(j=0_j<i_j++){,0
            buf[j]=64+i_,0
        ssl_sha_init(&sha)_,0
"        ssl_sha_update(&sha,buf,i)_",0
"        ssl_sha_update(&sha,secret->data,secret->data_len)_",0
"        if(!strcmp(usage,""client write key"") || !strcmp(usage,""server write key"")){",0
            if (rnd2),0
"                ssl_sha_update(&sha,rnd2->data,rnd2->data_len)_",0
"            ssl_sha_update(&sha,rnd1->data,rnd1->data_len)_",0
        else{,0
"        ssl_sha_final(buf,&sha)_",0
        ssl_sha_cleanup(&sha)_,0
"        ssl_debug_printf(""ssl3_prf: md5_hash(%d) datalen %d\n"",i,",0
            secret->data_len)_,0
        ssl_md5_init(&md5)_,0
"        ssl_md5_update(&md5,secret->data,secret->data_len)_",0
"        ssl_md5_update(&md5,buf,20)_",0
"        ssl_md5_final(outbuf,&md5)_",0
        ssl_md5_cleanup(&md5)_,0
"        memcpy(out->data + off, outbuf, MIN(out_len - off, 16))_",0
/* out_len is the wanted output length for the pseudorandom function.,0
 * Ensure that ssl->cipher_suite is set. */,0
"prf(SslDecryptSession *ssl, StringInfo *secret, const gchar *usage,",0
"    StringInfo *rnd1, StringInfo *rnd2, StringInfo *out, guint out_len)",0
    switch (ssl->session.version) {,0
    case SSLV3_VERSION:,0
"        return ssl3_prf(secret, usage, rnd1, rnd2, out, out_len)_",0
    case TLSV1_VERSION:,0
    case TLSV1DOT1_VERSION:,0
    case DTLSV1DOT0_VERSION:,0
    case DTLSV1DOT0_OPENSSL_VERSION:,0
"        return tls_prf(secret, usage, rnd1, rnd2, out, out_len)_",0
    default: /* TLSv1.2 */,0
        switch (ssl->cipher_suite->dig) {,0
        case DIG_SHA384:,0
"            return tls12_prf(GCRY_MD_SHA384, secret, usage, rnd1, rnd2,",0
"                             out, out_len)_",0
"            return tls12_prf(GCRY_MD_SHA256, secret, usage, rnd1, rnd2,",0
"static gint tls_handshake_hash(SslDecryptSession* ssl, StringInfo* out)",0
"    if (ssl_data_alloc(out, 36) < 0)",0
"    ssl_md5_update(&md5,ssl->handshake_data.data,ssl->handshake_data.data_len)_",0
"    ssl_md5_final(out->data,&md5)_",0
    ssl_sha_init(&sha)_,0
"    ssl_sha_update(&sha,ssl->handshake_data.data,ssl->handshake_data.data_len)_",0
"    ssl_sha_final(out->data+16,&sha)_",0
    ssl_sha_cleanup(&sha)_,0
"static gint tls12_handshake_hash(SslDecryptSession* ssl, gint md, StringInfo* out)",0
    SSL_MD  mc_,0
    guint8 tmp[48]_,0
    guint  len_,0
"    ssl_md_init(&mc, md)_",0
"    ssl_md_update(&mc,ssl->handshake_data.data,ssl->handshake_data.data_len)_",0
"    ssl_md_final(&mc, tmp, &len)_",0
    ssl_md_cleanup(&mc)_,0
"    if (ssl_data_alloc(out, len) < 0)",0
"    memcpy(out->data, tmp, len)_",0
/* HMAC and the Pseudorandom function }}} */,0
/* Stub code when decryption support is not available. {{{ */,0
"ssl_generate_pre_master_secret(SslDecryptSession *ssl_session _U_,",0
"        guint32 length _U_, tvbuff_t *tvb _U_, guint32 offset _U_,",0
"        const gchar *ssl_psk _U_, const ssl_master_key_map_t *mk_map _U_)",0
"    ssl_debug_printf(""%s: impossible without gnutls.\n"", G_STRFUNC)_",0
ssl_generate_keyring_material(SslDecryptSession*ssl),0
"    ssl_debug_printf(""ssl_generate_keyring_material: impossible without gnutls. ssl %p\n"",",0
        ssl)_,0
    /* We cannot determine whether the cipher suite is valid. Fail such that,0
     * ssl_set_master_secret bails out. */,0
"ssl_change_cipher(SslDecryptSession *ssl_session, gboolean server)",0
"    ssl_debug_printf(""ssl_change_cipher %s: makes no sense without gnutls. ssl %p\n"",",0
"        (server)?""SERVER"":""CLIENT"", ssl_session)_",0
"ssl_decrypt_record(SslDecryptSession*ssl, SslDecoder* decoder, gint ct,",0
"        const guchar* in, guint inl, StringInfo* comp_str _U_, StringInfo* out, guint* outl)",0
"    ssl_debug_printf(""ssl_decrypt_record: impossible without gnutls. ssl %p""",0
"        ""decoder %p ct %d, in %p inl %d out %p outl %p\n"", ssl, decoder, ct,",0
"        in, inl, out, outl)_",0
/* }}} */,0
/* Record Decompression (after decryption) {{{ */,0
/* memory allocation functions for zlib initialization */,0
"static void* ssl_zalloc(void* opaque _U_, unsigned int no, unsigned int size)",0
    return g_malloc0(no*size)_,0
"static void ssl_zfree(void* opaque _U_, void* addr)",0
    g_free(addr)_,0
static SslDecompress*,0
ssl_create_decompressor(gint compression),0
    SslDecompress *decomp_,0
    int err_,0
    if (compression == 0) return NULL_,0
"    ssl_debug_printf(""ssl_create_decompressor: compression method %d\n"", compression)_",0
"    decomp = (SslDecompress *)wmem_alloc(wmem_file_scope(), sizeof(SslDecompress))_",0
    decomp->compression = compression_,0
    switch (decomp->compression) {,0
        case 1:  /* DEFLATE */,0
            decomp->istream.zalloc = ssl_zalloc_,0
            decomp->istream.zfree = ssl_zfree_,0
            decomp->istream.opaque = Z_NULL_,0
            decomp->istream.next_in = Z_NULL_,0
            decomp->istream.next_out = Z_NULL_,0
            decomp->istream.avail_in = 0_,0
            decomp->istream.avail_out = 0_,0
"            err = inflateInit_(&decomp->istream, ZLIB_VERSION, sizeof(z_stream))_",0
            if (err != Z_OK) {,0
"                ssl_debug_printf(""ssl_create_decompressor: inflateInit_() failed - %d\n"", err)_",0
"            ssl_debug_printf(""ssl_create_decompressor: unsupported compression method %d\n"", decomp->compression)_",0
    return decomp_,0
"ssl_decompress_record(SslDecompress* decomp, const guchar* in, guint inl, StringInfo* out_str, guint* outl)",0
            err = Z_OK_,0
            if (out_str->data_len < 16384) {  /* maximal plain length */,0
"                ssl_data_realloc(out_str, 16384)_",0
#ifdef z_const,0
            decomp->istream.next_in = in_,0
DIAG_OFF(cast-qual),0
            decomp->istream.next_in = (Bytef *)in_,0
DIAG_ON(cast-qual),0
            decomp->istream.avail_in = inl_,0
            decomp->istream.next_out = out_str->data_,0
            decomp->istream.avail_out = out_str->data_len_,0
            if (inl > 0),0
"                err = inflate(&decomp->istream, Z_SYNC_FLUSH)_",0
"                ssl_debug_printf(""ssl_decompress_record: inflate() failed - %d\n"", err)_",0
                return -1_,0
            *outl = out_str->data_len - decomp->istream.avail_out_,0
"            ssl_debug_printf(""ssl_decompress_record: unsupported compression method %d\n"", decomp->compression)_",0
            return -1_,0
"ssl_decompress_record(SslDecompress* decomp _U_, const guchar* in _U_, guint inl _U_, StringInfo* out_str _U_, guint* outl _U_)",0
"    ssl_debug_printf(""ssl_decompress_record: unsupported compression method %d\n"", decomp->compression)_",0
/* Record Decompression (after decryption) }}} */,0
#endif /* HAVE_LIBGCRYPT */,0
/* Create a new structure to store decrypted chunks. {{{ */,0
static SslFlow*,0
ssl_create_flow(void),0
  SslFlow *flow_,0
"  flow = (SslFlow *)wmem_alloc(wmem_file_scope(), sizeof(SslFlow))_",0
  flow->byte_seq = 0_,0
  flow->flags = 0_,0
  flow->multisegment_pdus = wmem_tree_new(wmem_file_scope())_,0
  return flow_,0
/* Use the negotiated security parameters for decryption. {{{ */,0
"    ssl_debug_printf(""ssl_change_cipher %s\n"", (server)?""SERVER"":""CLIENT"")_",0
    if (server) {,0
        ssl_session->server = ssl_session->server_new_,0
        ssl_session->server_new = NULL_,0
        ssl_session->client = ssl_session->client_new_,0
        ssl_session->client_new = NULL_,0
/* Init cipher state given some security parameters. {{{ */,0
static SslDecoder*,0
"ssl_create_decoder(const SslCipherSuite *cipher_suite, gint compression,",0
"        guint8 *mk, guint8 *sk, guint8 *iv)",0
    SslDecoder *dec_,0
    gint        ciph_,0
"    dec = (SslDecoder *)wmem_alloc0(wmem_file_scope(), sizeof(SslDecoder))_",0
    /* Find the SSLeay cipher */,0
    if(cipher_suite->enc!=ENC_NULL) {,0
"        ssl_debug_printf(""ssl_create_decoder CIPHER: %s\n"", ciphers[cipher_suite->enc-0x30])_",0
        ciph=ssl_get_cipher_by_name(ciphers[cipher_suite->enc-0x30])_,0
"        ssl_debug_printf(""ssl_create_decoder CIPHER: %s\n"", ""NULL"")_",0
        ciph = -1_,0
    if (ciph == 0) {,0
"        ssl_debug_printf(""ssl_create_decoder can't find cipher %s\n"",",0
            ciphers[cipher_suite->enc > ENC_NULL ? ENC_NULL-0x30 : (cipher_suite->enc-0x30)])_,0
    /* init mac buffer: mac storage is embedded into decoder struct to save a,0
     memory allocation and waste samo more memory*/,0
    dec->cipher_suite=cipher_suite_,0
    dec->compression = compression_,0
    /* AEED ciphers require a write IV (iv) and do not use MAC keys (mk).,0
"     * All other ciphers require a MAC key. As a special case, allow omission",0
     * for the NULL cipher such that record payloads can still be dissected. */,0
    if (mk != NULL) {,0
        dec->mac_key.data = dec->_mac_key_or_write_iv_,0
"        ssl_data_set(&dec->mac_key, mk, ssl_cipher_suite_dig(cipher_suite)->len)_",0
    } else if (iv != NULL) {,0
        dec->write_iv.data = dec->_mac_key_or_write_iv_,0
"        ssl_data_set(&dec->write_iv, iv, cipher_suite->block)_",0
        DISSECTOR_ASSERT(cipher_suite->enc == ENC_NULL)_,0
    dec->seq = 0_,0
    dec->decomp = ssl_create_decompressor(compression)_,0
    dec->flow = ssl_create_flow()_,0
    /* TODO this does nothing as dec->evp is always NULL. */,0
    if (dec->evp),0
        ssl_cipher_cleanup(&dec->evp)_,0
"    if (ssl_cipher_init(&dec->evp,ciph,sk,iv,cipher_suite->mode) < 0) {",0
"        ssl_debug_printf(""ssl_create_decoder: can't create cipher id:%d mode:%d\n"",",0
"            ciph, cipher_suite->mode)_",0
"    ssl_debug_printf(""decoder initialized (digest len %d)\n"", ssl_cipher_suite_dig(cipher_suite)->len)_",0
    return dec_,0
/* (Pre-)master secrets calculations {{{ */,0
"ssl_decrypt_pre_master_secret(SslDecryptSession *ssl_session,",0
"                              StringInfo *encrypted_pre_master,",0
                              gcry_sexp_t pk)_,0
"ssl_restore_master_key(SslDecryptSession *ssl, const char *label,",0
"                       gboolean is_pre_master, GHashTable *ht, StringInfo *key)_",0
"ssl_generate_pre_master_secret(SslDecryptSession *ssl_session,",0
"                               guint32 length, tvbuff_t *tvb, guint32 offset,",0
"                               const gchar *ssl_psk,",0
                               const ssl_master_key_map_t *mk_map),0
    /* check for required session data */,0
"    ssl_debug_printf(""%s: found SSL_HND_CLIENT_KEY_EXCHG, state %X\n"",",0
"                     G_STRFUNC, ssl_session->state)_",0
    if ((ssl_session->state & (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION)) !=,0
        (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION)) {,0
"        ssl_debug_printf(""%s: not enough data to generate key (required state %X)\n"", G_STRFUNC,",0
                         (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION))_,0
    /* check to see if the PMS was provided to us*/,0
"    if (ssl_restore_master_key(ssl_session, ""Unencrypted pre-master secret"", TRUE,",0
"           mk_map->pms, &ssl_session->client_random)) {",0
    if (ssl_session->cipher_suite->kex == KEX_PSK),0
        /* calculate pre master secret*/,0
        StringInfo pre_master_secret_,0
"        guint psk_len, pre_master_len_",0
        if (!ssl_psk || (ssl_psk[0] == 0)) {,0
"            ssl_debug_printf(""%s: can't find pre-shared-key\n"", G_STRFUNC)_",0
        /* convert hex string into char*/,0
"        if (!from_hex(&ssl_session->psk, ssl_psk, strlen(ssl_psk))) {",0
"            ssl_debug_printf(""%s: ssl.psk/dtls.psk contains invalid hex\n"",",0
                             G_STRFUNC)_,0
        psk_len = ssl_session->psk.data_len_,0
        if (psk_len >= (2 << 15)) {,0
"            ssl_debug_printf(""%s: ssl.psk/dtls.psk must not be larger than 2^15 - 1\n"",",0
        pre_master_len = psk_len * 2 + 4_,0
"        pre_master_secret.data = (guchar *)wmem_alloc(wmem_file_scope(), pre_master_len)_",0
        pre_master_secret.data_len = pre_master_len_,0
        /* 2 bytes psk_len*/,0
        pre_master_secret.data[0] = psk_len >> 8_,0
        pre_master_secret.data[1] = psk_len & 0xFF_,0
        /* psk_len bytes times 0*/,0
"        memset(&pre_master_secret.data[2], 0, psk_len)_",0
        pre_master_secret.data[psk_len + 2] = psk_len >> 8_,0
        pre_master_secret.data[psk_len + 3] = psk_len & 0xFF_,0
        /* psk*/,0
"        memcpy(&pre_master_secret.data[psk_len + 4], ssl_session->psk.data, psk_len)_",0
        ssl_session->pre_master_secret.data = pre_master_secret.data_,0
        ssl_session->pre_master_secret.data_len = pre_master_len_,0
"        /*ssl_debug_printf(""pre master secret"",&ssl->pre_master_secret)_*/",0
        /* Remove the master secret if it was there.,0
           This forces keying material regeneration in,0
           case we're renegotiating */,0
        ssl_session->state &= ~(SSL_MASTER_SECRET|SSL_HAVE_SESSION_KEY)_,0
        ssl_session->state |= SSL_PRE_MASTER_SECRET_,0
        StringInfo encrypted_pre_master_,0
"        guint encrlen, skip_",0
        encrlen = length_,0
        skip = 0_,0
"        /* get encrypted data, on tls1 we have to skip two bytes",0
         * (it's the encrypted len and should be equal to record len - 2),0
         * in case of rsa1024 that would be 128 + 2 = 130_ for psk not necessary,0
        if (ssl_session->cipher_suite->kex == KEX_RSA &&,0
           (ssl_session->session.version == TLSV1_VERSION ||,0
            ssl_session->session.version == TLSV1DOT1_VERSION ||,0
            ssl_session->session.version == TLSV1DOT2_VERSION ||,0
            ssl_session->session.version == DTLSV1DOT0_VERSION ||,0
            ssl_session->session.version == DTLSV1DOT2_VERSION)),0
"            encrlen  = tvb_get_ntohs(tvb, offset)_",0
            skip = 2_,0
            if (encrlen > length - 2),0
"                ssl_debug_printf(""%s: wrong encrypted length (%d max %d)\n"",",0
"                                 G_STRFUNC, encrlen, length)_",0
                return FALSE_,1
"        /* the valid lower bound is higher than 8, but it is sufficient for the",0
         * ssl keylog file below */,0
        if (encrlen < 8) {,0
"            ssl_debug_printf(""%s: invalid encrypted pre-master key length %d\n"",",0
"                             G_STRFUNC, encrlen)_",0
"        encrypted_pre_master.data = (guchar *)wmem_alloc(wmem_file_scope(), encrlen)_",0
        encrypted_pre_master.data_len = encrlen_,0
"        tvb_memcpy(tvb, encrypted_pre_master.data, offset+skip, encrlen)_",0
        if (ssl_session->private_key) {,0
            /* try to decrypt encrypted pre-master with RSA key */,0
"            if (ssl_decrypt_pre_master_secret(ssl_session,",0
"                &encrypted_pre_master, ssl_session->private_key))",0
                return TRUE_,0
"            ssl_debug_printf(""%s: can't decrypt pre-master secret\n"",",0
        /* try to find the pre-master secret from the encrypted one. The,0
"         * ssl key logfile stores only the first 8 bytes, so truncate it */",0
        encrypted_pre_master.data_len = 8_,0
"        if (ssl_restore_master_key(ssl_session, ""Encrypted pre-master secret"",",0
"            TRUE, mk_map->pre_master, &encrypted_pre_master))",0
ssl_generate_keyring_material(SslDecryptSession*ssl_session),0
"    StringInfo  key_block = { NULL, 0 }_",0
"    guint8      _iv_c[MAX_BLOCK_SIZE],_iv_s[MAX_BLOCK_SIZE]_",0
"    guint8      _key_c[MAX_KEY_SIZE],_key_s[MAX_KEY_SIZE]_",0
    gint        needed_,0
"    guint8     *ptr, *c_iv = _iv_c,*s_iv = _iv_s_",0
"    guint8     *c_wk = NULL, *s_wk = NULL, *c_mk = NULL, *s_mk = NULL_",0
    const SslCipherSuite *cipher_suite = ssl_session->cipher_suite_,0
    /* check for enough info to proced */,0
    guint need_all = SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION_,0
    guint need_any = SSL_MASTER_SECRET | SSL_PRE_MASTER_SECRET_,0
    if (((ssl_session->state & need_all) != need_all) || ((ssl_session->state & need_any) == 0)) {,0
"        ssl_debug_printf(""ssl_generate_keyring_material not enough data to generate key """,0
"                         ""(0x%02X required 0x%02X or 0x%02X)\n"", ssl_session->state,",0
"                         need_all|SSL_MASTER_SECRET, need_all|SSL_PRE_MASTER_SECRET)_",0
"        /* Special case: for NULL encryption, allow dissection of data even if",0
         * the Client Hello is missing (MAC keys are now skipped though). */,0
        need_all = SSL_CIPHER|SSL_VERSION_,0
        if ((ssl_session->state & need_all) == need_all &&,0
                cipher_suite->enc == ENC_NULL) {,0
"            ssl_debug_printf(""%s NULL cipher found, will create a decoder but """,0
"                    ""skip MAC validation as keys are missing.\n"", G_STRFUNC)_",0
            goto create_decoders_,0
"    /* if master key is not available, generate is from the pre-master secret */",0
    if (!(ssl_session->state & SSL_MASTER_SECRET)) {,0
        if ((ssl_session->state & SSL_EXTENDED_MASTER_SECRET_MASK) == SSL_EXTENDED_MASTER_SECRET_MASK) {,0
            StringInfo handshake_hashed_data_,0
            gint ret_,0
            handshake_hashed_data.data = NULL_,0
            handshake_hashed_data.data_len = 0_,0
"            ssl_debug_printf(""%s:PRF(pre_master_secret_extended)\n"", G_STRFUNC)_",0
"            ssl_print_string(""pre master secret"",&ssl_session->pre_master_secret)_",0
            DISSECTOR_ASSERT(ssl_session->handshake_data.data_len > 0)_,0
            switch(ssl_session->session.version) {,0
            case TLSV1_VERSION:,0
            case TLSV1DOT1_VERSION:,0
            case DTLSV1DOT0_VERSION:,0
            case DTLSV1DOT0_OPENSSL_VERSION:,0
"                ret = tls_handshake_hash(ssl_session, &handshake_hashed_data)_",0
                switch (cipher_suite->dig) {,0
                case DIG_SHA384:,0
"                    ret = tls12_handshake_hash(ssl_session, GCRY_MD_SHA384, &handshake_hashed_data)_",0
"                    ret = tls12_handshake_hash(ssl_session, GCRY_MD_SHA256, &handshake_hashed_data)_",0
            if (ret) {,0
"                ssl_debug_printf(""%s can't generate handshake hash\n"", G_STRFUNC)_",0
"            wmem_free(wmem_file_scope(), ssl_session->handshake_data.data)_",0
            ssl_session->handshake_data.data = NULL_,0
            ssl_session->handshake_data.data_len = 0_,0
"            if (!prf(ssl_session, &ssl_session->pre_master_secret, ""extended master secret"",",0
"                     &handshake_hashed_data,",0
"                     NULL, &ssl_session->master_secret,",0
                     SSL_MASTER_SECRET_LENGTH)) {,0
"                ssl_debug_printf(""%s can't generate master_secret\n"", G_STRFUNC)_",0
                g_free(handshake_hashed_data.data)_,0
            g_free(handshake_hashed_data.data)_,0
"            ssl_debug_printf(""%s:PRF(pre_master_secret)\n"", G_STRFUNC)_",0
"            ssl_print_string(""client random"",&ssl_session->client_random)_",0
"            ssl_print_string(""server random"",&ssl_session->server_random)_",0
"            if (!prf(ssl_session, &ssl_session->pre_master_secret, ""master secret"",",0
"                     &ssl_session->client_random,",0
"                     &ssl_session->server_random, &ssl_session->master_secret,",0
"        ssl_print_string(""master secret"",&ssl_session->master_secret)_",0
        /* the pre-master secret has been 'consumend' so we must clear it now */,0
        ssl_session->state &= ~SSL_PRE_MASTER_SECRET_,0
        ssl_session->state |= SSL_MASTER_SECRET_,0
    /* Compute the key block. First figure out how much data we need*/,0
    needed=ssl_cipher_suite_dig(cipher_suite)->len*2_,0
    needed+=cipher_suite->bits / 4_,0
    if(cipher_suite->block>1),0
        needed+=cipher_suite->block*2_,0
    key_block.data = (guchar *)g_malloc(needed)_,0
"    ssl_debug_printf(""%s sess key generation\n"", G_STRFUNC)_",0
"    if (!prf(ssl_session, &ssl_session->master_secret, ""key expansion"",",0
"            &ssl_session->server_random,&ssl_session->client_random,",0
"            &key_block, needed)) {",0
"        ssl_debug_printf(""%s can't generate key_block\n"", G_STRFUNC)_",0
        goto fail_,0
"    ssl_print_string(""key expansion"", &key_block)_",0
    ptr=key_block.data_,0
    /* AEAD ciphers do not have a separate MAC */,0
    if (cipher_suite->mode == MODE_GCM ||,0
        cipher_suite->mode == MODE_CCM ||,0
        cipher_suite->mode == MODE_CCM_8) {,0
        c_mk = s_mk = NULL_,0
        c_mk=ptr_ ptr+=ssl_cipher_suite_dig(cipher_suite)->len_,0
        s_mk=ptr_ ptr+=ssl_cipher_suite_dig(cipher_suite)->len_,0
    c_wk=ptr_ ptr+=cipher_suite->eff_bits/8_,0
    s_wk=ptr_ ptr+=cipher_suite->eff_bits/8_,0
    if(cipher_suite->block>1){,0
        c_iv=ptr_ ptr+=cipher_suite->block_,0
        s_iv=ptr_ /*ptr+=cipher_suite->block_*/,0
    /* export ciphers work with a smaller key length */,0
    if (cipher_suite->eff_bits < cipher_suite->bits) {,0
        if(cipher_suite->block>1){,0
"            /* We only have room for MAX_BLOCK_SIZE bytes IVs, but that's",0
             all we should need. This is a sanity check */,0
            if(cipher_suite->block>MAX_BLOCK_SIZE) {,0
"                ssl_debug_printf(""%s cipher suite block must be at most %d nut is %d\n"",",0
"                G_STRFUNC, MAX_BLOCK_SIZE, cipher_suite->block)_",0
                goto fail_,0
            if(ssl_session->session.version==SSLV3_VERSION){,0
                /* The length of these fields are ignored by this caller */,0
"                StringInfo iv_c, iv_s_",0
                iv_c.data = _iv_c_,0
                iv_s.data = _iv_s_,0
"                ssl_debug_printf(""%s ssl3_generate_export_iv\n"", G_STRFUNC)_",0
"                ssl3_generate_export_iv(&ssl_session->client_random,",0
"                        &ssl_session->server_random, &iv_c,",0
                        cipher_suite->block)_,0
"                ssl_debug_printf(""%s ssl3_generate_export_iv(2)\n"", G_STRFUNC)_",0
"                ssl3_generate_export_iv(&ssl_session->server_random,",0
"                        &ssl_session->client_random, &iv_s,",0
            else{,0
                guint8 _iv_block[MAX_BLOCK_SIZE * 2]_,0
                StringInfo iv_block_,0
                StringInfo key_null_,0
                guint8 _key_null_,0
                key_null.data = &_key_null_,0
                key_null.data_len = 0_,0
                iv_block.data = _iv_block_,0
"                ssl_debug_printf(""%s prf(iv_block)\n"", G_STRFUNC)_",0
"                if (!prf(ssl_session, &key_null, ""IV block"",",0
"                        &ssl_session->client_random,",0
"                        &ssl_session->server_random, &iv_block,",0
                        cipher_suite->block * 2)) {,0
"                    ssl_debug_printf(""%s can't generate tls31 iv block\n"", G_STRFUNC)_",0
                    goto fail_,0
"                memcpy(_iv_c,iv_block.data,cipher_suite->block)_",0
"                memcpy(_iv_s,iv_block.data+cipher_suite->block,",0
                    cipher_suite->block)_,0
            c_iv=_iv_c_,0
            s_iv=_iv_s_,0
        if (ssl_session->session.version==SSLV3_VERSION){,0
            SSL_MD5_CTX md5_,0
"            ssl_debug_printf(""%s MD5(client_random)\n"", G_STRFUNC)_",0
            ssl_md5_init(&md5)_,0
"            ssl_md5_update(&md5,c_wk,cipher_suite->eff_bits/8)_",0
"            ssl_md5_update(&md5,ssl_session->client_random.data,",0
                ssl_session->client_random.data_len)_,0
"            ssl_md5_update(&md5,ssl_session->server_random.data,",0
                ssl_session->server_random.data_len)_,0
"            ssl_md5_final(_key_c,&md5)_",0
            ssl_md5_cleanup(&md5)_,0
            c_wk=_key_c_,0
"            ssl_debug_printf(""%s MD5(server_random)\n"", G_STRFUNC)_",0
"            ssl_md5_update(&md5,s_wk,cipher_suite->eff_bits/8)_",0
"            ssl_md5_final(_key_s,&md5)_",0
            s_wk=_key_s_,0
"            StringInfo key_c, key_s, k_",0
            key_c.data = _key_c_,0
            key_s.data = _key_s_,0
            k.data = c_wk_,0
            k.data_len = cipher_suite->eff_bits/8_,0
"            ssl_debug_printf(""%s PRF(key_c)\n"", G_STRFUNC)_",0
"            if (!prf(ssl_session, &k, ""client write key"",",0
"                    &ssl_session->client_random,",0
"                    &ssl_session->server_random, &key_c, sizeof(_key_c))) {",0
"                ssl_debug_printf(""%s can't generate tll31 server key \n"", G_STRFUNC)_",0
            k.data = s_wk_,0
"            ssl_debug_printf(""%s PRF(key_s)\n"", G_STRFUNC)_",0
"            if (!prf(ssl_session, &k, ""server write key"",",0
"                    &ssl_session->server_random, &key_s, sizeof(_key_s))) {",0
"                ssl_debug_printf(""%s can't generate tll31 client key \n"", G_STRFUNC)_",0
    /* show key material info */,0
    if (c_mk != NULL) {,0
"        ssl_print_data(""Client MAC key"",c_mk,ssl_cipher_suite_dig(cipher_suite)->len)_",0
"        ssl_print_data(""Server MAC key"",s_mk,ssl_cipher_suite_dig(cipher_suite)->len)_",0
"    ssl_print_data(""Client Write key"",c_wk,cipher_suite->bits/8)_",0
"    ssl_print_data(""Server Write key"",s_wk,cipher_suite->bits/8)_",0
    if(cipher_suite->block>1) {,0
"        ssl_print_data(""Client Write IV"",c_iv,cipher_suite->block)_",0
"        ssl_print_data(""Server Write IV"",s_iv,cipher_suite->block)_",0
"        ssl_print_data(""Client Write IV"",c_iv,8)_",0
"        ssl_print_data(""Server Write IV"",s_iv,8)_",0
create_decoders:,0
    /* create both client and server ciphers*/,0
"    ssl_debug_printf(""%s ssl_create_decoder(client)\n"", G_STRFUNC)_",0
"    ssl_session->client_new = ssl_create_decoder(cipher_suite, ssl_session->session.compression, c_mk, c_wk, c_iv)_",0
    if (!ssl_session->client_new) {,0
"        ssl_debug_printf(""%s can't init client decoder\n"", G_STRFUNC)_",0
"    ssl_debug_printf(""%s ssl_create_decoder(server)\n"", G_STRFUNC)_",0
"    ssl_session->server_new = ssl_create_decoder(cipher_suite, ssl_session->session.compression, s_mk, s_wk, s_iv)_",0
    if (!ssl_session->server_new) {,0
"    ssl_debug_printf(""%s: client seq %d, server seq %d\n"",",0
"        G_STRFUNC, ssl_session->client_new->seq, ssl_session->server_new->seq)_",0
    g_free(key_block.data)_,0
    ssl_session->state |= SSL_HAVE_SESSION_KEY_,0
fail:,0
/* (Pre-)master secrets calculations }}} */,0
/* Decrypt RSA pre-master secret using RSA private key. {{{ */,0
"ssl_decrypt_pre_master_secret(SslDecryptSession*ssl_session,",0
"    StringInfo* encrypted_pre_master, gcry_sexp_t pk)",0
    if (!encrypted_pre_master),0
    if (KEX_IS_DH(ssl_session->cipher_suite->kex)) {,0
"        ssl_debug_printf(""%s: session uses Diffie-Hellman key exchange """,0
"                         ""(cipher suite 0x%04X %s) and cannot be decrypted """,0
"                         ""using a RSA private key file.\n"",",0
"                         G_STRFUNC, ssl_session->session.cipher,",0
"                         val_to_str_ext_const(ssl_session->session.cipher,",0
"                             &ssl_31_ciphersuite_ext, ""unknown""))_",0
    } else if(ssl_session->cipher_suite->kex != KEX_RSA) {,0
"         ssl_debug_printf(""%s key exchange %d different from KEX_RSA (%d)\n"",",0
"                          G_STRFUNC, ssl_session->cipher_suite->kex, KEX_RSA)_",0
"    /* with tls key loading will fail if not rsa type, so no need to check*/",0
"    ssl_print_string(""pre master encrypted"",encrypted_pre_master)_",0
"    ssl_debug_printf(""%s: RSA_private_decrypt\n"", G_STRFUNC)_",0
"    i=ssl_private_decrypt(encrypted_pre_master->data_len,",0
"        encrypted_pre_master->data, pk)_",0
    if (i!=48) {,0
"        ssl_debug_printf(""%s wrong pre_master_secret length (%d, expected """,0
"                         ""%d)\n"", G_STRFUNC, i, 48)_",0
    /* the decrypted data has been written into the pre_master key buffer */,0
    ssl_session->pre_master_secret.data = encrypted_pre_master->data_,0
    ssl_session->pre_master_secret.data_len=48_,0
"    ssl_print_string(""pre master secret"",&ssl_session->pre_master_secret)_",0
    /* Remove the master secret if it was there.,0
       This forces keying material regeneration in,0
       case we're renegotiating */,0
    ssl_session->state &= ~(SSL_MASTER_SECRET|SSL_HAVE_SESSION_KEY)_,0
    ssl_session->state |= SSL_PRE_MASTER_SECRET_,0
/* Decryption integrity check {{{ */,0
/* convert network byte order 32 byte number to right-aligned host byte order *,0
 * 8 bytes buffer */,0
"static gint fmt_seq(guint32 num, guint8* buf)",0
    guint32 netnum_,0
"    memset(buf,0,8)_",0
    netnum=g_htonl(num)_,0
"    memcpy(buf+4,&netnum,4)_",0
    return(0)_,0
"tls_check_mac(SslDecoder*decoder, gint ct, gint ver, guint8* data,",0
"        guint32 datalen, guint8* mac)",0
    SSL_HMAC hm_,0
    gint     md_,0
    guint32  len_,0
    guint8   buf[DIGEST_MAX_SIZE]_,0
    gint16   temp_,0
    md=ssl_get_digest_by_name(ssl_cipher_suite_dig(decoder->cipher_suite)->name)_,0
"    ssl_debug_printf(""tls_check_mac mac type:%s md %d\n"",",0
"        ssl_cipher_suite_dig(decoder->cipher_suite)->name, md)_",0
"    if (ssl_hmac_init(&hm,decoder->mac_key.data,decoder->mac_key.data_len,md) != 0)",0
    /* hash sequence number */,0
"    fmt_seq(decoder->seq,buf)_",0
    decoder->seq++_,0
"    ssl_hmac_update(&hm,buf,8)_",0
    /* hash content type */,0
    buf[0]=ct_,0
"    ssl_hmac_update(&hm,buf,1)_",0
"    /* hash version,data length and data*/",0
    /* *((gint16*)buf) = g_htons(ver)_ */,0
    temp = g_htons(ver)_,0
"    memcpy(buf, &temp, 2)_",0
"    ssl_hmac_update(&hm,buf,2)_",0
    /* *((gint16*)buf) = g_htons(datalen)_ */,0
    temp = g_htons(datalen)_,0
"    ssl_hmac_update(&hm,data,datalen)_",0
    /* get digest and digest len*/,0
    len = sizeof(buf)_,0
"    ssl_hmac_final(&hm,buf,&len)_",0
    ssl_hmac_cleanup(&hm)_,0
"    ssl_print_data(""Mac"", buf, len)_",0
"    if(memcmp(mac,buf,len))",0
"ssl3_check_mac(SslDecoder*decoder,int ct,guint8* data,",0
    gint    md_,0
    guint32 len_,0
"    guint8  buf[64],dgst[20]_",0
    gint    pad_ct_,0
    gint16  temp_,0
    pad_ct=(decoder->cipher_suite->dig==DIG_SHA)?40:48_,0
    /* get cipher used for digest comptuation */,0
"    if (ssl_md_init(&mc,md) !=0)",0
    /* do hash computation on data && padding */,0
"    ssl_md_update(&mc,decoder->mac_key.data,decoder->mac_key.data_len)_",0
    /* hash padding*/,0
"    memset(buf,0x36,pad_ct)_",0
"    ssl_md_update(&mc,buf,pad_ct)_",0
"    ssl_md_update(&mc,buf,8)_",0
"    ssl_md_update(&mc,buf,1)_",0
    /* hash data length in network byte order and data*/,0
    /* *((gint16* )buf) = g_htons(datalen)_ */,0
"    ssl_md_update(&mc,buf,2)_",0
"    ssl_md_update(&mc,data,datalen)_",0
    /* get partial digest */,0
"    ssl_md_final(&mc,dgst,&len)_",0
"    ssl_md_init(&mc,md)_",0
    /* hash mac key */,0
    /* hash padding and partial digest*/,0
"    memset(buf,0x5c,pad_ct)_",0
"    ssl_md_update(&mc,dgst,len)_",0
"    if(memcmp(mac,dgst,len))",0
"dtls_check_mac(SslDecoder*decoder, gint ct,int ver, guint8* data,",0
"    ssl_debug_printf(""dtls_check_mac mac type:%s md %d\n"",",0
"    ssl_debug_printf(""dtls_check_mac seq: %d epoch: %d\n"",decoder->seq,decoder->epoch)_",0
    buf[0]=decoder->epoch>>8_,0
    buf[1]=(guint8)decoder->epoch_,0
"    /* hash version,data length and data */",0
    /* get digest and digest len */,0
/* Decryption integrity check }}} */,0
/* Record decryption glue based on security parameters {{{ */,0
/* Assume that we are called only for a non-NULL decoder which also means that,0
 * we have a non-NULL decoder->cipher_suite. */,0
"ssl_decrypt_record(SslDecryptSession*ssl,SslDecoder* decoder, gint ct,",0
"        const guchar* in, guint inl, StringInfo* comp_str, StringInfo* out_str, guint* outl)",0
"    guint   pad, worklen, uncomplen_",0
    guint8 *mac_,0
"    ssl_debug_printf(""ssl_decrypt_record ciphertext len %d\n"", inl)_",0
"    ssl_print_data(""Ciphertext"",in, inl)_",0
    /* ensure we have enough storage space for decrypted data */,0
    if (inl > out_str->data_len),0
"        ssl_debug_printf(""ssl_decrypt_record: allocating %d bytes for decrypt data (old len %d)\n"",",0
"                inl + 32, out_str->data_len)_",0
"        ssl_data_realloc(out_str, inl + 32)_",0
    /* RFC 6101/2246: SSLCipherText/TLSCipherText has two structures for types:,0
"     * (notation: { unencrypted, [ encrypted ] })",0
"     * GenericStreamCipher: { [content, mac] }",0
"     * GenericBlockCipher: { IV (TLS 1.1+), [content, mac, padding, padding_len] }",0
     * RFC 5426 (TLS 1.2): TLSCipherText has additionally:,0
"     * GenericAEADCipher: { nonce_explicit, [content] }",0
"     * RFC 4347 (DTLS): based on TLS 1.1, only GenericBlockCipher is supported.",0
"     * RFC 6347 (DTLS 1.2): based on TLS 1.2, includes GenericAEADCipher too.",0
"    /* (TLS 1.1 and later, DTLS) Extract explicit IV for GenericBlockCipher */",0
    if (decoder->cipher_suite->mode == MODE_CBC) {,0
        switch (ssl->session.version) {,0
        case TLSV1DOT1_VERSION:,0
        case TLSV1DOT2_VERSION:,0
        case DTLSV1DOT0_VERSION:,0
        case DTLSV1DOT2_VERSION:,0
        case DTLSV1DOT0_OPENSSL_VERSION:,0
            if ((gint)inl < decoder->cipher_suite->block) {,0
"                ssl_debug_printf(""ssl_decrypt_record failed: input %d has no space for IV %d\n"",",0
"                        inl, decoder->cipher_suite->block)_",0
"            pad = gcry_cipher_setiv(decoder->evp, in, decoder->cipher_suite->block)_",0
            if (pad != 0) {,0
"                ssl_debug_printf(""ssl_decrypt_record failed: failed to set IV: %s %s\n"",",0
"                        gcry_strsource (pad), gcry_strerror (pad))_",0
            inl -= decoder->cipher_suite->block_,0
            in += decoder->cipher_suite->block_,0
    /* Nonce for GenericAEADCipher */,0
    if (decoder->cipher_suite->mode == MODE_GCM ||,0
        decoder->cipher_suite->mode == MODE_CCM ||,0
        decoder->cipher_suite->mode == MODE_CCM_8) {,0
"        /* 4 bytes write_iv, 8 bytes explicit_nonce, 4 bytes counter */",0
        guchar gcm_nonce[16] = { 0 }_,0
        if ((gint)inl < SSL_EX_NONCE_LEN_GCM) {,0
"            ssl_debug_printf(""ssl_decrypt_record failed: input %d has no space for nonce %d\n"",",0
"                inl, SSL_EX_NONCE_LEN_GCM)_",0
        if (decoder->cipher_suite->mode == MODE_GCM) {,0
"            memcpy(gcm_nonce, decoder->write_iv.data, decoder->write_iv.data_len)_ /* salt */",0
"            memcpy(gcm_nonce + decoder->write_iv.data_len, in, SSL_EX_NONCE_LEN_GCM)_",0
"            /* NIST SP 800-38D, sect. 7.2 says that the 32-bit counter part starts",0
"             * at 1, and gets incremented before passing to the block cipher. */",0
            gcm_nonce[4 + SSL_EX_NONCE_LEN_GCM + 3] = 2_,0
        } else { /* MODE_CCM and MODE_CCM_8 */,0
"            /* The nonce for CCM and GCM are the same, but the nonce is used as input",0
             * in the CCM algorithm described in RFC 3610. The nonce generated here is,0
             * the one from RFC 3610 sect 2.3. Encryption. */,0
            /* Flags: (L-1) _ L = 16 - 1 - nonceSize */,0
            gcm_nonce[0] = 3 - 1_,0
"            memcpy(gcm_nonce + 1, decoder->write_iv.data, decoder->write_iv.data_len)_ /* salt */",0
"            memcpy(gcm_nonce + 1 + decoder->write_iv.data_len, in, SSL_EX_NONCE_LEN_GCM)_",0
            gcm_nonce[4 + SSL_EX_NONCE_LEN_GCM + 3] = 1_,0
"        pad = gcry_cipher_setctr (decoder->evp, gcm_nonce, sizeof (gcm_nonce))_",0
        if (pad != 0) {,0
"            ssl_debug_printf(""ssl_decrypt_record failed: failed to set CTR: %s %s\n"",",0
"                    gcry_strsource (pad), gcry_strerror (pad))_",0
        inl -= SSL_EX_NONCE_LEN_GCM_,0
        in += SSL_EX_NONCE_LEN_GCM_,0
    /* First decrypt*/,0
"    if ((pad = ssl_cipher_decrypt(&decoder->evp, out_str->data, out_str->data_len, in, inl))!= 0) {",0
"        ssl_debug_printf(""ssl_decrypt_record failed: ssl_cipher_decrypt: %s %s\n"", gcry_strsource (pad),",0
                    gcry_strerror (pad))_,0
"    ssl_print_data(""Plaintext"", out_str->data, inl)_",0
    worklen=inl_,0
    /* RFC 5116 sect 5.1/5.3: AES128/256 GCM/CCM uses 16 bytes for auth tag,0
     * RFC 6655 sect 6.1: AEAD_AES_128_CCM uses 16 bytes for auth tag */,0
        decoder->cipher_suite->mode == MODE_CCM) {,0
        if (worklen < 16) {,0
"            ssl_debug_printf(""ssl_decrypt_record failed: missing tag, work %d\n"", worklen)_",0
        /* XXX - validate auth tag */,0
        worklen -= 16_,0
    /* RFC 6655 sect 6.1: AEAD_AES_128_CCM_8 uses 8 bytes for auth tag */,0
    if (decoder->cipher_suite->mode == MODE_CCM_8) {,0
        if (worklen < 8) {,0
        worklen -= 8_,0
    /* strip padding for GenericBlockCipher */,0
        if (inl < 1) { /* Should this check happen earlier? */,0
"            ssl_debug_printf(""ssl_decrypt_record failed: input length %d too small\n"", inl)_",0
        pad=out_str->data[inl-1]_,0
        if (worklen <= pad) {,0
"            ssl_debug_printf(""ssl_decrypt_record failed: padding %d too large for work %d\n"",",0
"                pad, worklen)_",0
        worklen-=(pad+1)_,0
"        ssl_debug_printf(""ssl_decrypt_record found padding %d final len %d\n"",",0
"            pad, worklen)_",0
    /* MAC for GenericStreamCipher and GenericBlockCipher */,0
    if (decoder->cipher_suite->mode == MODE_STREAM ||,0
        decoder->cipher_suite->mode == MODE_CBC) {,0
        if (ssl_cipher_suite_dig(decoder->cipher_suite)->len > (gint)worklen) {,0
"            ssl_debug_printf(""ssl_decrypt_record wrong record len/padding outlen %d\n work %d\n"",*outl, worklen)_",0
        worklen-=ssl_cipher_suite_dig(decoder->cipher_suite)->len_,0
        mac = out_str->data + worklen_,0
    } else /* if (decoder->cipher_suite->mode == MODE_GCM) */ {,0
        /* GenericAEADCipher has no MAC */,0
        goto skip_mac_,0
"    /* If NULL encryption active and no keys are available, do not bother",0
     * checking the MAC. We do not have keys for that. */,0
    if (decoder->cipher_suite->mode == MODE_STREAM &&,0
            decoder->cipher_suite->enc == ENC_NULL &&,0
            !(ssl->state & SSL_MASTER_SECRET)) {,0
"        ssl_debug_printf(""MAC check skipped due to missing keys\n"")_",0
    /* Now check the MAC */,0
"    ssl_debug_printf(""checking mac (len %d, version %X, ct %d seq %d)\n"",",0
"        worklen, ssl->session.version, ct, decoder->seq)_",0
    if(ssl->session.version==SSLV3_VERSION){,0
"        if(ssl3_check_mac(decoder,ct,out_str->data,worklen,mac) < 0) {",0
            if(ssl_ignore_mac_failed) {,0
"                ssl_debug_printf(""ssl_decrypt_record: mac failed, but ignored for troubleshooting _-)\n"")_",0
"                ssl_debug_printf(""ssl_decrypt_record: mac failed\n"")_",0
"            ssl_debug_printf(""ssl_decrypt_record: mac ok\n"")_",0
    else if(ssl->session.version==TLSV1_VERSION || ssl->session.version==TLSV1DOT1_VERSION || ssl->session.version==TLSV1DOT2_VERSION){,0
"        if(tls_check_mac(decoder,ct,ssl->session.version,out_str->data,worklen,mac)< 0) {",0
    else if(ssl->session.version==DTLSV1DOT0_VERSION ||,0
        ssl->session.version==DTLSV1DOT2_VERSION ||,0
        ssl->session.version==DTLSV1DOT0_OPENSSL_VERSION){,0
"        /* Try rfc-compliant mac first, and if failed, try old openssl's non-rfc-compliant mac */",0
"        if(dtls_check_mac(decoder,ct,ssl->session.version,out_str->data,worklen,mac)>= 0) {",0
"        else if(tls_check_mac(decoder,ct,TLSV1_VERSION,out_str->data,worklen,mac)>= 0) {",0
"            ssl_debug_printf(""ssl_decrypt_record: dtls rfc-compliant mac failed, but old openssl's non-rfc-compliant mac ok\n"")_",0
        else if(ssl_ignore_mac_failed) {,0
"            ssl_debug_printf(""ssl_decrypt_record: mac failed, but ignored for troubleshooting _-)\n"")_",0
"            ssl_debug_printf(""ssl_decrypt_record: mac failed\n"")_",0
skip_mac:,0
    *outl = worklen_,0
    if (decoder->compression > 0) {,0
"        ssl_debug_printf(""ssl_decrypt_record: compression method %d\n"", decoder->compression)_",0
"        ssl_data_copy(comp_str, out_str)_",0
"        ssl_print_data(""Plaintext compressed"", comp_str->data, worklen)_",0
        if (!decoder->decomp) {,0
"            ssl_debug_printf(""decrypt_ssl3_record: no decoder available\n"")_",0
"        if (ssl_decompress_record(decoder->decomp, comp_str->data, worklen, out_str, &uncomplen) < 0) return -1_",0
"        ssl_print_data(""Plaintext uncompressed"", out_str->data, uncomplen)_",0
        *outl = uncomplen_,0
/* Record decryption glue based on security parameters }}} */,0
/* RSA private key file processing {{{ */,0
#define RSA_PARS 6,0
static gcry_sexp_t,0
ssl_privkey_to_sexp(gnutls_x509_privkey_t priv_key),0
"    gnutls_datum_t rsa_datum[RSA_PARS]_ /* m, e, d, p, q, u */",0
    size_t         tmp_size_,0
    gcry_error_t   gret_,0
    gcry_sexp_t    rsa_priv_key = NULL_,0
    gint           i_,0
    gcry_mpi_t     rsa_params[RSA_PARS]_,0
    /* RSA get parameter */,0
"    if (gnutls_x509_privkey_export_rsa_raw(priv_key,",0
"                                           &rsa_datum[0],",0
"                                           &rsa_datum[1],",0
"                                           &rsa_datum[2],",0
"                                           &rsa_datum[3],",0
"                                           &rsa_datum[4],",0
                                           &rsa_datum[5])  != 0) {,0
"        ssl_debug_printf(""ssl_load_key: can't export rsa param (is a rsa private key file ?!?)\n"")_",0
    /* convert each rsa parameter to mpi format*/,0
    for(i=0_ i<RSA_PARS_ i++) {,0
"      gret = gcry_mpi_scan(&rsa_params[i], GCRYMPI_FMT_USG, rsa_datum[i].data, rsa_datum[i].size,&tmp_size)_",0
      /* these buffers were allocated by gnutls_x509_privkey_export_rsa_raw() */,0
      g_free(rsa_datum[i].data)_,0
      if (gret != 0) {,0
"        ssl_debug_printf(""ssl_load_key: can't convert m rsa param to int (size %d)\n"", rsa_datum[i].size)_",0
"    /* libgcrypt expects p < q, and gnutls might not return it as such, depending on gnutls version and its crypto backend */",0
"    if (gcry_mpi_cmp(rsa_params[3], rsa_params[4]) > 0)",0
"        ssl_debug_printf(""ssl_load_key: swapping p and q parameters and recomputing u\n"")_",0
"        /* p, q = q, p */",0
"        gcry_mpi_swap(rsa_params[3], rsa_params[4])_",0
"        /* due to swapping p and q, u = p^-1 mod p which happens to be needed. */",0
"    /* libgcrypt expects u = p^-1 mod q (for OpenPGP), but the u parameter",0
     * says u = q^-1 mod p. Recompute u = p^-1 mod q. Do this unconditionally as,0
     * at least GnuTLS 2.12.23 computes an invalid value. */,0
"    gcry_mpi_invm(rsa_params[5], rsa_params[3], rsa_params[4])_",0
"    if  (gcry_sexp_build( &rsa_priv_key, NULL,",0
"            ""(private-key(rsa((n%m)(e%m)(d%m)(p%m)(q%m)(u%m))))"", rsa_params[0],",0
"            rsa_params[1], rsa_params[2], rsa_params[3], rsa_params[4],",0
            rsa_params[5]) != 0) {,0
"        ssl_debug_printf(""ssl_load_key: can't build rsa private key s-exp\n"")_",0
    for (i=0_ i< 6_ i++),0
        gcry_mpi_release(rsa_params[i])_,0
    return rsa_priv_key_,0
/** Load an RSA private key from specified file,0
 @param fp the file that contain the key data,0
" @return a pointer to the loaded key on success, or NULL */",0
static gnutls_x509_privkey_t,0
ssl_load_key(FILE* fp),0
"    /* gnutls makes our work much harder, since we have to work internally with",0
"     * s-exp formatted data, but PEM loader exports only in ""gnutls_datum_t""",0
"     * format, and a datum -> s-exp convertion function does not exist.",0
    gnutls_x509_privkey_t priv_key_,0
    gnutls_datum_t        key_,0
    ws_statb64            statbuf_,0
    gint                  ret_,0
    guint                 bytes_,0
"    if (ws_fstat64(ws_fileno(fp), &statbuf) == -1) {",0
"        ssl_debug_printf(""ssl_load_key: can't ws_fstat64 file\n"")_",0
    if (S_ISDIR(statbuf.st_mode)) {,0
"        ssl_debug_printf(""ssl_load_key: file is a directory\n"")_",0
        errno = EISDIR_,0
    if (S_ISFIFO(statbuf.st_mode)) {,0
"        ssl_debug_printf(""ssl_load_key: file is a named pipe\n"")_",0
        errno = EINVAL_,0
    if (!S_ISREG(statbuf.st_mode)) {,0
"        ssl_debug_printf(""ssl_load_key: file is not a regular file\n"")_",0
    /* XXX - check for a too-big size */,0
    /* load all file contents into a datum buffer*/,0
    key.data = (unsigned char *)g_malloc((size_t)statbuf.st_size)_,0
    key.size = (int)statbuf.st_size_,0
"    bytes = (guint) fread(key.data, 1, key.size, fp)_",0
    if (bytes < key.size) {,0
"        ssl_debug_printf(""ssl_load_key: can't read from file %d bytes, got %d\n"",",0
"            key.size, bytes)_",0
        g_free(key.data)_,0
    /* init private key data*/,0
    gnutls_x509_privkey_init(&priv_key)_,0
    /* import PEM data*/,0
"    if ((ret = gnutls_x509_privkey_import(priv_key, &key, GNUTLS_X509_FMT_PEM)) != GNUTLS_E_SUCCESS) {",0
"        ssl_debug_printf(""ssl_load_key: can't import pem data: %s\n"", gnutls_strerror(ret))_",0
    if (gnutls_x509_privkey_get_pk_algorithm(priv_key) != GNUTLS_PK_RSA) {,0
"        ssl_debug_printf(""ssl_load_key: private key public key algorithm isn't RSA\n"")_",0
    g_free(key.data)_,0
    return priv_key_,0
BAGTYPE(gnutls_pkcs12_bag_type_t x) {,0
    switch (x) {,0
"        case GNUTLS_BAG_EMPTY:               return ""Empty""_",0
"        case GNUTLS_BAG_PKCS8_ENCRYPTED_KEY: return ""PKCS#8 Encrypted key""_",0
"        case GNUTLS_BAG_PKCS8_KEY:           return ""PKCS#8 Key""_",0
"        case GNUTLS_BAG_CERTIFICATE:         return ""Certificate""_",0
"        case GNUTLS_BAG_CRL:                 return ""CRL""_",0
"        case GNUTLS_BAG_ENCRYPTED:           return ""Encrypted""_",0
"        case GNUTLS_BAG_UNKNOWN:             return ""Unknown""_",0
"        default:                             return ""<undefined>""_",0
 * Load a RSA private key from a PKCS#12 file.,0
 * @param fp the file that contains the key data.,0
 * @param cert_passwd password to decrypt the PKCS#12 file.,0
 * @param[out] err error message upon failure_ NULL upon success.,0
 * @return a pointer to the loaded key on success_ NULL upon failure.,0
"ssl_load_pkcs12(FILE* fp, const gchar *cert_passwd, char** err) {",0
"    int                       i, j, ret_",0
    int                       rest_,0
    unsigned char            *p_,0
    gnutls_datum_t            data_,0
    gnutls_pkcs12_bag_t       bag = NULL_,0
    gnutls_pkcs12_bag_type_t  bag_type_,0
    size_t                    len_,0
    gnutls_pkcs12_t       ssl_p12  = NULL_,0
    gnutls_x509_privkey_t ssl_pkey = NULL_,0
    gnutls_x509_privkey_t     priv_key = NULL_,0
    *err = NULL_,0
    rest = 4096_,0
    data.data = (unsigned char *)g_malloc(rest)_,0
    data.size = rest_,0
    p = data.data_,0
"    while ((len = fread(p, 1, rest, fp)) > 0) {",0
        p += len_,0
        rest -= (int) len_,0
        if (!rest) {,0
            rest = 1024_,0
"            data.data = (unsigned char *)g_realloc(data.data, data.size + rest)_",0
            p = data.data + data.size_,0
            data.size += rest_,0
    data.size -= rest_,0
"    ssl_debug_printf(""%d bytes read\n"", data.size)_",0
    if (!feof(fp)) {,0
"        *err = g_strdup(""Error during certificate reading."")_",0
"        ssl_debug_printf(""%s\n"", *err)_",0
        g_free(data.data)_,0
    ret = gnutls_pkcs12_init(&ssl_p12)_,0
    if (ret < 0) {,0
"        *err = g_strdup_printf(""gnutls_pkcs12_init(&st_p12) - %s"", gnutls_strerror(ret))_",0
    /* load PKCS#12 in DER or PEM format */,0
"    ret = gnutls_pkcs12_import(ssl_p12, &data, GNUTLS_X509_FMT_DER, 0)_",0
"        *err = g_strdup_printf(""could not load PKCS#12 in DER format: %s"", gnutls_strerror(ret))_",0
"        ret = gnutls_pkcs12_import(ssl_p12, &data, GNUTLS_X509_FMT_PEM, 0)_",0
        if (ret < 0) {,0
"            *err = g_strdup_printf(""could not load PKCS#12 in PEM format: %s"", gnutls_strerror(ret))_",0
"            ssl_debug_printf(""%s\n"", *err)_",0
    g_free(data.data)_,0
"    ssl_debug_printf( ""PKCS#12 imported\n"")_",0
"    /* TODO: Use gnutls_pkcs12_simple_parse, since 3.1.0 (August 2012) */",0
    for (i=0_ _ i++) {,0
        ret = gnutls_pkcs12_bag_init(&bag)_,0
        if (ret < 0) break_,0
"        ret = gnutls_pkcs12_get_bag(ssl_p12, i, bag)_",0
        for (j=0_ j<gnutls_pkcs12_bag_get_count(bag)_ j++) {,0
"            ret = gnutls_pkcs12_bag_get_type(bag, j)_",0
            if (ret < 0) goto done_,0
            bag_type = (gnutls_pkcs12_bag_type_t)ret_,0
            if (bag_type >= GNUTLS_BAG_UNKNOWN) goto done_,0
"            ssl_debug_printf( ""Bag %d/%d: %s\n"", i, j, BAGTYPE(bag_type))_",0
            if (bag_type == GNUTLS_BAG_ENCRYPTED) {,0
"                ret = gnutls_pkcs12_bag_decrypt(bag, cert_passwd)_",0
                if (ret == 0) {,0
"                    ret = gnutls_pkcs12_bag_get_type(bag, j)_",0
                    if (ret < 0) goto done_,0
                    bag_type = (gnutls_pkcs12_bag_type_t)ret_,0
                    if (bag_type >= GNUTLS_BAG_UNKNOWN) goto done_,0
"                    ssl_debug_printf( ""Bag %d/%d decrypted: %s\n"", i, j, BAGTYPE(bag_type))_",0
"            ret = gnutls_pkcs12_bag_get_data(bag, j, &data)_",0
            switch (bag_type) {,0
                case GNUTLS_BAG_PKCS8_KEY:,0
                case GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:,0
                    ret = gnutls_x509_privkey_init(&ssl_pkey)_,0
                    if (ret < 0) {,0
"                        *err = g_strdup_printf(""gnutls_x509_privkey_init(&ssl_pkey) - %s"", gnutls_strerror(ret))_",0
"                        ssl_debug_printf(""%s\n"", *err)_",0
                        goto done_,0
"                    ret = gnutls_x509_privkey_import_pkcs8(ssl_pkey, &data, GNUTLS_X509_FMT_DER, cert_passwd,",0
                                                           (bag_type==GNUTLS_BAG_PKCS8_KEY) ? GNUTLS_PKCS_PLAIN : 0)_,0
"                        *err = g_strdup_printf(""Can not decrypt private key - %s"", gnutls_strerror(ret))_",0
                    if (gnutls_x509_privkey_get_pk_algorithm(ssl_pkey) != GNUTLS_PK_RSA) {,0
"                        *err = g_strdup(""ssl_load_pkcs12: private key public key algorithm isn't RSA"")_",0
"                    /* Private key found, return it. */",0
                    priv_key = ssl_pkey_,0
                    goto done_,0
                default: _,0
        }  /* j */,0
        if (bag) { gnutls_pkcs12_bag_deinit(bag)_ bag = NULL_ },0
    }  /* i */,0
done:,0
    if (!priv_key && ssl_pkey),0
        gnutls_x509_privkey_deinit(ssl_pkey)_,0
    if (bag),0
        gnutls_pkcs12_bag_deinit(bag)_,0
ssl_private_key_free(gpointer key),0
    gcry_sexp_release((gcry_sexp_t) key)_,0
"ssl_find_private_key_by_pubkey(SslDecryptSession *ssl, GHashTable *key_hash,",0
                               gnutls_datum_t *subjectPublicKeyInfo),0
    gnutls_pubkey_t pubkey = NULL_,0
    guchar key_id[20]_,0
    size_t key_id_len = sizeof(key_id)_,0
    int r_,0
    if (!subjectPublicKeyInfo->size) {,0
"        ssl_debug_printf(""%s: could not find SubjectPublicKeyInfo\n"", G_STRFUNC)_",0
    r = gnutls_pubkey_init(&pubkey)_,0
    if (r < 0) {,0
"        ssl_debug_printf(""%s: failed to init pubkey: %s\n"",",0
"                G_STRFUNC, gnutls_strerror(r))_",0
"    r = gnutls_pubkey_import(pubkey, subjectPublicKeyInfo, GNUTLS_X509_FMT_DER)_",0
"        ssl_debug_printf(""%s: failed to import pubkey from handshake: %s\n"",",0
        goto end_,0
    /* Generate a 20-byte SHA-1 hash. */,0
"    r = gnutls_pubkey_get_key_id(pubkey, 0, key_id, &key_id_len)_",0
"        ssl_debug_printf(""%s: failed to extract key id from pubkey: %s\n"",",0
"    ssl_print_data(""lookup(KeyID)"", key_id, key_id_len)_",0
"    ssl->private_key = (gcry_sexp_t)g_hash_table_lookup(key_hash, key_id)_",0
"    ssl_debug_printf(""%s: lookup result: %p\n"", G_STRFUNC, (void *) ssl->private_key)_",0
end:,0
    gnutls_pubkey_deinit(pubkey)_,0
/* RSA private key file processing }}} */,0
#else /* ! (defined(HAVE_LIBGNUTLS) && defined(HAVE_LIBGCRYPT)) */,0
ssl_private_key_free(gpointer key _U_),0
#endif /* ! (defined(HAVE_LIBGNUTLS) && defined(HAVE_LIBGCRYPT)) */,0
/*--- Start of dissector-related code below ---*/,0
/* get ssl data for this session. if no ssl data is found allocate a new one*/,0
SslDecryptSession *,0
"ssl_get_session(conversation_t *conversation, dissector_handle_t ssl_handle)",0
    void               *conv_data_,0
    SslDecryptSession  *ssl_session_,0
    int                 proto_ssl_,0
    proto_ssl = dissector_handle_get_protocol_index(ssl_handle)_,0
"    conv_data = conversation_get_proto_data(conversation, proto_ssl)_",0
    if (conv_data != NULL),0
        return (SslDecryptSession *)conv_data_,0
"    /* no previous SSL conversation info, initialize it. */",0
"    ssl_session = wmem_new0(wmem_file_scope(), SslDecryptSession)_",0
"    /* data_len is the part that is meaningful, not the allocated length */",0
    ssl_session->master_secret.data_len = 0_,0
    ssl_session->master_secret.data = ssl_session->_master_secret_,0
    ssl_session->session_id.data_len = 0_,0
    ssl_session->session_id.data = ssl_session->_session_id_,0
    ssl_session->client_random.data_len = 0_,0
    ssl_session->client_random.data = ssl_session->_client_random_,0
    ssl_session->server_random.data_len = 0_,0
    ssl_session->server_random.data = ssl_session->_server_random_,0
    ssl_session->session_ticket.data_len = 0_,0
    ssl_session->session_ticket.data = NULL_ /* will be re-alloced as needed */,0
    ssl_session->server_data_for_iv.data_len = 0_,0
    ssl_session->server_data_for_iv.data = ssl_session->_server_data_for_iv_,0
    ssl_session->client_data_for_iv.data_len = 0_,0
    ssl_session->client_data_for_iv.data = ssl_session->_client_data_for_iv_,0
    ssl_session->app_data_segment.data = NULL_,0
    ssl_session->app_data_segment.data_len = 0_,0
    ssl_session->handshake_data.data=NULL_,0
    ssl_session->handshake_data.data_len=0_,0
    /* Initialize parameters which are not necessary specific to decryption. */,0
    ssl_session->session.version = SSL_VER_UNKNOWN_,0
    clear_address(&ssl_session->session.srv_addr)_,0
    ssl_session->session.srv_ptype = PT_NONE_,0
    ssl_session->session.srv_port = 0_,0
"    conversation_add_proto_data(conversation, proto_ssl, ssl_session)_",0
    return ssl_session_,0
"ssl_starttls(dissector_handle_t ssl_handle, packet_info *pinfo,",0
"                 dissector_handle_t app_handle, guint32 last_nontls_frame)",0
    conversation_t  *conversation_,0
    SslSession      *session_,0
    /* Ignore if the SSL dissector is disabled. */,0
    if (!ssl_handle),0
    /* The caller should always pass a valid handle to its own dissector. */,0
    DISSECTOR_ASSERT(app_handle)_,0
"    session = &ssl_get_session(conversation, ssl_handle)->session_",0
"    ssl_debug_printf(""%s: old frame %d, app_handle=%p (%s)\n"", G_STRFUNC,",0
"                     session->last_nontls_frame,",0
"                     (void *)session->app_handle,",0
                     dissector_handle_get_dissector_name(session->app_handle))_,0
"    ssl_debug_printf(""%s: current frame %d, app_handle=%p (%s)\n"", G_STRFUNC,",0
"                     pinfo->num, (void *)app_handle,",0
                     dissector_handle_get_dissector_name(app_handle))_,0
    /* Do not switch again if a dissector did it before. */,0
    if (session->last_nontls_frame) {,0
"        ssl_debug_printf(""%s: not overriding previous app handle!\n"", G_STRFUNC)_",0
        return session->last_nontls_frame_,0
    session->app_handle = app_handle_,0
    /* The SSL dissector should be called first for this conversation. */,0
"    conversation_set_dissector(conversation, ssl_handle)_",0
    /* SSL starts after this frame. */,0
    session->last_nontls_frame = last_nontls_frame_,0
/* ssl_starttls_ack: mark future frames as encrypted. {{{ */,0
"ssl_starttls_ack(dissector_handle_t ssl_handle, packet_info *pinfo,",0
                 dissector_handle_t app_handle),0
"    return ssl_starttls(ssl_handle, pinfo, app_handle, pinfo->num)_",0
"ssl_starttls_post_ack(dissector_handle_t ssl_handle, packet_info *pinfo,",0
"    return ssl_starttls(ssl_handle, pinfo, app_handle, pinfo->num - 1)_",0
/* Functions for TLS/DTLS sessions and RSA private keys hashtables. {{{ */,0
"ssl_equal (gconstpointer v, gconstpointer v2)",0
    const StringInfo *val1_,0
    const StringInfo *val2_,0
    val1 = (const StringInfo *)v_,0
    val2 = (const StringInfo *)v2_,0
    if (val1->data_len == val2->data_len &&,0
"        !memcmp(val1->data, val2->data, val2->data_len)) {",0
        return 1_,0
ssl_hash  (gconstpointer v),0
"    guint l,hash_",0
    const StringInfo* id_,0
    const guint* cur_,0
    hash = 0_,0
    id = (const StringInfo*) v_,0
    /*  id and id->data are mallocated in ssl_save_master_key().  As such 'data',0
     *  should be aligned for any kind of access (for example as a guint as,0
"     *  is done below).  The intermediate void* cast is to prevent ""cast",0
"     *  increases required alignment of target type"" warnings on CPUs (such",0
     *  as SPARCs) that do not allow misaligned memory accesses.,0
    cur = (const guint*)(void*) id->data_,0
"    for (l=4_ (l < id->data_len)_ l+=4, cur++)",0
        hash = hash ^ (*cur)_,0
    return hash_,0
"ssl_private_key_equal (gconstpointer v, gconstpointer v2)",0
"    /* key ID length (SHA-1 hash, per GNUTLS_KEYID_USE_SHA1) */",0
"    return !memcmp(v, v2, 20)_",0
guint,0
ssl_private_key_hash (gconstpointer v),0
"    guint        l, hash = 0_",0
    const guint8 *cur = (const guint8 *)v_,0
    /* The public key' SHA-1 hash (which maps to a private key) has a uniform,0
"     * distribution, hence simply xor'ing them should be sufficient. */",0
"    for (l = 0_ l < 20_ l += 4, cur += 4)",0
        hash ^= pntoh32(cur)_,0
/* Functions for TLS/DTLS sessions and RSA private keys hashtables. }}} */,0
/* Handling of association between tls/dtls ports and clear text protocol. {{{ */,0
"ssl_association_add(const char* dissector_table_name, dissector_handle_t main_handle, dissector_handle_t subdissector_handle, guint port, gboolean tcp)",0
    DISSECTOR_ASSERT(main_handle)_,0
    DISSECTOR_ASSERT(subdissector_handle)_,0
    /* Registration is required for Export PDU feature to work properly. */,0
"    DISSECTOR_ASSERT_HINT(dissector_handle_get_dissector_name(subdissector_handle),",0
"            ""SSL appdata dissectors must register with register_dissector()!"")_",0
"    ssl_debug_printf(""association_add %s port %d handle %p\n"", dissector_table_name, port, (void *)subdissector_handle)_",0
    if (port) {,0
"        dissector_add_uint(dissector_table_name, port, subdissector_handle)_",0
        if (tcp),0
"            dissector_add_uint(""tcp.port"", port, main_handle)_",0
"            dissector_add_uint(""udp.port"", port, main_handle)_",0
"        dissector_add_uint(""sctp.port"", port, main_handle)_",0
"        dissector_add_for_decode_as(dissector_table_name, subdissector_handle)_",0
"ssl_association_remove(const char* dissector_table_name, dissector_handle_t main_handle, dissector_handle_t subdissector_handle, guint port, gboolean tcp)",0
"    ssl_debug_printf(""ssl_association_remove removing %s %u - handle %p\n"",",0
"                     tcp?""TCP"":""UDP"", port, (void *)subdissector_handle)_",0
    if (main_handle) {,0
"        dissector_delete_uint(tcp?""tcp.port"":""udp.port"", port, main_handle)_",0
"        dissector_delete_uint(""sctp.port"", port, main_handle)_",0
"        dissector_delete_uint(dissector_table_name, port, subdissector_handle)_",0
"ssl_set_server(SslSession *session, address *addr, port_type ptype, guint32 port)",0
"    copy_address_wmem(wmem_file_scope(), &session->srv_addr, addr)_",0
    session->srv_ptype = ptype_,0
    session->srv_port = port_,0
"ssl_packet_from_server(SslSession *session, dissector_table_t table, packet_info *pinfo)",0
    if (session->srv_ptype != PT_NONE) {,0
        ret = (session->srv_ptype == pinfo->ptype) &&,0
              (session->srv_port == pinfo->srcport) &&,0
"              addresses_equal(&session->srv_addr, &pinfo->src)_",0
"        ret = (dissector_get_uint_handle(table, pinfo->srcport) != 0)_",0
"    ssl_debug_printf(""packet_from_server: is from server - %s\n"", (ret)?""TRUE"":""FALSE"")_",0
/* Handling of association between tls/dtls ports and clear text protocol. }}} */,0
/* Links SSL records with the real packet data. {{{ */,0
/* add to packet data a copy of the specified real data */,0
"ssl_add_record_info(gint proto, packet_info *pinfo, guchar* data, gint data_len, gint record_id)",0
    guchar*        real_data_,0
    SslRecordInfo* rec_,0
    SslPacketInfo* pi_,0
"    pi = (SslPacketInfo *)p_get_proto_data(wmem_file_scope(), pinfo, proto, 0)_",0
    if (!pi),0
"        pi = (SslPacketInfo *)wmem_alloc0(wmem_file_scope(), sizeof(SslPacketInfo))_",0
"        p_add_proto_data(wmem_file_scope(), pinfo, proto, 0, pi)_",0
"    real_data = (guchar *)wmem_alloc(wmem_file_scope(), data_len)_",0
"    memcpy(real_data, data, data_len)_",0
"    rec = (SslRecordInfo *)wmem_alloc(wmem_file_scope(), sizeof(SslRecordInfo))_",0
    rec->id = record_id_,0
    rec->real_data = real_data_,0
    rec->data_len = data_len_,0
    /* head insertion */,0
    rec->next= pi->handshake_data_,0
    pi->handshake_data = rec_,0
/* search in packet data for the specified id_ return a newly created tvb for the associated data */,0
tvbuff_t*,0
"ssl_get_record_info(tvbuff_t *parent_tvb, int proto, packet_info *pinfo, gint record_id)",0
    for (rec = pi->handshake_data_ rec_ rec = rec->next),0
        if (rec->id == record_id),0
            /* link new real_data_tvb with a parent tvb so it is freed when frame dissection is complete */,0
"            return tvb_new_child_real_data(parent_tvb, rec->real_data, rec->data_len, rec->data_len)_",0
"ssl_add_data_info(gint proto, packet_info *pinfo, guchar* data, gint data_len, gint key, SslFlow *flow)",0
"    SslDataInfo   *rec, **prec_",0
    SslPacketInfo *pi_,0
"    rec = (SslDataInfo *)wmem_alloc(wmem_file_scope(), sizeof(SslDataInfo)+data_len)_",0
    rec->key = key_,0
    rec->plain_data.data = (guchar*)(rec + 1)_,0
"    memcpy(rec->plain_data.data, data, data_len)_",0
    rec->plain_data.data_len = data_len_,0
    if (flow),0
        rec->seq = flow->byte_seq_,0
        rec->nxtseq = flow->byte_seq + data_len_,0
        rec->flow = flow_,0
        flow->byte_seq += data_len_,0
    rec->next = NULL_,0
    /* insertion */,0
    prec = &pi->appl_data_,0
    while (*prec) prec = &(*prec)->next_,0
    *prec = rec_,0
"    ssl_debug_printf(""ssl_add_data_info: new data inserted data_len = %d, seq = %u, nxtseq = %u\n"",",0
"                     rec->plain_data.data_len, rec->seq, rec->nxtseq)_",0
SslDataInfo*,0
"ssl_get_data_info(int proto, packet_info *pinfo, gint key)",0
    SslDataInfo*   rec_,0
    if (!pi) return NULL_,0
    rec = pi->appl_data_,0
    while (rec) {,0
        if (rec->key == key) return rec_,0
        rec = rec->next_,0
/* Links SSL records with the real packet data. }}} */,0
/* initialize/reset per capture state data (ssl sessions cache). {{{ */,0
"ssl_common_init(ssl_master_key_map_t *mk_map,",0
"                StringInfo *decrypted_data, StringInfo *compressed_data)",0
"    mk_map->session = g_hash_table_new(ssl_hash, ssl_equal)_",0
"    mk_map->tickets = g_hash_table_new(ssl_hash, ssl_equal)_",0
"    mk_map->crandom = g_hash_table_new(ssl_hash, ssl_equal)_",0
"    mk_map->pre_master = g_hash_table_new(ssl_hash, ssl_equal)_",0
"    mk_map->pms = g_hash_table_new(ssl_hash, ssl_equal)_",0
"    ssl_data_alloc(decrypted_data, 32)_",0
"    ssl_data_alloc(compressed_data, 32)_",0
"ssl_common_cleanup(ssl_master_key_map_t *mk_map, FILE **ssl_keylog_file,",0
"                   StringInfo *decrypted_data, StringInfo *compressed_data)",0
    g_hash_table_destroy(mk_map->session)_,0
    g_hash_table_destroy(mk_map->tickets)_,0
    g_hash_table_destroy(mk_map->crandom)_,0
    g_hash_table_destroy(mk_map->pre_master)_,0
    g_hash_table_destroy(mk_map->pms)_,0
    g_free(decrypted_data->data)_,0
    g_free(compressed_data->data)_,0
"    /* close the previous keylog file now that the cache are cleared, this",0
     * allows the cache to be filled with the full keylog file contents. */,0
    if (*ssl_keylog_file) {,0
        fclose(*ssl_keylog_file)_,0
        *ssl_keylog_file = NULL_,0
/* parse ssl related preferences (private keys and ports association strings) */,0
/* Load a single RSA key file item from preferences. {{{ */,0
"ssl_parse_key_list(const ssldecrypt_assoc_t *uats, GHashTable *key_hash, const char* dissector_table_name, dissector_handle_t main_handle, gboolean tcp)",0
    gcry_sexp_t        private_key_,0
    FILE*              fp     = NULL_,0
    int                ret_,0
    size_t             key_id_len = 20_,0
    guchar            *key_id = NULL_,0
    dissector_handle_t handle_,0
    /* try to load keys file first */,0
"    fp = ws_fopen(uats->keyfile, ""rb"")_",0
    if (!fp) {,0
"        report_open_failure(uats->keyfile, errno, FALSE)_",0
    if ((gint)strlen(uats->password) == 0) {,0
        priv_key = ssl_load_key(fp)_,0
        char *err = NULL_,0
"        priv_key = ssl_load_pkcs12(fp, uats->password, &err)_",0
        if (err) {,0
"            report_failure(""%s\n"", err)_",0
            g_free(err)_,0
    fclose(fp)_,0
    if (!priv_key) {,0
"        report_failure(""Can't load private key from %s\n"", uats->keyfile)_",0
    key_id = (guchar *) g_malloc0(key_id_len)_,0
"    ret = gnutls_x509_privkey_get_key_id(priv_key, 0, key_id, &key_id_len)_",0
"        report_failure(""Can't calculate public key ID for %s: %s"",",0
"                uats->keyfile, gnutls_strerror(ret))_",0
"    ssl_print_data(""KeyID"", key_id, key_id_len)_",0
    private_key = ssl_privkey_to_sexp(priv_key)_,0
    if (!private_key) {,0
"        report_failure(""Can't extract private key parameters for %s"", uats->keyfile)_",0
"    g_hash_table_replace(key_hash, key_id, private_key)_",0
"    key_id = NULL_ /* used in key_hash, do not free. */",0
"    ssl_debug_printf(""ssl_init private key file %s successfully loaded.\n"", uats->keyfile)_",0
"        int port = atoi(uats->port)_ /* Also maps ""start_tls"" -> 0 (wildcard) */",0
"        ssl_debug_printf(""ssl_init port '%d' filename '%s' password(only for p12 file) '%s'\n"",",0
"            port, uats->keyfile, uats->password)_",0
        handle = find_dissector(uats->protocol)_,0
"        ssl_association_add(dissector_table_name, main_handle, handle, port, tcp)_",0
    gnutls_x509_privkey_deinit(priv_key)_,0
    g_free(key_id)_,0
"ssl_parse_key_list(const ssldecrypt_assoc_t *uats _U_, GHashTable *key_hash _U_, const char* dissector_table_name _U_, dissector_handle_t main_handle _U_, gboolean tcp _U_)",0
"    report_failure(""Can't load private key files, support is not compiled in."")_",0
#ifdef HAVE_LIBGCRYPT /* useless without decryption support. */,0
/* Store/load a known (pre-)master secret from/for this SSL session. {{{ */,0
/** store a known (pre-)master secret into cache */,0
"ssl_save_master_key(const char *label, GHashTable *ht, StringInfo *key,",0
                    StringInfo *mk),0
"    StringInfo *ht_key, *master_secret_",0
    if (key->data_len == 0) {,0
"        ssl_debug_printf(""%s: not saving empty %s!\n"", G_STRFUNC, label)_",0
    if (mk->data_len == 0) {,0
"        ssl_debug_printf(""%s not saving empty (pre-)master secret for %s!\n"",",0
"                         G_STRFUNC, label)_",0
    /* ssl_hash() depends on session_ticket->data being aligned for guint access,0
     * so be careful in changing how it is allocated. */,0
    ht_key = ssl_data_clone(key)_,0
    master_secret = ssl_data_clone(mk)_,0
"    g_hash_table_insert(ht, ht_key, master_secret)_",0
"    ssl_debug_printf(""%s inserted (pre-)master secret for %s\n"", G_STRFUNC, label)_",0
"    ssl_print_string(""stored key"", ht_key)_",0
"    ssl_print_string(""stored (pre-)master secret"", master_secret)_",0
/** restore a (pre-)master secret given some key in the cache */,0
"                       gboolean is_pre_master, GHashTable *ht, StringInfo *key)",0
    StringInfo *ms_,0
"        ssl_debug_printf(""%s can't restore %smaster secret using an empty %s\n"",",0
"                         G_STRFUNC, is_pre_master ? ""pre-"" : """", label)_",0
"    ms = (StringInfo *)g_hash_table_lookup(ht, key)_",0
    if (!ms) {,0
"        ssl_debug_printf(""%s can't find %smaster secret by %s\n"", G_STRFUNC,",0
"                         is_pre_master ? ""pre-"" : """", label)_",0
"    /* (pre)master secret found, clear knowledge of other keys and set it in the",0
     * current conversation */,0
    ssl->state &= ~(SSL_MASTER_SECRET | SSL_PRE_MASTER_SECRET |,0
                    SSL_HAVE_SESSION_KEY)_,0
    if (is_pre_master) {,0
"        /* unlike master secret, pre-master secret has a variable size (48 for",0
"         * RSA, varying for PSK) and is therefore not statically allocated */",0
"        ssl->pre_master_secret.data = (guchar *) wmem_alloc(wmem_file_scope(),",0
                                                            ms->data_len)_,0
"        ssl_data_set(&ssl->pre_master_secret, ms->data, ms->data_len)_",0
        ssl->state |= SSL_PRE_MASTER_SECRET_,0
"        ssl_data_set(&ssl->master_secret, ms->data, ms->data_len)_",0
        ssl->state |= SSL_MASTER_SECRET_,0
"    ssl_debug_printf(""%s %smaster secret retrieved using %s\n"", G_STRFUNC,",0
"                     is_pre_master ? ""pre-"" : """", label)_",0
"    ssl_print_string(label, key)_",0
"    ssl_print_string(""(pre-)master secret"", ms)_",0
/* Store/load a known (pre-)master secret from/for this SSL session. }}} */,0
"/* Should be called when all parameters are ready (after ChangeCipherSpec), and",0
 * the decoder should be attempted to be initialized. {{{*/,0
"ssl_finalize_decryption(SslDecryptSession *ssl, ssl_master_key_map_t *mk_map)",0
"    ssl_debug_printf(""%s state = 0x%02X\n"", G_STRFUNC, ssl->state)_",0
    if (ssl->state & SSL_HAVE_SESSION_KEY) {,0
"        ssl_debug_printf(""  session key already available, nothing to do.\n"")_",0
    if (!(ssl->state & SSL_CIPHER)) {,0
"        ssl_debug_printf(""  Cipher suite (Server Hello) is missing!\n"")_",0
"    /* for decryption, there needs to be a master secret (which can be derived",0
"     * from pre-master secret). If missing, try to pick a master key from cache",0
     * (an earlier packet in the capture or key logfile). */,0
    if (!(ssl->state & (SSL_MASTER_SECRET | SSL_PRE_MASTER_SECRET)) &&,0
"        !ssl_restore_master_key(ssl, ""Session ID"", FALSE,",0
"                                mk_map->session, &ssl->session_id) &&",0
        (!ssl->session.is_session_resumed ||,0
"         !ssl_restore_master_key(ssl, ""Session Ticket"", FALSE,",0
"                                 mk_map->tickets, &ssl->session_ticket)) &&",0
"        !ssl_restore_master_key(ssl, ""Client Random"", FALSE,",0
"                                mk_map->crandom, &ssl->client_random)) {",0
        if (ssl->cipher_suite->enc != ENC_NULL) {,0
"            /* how unfortunate, the master secret could not be found */",0
"            ssl_debug_printf(""  Cannot find master secret\n"")_",0
"            ssl_debug_printf("" Cannot find master secret, continuing anyway """,0
"                    ""because of a NULL cipher\n"")_",0
    if (ssl_generate_keyring_material(ssl) < 0) {,0
"        ssl_debug_printf(""%s can't generate keyring material\n"", G_STRFUNC)_",0
"    /* Save Client Random/ Session ID for ""SSL Export Session keys"" */",0
"    ssl_save_master_key(""Client Random"", mk_map->crandom,",0
"                        &ssl->client_random, &ssl->master_secret)_",0
"    ssl_save_master_key(""Session ID"", mk_map->session,",0
"                        &ssl->session_id, &ssl->master_secret)_",0
    /* Only save the new secrets if the server sent the ticket. The client,0
     * ticket might have become stale. */,0
    if (ssl->state & SSL_NEW_SESSION_TICKET) {,0
"        ssl_save_master_key(""Session Ticket"", mk_map->tickets,",0
"                            &ssl->session_ticket, &ssl->master_secret)_",0
/** SSL keylog file handling. {{{ */,0
static GRegex *,0
ssl_compile_keyfile_regex(void),0
"#define OCTET ""(?:[[:xdigit:]]{2})""",0
    const gchar *pattern =,0
"        ""(?:""",0
        /* Matches Client Hellos having this Client Random */,0
"        ""PMS_CLIENT_RANDOM (?<client_random_pms>"" OCTET ""{32}) """,0
        /* Matches first part of encrypted RSA pre-master secret */,0
"        ""|RSA (?<encrypted_pmk>"" OCTET ""{8}) """,0
"        /* Pre-Master-Secret is given, it is 48 bytes for RSA,",0
           but it can be of any length for DHE */,0
"        "")(?<pms>"" OCTET ""+)""",0
"        ""|(?:""",0
        /* Matches Server Hellos having a Session ID */,0
"        ""RSA Session-ID:(?<session_id>"" OCTET ""+) Master-Key:""",0
"        ""|CLIENT_RANDOM (?<client_random>"" OCTET ""{32}) """,0
"        /* Master-Secret is given, its length is fixed */",0
"        "")(?<master_secret>"" OCTET ""{"" G_STRINGIFY(SSL_MASTER_SECRET_LENGTH) ""})""_",0
#undef OCTET,0
    static GRegex *regex = NULL_,0
    GError *gerr = NULL_,0
    if (!regex) {,0
"        regex = g_regex_new(pattern,",0
"                (GRegexCompileFlags)(G_REGEX_OPTIMIZE | G_REGEX_ANCHORED),",0
"                G_REGEX_MATCH_ANCHORED, &gerr)_",0
        if (gerr) {,0
"            ssl_debug_printf(""%s failed to compile regex: %s\n"", G_STRFUNC,",0
                             gerr->message)_,0
            g_error_free(gerr)_,0
            regex = NULL_,0
    return regex_,0
"file_needs_reopen(FILE *fp, const char *filename)",0
"    ws_statb64 open_stat, current_stat_",0
"    /* consider a file deleted when stat fails for either file,",0
     * or when the residing device / inode has changed. */,0
"    if (0 != ws_fstat64(ws_fileno(fp), &open_stat))",0
"    if (0 != ws_stat64(filename, &current_stat))",0
"    /* Note: on Windows, ino may be 0. Existing files cannot be deleted on",0
"     * Windows, but hopefully the size is a good indicator when a file got",0
     * removed and recreated */,0
    return  open_stat.st_dev != current_stat.st_dev ||,0
            open_stat.st_ino != current_stat.st_ino ||,0
            open_stat.st_size > current_stat.st_size_,0
typedef struct ssl_master_key_match_group {,0
    const char *re_group_name_,0
    GHashTable *master_key_ht_,0
} ssl_master_key_match_group_t_,0
"ssl_load_keyfile(const gchar *ssl_keylog_filename, FILE **keylog_file,",0
                 const ssl_master_key_map_t *mk_map),0
    unsigned i_,0
    GRegex *regex_,0
    ssl_master_key_match_group_t mk_groups[] = {,0
"        { ""encrypted_pmk"",  mk_map->pre_master },",0
"        { ""session_id"",     mk_map->session },",0
"        { ""client_random"",  mk_map->crandom },",0
"        { ""client_random_pms"",  mk_map->pms},",0
    /* no need to try if no key log file is configured. */,0
    if (!ssl_keylog_filename || !*ssl_keylog_filename) {,0
"        ssl_debug_printf(""%s dtls/ssl.keylog_file is not configured!\n"",",0
                         G_STRFUNC)_,0
    /* The format of the file is a series of records with one of the following formats:,0
"     *   - ""RSA xxxx yyyy""",0
     *     Where xxxx are the first 8 bytes of the encrypted pre-master secret (hex-encoded),0
     *     Where yyyy is the cleartext pre-master secret (hex-encoded),0
     *     (this is the original format introduced with bug 4349),0
"     *   - ""RSA Session-ID:xxxx Master-Key:yyyy""",0
     *     Where xxxx is the SSL session ID (hex-encoded),0
     *     Where yyyy is the cleartext master secret (hex-encoded),0
     *     (added to support openssl s_client Master-Key output),0
     *     This is somewhat is a misnomer because there's nothing RSA specific,0
     *     about this.,0
"     *   - ""PMS_CLIENT_RANDOM xxxx yyyy""",0
     *     Where xxxx is the client_random from the ClientHello (hex-encoded),0
"     *     (This format allows SSL connections to be decrypted, if a user can",0
     *     capture the PMS but could not recover the MS for a specific session,0
     *     with a SSL Server.),0
"     *   - ""CLIENT_RANDOM xxxx yyyy""",0
"     *     (This format allows non-RSA SSL connections to be decrypted, i.e.",0
     *     ECDHE-RSA.),0
    regex = ssl_compile_keyfile_regex()_,0
    if (!regex),0
"    ssl_debug_printf(""trying to use SSL keylog in %s\n"", ssl_keylog_filename)_",0
"    /* if the keylog file was deleted, re-open it */",0
"    if (*keylog_file && file_needs_reopen(*keylog_file, ssl_keylog_filename)) {",0
"        ssl_debug_printf(""%s file got deleted, trying to re-open\n"", G_STRFUNC)_",0
        fclose(*keylog_file)_,0
        *keylog_file = NULL_,0
    if (*keylog_file == NULL) {,0
"        *keylog_file = ws_fopen(ssl_keylog_filename, ""r"")_",0
        if (!*keylog_file) {,0
"            ssl_debug_printf(""%s failed to open SSL keylog\n"", G_STRFUNC)_",0
    for (__) {,0
"        char buf[512], *line_",0
        gsize bytes_read_,0
        GMatchInfo *mi_,0
"        line = fgets(buf, sizeof(buf), *keylog_file)_",0
        if (!line),0
        bytes_read = strlen(line)_,0
        /* fgets includes the \n at the end of the line. */,0
        if (bytes_read > 0 && line[bytes_read - 1] == '\n') {,0
            line[bytes_read - 1] = 0_,0
            bytes_read--_,0
        if (bytes_read > 0 && line[bytes_read - 1] == '\r') {,0
"        ssl_debug_printf(""  checking keylog line: %s\n"", line)_",0
"        if (g_regex_match(regex, line, G_REGEX_MATCH_ANCHORED, &mi)) {",0
"            gchar *hex_key, *hex_pre_ms_or_ms_",0
"            StringInfo *key = wmem_new(wmem_file_scope(), StringInfo)_",0
            StringInfo *pre_ms_or_ms = NULL_,0
            GHashTable *ht = NULL_,0
            /* Is the PMS being supplied with the PMS_CLIENT_RANDOM,0
             * otherwise we will use the Master Secret,0
"            hex_pre_ms_or_ms = g_match_info_fetch_named(mi, ""master_secret"")_",0
            if (hex_pre_ms_or_ms == NULL || strlen(hex_pre_ms_or_ms) == 0){,0
                g_free(hex_pre_ms_or_ms)_,0
"                hex_pre_ms_or_ms = g_match_info_fetch_named(mi, ""pms"")_",0
"            /* There is always a match, otherwise the regex is wrong. */",0
            DISSECTOR_ASSERT(hex_pre_ms_or_ms && strlen(hex_pre_ms_or_ms))_,0
            /* convert from hex to bytes and save to hashtable */,0
"            pre_ms_or_ms = wmem_new(wmem_file_scope(), StringInfo)_",0
"            from_hex(pre_ms_or_ms, hex_pre_ms_or_ms, strlen(hex_pre_ms_or_ms))_",0
            g_free(hex_pre_ms_or_ms)_,0
"            /* Find a master key from any format (CLIENT_RANDOM, SID, ...) */",0
            for (i = 0_ i < G_N_ELEMENTS(mk_groups)_ i++) {,0
                ssl_master_key_match_group_t *g = &mk_groups[i]_,0
"                hex_key = g_match_info_fetch_named(mi, g->re_group_name)_",0
                if (hex_key && *hex_key) {,0
"                    ssl_debug_printf(""    matched %s\n"", g->re_group_name)_",0
                    ht = g->master_key_ht_,0
"                    from_hex(key, hex_key, strlen(hex_key))_",0
                    g_free(hex_key)_,0
                g_free(hex_key)_,0
"            DISSECTOR_ASSERT(ht)_ /* Cannot be reached, or regex is wrong. */",0
"            g_hash_table_insert(ht, key, pre_ms_or_ms)_",0
"            ssl_debug_printf(""    unrecognized line\n"")_",0
        /* always free match info even if there is no match. */,0
        g_match_info_free(mi)_,0
/** SSL keylog file handling. }}} */,0
#ifdef SSL_DECRYPT_DEBUG /* {{{ */,0
static FILE* ssl_debug_file=NULL_,0
ssl_set_debug(const gchar* name),0
    static gint debug_file_must_be_closed_,0
    gint        use_stderr_,0
"    use_stderr                = name?(strcmp(name, SSL_DEBUG_USE_STDERR) == 0):0_",0
    if (debug_file_must_be_closed),0
        fclose(ssl_debug_file)_,0
    if (use_stderr),0
        ssl_debug_file = stderr_,0
"    else if (!name || (strcmp(name, """") ==0))",0
        ssl_debug_file = NULL_,0
"        ssl_debug_file = ws_fopen(name, ""w"")_",0
    if (!use_stderr && ssl_debug_file),0
        debug_file_must_be_closed = 1_,0
        debug_file_must_be_closed = 0_,0
"    ssl_debug_printf(""Wireshark SSL debug log \n\n"")_",0
"    ssl_debug_printf(""Wireshark version: %s\n"", get_ws_vcs_version_info())_",0
"    ssl_debug_printf(""GnuTLS version:    %s\n"", gnutls_check_version(NULL))_",0
"    ssl_debug_printf(""Libgcrypt version: %s\n"", gcry_check_version(NULL))_",0
"    ssl_debug_printf(""\n"")_",0
ssl_debug_flush(void),0
    if (ssl_debug_file),0
        fflush(ssl_debug_file)_,0
"ssl_debug_printf(const gchar* fmt, ...)",0
    if (!ssl_debug_file),0
"    va_start(ap, fmt)_",0
"    vfprintf(ssl_debug_file, fmt, ap)_",0
"ssl_print_data(const gchar* name, const guchar* data, size_t len)",0
"    size_t i, j, k_",0
"    fprintf(ssl_debug_file,""%s[%d]:\n"",name, (int) len)_",0
    for (i=0_ i<len_ i+=16) {,0
"        fprintf(ssl_debug_file,""| "")_",0
"        for (j=i, k=0_ k<16 && j<len_ ++j, ++k)",0
"            fprintf(ssl_debug_file,""%.2x "",data[j])_",0
        for (_ k<16_ ++k),0
"            fprintf(ssl_debug_file,""   "")_",0
"        fputc('|', ssl_debug_file)_",0
"        for (j=i, k=0_ k<16 && j<len_ ++j, ++k) {",0
            guchar c = data[j]_,0
            if (!g_ascii_isprint(c) || (c=='\t')) c = '.'_,0
"            fputc(c, ssl_debug_file)_",0
"            fputc(' ', ssl_debug_file)_",0
"        fprintf(ssl_debug_file,""|\n"")_",0
"ssl_print_string(const gchar* name, const StringInfo* data)",0
"    ssl_print_data(name, data->data, data->data_len)_",0
#endif /* SSL_DECRYPT_DEBUG }}} */,0
/* UAT preferences callbacks. {{{ */,0
/* checks for SSL and DTLS UAT key list fields */,0
"ssldecrypt_uat_fld_ip_chk_cb(void* r _U_, const char* p, guint len _U_, const void* u1 _U_, const void* u2 _U_, char** err)",0
    if (!p || strlen(p) == 0u) {,0
"        *err = g_strdup(""No IP address given."")_",0
"ssldecrypt_uat_fld_port_chk_cb(void* r _U_, const char* p, guint len _U_, const void* u1 _U_, const void* u2 _U_, char** err)",0
"        *err = g_strdup(""No Port given."")_",0
"    if (strcmp(p, ""start_tls"") != 0){",0
        const gint i = atoi(p)_,0
        if (i < 0 || i > 65535) {,0
"            *err = g_strdup(""Invalid port given."")_",0
"ssldecrypt_uat_fld_fileopen_chk_cb(void* r _U_, const char* p, guint len _U_, const void* u1 _U_, const void* u2 _U_, char** err)",0
    ws_statb64 st_,0
"        *err = g_strdup(""No filename given."")_",0
"        if (ws_stat64(p, &st) != 0) {",0
"            *err = g_strdup_printf(""File '%s' does not exist or access is denied."", p)_",0
"ssldecrypt_uat_fld_password_chk_cb(void *r _U_, const char *p _U_, guint len _U_, const void *u1 _U_, const void *u2 _U_, char **err)",0
    ssldecrypt_assoc_t*  f  = (ssldecrypt_assoc_t *)r_,0
    FILE                *fp = NULL_,0
    if (p && (strlen(p) > 0u)) {,0
"        fp = ws_fopen(f->keyfile, ""rb"")_",0
        if (fp) {,0
            char *msg = NULL_,0
"            gnutls_x509_privkey_t priv_key = ssl_load_pkcs12(fp, p, &msg)_",0
            if (!priv_key) {,0
"                *err = g_strdup_printf(""Could not load PKCS#12 key file: %s"", msg)_",0
                g_free(msg)_,0
            g_free(msg)_,0
            gnutls_x509_privkey_deinit(priv_key)_,0
            fclose(fp)_,0
"            *err = g_strdup_printf(""Leave this field blank if the keyfile is not PKCS#12."")_",0
"    *err = g_strdup(""Cannot load key files, support is not compiled in."")_",0
/* UAT preferences callbacks. }}} */,0
/** maximum size of ssl_association_info() string */,0
#define SSL_ASSOC_MAX_LEN 8192,0
typedef struct ssl_association_info_callback_data,0
    gchar *str_,0
    const char *table_protocol_,0
} ssl_association_info_callback_data_t_,0
 * callback function used by ssl_association_info() to traverse the SSL associations.,0
"ssl_association_info_(const gchar *table _U_, gpointer handle, gpointer user_data)",0
    ssl_association_info_callback_data_t* data = (ssl_association_info_callback_data_t*)user_data_,0
    const int l = (const int)strlen(data->str)_,0
"    g_snprintf(data->str+l, SSL_ASSOC_MAX_LEN-l, ""'%s' %s\n"", dissector_handle_get_short_name((dissector_handle_t)handle), data->table_protocol)_",0
 * @return an information string on the SSL protocol associations. The string has ephemeral lifetime/scope.,0
gchar*,0
"ssl_association_info(const char* dissector_table_name, const char* table_protocol)",0
    ssl_association_info_callback_data_t data_,0
    data.str = (gchar *)g_malloc0(SSL_ASSOC_MAX_LEN)_,0
    data.table_protocol = table_protocol_,0
"    dissector_table_foreach_handle(dissector_table_name, ssl_association_info_, &data)_",0
    return data.str_,0
/** Begin of code related to dissection of wire data. */,0
/* change_cipher_spec(20) dissection */,0
"ssl_dissect_change_cipher_spec(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                               packet_info *pinfo, proto_tree *tree,",0
"                               guint32 offset, SslSession *session,",0
"                               gboolean is_from_server,",0
                               const SslDecryptSession *ssl),0
     * struct {,0
"     *     enum { change_cipher_spec(1), (255) } type_",0
     * } ChangeCipherSpec_,0
"    proto_item_set_text(tree,",0
"            ""%s Record Layer: %s Protocol: Change Cipher Spec"",",0
"            val_to_str_const(session->version, ssl_version_short_names, ""SSL""),",0
"            val_to_str_const(SSL_ID_CHG_CIPHER_SPEC, ssl_31_content_type, ""unknown""))_",0
"    ti = proto_tree_add_item(tree, hf->hf.change_cipher_spec, tvb, offset, 1, ENC_NA)_",0
"    /* Use heuristics to detect an abbreviated handshake, assume that missing",0
     * ServerHelloDone implies reusing previously negotiating keys. Then when,0
"     * a Session ID or ticket is present, it must be a resumed session.",0
"     * Normally this should be done at the Finished message, but that may be",0
"     * encrypted so we do it here, at the last cleartext message. */",0
    if (is_from_server && ssl) {,0
        if (!(ssl->state & SSL_SERVER_HELLO_DONE)) {,0
            const char *resumed = NULL_,0
            if (ssl->session_ticket.data_len) {,0
"                resumed = ""Session Ticket""_",0
            } else if (ssl->session_id.data_len) {,0
"                resumed = ""Session ID""_",0
            if (resumed) {,0
"                ssl_debug_printf(""%s Session resumption using %s\n"", G_STRFUNC, resumed)_",0
                session->is_session_resumed = TRUE_,0
                /* Can happen if the capture somehow starts in the middle */,0
"                ssl_debug_printf(""%s No Session resumption, missing packets?\n"", G_STRFUNC)_",0
"            ssl_debug_printf(""%s Not using Session resumption\n"", G_STRFUNC)_",0
    if (is_from_server && session->is_session_resumed),0
"        expert_add_info(pinfo, ti, &hf->ei.resumed)_",0
/** Begin of handshake(22) record dissections */,0
"/* dissect a list of hash algorithms, return the number of bytes dissected",0
   this is used for the signature algorithms extension and for the,0
   TLS1.2 certificate request. {{{ */,0
"ssl_dissect_hash_alg_list(ssl_common_dissect_t *hf, tvbuff_t *tvb, proto_tree *tree,",0
"                          packet_info* pinfo, guint32 offset, guint16 len)",0
    guint32     offset_start_,0
"    proto_tree *subtree, *alg_tree_",0
    offset_start = offset_,0
    if (len==0),0
"    ti = proto_tree_add_none_format(tree, hf->hf.hs_sig_hash_algs, tvb,",0
"                                    offset, len,",0
"                                    ""Signature Hash Algorithms (%u algorithm%s)"",",0
"                                    len / 2, plurality(len / 2, """", ""s""))_",0
"    subtree = proto_item_add_subtree(ti, hf->ett.hs_sig_hash_algs)_",0
    if (len % 2) {,0
"        expert_add_info_format(pinfo, ti, &hf->ei.hs_sig_hash_algs_bad,",0
"                            ""Invalid Signature Hash Algorithm length: %d"", len)_",0
        return offset-offset_start_,0
    while (len > 0) {,0
"        ti = proto_tree_add_item(subtree, hf->hf.hs_sig_hash_alg,",0
"                                 tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"        alg_tree = proto_item_add_subtree(ti, hf->ett.hs_sig_hash_alg)_",0
"        proto_tree_add_item(alg_tree, hf->hf.hs_sig_hash_hash,",0
"                            tvb, offset, 1, ENC_BIG_ENDIAN)_",0
"        proto_tree_add_item(alg_tree, hf->hf.hs_sig_hash_sig,",0
"                            tvb, offset+1, 1, ENC_BIG_ENDIAN)_",0
        len -= 2_,0
    return offset-offset_start_,0
/** TLS Extensions (in Client Hello and Server Hello). {{{ */,0
"ssl_dissect_hnd_hello_ext_sig_hash_algs(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                        proto_tree *tree, packet_info* pinfo, guint32 offset, guint32 ext_len)",0
    guint16  sh_alg_length_,0
    gint     ret_,0
"    sh_alg_length = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_uint(tree, hf->hf.hs_sig_hash_alg_len,",0
"                        tvb, offset, 2, sh_alg_length)_",0
    offset += 2_,0
    if (ext_len < 2 || sh_alg_length != ext_len - 2) {,0
        /* ERROR: sh_alg_length must be 2 less than ext_len */,0
"    ret = ssl_dissect_hash_alg_list(hf, tvb, tree, pinfo, offset, sh_alg_length)_",0
    if (ret >= 0),0
        offset += ret_,0
"ssl_dissect_hnd_hello_ext_alpn(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                               proto_tree *tree, guint32 offset, guint32 ext_len,",0
"                               gboolean is_client, SslSession *session)",0
    guint16 alpn_length_,0
    guint8 name_length_,0
    proto_tree *alpn_tree_,0
"    alpn_length = tvb_get_ntohs(tvb, offset)_",0
    if (ext_len < 2 || alpn_length != ext_len - 2) {,0
        /* ERROR: alpn_length must be 2 less than ext_len */,0
"    proto_tree_add_item(tree, hf->hf.hs_ext_alpn_len,",0
"                        tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"    ti = proto_tree_add_item(tree, hf->hf.hs_ext_alpn_list,",0
"                             tvb, offset, alpn_length, ENC_NA)_",0
"    alpn_tree = proto_item_add_subtree(ti, hf->ett.hs_ext_alpn)_",0
"    /* If ALPN is given in ServerHello, then ProtocolNameList MUST contain",0
"     * exactly one ""ProtocolName"". */",0
    if (!is_client) {,0
        guint8 *proto_name_,0
        size_t i_,0
"        name_length = tvb_get_guint8(tvb, offset)_",0
        /* '\0'-terminated string for prefix/full string comparison purposes. */,0
"        proto_name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 1,",0
"                                        name_length, ENC_ASCII)_",0
        for (i = 0_ i < G_N_ELEMENTS(ssl_alpn_protocols)_ i++) {,0
            const ssl_alpn_protocol_t *alpn_proto = &ssl_alpn_protocols[i]_,0
            if (name_length >= alpn_proto->proto_name_len &&,0
"                (memcmp(proto_name, alpn_proto->proto_name,",0
                        alpn_proto->proto_name_len) == 0)) {,0
                dissector_handle_t handle_,0
"                /* ProtocolName match, so set the App data dissector handle.",0
"                 * This may override protocols given via the UAT dialog, but",0
"                 * since the ALPN hint is precise, do it anyway. */",0
                handle = find_dissector(alpn_proto->dissector_name)_,0
"                ssl_debug_printf(""%s: changing handle %p to %p (%s)"", G_STRFUNC,",0
"                                 (void *)session->app_handle,",0
"                                 (void *)handle, alpn_proto->dissector_name)_",0
"                /* if dissector is disabled, do not overwrite previous one */",0
                if (handle),0
                    session->app_handle = handle_,0
    while (alpn_length > 0) {,0
"        proto_tree_add_item(alpn_tree, hf->hf.hs_ext_alpn_str_len,",0
"                            tvb, offset, 1, ENC_NA)_",0
        alpn_length--_,0
"        proto_tree_add_item(alpn_tree, hf->hf.hs_ext_alpn_str,",0
"                            tvb, offset, name_length, ENC_ASCII|ENC_NA)_",0
        offset += name_length_,0
        alpn_length -= name_length_,0
"ssl_dissect_hnd_hello_ext_npn(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                              proto_tree *tree, guint32 offset, guint32 ext_len)",0
    guint8      npn_length_,0
    proto_tree *npn_tree_,0
    if (ext_len == 0) {,0
"    npn_tree = proto_tree_add_subtree(tree, tvb, offset, ext_len, hf->ett.hs_ext_npn, NULL, ""Next Protocol Negotiation"")_",0
    while (ext_len > 0) {,0
"        npn_length = tvb_get_guint8(tvb, offset)_",0
"        proto_tree_add_item(npn_tree, hf->hf.hs_ext_npn_str_len,",0
        ext_len--_,0
        if (npn_length > 0) {,0
"            proto_tree_add_item(npn_tree, hf->hf.hs_ext_npn_str,",0
"                                tvb, offset, npn_length, ENC_ASCII|ENC_NA)_",0
            offset += npn_length_,0
            ext_len -= npn_length_,0
"ssl_dissect_hnd_hello_ext_reneg_info(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                     proto_tree *tree, guint32 offset, guint32 ext_len)",0
    guint8      reneg_info_length_,0
    proto_tree *reneg_info_tree_,0
"    reneg_info_tree = proto_tree_add_subtree(tree, tvb, offset, ext_len, hf->ett.hs_ext_reneg_info, NULL, ""Renegotiation Info extension"")_",0
"    reneg_info_length = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(reneg_info_tree, hf->hf.hs_ext_reneg_info_len,",0
"              tvb, offset, 1, ENC_NA)_",0
    if (reneg_info_length > 0) {,0
"        proto_tree_add_item(reneg_info_tree, hf->hf.hs_ext_reneg_info, tvb, offset, reneg_info_length, ENC_NA)_",0
        offset += reneg_info_length_,0
"ssl_dissect_hnd_hello_ext_server_name(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                      proto_tree *tree, guint32 offset, guint32 ext_len)",0
    guint16     server_name_length_,0
    proto_tree *server_name_tree_,0
   if (ext_len == 0) {,0
       return offset_,0
   },0
"   server_name_tree = proto_tree_add_subtree(tree, tvb, offset, ext_len, hf->ett.hs_ext_server_name, NULL, ""Server Name Indication extension"")_",0
"   proto_tree_add_item(server_name_tree, hf->hf.hs_ext_server_name_list_len,",0
"                       tvb, offset, 2, ENC_BIG_ENDIAN)_",0
   offset += 2_,0
   ext_len -= 2_,0
   while (ext_len > 0) {,0
"       proto_tree_add_item(server_name_tree, hf->hf.hs_ext_server_name_type,",0
"                           tvb, offset, 1, ENC_NA)_",0
       offset += 1_,0
       ext_len -= 1_,0
"       server_name_length = tvb_get_ntohs(tvb, offset)_",0
"       proto_tree_add_item(server_name_tree, hf->hf.hs_ext_server_name_len,",0
"                           tvb, offset, 2, ENC_BIG_ENDIAN)_",0
       offset += 2_,0
       ext_len -= 2_,0
       if (server_name_length > 0) {,0
"           proto_tree_add_item(server_name_tree, hf->hf.hs_ext_server_name,",0
"                               tvb, offset, server_name_length, ENC_ASCII|ENC_NA)_",0
           offset += server_name_length_,0
           ext_len -= server_name_length_,0
   return offset_,0
"ssl_dissect_hnd_hello_ext_padding(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
    guint8      padding_length_,0
    proto_tree *padding_tree_,0
"    ti = proto_tree_add_item(tree, hf->hf.hs_ext_padding_data, tvb, offset, ext_len, ENC_NA)_",0
"    padding_tree = proto_item_add_subtree(ti, hf->ett.hs_ext_padding)_",0
"    proto_tree_add_item(padding_tree, hf->hf.hs_ext_padding_len, tvb, offset, 2, ENC_NA)_",0
"    padding_length = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(padding_tree, hf->hf.hs_ext_padding_data, tvb, offset, padding_length, ENC_NA)_",0
    offset += padding_length_,0
"ssl_dissect_hnd_hello_ext_session_ticket(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                      proto_tree *tree, guint32 offset, guint32 ext_len, gboolean is_client, SslDecryptSession *ssl)",0
    if (is_client && ssl && ext_len != 0) {,0
"        tvb_ensure_bytes_exist(tvb, offset, ext_len)_",0
        /* Save the Session Ticket such that it can be used as identifier for,0
         * restoring a previous Master Secret (in ChangeCipherSpec) */,0
"        ssl->session_ticket.data = (guchar*)wmem_realloc(wmem_file_scope(),",0
"                                    ssl->session_ticket.data, ext_len)_",0
        ssl->session_ticket.data_len = ext_len_,0
"        tvb_memcpy(tvb,ssl->session_ticket.data, offset, ext_len)_",0
"    proto_tree_add_bytes_format(tree, hf->hf.hs_ext_data,",0
"                                tvb, offset, ext_len, NULL,",0
"                                ""Data (%u byte%s)"",",0
"                                ext_len, plurality(ext_len, """", ""s""))_",0
    return offset + ext_len_,0
"ssl_dissect_hnd_hello_ext_cert_type(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                    proto_tree *tree, guint32 offset, guint32 ext_len,",0
"                                    gboolean is_client, guint16 ext_type, SslSession *session)",0
    guint8      cert_list_length_,0
    guint8      cert_type_,0
    proto_tree *cert_list_tree_,0
    if (is_client) {,0
"        cert_list_length = tvb_get_guint8(tvb, offset)_",0
"        proto_tree_add_item(tree, hf->hf.hs_ext_cert_types_len,",0
        offset += 1_,0
        if (ext_len != (guint32)cert_list_length + 1),0
"        ti = proto_tree_add_item(tree, hf->hf.hs_ext_cert_types, tvb, offset,",0
"                                 cert_list_length, cert_list_length)_",0
"        proto_item_append_text(ti, "" (%d)"", cert_list_length)_",0
        /* make this a subtree */,0
"        cert_list_tree = proto_item_add_subtree(ti, hf->ett.hs_ext_cert_types)_",0
        /* loop over all point formats */,0
        while (cert_list_length > 0),0
"            proto_tree_add_item(cert_list_tree, hf->hf.hs_ext_cert_type, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
            cert_list_length--_,0
"        cert_type = tvb_get_guint8(tvb, offset)_",0
"        proto_tree_add_item(tree, hf->hf.hs_ext_cert_type, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
        if (ext_type == SSL_HND_HELLO_EXT_CERT_TYPE || ext_type == SSL_HND_HELLO_EXT_CLIENT_CERT_TYPE) {,0
            session->client_cert_type = cert_type_,0
        if (ext_type == SSL_HND_HELLO_EXT_CERT_TYPE || ext_type == SSL_HND_HELLO_EXT_SERVER_CERT_TYPE) {,0
            session->server_cert_type = cert_type_,0
"ssl_dissect_hnd_hello_common(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                             proto_tree *tree, guint32 offset,",0
"                             SslDecryptSession *ssl, gboolean from_server)",0
    nstime_t     gmt_unix_time_,0
    guint8       sessid_length_,0
    proto_tree  *rnd_tree_,0
    if (ssl) {,0
        StringInfo *rnd_,0
        if (from_server),0
            rnd = &ssl->server_random_,0
            rnd = &ssl->client_random_,0
        /* save provided random for later keyring generation */,0
"        tvb_memcpy(tvb, rnd->data, offset, 32)_",0
        rnd->data_len = 32_,0
            ssl->state |= SSL_SERVER_RANDOM_,0
            ssl->state |= SSL_CLIENT_RANDOM_,0
"        ssl_debug_printf(""%s found %s RANDOM -> state 0x%02X\n"", G_STRFUNC,",0
"                from_server ? ""SERVER"" : ""CLIENT"", ssl->state)_",0
"    rnd_tree = proto_tree_add_subtree(tree, tvb, offset, 32,",0
"            hf->ett.hs_random, NULL, ""Random"")_",0
    /* show the time */,0
"    gmt_unix_time.secs  = tvb_get_ntohl(tvb, offset)_",0
    gmt_unix_time.nsecs = 0_,0
"    proto_tree_add_time(rnd_tree, hf->hf.hs_random_time,",0
"            tvb, offset, 4, &gmt_unix_time)_",0
    /* show the random bytes */,0
"    proto_tree_add_item(rnd_tree, hf->hf.hs_random_bytes,",0
"            tvb, offset, 28, ENC_NA)_",0
    offset += 28_,0
    /* show the session id (length followed by actual Session ID) */,0
"    sessid_length = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(tree, hf->hf.hs_session_id_len,",0
"            tvb, offset, 1, ENC_BIG_ENDIAN)_",0
        /* save the authorative SID for later use in ChangeCipherSpec.,0
"         * (D)TLS restricts the SID to 32 chars, it does not make sense to",0
"         * save more, so ignore larger ones. */",0
        if (from_server && sessid_length <= 32) {,0
"            tvb_memcpy(tvb, ssl->session_id.data, offset, sessid_length)_",0
            ssl->session_id.data_len = sessid_length_,0
    if (sessid_length > 0) {,0
"        proto_tree_add_item(tree, hf->hf.hs_session_id,",0
"                tvb, offset, sessid_length, ENC_NA)_",0
        offset += sessid_length_,0
"ssl_dissect_hnd_hello_ext_status_request(ssl_common_dissect_t *hf, tvbuff_t *tvb, proto_tree *tree,",0
"                                         guint32 offset, gboolean has_length)",0
    guint    cert_status_type_,0
"    cert_status_type = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(tree, hf->hf.hs_ext_cert_status_type,",0
"                        tvb, offset, 1, ENC_NA)_",0
    if (has_length) {,0
"        proto_tree_add_item(tree, hf->hf.hs_ext_cert_status_request_len,",0
"                            tvb, offset, 2, ENC_BIG_ENDIAN)_",0
    switch (cert_status_type) {,0
    case SSL_HND_CERT_STATUS_TYPE_OCSP:,0
    case SSL_HND_CERT_STATUS_TYPE_OCSP_MULTI:,0
            guint16      responder_id_list_len_,0
            guint16      request_extensions_len_,0
            proto_item  *responder_id_,0
            proto_item  *request_extensions_,0
"            responder_id_list_len = tvb_get_ntohs(tvb, offset)_",0
            responder_id =,0
"                proto_tree_add_item(tree,",0
"                                    hf->hf.hs_ext_cert_status_responder_id_list_len,",0
"                                    tvb, offset, 2, ENC_BIG_ENDIAN)_",0
            if (responder_id_list_len != 0) {,0
"                expert_add_info_format(NULL, responder_id,",0
"                                       &hf->ei.hs_ext_cert_status_undecoded,",0
"                                       ""Responder ID list is not implemented, contact Wireshark""",0
"                                       "" developers if you want this to be supported"")_",0
                /* Non-empty responder ID list would mess with extensions. */,0
"            request_extensions_len = tvb_get_ntohs(tvb, offset)_",0
            request_extensions =,0
"                                    hf->hf.hs_ext_cert_status_request_extensions_len, tvb, offset,",0
"                                    2, ENC_BIG_ENDIAN)_",0
            if (request_extensions_len != 0),0
"                expert_add_info_format(NULL, request_extensions,",0
"                                       ""Request Extensions are not implemented, contact""",0
"                                       "" Wireshark developers if you want this to be supported"")_",0
"ssl_dissect_hnd_hello_ext_status_request_v2(ssl_common_dissect_t *hf, tvbuff_t *tvb, proto_tree *tree,",0
                                            guint32 offset),0
    gint32   list_len_,0
"    list_len = tvb_get_ntohs(tvb, offset)_",0
    while (list_len > 0) {,0
        guint32 prev_offset = offset_,0
"        offset = ssl_dissect_hnd_hello_ext_status_request(hf, tvb, tree, offset, TRUE)_",0
        list_len -= (offset - prev_offset)_,0
"ssl_dissect_hnd_hello_ext_elliptic_curves(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                          proto_tree *tree, guint32 offset)",0
    guint16     curves_length_,0
    proto_tree *curves_tree_,0
"    curves_length = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(tree, hf->hf.hs_ext_elliptic_curves_len,",0
"    ti = proto_tree_add_none_format(tree,",0
"                                    hf->hf.hs_ext_elliptic_curves,",0
"                                    tvb, offset, curves_length,",0
"                                    ""Elliptic curves (%d curve%s)"",",0
"                                    curves_length / 2,",0
"                                    plurality(curves_length/2, """", ""s""))_",0
    /* make this a subtree */,0
"    curves_tree = proto_item_add_subtree(ti, hf->ett.hs_ext_curves)_",0
    /* loop over all curves */,0
    while (curves_length > 0),0
"        proto_tree_add_item(curves_tree, hf->hf.hs_ext_elliptic_curve, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
        curves_length -= 2_,0
"ssl_dissect_hnd_hello_ext_ec_point_formats(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                           proto_tree *tree, guint32 offset)",0
    guint8      ecpf_length_,0
    proto_tree *ecpf_tree_,0
"    ecpf_length = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(tree, hf->hf.hs_ext_ec_point_formats_len,",0
"        tvb, offset, 1, ENC_BIG_ENDIAN)_",0
"                                    tvb, offset, ecpf_length,",0
"                                    ""Elliptic curves point formats (%d)"",",0
                                    ecpf_length)_,0
"    ecpf_tree = proto_item_add_subtree(ti, hf->ett.hs_ext_curves_point_formats)_",0
    /* loop over all point formats */,0
    while (ecpf_length > 0),0
"        proto_tree_add_item(ecpf_tree, hf->hf.hs_ext_ec_point_format, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
        ecpf_length--_,0
/** TLS Extensions (in Client Hello and Server Hello). }}} */,0
/* Whether the Content and Handshake Types are valid_ handle Protocol Version. {{{ */,0
ssl_is_valid_content_type(guint8 type),0
    switch ((ContentType) type) {,0
    case SSL_ID_CHG_CIPHER_SPEC:,0
    case SSL_ID_ALERT:,0
    case SSL_ID_HANDSHAKE:,0
    case SSL_ID_APP_DATA:,0
    case SSL_ID_HEARTBEAT:,0
"ssl_is_valid_handshake_type(guint8 hs_type, gboolean is_dtls)",0
    switch ((HandshakeType) hs_type) {,0
    case SSL_HND_HELLO_VERIFY_REQUEST:,0
        /* hello_verify_request is DTLS-only */,0
        return is_dtls_,0
    case SSL_HND_HELLO_REQUEST:,0
    case SSL_HND_CLIENT_HELLO:,0
    case SSL_HND_SERVER_HELLO:,0
    case SSL_HND_NEWSESSION_TICKET:,0
    case SSL_HND_CERTIFICATE:,0
    case SSL_HND_SERVER_KEY_EXCHG:,0
    case SSL_HND_CERT_REQUEST:,0
    case SSL_HND_SVR_HELLO_DONE:,0
    case SSL_HND_CERT_VERIFY:,0
    case SSL_HND_CLIENT_KEY_EXCHG:,0
    case SSL_HND_FINISHED:,0
    case SSL_HND_CERT_URL:,0
    case SSL_HND_CERT_STATUS:,0
    case SSL_HND_SUPPLEMENTAL_DATA:,0
    case SSL_HND_ENCRYPTED_EXTS:,0
"ssl_is_authoritative_version_message(guint8 content_type, guint8 handshake_type,",0
                                     gboolean is_dtls),0
    /* Consider all valid Handshake messages (except for Client Hello) and,0
     * all other valid record types (other than Handshake) */,0
    return (content_type == SSL_ID_HANDSHAKE &&,0
"            ssl_is_valid_handshake_type(handshake_type, is_dtls) &&",0
            handshake_type != SSL_HND_CLIENT_HELLO) ||,0
           (content_type != SSL_ID_HANDSHAKE &&,0
            ssl_is_valid_content_type(content_type))_,0
"ssl_try_set_version(SslSession *session, SslDecryptSession *ssl,",0
"                    guint8 content_type, guint8 handshake_type,",0
"                    gboolean is_dtls, guint16 version)",0
"    if (!ssl_is_authoritative_version_message(content_type, handshake_type,",0
                is_dtls)),0
    switch (version) {,0
    case TLSV1DOT2_VERSION:,0
        if (is_dtls),0
    case DTLSV1DOT2_VERSION:,0
        if (!is_dtls),0
    default: /* invalid version number */,0
    session->version = version_,0
        ssl->state |= SSL_VERSION_,0
"        ssl_debug_printf(""%s found version 0x%04X -> state 0x%02X\n"", G_STRFUNC, version, ssl->state)_",0
/* Client Hello and Server Hello dissections. {{{ */,0
"ssl_dissect_hnd_hello_ext(ssl_common_dissect_t *hf, tvbuff_t *tvb, proto_tree *tree,",0
"                          packet_info* pinfo, guint32 offset, guint32 left, gboolean is_client,",0
"                          SslSession *session, SslDecryptSession *ssl)_",0
"ssl_dissect_hnd_cli_hello(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                          packet_info *pinfo, proto_tree *tree, guint32 offset,",0
"                          guint32 length, SslSession *session,",0
"                          SslDecryptSession *ssl, dtls_hfs_t *dtls_hfs)",0
    /* struct {,0
     *     ProtocolVersion client_version_,0
     *     Random random_,0
     *     SessionID session_id_,0
     *     opaque cookie<0..32>_                   //new field for DTLS,0
     *     CipherSuite cipher_suites<2..2^16-1>_,0
     *     CompressionMethod compression_methods<1..2^8-1>_,0
     *     Extension client_hello_extension_list<0..2^16-1>_,0
     * } ClientHello_,0
    proto_tree *cs_tree_,0
    guint16     cipher_suite_length_,0
    guint8      compression_methods_length_,0
    guint8      compression_method_,0
    guint16     start_offset = offset_,0
    /* show the client version */,0
"    proto_tree_add_item(tree, hf->hf.hs_client_version, tvb,",0
"                        offset, 2, ENC_BIG_ENDIAN)_",0
    /* dissect fields that are also present in ClientHello */,0
"    offset = ssl_dissect_hnd_hello_common(hf, tvb, tree, offset, ssl, FALSE)_",0
"    /* fields specific for DTLS (cookie_len, cookie) */",0
    if (dtls_hfs != NULL) {,0
        /* look for a cookie */,0
"        guint8 cookie_length = tvb_get_guint8(tvb, offset)_",0
"        proto_tree_add_uint(tree, dtls_hfs->hf_dtls_handshake_cookie_len,",0
"                            tvb, offset, 1, cookie_length)_",0
        if (cookie_length > 0) {,0
"            proto_tree_add_item(tree, dtls_hfs->hf_dtls_handshake_cookie,",0
"                                tvb, offset, cookie_length, ENC_NA)_",0
            offset += cookie_length_,0
    /* tell the user how many cipher suites there are */,0
"    cipher_suite_length = tvb_get_ntohs(tvb, offset)_",0
"    ti = proto_tree_add_item(tree, hf->hf.hs_cipher_suites_len,",0
"                             tvb, offset, 2, ENC_BIG_ENDIAN)_",0
    if (cipher_suite_length > 0) {,0
        if (cipher_suite_length % 2) {,0
"            expert_add_info_format(pinfo, ti, &hf->ei.hs_cipher_suites_len_bad,",0
"                ""Cipher suite length (%d) must be a multiple of 2"",",0
                cipher_suite_length)_,0
"        ti = proto_tree_add_none_format(tree,",0
"                                        hf->hf.hs_cipher_suites,",0
"                                        tvb, offset, cipher_suite_length,",0
"                                        ""Cipher Suites (%d suite%s)"",",0
"                                        cipher_suite_length / 2,",0
"                                        plurality(cipher_suite_length/2, """", ""s""))_",0
"        cs_tree = proto_item_add_subtree(ti, hf->ett.cipher_suites)_",0
        while (cipher_suite_length > 0) {,0
"            proto_tree_add_item(cs_tree, hf->hf.hs_cipher_suite,",0
"                                tvb, offset, 2, ENC_BIG_ENDIAN)_",0
            cipher_suite_length -= 2_,0
    /* tell the user how many compression methods there are */,0
"    compression_methods_length = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_uint(tree, hf->hf.hs_comp_methods_len,",0
"                        tvb, offset, 1, compression_methods_length)_",0
    if (compression_methods_length > 0) {,0
"                                        hf->hf.hs_comp_methods,",0
"                                        tvb, offset, compression_methods_length,",0
"                                        ""Compression Methods (%u method%s)"",",0
"                                        compression_methods_length,",0
"                                        plurality(compression_methods_length,",0
"                                          """", ""s""))_",0
"        cs_tree = proto_item_add_subtree(ti, hf->ett.comp_methods)_",0
        while (compression_methods_length > 0) {,0
"            compression_method = tvb_get_guint8(tvb, offset)_",0
            /* TODO: make reserved/private comp meth. fields selectable */,0
            if (compression_method < 64),0
"                proto_tree_add_uint(cs_tree, hf->hf.hs_comp_method,",0
"                                    tvb, offset, 1, compression_method)_",0
            else if (compression_method > 63 && compression_method < 193),0
"                proto_tree_add_uint_format_value(cs_tree, hf->hf.hs_comp_method, tvb, offset, 1,",0
"                                    compression_method, ""Reserved - to be assigned by IANA (%u)"",",0
                                    compression_method)_,0
"                                    compression_method, ""Private use range (%u)"",",0
            compression_methods_length--_,0
    if (length > offset - start_offset) {,0
"        ssl_dissect_hnd_hello_ext(hf, tvb, tree, pinfo, offset,",0
"                                  length - (offset - start_offset), TRUE,",0
"                                  session, ssl)_",0
"ssl_dissect_hnd_srv_hello(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                          packet_info* pinfo, proto_tree *tree, guint32 offset, guint32 length,",0
"                          SslSession *session, SslDecryptSession *ssl,",0
                          gboolean is_dtls),0
     *     ProtocolVersion server_version_,0
     *     CipherSuite cipher_suite_,0
     *     CompressionMethod compression_method_,0
     *     Extension server_hello_extension_list<0..2^16-1>_,0
     * } ServerHello_,0
    guint16 start_offset = offset_,0
    /* This version is always better than the guess at the Record Layer */,0
"    ssl_try_set_version(session, ssl, SSL_ID_HANDSHAKE, SSL_HND_SERVER_HELLO,",0
"            is_dtls, tvb_get_ntohs(tvb, offset))_",0
    /* show the server version */,0
"    proto_tree_add_item(tree, hf->hf.hs_server_version, tvb,",0
"    offset = ssl_dissect_hnd_hello_common(hf, tvb, tree, offset, ssl, TRUE)_",0
        /* store selected cipher suite for decryption */,0
"        ssl->session.cipher = tvb_get_ntohs(tvb, offset)_",0
        if (!(ssl->cipher_suite = ssl_find_cipher(ssl->session.cipher))) {,0
            ssl->state &= ~SSL_CIPHER_,0
"            ssl_debug_printf(""%s can't find cipher suite 0x%04X\n"",",0
"                             G_STRFUNC, ssl->session.cipher)_",0
"            /* Cipher found, save this for the delayed decoder init */",0
            ssl->state |= SSL_CIPHER_,0
"            ssl_debug_printf(""%s found CIPHER 0x%04X %s -> state 0x%02X\n"",",0
"                             G_STRFUNC, ssl->session.cipher,",0
"                             val_to_str_ext_const(ssl->session.cipher,",0
"                                 &ssl_31_ciphersuite_ext, ""unknown""),",0
                             ssl->state)_,0
    /* now the server-selected cipher suite */,0
"    proto_tree_add_item(tree, hf->hf.hs_cipher_suite,",0
        /* store selected compression method for decryption */,0
"        ssl->session.compression = tvb_get_guint8(tvb, offset)_",0
    /* and the server-selected compression method */,0
"    proto_tree_add_item(tree, hf->hf.hs_comp_method,",0
"                        tvb, offset, 1, ENC_BIG_ENDIAN)_",0
    /* remaining data are extensions */,0
"                                  length - (offset - start_offset), FALSE,",0
/* Client Hello and Server Hello dissections. }}} */,0
/* New Session Ticket dissection. {{{ */,0
"ssl_dissect_hnd_new_ses_ticket(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                               proto_tree *tree, guint32 offset,",0
"                               SslDecryptSession *ssl _U_,",0
                               GHashTable *session_hash _U_),0
    proto_tree  *subtree_,0
    guint16      ticket_len_,0
"    /* length of session ticket, may be 0 if the server has sent the",0
"     * SessionTicket extension, but decides not to use one. */",0
"    ticket_len = tvb_get_ntohs(tvb, offset + 4)_",0
"    subtree = proto_tree_add_subtree(tree, tvb, offset, 6 + ticket_len,",0
"                                     hf->ett.session_ticket, NULL,",0
"                                     ""TLS Session Ticket"")_",0
    /* ticket lifetime hint */,0
"    proto_tree_add_item(subtree, hf->hf.hs_session_ticket_lifetime_hint,",0
"                        tvb, offset, 4, ENC_BIG_ENDIAN)_",0
"    /* opaque ticket (length, data) */",0
"    proto_tree_add_item(subtree, hf->hf.hs_session_ticket_len,",0
"    /* Content depends on implementation, so just show data! */",0
"    proto_tree_add_item(subtree, hf->hf.hs_session_ticket,",0
"                        tvb, offset, ticket_len, ENC_NA)_",0
    /* save the session ticket to cache for ssl_finalize_decryption */,0
"        tvb_ensure_bytes_exist(tvb, offset, ticket_len)_",0
"                                    ssl->session_ticket.data, ticket_len)_",0
        ssl->session_ticket.data_len = ticket_len_,0
"        tvb_memcpy(tvb, ssl->session_ticket.data, offset, ticket_len)_",0
        /* NewSessionTicket is received after the first (client),0
"         * ChangeCipherSpec, and before the second (server) ChangeCipherSpec.",0
         * Since the second CCS has already the session key available it will,0
         * just return. To ensure that the session ticket is mapped to a,0
"         * master key (from the first CCS), save the ticket here too. */",0
"        ssl_save_master_key(""Session Ticket"", session_hash,",0
        ssl->state |= SSL_NEW_SESSION_TICKET_,0
/* Certificate and Certificate Request dissections. {{{ */,0
"ssl_dissect_hnd_cert(ssl_common_dissect_t *hf, tvbuff_t *tvb, proto_tree *tree,",0
"                     guint32 offset, packet_info *pinfo,",0
"                     const SslSession *session, SslDecryptSession *ssl _U_,",0
"                     GHashTable *key_hash _U_, gint is_from_server)",0
    /* opaque ASN.1Cert<1..2^24-1>_,0
     *     select(certificate_type) {,0
     *         // certificate type defined in RFC 7250,0
     *         case RawPublicKey:,0
     *           opaque ASN.1_subjectPublicKeyInfo<1..2^24-1>_,0
     *         // X.509 certificate defined in RFC 5246,0
     *         case X.509:,0
     *           ASN.1Cert certificate_list<0..2^24-1>_,0
     *     }_,0
     * } Certificate_,0
"    enum { CERT_X509, CERT_RPK } cert_type_",0
    asn1_ctx_t  asn1_ctx_,0
"    gnutls_datum_t subjectPublicKeyInfo = { NULL, 0 }_",0
"    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo)_",0
    if ((is_from_server && session->server_cert_type == SSL_HND_CERT_TYPE_RAW_PUBLIC_KEY) ||,0
        (!is_from_server && session->client_cert_type == SSL_HND_CERT_TYPE_RAW_PUBLIC_KEY)) {,0
        cert_type = CERT_RPK_,0
        cert_type = CERT_X509_,0
    /* Ask the pkcs1 dissector to return the public key details */,0
    if (ssl),0
        asn1_ctx.private_data = &subjectPublicKeyInfo_,0
    switch (cert_type) {,0
    case CERT_RPK:,0
"            proto_tree_add_item(tree, hf->hf.hs_certificate_len,",0
"                                tvb, offset, 3, ENC_BIG_ENDIAN)_",0
"            dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, tree, hf->hf.hs_certificate)_",0
    case CERT_X509:,0
            guint32     certificate_list_length_,0
            proto_item *ti_,0
            proto_tree *subtree_,0
"            certificate_list_length = tvb_get_ntoh24(tvb, offset)_",0
"            proto_tree_add_uint(tree, hf->hf.hs_certificates_len,",0
"                                tvb, offset, 3, certificate_list_length)_",0
            offset += 3_            /* 24-bit length value */,0
            if (certificate_list_length > 0) {,0
"                ti = proto_tree_add_none_format(tree,",0
"                                                hf->hf.hs_certificates,",0
"                                                tvb, offset, certificate_list_length,",0
"                                                ""Certificates (%u bytes)"",",0
                                                certificate_list_length)_,0
                /* make it a subtree */,0
"                subtree = proto_item_add_subtree(ti, hf->ett.certificates)_",0
                /* iterate through each certificate */,0
                while (certificate_list_length > 0) {,0
                    /* get the length of the current certificate */,0
                    guint32 cert_length_,0
"                    cert_length = tvb_get_ntoh24(tvb, offset)_",0
                    certificate_list_length -= 3 + cert_length_,0
"                    proto_tree_add_item(subtree, hf->hf.hs_certificate_len,",0
"                                        tvb, offset, 3, ENC_BIG_ENDIAN)_",0
                    offset += 3_,0
"                    dissect_x509af_Certificate(FALSE, tvb, offset, &asn1_ctx, subtree, hf->hf.hs_certificate)_",0
                    /* Only attempt to get the RSA modulus for the first cert. */,0
                    asn1_ctx.private_data = NULL_,0
                    offset += cert_length_,0
    if (is_from_server && ssl),0
"        ssl_find_private_key_by_pubkey(ssl, key_hash, &subjectPublicKeyInfo)_",0
"ssl_dissect_hnd_cert_req(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                          proto_tree *tree, guint32 offset, packet_info *pinfo,",0
                          const SslSession *session),0
     *    enum {,0
"     *        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),",0
     *        (255),0
     *    } ClientCertificateType_,0
     *    opaque DistinguishedName<1..2^16-1>_,0
     *    struct {,0
     *        ClientCertificateType certificate_types<1..2^8-1>_,0
     *        DistinguishedName certificate_authorities<3..2^16-1>_,0
     *    } CertificateRequest_,0
     * As per TLSv1.2 (RFC 5246) the format has changed to:,0
"     *        rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),",0
"     *        fortezza_dms_RESERVED(20), (255)",0
"     *        none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),",0
"     *        sha512(6), (255)",0
     *    } HashAlgorithm_,0
"     *    enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }",0
     *      SignatureAlgorithm_,0
     *          HashAlgorithm hash_,0
     *          SignatureAlgorithm signature_,0
     *    } SignatureAndHashAlgorithm_,0
     *    SignatureAndHashAlgorithm,0
     *      supported_signature_algorithms<2..2^16-2>_,0
     *        SignatureAndHashAlgorithm,0
     *          supported_signature_algorithms<2^16-1>_,0
     *        DistinguishedName certificate_authorities<0..2^16-1>_,0
    proto_tree *subtree_,0
    guint8      cert_types_count_,0
    gint        sh_alg_length_,0
    gint        dnames_length_,0
    gint        ret_,0
    if (!tree),0
"    cert_types_count = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_uint(tree, hf->hf.hs_cert_types_count,",0
"            tvb, offset, 1, cert_types_count)_",0
    if (cert_types_count > 0) {,0
"                hf->hf.hs_cert_types,",0
"                tvb, offset, cert_types_count,",0
"                ""Certificate types (%u type%s)"",",0
"                cert_types_count,",0
"                plurality(cert_types_count, """", ""s""))_",0
"        subtree = proto_item_add_subtree(ti, hf->ett.cert_types)_",0
        while (cert_types_count > 0) {,0
"            proto_tree_add_item(subtree, hf->hf.hs_cert_type,",0
"                    tvb, offset, 1, ENC_BIG_ENDIAN)_",0
            cert_types_count--_,0
    switch (session->version) {,0
"            sh_alg_length = tvb_get_ntohs(tvb, offset)_",0
            if (sh_alg_length % 2) {,0
"                expert_add_info_format(pinfo, NULL,",0
"                        &hf->ei.hs_sig_hash_alg_len_bad,",0
"                        ""Signature Hash Algorithm length (%d) must be a multiple of 2"",",0
                        sh_alg_length)_,0
"            proto_tree_add_uint(tree, hf->hf.hs_sig_hash_alg_len,",0
"                    tvb, offset, 2, sh_alg_length)_",0
"            ret = ssl_dissect_hash_alg_list(hf, tvb, tree, pinfo, offset, sh_alg_length)_",0
            if (ret >= 0),0
                offset += ret_,0
"    dnames_length = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_uint(tree, hf->hf.hs_dnames_len,",0
"            tvb, offset, 2, dnames_length)_",0
    if (dnames_length > 0) {,0
"                hf->hf.hs_dnames,",0
"                tvb, offset, dnames_length,",0
"                ""Distinguished Names (%d byte%s)"",",0
"                dnames_length,",0
"                plurality(dnames_length, """", ""s""))_",0
"        subtree = proto_item_add_subtree(ti, hf->ett.dnames)_",0
        while (dnames_length > 0) {,0
            /* get the length of the current certificate */,0
            guint16 name_length_,0
"            name_length = tvb_get_ntohs(tvb, offset)_",0
            dnames_length -= 2 + name_length_,0
"            proto_tree_add_item(subtree, hf->hf.hs_dname_len,",0
"                    tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"            dissect_x509if_DistinguishedName(FALSE, tvb, offset, &asn1_ctx,",0
"                                             subtree, hf->hf.hs_dname)_",0
            offset += name_length_,0
/* Certificate and Certificate Request dissections. }}} */,0
"ssl_dissect_digitally_signed(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                             const SslSession *session,",0
"                             gint hf_sig_len, gint hf_sig)_",0
"ssl_dissect_hnd_cli_cert_verify(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                proto_tree *tree, guint32 offset,",0
                                const SslSession *session),0
"    ssl_dissect_digitally_signed(hf, tvb, tree, offset, session,",0
"                                 hf->hf.hs_client_cert_vrfy_sig_len,",0
                                 hf->hf.hs_client_cert_vrfy_sig)_,0
/* Finished dissection. {{{ */,0
"ssl_dissect_hnd_finished(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                         proto_tree *tree, guint32 offset,",0
"                         const SslSession *session, ssl_hfs_t *ssl_hfs)",0
    /* For SSLv3:,0
     *     struct {,0
     *         opaque md5_hash[16]_,0
     *         opaque sha_hash[20]_,0
     *     } Finished_,0
     * For (D)TLS:,0
     *         opaque verify_data[12]_,0
    if (session->version == SSLV3_VERSION) {,0
        if (ssl_hfs != NULL) {,0
"            proto_tree_add_item(tree, ssl_hfs->hs_md5_hash,",0
"                                tvb, offset, 16, ENC_NA)_",0
"            proto_tree_add_item(tree, ssl_hfs->hs_sha_hash,",0
"                                tvb, offset + 16, 20, ENC_NA)_",0
"        proto_tree_add_item(tree, hf->hf.hs_finished,",0
"                            tvb, offset, 12, ENC_NA)_",0
/* RFC 6066 Certificate URL handshake message dissection. {{{ */,0
"ssl_dissect_hnd_cert_url(ssl_common_dissect_t *hf, tvbuff_t *tvb, proto_tree *tree, guint32 offset)",0
    guint16  url_hash_len_,0
    /* enum {,0
"     *     individual_certs(0), pkipath(1), (255)",0
     * } CertChainType_,0
     *     CertChainType type_,0
     *     URLAndHash url_and_hash_list<1..2^16-1>_,0
     * } CertificateURL_,0
     *     opaque url<1..2^16-1>_,0
     *     unint8 padding_,0
     *     opaque SHA1Hash[20]_,0
     * } URLAndHash_,0
"    proto_tree_add_item(tree, hf->hf.hs_ext_cert_url_type,",0
"    url_hash_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(tree, hf->hf.hs_ext_cert_url_url_hash_list_len,",0
    while (url_hash_len-- > 0) {,0
        proto_item  *urlhash_item_,0
        proto_tree  *urlhash_tree_,0
        guint16      url_len_,0
"        urlhash_item = proto_tree_add_item(tree, hf->hf.hs_ext_cert_url_item,",0
"                                           tvb, offset, -1, ENC_NA)_",0
"        urlhash_tree = proto_item_add_subtree(urlhash_item, hf->ett.urlhash)_",0
"        url_len = tvb_get_ntohs(tvb, offset)_",0
"        proto_tree_add_item(urlhash_tree, hf->hf.hs_ext_cert_url_url_len,",0
"        proto_tree_add_item(urlhash_tree, hf->hf.hs_ext_cert_url_url,",0
"                            tvb, offset, url_len, ENC_ASCII|ENC_NA)_",0
        offset += url_len_,0
"        proto_tree_add_item(urlhash_tree, hf->hf.hs_ext_cert_url_padding,",0
        /* Note: RFC 6066 says that padding must be 0x01 */,0
"        proto_tree_add_item(urlhash_tree, hf->hf.hs_ext_cert_url_sha1,",0
"                            tvb, offset, 20, ENC_NA)_",0
        offset += 20_,0
/* Client Hello and Server Hello TLS extensions dissection. {{{ */,0
"                          SslSession *session, SslDecryptSession *ssl)",0
    guint16     extension_length_,0
    guint16     ext_type_,0
    guint16     ext_len_,0
    proto_tree *ext_tree_,0
    if (left < 2),0
"    extension_length = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_uint(tree, hf->hf.hs_exts_len,",0
"                        tvb, offset, 2, extension_length)_",0
    left   -= 2_,0
    while (left >= 4),0
"        ext_type = tvb_get_ntohs(tvb, offset)_",0
"        ext_len  = tvb_get_ntohs(tvb, offset + 2)_",0
"        ext_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4 + ext_len, hf->ett.hs_ext, NULL,",0
"                                            tls_hello_extension_types,",0
"                                            ""Unknown %u""))_",0
"        proto_tree_add_uint(ext_tree, hf->hf.hs_ext_type,",0
"                            tvb, offset, 2, ext_type)_",0
"        proto_tree_add_uint(ext_tree, hf->hf.hs_ext_len,",0
"                            tvb, offset, 2, ext_len)_",0
        switch (ext_type) {,0
        case SSL_HND_HELLO_EXT_STATUS_REQUEST:,0
            if (is_client),0
"                offset = ssl_dissect_hnd_hello_ext_status_request(hf, tvb, ext_tree, offset, FALSE)_",0
                offset += ext_len_ /* server must return empty extension_data */,0
        case SSL_HND_HELLO_EXT_STATUS_REQUEST_V2:,0
"                offset = ssl_dissect_hnd_hello_ext_status_request_v2(hf, tvb, ext_tree, offset)_",0
        case SSL_HND_HELLO_EXT_ELLIPTIC_CURVES:,0
"            offset = ssl_dissect_hnd_hello_ext_elliptic_curves(hf, tvb, ext_tree, offset)_",0
        case SSL_HND_HELLO_EXT_EC_POINT_FORMATS:,0
"            offset = ssl_dissect_hnd_hello_ext_ec_point_formats(hf, tvb, ext_tree, offset)_",0
        case SSL_HND_HELLO_EXT_SIG_HASH_ALGS:,0
"            offset = ssl_dissect_hnd_hello_ext_sig_hash_algs(hf, tvb, ext_tree, pinfo, offset, ext_len)_",0
        case SSL_HND_HELLO_EXT_ALPN:,0
"            offset = ssl_dissect_hnd_hello_ext_alpn(hf, tvb, ext_tree, offset, ext_len, is_client, session)_",0
        case SSL_HND_HELLO_EXT_NPN:,0
"            offset = ssl_dissect_hnd_hello_ext_npn(hf, tvb, ext_tree, offset, ext_len)_",0
        case SSL_HND_HELLO_EXT_RENEG_INFO:,0
"            offset = ssl_dissect_hnd_hello_ext_reneg_info(hf, tvb, ext_tree, offset, ext_len)_",0
        case SSL_HND_HELLO_EXT_SERVER_NAME:,0
"            offset = ssl_dissect_hnd_hello_ext_server_name(hf, tvb, ext_tree, offset, ext_len)_",0
        case SSL_HND_HELLO_EXT_HEARTBEAT:,0
"            proto_tree_add_item(ext_tree, hf->hf.hs_ext_heartbeat_mode,",0
"                                tvb, offset, 1, ENC_BIG_ENDIAN)_",0
            offset += ext_len_,0
        case SSL_HND_HELLO_EXT_PADDING:,0
"            offset = ssl_dissect_hnd_hello_ext_padding(hf, tvb, ext_tree, offset, ext_len)_",0
        case SSL_HND_HELLO_EXT_SESSION_TICKET:,0
"            offset = ssl_dissect_hnd_hello_ext_session_ticket(hf, tvb, ext_tree, offset, ext_len, is_client, ssl)_",0
        case SSL_HND_HELLO_EXT_CERT_TYPE:,0
        case SSL_HND_HELLO_EXT_SERVER_CERT_TYPE:,0
        case SSL_HND_HELLO_EXT_CLIENT_CERT_TYPE:,0
"            offset = ssl_dissect_hnd_hello_ext_cert_type(hf, tvb, ext_tree,",0
"                                                         offset, ext_len,",0
"                                                         is_client, ext_type,",0
                                                         session)_,0
        case SSL_HND_HELLO_EXT_EXTENDED_MASTER_SECRET_TYPE:,0
            if (ssl),0
                ssl->state |= (is_client ? SSL_CLIENT_EXTENDED_MASTER_SECRET : SSL_SERVER_EXTENDED_MASTER_SECRET)_,0
"            proto_tree_add_item(ext_tree, hf->hf.hs_ext_data,",0
"                                        tvb, offset, ext_len, ENC_NA)_",0
        left -= 2 + 2 + ext_len_,0
/* ClientKeyExchange algo-specific dissectors. {{{ */,0
"dissect_ssl3_hnd_cli_keyex_ecdh(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
                                guint32 length),0
    gint        point_len_,0
    proto_tree *ssl_ecdh_tree_,0
"    ssl_ecdh_tree = proto_tree_add_subtree(tree, tvb, offset, length,",0
"                                  hf->ett.keyex_params, NULL, ""EC Diffie-Hellman Client Params"")_",0
    /* point */,0
"    point_len = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(ssl_ecdh_tree, hf->hf.hs_client_keyex_point_len, tvb,",0
"                        offset, 1, ENC_BIG_ENDIAN)_",0
"    proto_tree_add_item(ssl_ecdh_tree, hf->hf.hs_client_keyex_point, tvb,",0
"                        offset + 1, point_len, ENC_NA)_",0
"dissect_ssl3_hnd_cli_keyex_dh(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                              proto_tree *tree, guint32 offset, guint32 length)",0
    gint        yc_len_,0
    proto_tree *ssl_dh_tree_,0
"    ssl_dh_tree = proto_tree_add_subtree(tree, tvb, offset, length,",0
"                                hf->ett.keyex_params, NULL, ""Diffie-Hellman Client Params"")_",0
    /* ClientDiffieHellmanPublic.dh_public (explicit) */,0
"    yc_len  = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_client_keyex_yc_len, tvb,",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_client_keyex_yc, tvb,",0
"                        offset + 2, yc_len, ENC_NA)_",0
"dissect_ssl3_hnd_cli_keyex_rsa(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                               guint32 length, const SslSession *session)",0
    gint        epms_len_,0
    proto_tree *ssl_rsa_tree_,0
"    ssl_rsa_tree = proto_tree_add_subtree(tree, tvb, offset, length,",0
"                                 hf->ett.keyex_params, NULL, ""RSA Encrypted PreMaster Secret"")_",0
    /* EncryptedPreMasterSecret.pre_master_secret */,0
    case SSLV2_VERSION:,0
        /* OpenSSL pre-0.9.8f DTLS and pre-TLS quirk: 2-octet length vector is,0
"         * not present. The handshake contents represents the EPMS, see:",0
         * https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=10222 */,0
        epms_len = length_,0
        /* TLS and DTLS include vector length before EPMS */,0
"        epms_len = tvb_get_ntohs(tvb, offset)_",0
"        proto_tree_add_item(ssl_rsa_tree, hf->hf.hs_client_keyex_epms_len, tvb,",0
"                            offset, 2, ENC_BIG_ENDIAN)_",0
"    proto_tree_add_item(ssl_rsa_tree, hf->hf.hs_client_keyex_epms, tvb,",0
"                        offset, epms_len, ENC_NA)_",0
/* Used in PSK cipher suites */,0
"dissect_ssl3_hnd_cli_keyex_psk(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                               proto_tree *tree, guint32 offset, guint32 length)",0
    guint        identity_len_,0
    proto_tree *ssl_psk_tree_,0
"    ssl_psk_tree = proto_tree_add_subtree(tree, tvb, offset, length,",0
"                                 hf->ett.keyex_params, NULL, ""PSK Client Params"")_",0
    /* identity */,0
"    identity_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_client_keyex_identity_len, tvb,",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_client_keyex_identity, tvb,",0
"                        offset + 2, identity_len, ENC_NA)_",0
/* Used in RSA PSK cipher suites */,0
"dissect_ssl3_hnd_cli_keyex_rsa_psk(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                   proto_tree *tree, guint32 offset,",0
                                   guint32 length),0
"    gint        identity_len, epms_len_",0
"                                 hf->ett.keyex_params, NULL, ""RSA PSK Client Params"")_",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_client_keyex_identity_len,",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_client_keyex_identity,",0
"                        tvb, offset + 2, identity_len, ENC_NA)_",0
    offset += 2 + identity_len_,0
    /* Yc */,0
"    epms_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_client_keyex_epms_len, tvb,",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_client_keyex_epms, tvb,",0
"                        offset + 2, epms_len, ENC_NA)_",0
/* ClientKeyExchange algo-specific dissectors. }}} */,0
/* Dissects DigitallySigned (see RFC 5246 4.7 Cryptographic Attributes). {{{ */,0
"                             gint hf_sig_len, gint hf_sig)",0
    gint        sig_len_,0
    proto_item *ti_algo_,0
    proto_tree *ssl_algo_tree_,0
"        ti_algo = proto_tree_add_item(tree, hf->hf.hs_sig_hash_alg, tvb,",0
"                                      offset, 2, ENC_BIG_ENDIAN)_",0
"        ssl_algo_tree = proto_item_add_subtree(ti_algo, hf->ett.hs_sig_hash_alg)_",0
"        /* SignatureAndHashAlgorithm { hash, signature } */",0
"        proto_tree_add_item(ssl_algo_tree, hf->hf.hs_sig_hash_hash, tvb,",0
"                            offset, 1, ENC_BIG_ENDIAN)_",0
"        proto_tree_add_item(ssl_algo_tree, hf->hf.hs_sig_hash_sig, tvb,",0
"                            offset + 1, 1, ENC_BIG_ENDIAN)_",0
    /* Sig */,0
"    sig_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(tree, hf_sig_len, tvb, offset, 2, ENC_BIG_ENDIAN)_",0
"    proto_tree_add_item(tree, hf_sig, tvb, offset + 2, sig_len, ENC_NA)_",0
/* ServerKeyExchange algo-specific dissectors. {{{ */,0
/* dissects signed_params inside a ServerKeyExchange for some keyex algos */,0
"dissect_ssl3_hnd_srv_keyex_sig(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
                               const SslSession *session),0
     * TLSv1.2 (RFC 5246 sec 7.4.8),0
     *  struct {,0
     *      digitally-signed struct {,0
     *          opaque handshake_messages[handshake_messages_length]_,0
     *      },0
     *  } CertificateVerify_,0
     * TLSv1.0/TLSv1.1 (RFC 5436 sec 7.4.8 and 7.4.3) works essentially the same,0
"     * as TLSv1.2, but the hash algorithms are not explicit in digitally-signed.",0
     * SSLv3 (RFC 6101 sec 5.6.8) esseentially works the same as TLSv1.0 but it,0
     * does more hashing including the master secret and padding.,0
"                                 hf->hf.hs_server_keyex_sig_len,",0
                                 hf->hf.hs_server_keyex_sig)_,0
"dissect_ssl3_hnd_srv_keyex_ecdh(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                                guint32 length, const SslSession *session,",0
                                gboolean anon),0
     * RFC 4492 ECC cipher suites for TLS,0
     *      ECCurveType    curve_type_,0
     *      select (curve_type) {,0
     *          case explicit_prime:,0
     *              ...,0
     *          case explicit_char2:,0
     *          case named_curve:,0
     *              NamedCurve namedcurve_,0
     *      }_,0
     *  } ECParameters_,0
     *      opaque point <1..2^8-1>_,0
     *  } ECPoint_,0
     *      ECParameters    curve_params_,0
     *      ECPoint         public_,0
     *  } ServerECDHParams_,0
     *  select (KeyExchangeAlgorithm) {,0
     *      case ec_diffie_hellman:,0
     *          ServerECDHParams    params_,0
     *          Signature           signed_params_,0
     *  } ServerKeyExchange_,0
    gint        curve_type_,0
"                                  hf->ett.keyex_params, NULL, ""EC Diffie-Hellman Server Params"")_",0
    /* ECParameters.curve_type */,0
"    curve_type = tvb_get_guint8(tvb, offset)_",0
"    proto_tree_add_item(ssl_ecdh_tree, hf->hf.hs_server_keyex_curve_type, tvb,",0
    if (curve_type != 3),0
        return_ /* only named_curves are supported */,0
    /* case curve_type == named_curve_ ECParameters.namedcurve */,0
"    proto_tree_add_item(ssl_ecdh_tree, hf->hf.hs_server_keyex_named_curve, tvb,",0
    /* ECPoint.point */,0
"    proto_tree_add_item(ssl_ecdh_tree, hf->hf.hs_server_keyex_point_len, tvb,",0
"    proto_tree_add_item(ssl_ecdh_tree, hf->hf.hs_server_keyex_point, tvb,",0
    offset += 1 + point_len_,0
    /* Signature (if non-anonymous KEX) */,0
    if (!anon) {,0
"        dissect_ssl3_hnd_srv_keyex_sig(hf, tvb, ssl_ecdh_tree, offset, session)_",0
"dissect_ssl3_hnd_srv_keyex_dhe(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                               proto_tree *tree, guint32 offset, guint32 length,",0
"                               const SslSession *session, gboolean anon)",0
"    gint        p_len, g_len, ys_len_",0
"                                hf->ett.keyex_params, NULL, ""Diffie-Hellman Server Params"")_",0
    /* p */,0
"    p_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_server_keyex_p_len, tvb,",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_server_keyex_p, tvb,",0
"                        offset + 2, p_len, ENC_NA)_",0
    offset += 2 + p_len_,0
    /* g */,0
"    g_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_server_keyex_g_len, tvb,",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_server_keyex_g, tvb,",0
"                        offset + 2, g_len, ENC_NA)_",0
    offset += 2 + g_len_,0
    /* Ys */,0
"    ys_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_uint(ssl_dh_tree, hf->hf.hs_server_keyex_ys_len, tvb,",0
"                        offset, 2, ys_len)_",0
"    proto_tree_add_item(ssl_dh_tree, hf->hf.hs_server_keyex_ys, tvb,",0
"                        offset + 2, ys_len, ENC_NA)_",0
    offset += 2 + ys_len_,0
"        dissect_ssl3_hnd_srv_keyex_sig(hf, tvb, ssl_dh_tree, offset, session)_",0
/* Only used in RSA-EXPORT cipher suites */,0
"dissect_ssl3_hnd_srv_keyex_rsa(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"    gint        modulus_len, exponent_len_",0
"                                 hf->ett.keyex_params, NULL, ""RSA-EXPORT Server Params"")_",0
    /* modulus */,0
"    modulus_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_rsa_tree, hf->hf.hs_server_keyex_modulus_len, tvb,",0
"    proto_tree_add_item(ssl_rsa_tree, hf->hf.hs_server_keyex_modulus, tvb,",0
"                        offset + 2, modulus_len, ENC_NA)_",0
    offset += 2 + modulus_len_,0
    /* exponent */,0
"    exponent_len = tvb_get_ntohs(tvb, offset)_",0
"    proto_tree_add_item(ssl_rsa_tree, hf->hf.hs_server_keyex_exponent_len,",0
"    proto_tree_add_item(ssl_rsa_tree, hf->hf.hs_server_keyex_exponent,",0
"                        tvb, offset + 2, exponent_len, ENC_NA)_",0
    offset += 2 + exponent_len_,0
    /* Signature */,0
"    dissect_ssl3_hnd_srv_keyex_sig(hf, tvb, ssl_rsa_tree, offset, session)_",0
/* Used in RSA PSK and PSK cipher suites */,0
"dissect_ssl3_hnd_srv_keyex_psk(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
    guint        hint_len_,0
"    hint_len = tvb_get_ntohs(tvb, offset)_",0
    if ((2 + hint_len) != length) {,0
        /* Lengths don't line up (wasn't what we expected?) */,0
"                                 hf->ett.keyex_params, NULL, ""PSK Server Params"")_",0
    /* hint */,0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_server_keyex_hint_len, tvb,",0
"    proto_tree_add_item(ssl_psk_tree, hf->hf.hs_server_keyex_hint, tvb,",0
"                        offset + 2, hint_len, ENC_NA)_",0
/* ServerKeyExchange algo-specific dissectors. }}} */,0
/* Client Key Exchange and Server Key Exchange handshake dissections. {{{ */,0
"ssl_dissect_hnd_cli_keyex(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
"                          proto_tree *tree, guint32 offset, guint32 length,",0
    switch (ssl_get_keyex_alg(session->cipher)) {,0
"    case KEX_DH_ANON: /* RFC 5246_ DHE_DSS, DHE_RSA, DH_DSS, DH_RSA, DH_ANON: ClientDiffieHellmanPublic */",0
    case KEX_DH_DSS:,0
    case KEX_DH_RSA:,0
    case KEX_DHE_DSS:,0
    case KEX_DHE_RSA:,0
"        dissect_ssl3_hnd_cli_keyex_dh(hf, tvb, tree, offset, length)_",0
"    case KEX_DHE_PSK: /* RFC 4279_ diffie_hellman_psk: psk_identity, ClientDiffieHellmanPublic */",0
        /* XXX: implement support for DHE_PSK */,0
    case KEX_ECDH_ANON: /* RFC 4492_ ec_diffie_hellman: ClientECDiffieHellmanPublic */,0
    case KEX_ECDH_ECDSA:,0
    case KEX_ECDH_RSA:,0
    case KEX_ECDHE_ECDSA:,0
    case KEX_ECDHE_RSA:,0
"        dissect_ssl3_hnd_cli_keyex_ecdh(hf, tvb, tree, offset, length)_",0
"    case KEX_ECDHE_PSK: /* RFC 5489_ ec_diffie_hellman_psk: psk_identity, ClientECDiffieHellmanPublic */",0
        /* XXX: implement support for ECDHE_PSK */,0
    case KEX_KRB5: /* RFC 2712_ krb5: KerberosWrapper */,0
        /* XXX: implement support for KRB5 */,0
    case KEX_PSK: /* RFC 4279_ psk: psk_identity */,0
"        dissect_ssl3_hnd_cli_keyex_psk(hf, tvb, tree, offset, length)_",0
    case KEX_RSA: /* RFC 5246_ rsa: EncryptedPreMasterSecret */,0
"        dissect_ssl3_hnd_cli_keyex_rsa(hf, tvb, tree, offset, length, session)_",0
"    case KEX_RSA_PSK: /* RFC 4279_ rsa_psk: psk_identity, EncryptedPreMasterSecret */",0
"        dissect_ssl3_hnd_cli_keyex_rsa_psk(hf, tvb, tree, offset, length)_",0
    case KEX_SRP_SHA: /* RFC 5054_ srp: ClientSRPPublic */,0
    case KEX_SRP_SHA_DSS:,0
    case KEX_SRP_SHA_RSA:,0
        /* XXX: implement support for SRP_SHA* */,0
        /* XXX: add info message for not supported KEX algo */,0
"ssl_dissect_hnd_srv_keyex(ssl_common_dissect_t *hf, tvbuff_t *tvb,",0
    case KEX_DH_ANON: /* RFC 5246_ ServerDHParams */,0
"        dissect_ssl3_hnd_srv_keyex_dhe(hf, tvb, tree, offset, length, session, TRUE)_",0
    case KEX_DH_DSS: /* RFC 5246_ not allowed */,0
        /* XXX: add error on not allowed KEX */,0
"    case KEX_DHE_DSS: /* RFC 5246_ dhe_dss, dhe_rsa: ServerDHParams, Signature */",0
"        dissect_ssl3_hnd_srv_keyex_dhe(hf, tvb, tree, offset, length, session, FALSE)_",0
"    case KEX_DHE_PSK: /* RFC 4279_ diffie_hellman_psk: psk_identity_hint, ServerDHParams */",0
    case KEX_ECDH_ANON: /* RFC 4492_ ec_diffie_hellman: ServerECDHParams (without signature for anon) */,0
"        dissect_ssl3_hnd_srv_keyex_ecdh(hf, tvb, tree, offset, length, session, TRUE)_",0
"    case KEX_ECDHE_PSK: /* RFC 5489_ psk_identity_hint, ServerECDHParams */",0
"    case KEX_ECDH_ECDSA: /* RFC 4492_ ec_diffie_hellman: ServerECDHParams, Signature */",0
"        dissect_ssl3_hnd_srv_keyex_ecdh(hf, tvb, tree, offset, length, session, FALSE)_",0
    case KEX_KRB5: /* RFC 2712_ not allowed */,0
"    case KEX_PSK: /* RFC 4279_ psk, rsa: psk_identity*/",0
    case KEX_RSA_PSK:,0
"        dissect_ssl3_hnd_srv_keyex_psk(hf, tvb, tree, offset, length)_",0
    case KEX_RSA: /* only allowed if the public key in the server certificate is longer than 512 bits*/,0
"        dissect_ssl3_hnd_srv_keyex_rsa(hf, tvb, tree, offset, length, session)_",0
"    case KEX_SRP_SHA: /* RFC 5054_ srp: ServerSRPParams, Signature */",0
/* Client Key Exchange and Server Key Exchange handshake dissections. }}} */,0
"ssl_common_register_options(module_t *module, ssl_common_options_t *options)",0
"        prefs_register_string_preference(module, ""psk"", ""Pre-Shared-Key"",",0
"             ""Pre-Shared-Key as HEX string. Should be 0 to 16 bytes."",",0
             &(options->psk))_,0
"        prefs_register_filename_preference(module, ""keylog_file"", ""(Pre)-Master-Secret log filename"",",0
"             ""The name of a file which contains a list of \n""",0
"             ""(pre-)master secrets in one of the following formats:\n""",0
"             ""\n""",0
"             ""RSA <EPMS> <PMS>\n""",0
"             ""RSA Session-ID:<SSLID> Master-Key:<MS>\n""",0
"             ""CLIENT_RANDOM <CRAND> <MS>\n""",0
"             ""PMS_CLIENT_RANDOM <CRAND> <PMS>\n""",0
"             ""Where:\n""",0
"             ""<EPMS> = First 8 bytes of the Encrypted PMS\n""",0
"             ""<PMS> = The Pre-Master-Secret (PMS) used to derive the MS\n""",0
"             ""<SSLID> = The SSL Session ID\n""",0
"             ""<MS> = The Master-Secret (MS)\n""",0
"             ""<CRAND> = The Client's random number from the ClientHello message\n""",0
"             ""(All fields are in hex notation)"",",0
             &(options->keylog_filename))_,0
"ssl_common_register_options(module_t *module _U_, ssl_common_options_t *options _U_)",0
"ssl_calculate_handshake_hash(SslDecryptSession *ssl_session, tvbuff_t *tvb, guint32 offset, guint32 length)",0
    if (ssl_session && !(ssl_session->state & SSL_MASTER_SECRET)) {,0
        guint32 old_length = ssl_session->handshake_data.data_len_,0
"        ssl_debug_printf(""Calculating hash with offset %d %d\n"", offset, length)_",0
"        ssl_session->handshake_data.data = (guchar *)wmem_realloc(wmem_file_scope(), ssl_session->handshake_data.data, old_length + length)_",0
"        tvb_memcpy(tvb, ssl_session->handshake_data.data + old_length, offset, length)_",0
        ssl_session->handshake_data.data_len += length_,0
"    proto_elasticsearch_http = proto_register_protocol(""Elasticsearch (HTTP)"", ""Elasticsearch (HTTP)"", ""elasticsearch_http"")_",0
"    elasticsearch_handle_http = create_dissector_handle(dissect_elasticsearch_http, proto_elasticsearch_http)_",0
"        if (!ws_strtoi32(s, &n)) {",0
"    if (!ws_strtoi32(s, &n)) {",0
"	DLM_LOCK_FLAGS_GET_LVB = 0x40000000,",1
    guint32 center_freq1 = -1_,1
"        if (!ws_strtou32(options[0], &freq))",0
    int           split_packet_count = 0_,1
    if (split_packet_count > 0) {,1
                if (split_packet_count > 0) {,1
                while ((phdr->ts.secs - block_start.secs >  secs_per_block),0
	if (http_type == HTTP_REQUEST),0
"		snprintf(valbuf, sizeof(valbuf), ""%04d-%02d-%02dT%02d:%02d:%02d.%d%c%02d%02d"", year, month, day, hours, minutes, seconds, decisecs, utcsign, utchours, utcminutes)_",0
"    if ( !g_hash_table_lookup(ifaces, interface->call) )",0
    return interface->help_,1
    gchar * help_,1
    gchar * extcap_path_,1
	/* parse LVB-related message when LVB related flag is set */,0
Don't use zero-length arrays_ not all compilers support them.  If an,1
to the end of the line) in C code. Wireshark's dissectors are written in,0
#ifndef _STRTOL_H,1
#define ws_strtoi ws_strtoi64,1
"	gint64 val = g_ascii_strtoll(str, &endptr, 10)_",1
"	guint64 val = g_ascii_strtoull(str, &endptr, 10)_",1
	if (val < llimit || val > hlimit) { \,0
	if (val == G_MAXUINT64 || (val == 0 && errno == EINVAL)) {,0
"#define ws_strtou_barebone(bits, hlimit) \",0
"int ws_strtou##bits(const gchar* str, guint##bits* cint) \",0
{ \,0
	guint64 val_ \,0
"	int ret = ws_strtou(str, &val)_ \",0
	if (ret != EXIT_SUCCESS) { \,0
		return ret_ \,0
	} \,0
	if (val > hlimit) { \,0
		*cint = 0_ \,0
		errno = ERANGE_ \,0
		print_warning()_ \,0
		return EXIT_FAILURE_ \,0
	*cint = (guint##bits)val_ \,0
	return EXIT_SUCCESS_ \,0
"ws_strtou_barebone(32, G_MAXUINT32)_",0
"ws_strtou_barebone(16, G_MAXUINT16)_",0
	strtoi.h		\,1
" On error, errno is set to EINVAL for unrecognized input and ERANGE",0
"	if (ws_strtoi64(str, &val)) { \",0
"	if (ws_strtou64(str, &val)) { \",1
"	CQL_V3_RESULT_ROW_TYPE_TUPLE = 0x0031,",0
cql_v3_flags_str(const guint8 flags) {,0
cql_v3_query_flags_str(const guint8 flags) {,0
cql_v3_result_flags_str(const guint32 flags) {,0
"			proto_tree_add_debug_text(column_tree, ""%s"", ""Unknown CQL [option] type. Remaining dissection is likely to fail."")_",0
"	item = proto_tree_add_uint_format(tree, hf_cql_v3_result_flags_values, tvb, *offset, 4, metadata->flags, ""Flags: 0x%08x (%s)"", metadata->flags, cql_v3_result_flags_str(metadata->flags))_",0
"	item = proto_tree_add_uint_format(tree, hf_cql_v3_flags, tvb, *offset, 1, flags, ""Flags: 0x%02x (%s)"", flags, cql_v3_query_flags_str(flags))_",0
"				proto_tree_add_debug_text(cql_tree, ""%s"", ""Unknown CQL [opcode] type. Remaining dissection is likely to fail."")_",0
"	proto_tree_add_item_ret_uint(cql_subtree, hf_cql_v3_flags, tvb, offset, 1, ENC_BIG_ENDIAN, &flags)_",0
"	proto_tree_add_item(cql_tree, hf_cql_v3_flags, tvb, offset, 1, ENC_BIG_ENDIAN)_",0
	if (server_to_client == 0) {,0
				},0
    if (!initialized) {,1
		/* Note: cannot be reached since memory allocation failure terminates early */,0
	return local_interfaces_to_list_win()_,0
#ifdef HAVE_GETIFADDRS,0
	return local_interfaces_to_list_nix()_,0
"	set(wsutil_LIBS ${wsutil_LIBS} ""iphlpapi.lib"" ""ws2_32.lib"")",0
    GSList *interfaces = NULL_,1
    struct ifaddrs *ifap_,1
    struct ifaddrs *ifa_,1
    int family_,1
		set(sshdump_LIBS wsutil iphlpapi.lib ${sshdump_LIBS}),0
"	#pragma comment(lib, ""iphlpapi.lib"")",1
    char* name = g_strdup(exename)_,1
    extcap->exename = g_strdup(basename(name))_,1
		set(ADDED_WARN_C_FLAGS ${ADDED_WARN_C_FLAGS} ${${F}}),0
		set(ADDED_WARN_CXX_FLAGS ${ADDED_WARN_CXX_FLAGS} ${${F}}),0
"string(REPLACE ""_"" "" "" _warnings_c_flags ""${WS_WARNINGS_C_FLAGS}"")",0
"    if (g_regex_match_full(cf->regex, (const gchar *)ws_buffer_start_ptr(&cf->buf), fdata->cap_len,",0
        if (tot_len < 1),1
    /* BUG: encr/auth specs are not set properly after editing IKEv2 UAT (adding / removing rows).,1
isakmp_prefs_apply_cb(void) {,0
"	target_compile_options(dissectors-corba PUBLIC ""/Ox"")",0
"        memset( encr_iv, 0, encr_iv_len )_",1
"        tag = (guchar *)wmem_alloc(pinfo->pool, tag_len)_",1
"         * of ICV, so it won't work with 12 and 8 bytes of ICV.",0
        if (key_info->encr_spec->gcry_mode == GCRY_CIPHER_MODE_GCM ),1
        if (tag_len > (int)sizeof(tag)) {,1
"            key_info->encr_spec->gcry_alg, (int)tag_len, (int)sizeof(tag)))_",1
"    { IEEE802154_MLME_SUBIE_RCC_PHY_OPER_MODE,        ""RCC PHY Operating Mode IE"" },",0
    packet->short_table = ieee802154_map.short_table_,0
"                    ""Data: Link Information"")_",0
/* 0x37-0x7f Reserved */,0
    /* size of the header IE list*/,0
      8388724 Network-Status-Request/Answer (NSR/NSA) [3GPP TS 29.153][Kimmo_Kymalainen] ,0
            gboolean handled = FALSE_,0
	/** We got a ROS Clock msg */,1
#define IS_ASCII(_c) (!(_c & 0x80)),1
"        col_append_str(pinfo->cinfo, COL_INFO, ""[ROS Clock] "")_",1
        if( available < 8+1 ),1
        if( msg_len < 4+1 ),1
        gint string_len = 0_,1
        if( msg_len < 16 ),1
"				   ""TCPROS_tcp"", proto_tcpros, HEURISTIC_ENABLE)_",1
    return iv_,0
    iv = NULL_,0
"  set_next_iv(buf, buf_len, message_id, decr)_",0
"  iv = p_get_proto_data(wmem_file_scope(), pinfo, proto_isakmp, PINFO_CBC_IV)_",0
   * and is not NULL.,0
    goto out_,1
"  memcpy(iv, gcry_md_read(md_ctx, md_algo), iv_len)_",0
      decr->digest_len < decr->cipher_blklen),0
"  if (gcry_cipher_setiv(decr_ctx, iv, decr->cipher_blklen))",0
"  decrypted_data = (guint8 *)wmem_alloc(pinfo->pool, buf_len)_",0
"        col_append_str(pinfo->cinfo, COL_INFO, ""[Malformed Packet]"")_",1
        if((remaining - length_of_fixed_part - id_len) < bm_len) {,0
"            ti = proto_tree_add_item(seed_info_tree, hf_icmpv6_mpl_seed_info_bm, tvb, body_offset, bm_len, ENC_NA)_",0
            case 0:,0
                /* do nothing */,0
                    if (b & (0x80 >> j)) {,1
      return RESAMPLER_ERR_INVALID_ARG_,1
   if (quality > 10 || quality < 0 || ratio_den <= 0 || ratio_num <= 0),0
   if (ratio_den <= 0 || ratio_num <= 0),0
   if (num_rate <= 0),0
         st->den_rate /= fact_,0
brew install c-ares glib gnutls lua,0
sudo rm /usr/local/mkspecs /usr/local/plugins,0
"filter_script=$""$hookdir/pre-commit-ignore.py""",0
"    CHECK_FILES=""$COMMIT_FILES""",1
    sys.exit(str(err)),0
"      proto_tree_add_expert_format(ntree, pinfo, &ei_isakmp_payload_bad_length, tvb, 0, 0,",0
"                                   ""Payload (bogus, length is %u, must be at least 4)"",",0
    *next_payload_p = 0_,0
Wireshark is known to compile and run on the following systems. Installation,0
  - OpenBSD,1
	/* (reserved up to 16) */,0
"dissect_gtpv2_tgt_src_trans_con(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, guint8 instance _U_, session_args_t * args _U_)",0
    tvb_len = (gint)tvb_reported_length(tvb)_,0
        /* Parse out the 'new event' fields. */,0
"        sif = tvb_get_bits8(tvb, 43, 1)_",0
"    proto_tree_add_item(tree, hf_descriptor_preroll, tvb, offset++, 1, ENC_NA)_",0
"                        offset++, 1, ENC_NA)_",0
	packet-scte35.c		\,0
#define SCTE35_CMD_SPLICE_NULL (0x00),0
          strbuf = wmem_strbuf_new_label(wmem_epan_scope())_,0
"      { ""MII RX_ER error"", ""netanalyzer.packetstatus.rx_er"",",0
"				proto_tree_add_item(tcpdbgTree, hf_ns_tcpdbg_httpabort, tvb, offset+TCPRECOFFSET(http_abort_reason), 1, ENC_LITTLE_ENDIAN)_",0
void proto_reg_handoff_uftp4(void),0
    return rval_,0
"                        *(p + 2), *(p + 3), *(p + 4),",0
The recommended Qt version to compile wireshark on Windows is 5.6.1.,0
The recommended Qt version to compile wireshark on windows is 5.6.1.,0
====,0
The currect QT version needed to compile wireshark is 5.6.1.,0
    if (sock != INVALID_SOCKET) {,0
                    try_next += 1_,1
	# Add trusty specific packages,1
trusty),0
"    guint     segment_len_rem_          /* The remaining segment length, used to find last segment */",0
                            connection_info->nextexpectedseqnum = (oct & 0x4)>>2_,0
"    guint retransmitt : 1_ /* 0 = No, 1 Retransmitted frame */",0
                    ,0
                        if (connection_info->nextexpectedseqnum == ((oct & 0x8) > 3)) {,0
                            connection_info->nextexpectedseqnum = (oct & 0x4) > 2_,0
"                    frag_btl2cap_msg, ",0
"                    (void*)process_reassembled_data(tvb, offset, pinfo,",0
    if (name_offset != -1),1
"	{ WS_NFNL_SUBSYS_CTHELPER,	    ""Connection Tracking Helpers"" },",0
"	proto_tree_add_item(fh_hdr, &hfi_netlink_hdr_pid, tvb, offset, 4, encoding)_",1
"    range_convert_str(&new_kafka_tcp_range, TCP_DEFAULT_RANGE, 65535)_",0
"	extcap_help_add_header(extcap_conf, help_header)_",0
	g_free(help_header)_,0
"	extcap_help_add_option(extcap_conf, ""--help"", ""print this help"")_",0
"    extcap_help_add_option(extcap_conf, ""--version"", ""print the version"")_",0
"    extcap_help_add_option(extcap_conf, ""--verbose"", ""print more messages"")_",0
"    extcap_help_add_option(extcap_conf, ""--remote-host <host>"", ""the remote SSH host"")_",0
"    extcap_help_add_option(extcap_conf, ""--remote-port <port>"", ""the remote SSH port (default: 22)"")_",0
"    extcap_help_add_option(extcap_conf, ""--remote-username <username>"", ""the remote SSH username (default: the current user)"")_",0
"    extcap_help_add_option(extcap_conf, ""--remote-password <password>"", ""the remote SSH password. If not specified, ssh-agent and ssh-key are used"")_",0
"    extcap_help_add_option(extcap_conf, ""--sshkey <public key path>"", ""the path of the ssh key"")_",0
"    extcap_help_add_option(extcap_conf, ""--sshkey-passphrase <public key passphrase>"", ""the passphrase to unlock public ssh"")_",0
"    extcap_help_add_option(extcap_conf, ""--remote-interface <iface>"", ""the remote capture interface (default: eth0)"")_",0
"    extcap_help_add_option(extcap_conf, ""--remote-capture-bin <capture bin>"", ""the remote dumcap binary (default: "" DEFAULT_CAPTURE_BIN "")"")_",0
        case EXTCAP_OPT_VERBOSE:,0
    if (!iso15765_info) {,0
"        iso15765_info = wmem_new(wmem_file_scope(), iso15765_identifier_t)_",0
"    pci = tvb_get_guint8(tvb, ae + ISO15765_PCI_OFFSET)_",0
"    col_add_fstr(pinfo->cinfo, COL_INFO, ""%s"", val_to_str(message_type, iso15765_message_types, ""Unknown (0x%02x)""))_",0
            iso15765_frame->last_frag_id = 0_,0
        DISSECTOR_ASSERT(iso15765_frame)_,0
        /* Check if there is an error in conversation */,0
    if (next_tvb) {,0
"    dissector_add_for_decode_as(""can.subdissector"", iso15765_handle)_",0
        //interface_opts.extcap_child_watch =,1
"            extcap_child_err_cb(child->err, G_IO_IN, interface_opts.extcap_userdata)_",1
"        g_io_channel_read_line ( channel, &string, &size, NULL, NULL )_",0
"            g_child_watch_add(pid, extcap_child_watch_cb, (gpointer)capture_opts)_",0
"            g_snprintf(arg->storeval, 128, ""%s"", newval)_",0
"					/* ID: 0x0, 0x2, 0x7-0x63 are reserved. */",0
"		{ ""Platform ID"", ""erspan.platid"", FT_UINT16, BASE_DEC, NULL,",0
        (tvb_captured_length(tvb) < 5)),1
    int reader_offset = offset_,0
    /* moving to next field */,0
        total_length = reader_offset_,0
"		{ &hf_smb2_error_reserved,",0
"		  { ""Symbolic Link Error Response"", ""smb2.symlink_error_response"", FT_NONE, BASE_NONE,",0
"	share_type = tvb_get_letohs(tvb, offset)_",1
    off += 8_,0
"    proto_tree_add_item(vsock_tree, hf_vsock_src_port, tvb, off, 4, ENC_LITTLE_ENDIAN)_",0
"    AF_VSOCK_T_UNKNOWN = 0,",0
    /* Clear column information before start parsing */,0
    /* Parse generic header part */,0
    /* Append summary information to top tree */,0
    /* Fill columns */,0
"    col_set_str(pinfo->cinfo, COL_PROTOCOL, ""vSocket"")_ ",0
        case AF_VSOCK_T_VIRTIO:,0
    /* Append payload */,0
    payload_len = tvb_reported_length(tvb) - 80_,0
    void,0
"            {""Source port"", ""vsock.virtio.src_prot"", FT_UINT32, BASE_DEC, NULL,",0
"            {""Fwd cnt"", ""vsock.virtio.buf_alloc"", FT_UINT32, BASE_DEC, NULL,",0
"            ""vsock"", ""vsock"")_",0
"    dissector_add_uint(""wtap_encap"", WTAP_ENCAP_USER0, vsock_handle)_",0
	seq_nr = (hdr2 >> 6) & 0x1f_,0
/* packet-gsm_abis_tfp.c,0
gint hf_zbee_zdp_number_of_children = -1_,0
        readStream()_,1
"    vsnprintf_s(buffer, size_of_buffer, _TRUNCATE, format, ap)_",1
	packet-nordic_ble.c		\,0
"#define VAR_NAME_VALUE(var) #var ""			=""  VALUE(var)",0
 * default to 0 unless there is an IANA-registered (or equivalent) port for your,0
"    { &hf_nordic_ble_board_id,",0
     static ei_register_info ei[] = {,0
        if (packet.security_level == ZBEE_NWK_GP_SECURITY_LEVEL_FULLENCR) {,0
"            g_byte_array_free(follow_record->data, TRUE)_",0
			 *  telling us that the field's value is meaningless_,1
        Generic Protocol Extension Support for VXLAN,0
    int offset = 0_,0
		case VXLAN_IPV4 :,0
    if(pinfo->srcport == UDP_PORT_VXLAN_GPE){,1
	/* XXX - Just for Decode As? */,0
"	vxlan_gpe_handle = create_dissector_handle(dissect_vxlan_gpe, proto_vxlan_gpe)_",0
    /* collect packet info */,0
"		  { ""SYMBOLIC_LINK_REPARSE_DATA_BUFFER"", ""smb2.SYMBOLIC_LINK_REPARSE_DATA_BUFFER"", FT_NONE, BASE_NONE,",0
    /* Allocate a buffer for the packet and copy in the IPv6 header. */,0
"		  FT_UINT8, BASE_CUSTOM, CF_FUNC(packet_type_format), 0x0,",0
"    g_snprintf(buf, ITEM_LABEL_LENGTH,",1
        done_flag = TRUE_,1
"                        if (sscanf(pch, ""ModuleIdentNumber=\""%[^\""]"", convertStr) == 1) {  /* Change format of Value string-->numeric string */",0
get_ipv6_meta_data(packet_info *pinfo),0
        p += 4_,0
"        proto_tree_add_none_format(shim_tree, hf_shim6_ct, tvb,",0
"                            offset + (int)offsetof(struct ip6_shim, ip6s_p), 1,",0
/* wtap_opttypes.c,0
 * Copyright 2001 Gerald Combs,0
"#include ""wtap.h""",0
"#include ""wtap_opttypes.h""",0
"#include ""wtap-int.h""",0
"#include ""pcapng.h""",0
"#include ""pcapng_module.h""",0
#define wtap_debug(...) g_warning(__VA_ARGS__),0
#define wtap_debug(...),0
 * Structure describing a type of block.,0
typedef struct {,0
    wtap_block_type_t block_type_    /**< internal type code for block */,0
    const char *name_                /**< name of block */,0
    const char *description_         /**< human-readable description of block */,0
    wtap_block_create_func create_,0
    wtap_mand_free_func free_mand_,0
    wtap_mand_copy_func copy_mand_,0
    GArray *options_                 /**< array of known options */,0
} wtap_blocktype_t_,0
typedef void (*wtap_opttype_free_custom_func)(void* data)_,0
 * Structure describing a type of option.,0
    const char *name_                        /**< name of option */,0
    const char *description_                 /**< human-readable description of option */,0
    wtap_opttype_e data_type_                /**< data type of that option */,0
    guint flags_                             /**< flags for the option */,0
    wtap_opttype_free_custom_func free_func_ /**< function to free custom option data */,0
} wtap_opttype_t_,0
/* Flags */,0
#define WTAP_OPTTYPE_FLAG_MULTIPLE_ALLOWED 0x00000001 /* multiple instances allowed */,0
struct wtap_block,0
    wtap_blocktype_t* info_,0
    void* mandatory_data_,0
    GArray* options_,0
#define MAX_WTAP_BLOCK_CUSTOM    10,0
#define MAX_WTAP_BLOCK_TYPE_VALUE (WTAP_BLOCK_END_OF_LIST+MAX_WTAP_BLOCK_CUSTOM),0
/* Keep track of wtap_blocktype_t's via their id number */,0
static wtap_blocktype_t* blocktype_list[MAX_WTAP_BLOCK_TYPE_VALUE]_,0
static guint num_custom_blocks_,0
static wtap_blocktype_t custom_blocktype_list[MAX_WTAP_BLOCK_CUSTOM]_,0
"static void wtap_opttype_block_register(int block_type, wtap_blocktype_t *blocktype)",0
    static const wtap_opttype_t opt_comment = {,0
"        ""opt_comment"",",0
"        ""Comment"",",0
"        WTAP_OPTTYPE_STRING, ",0
"        WTAP_OPTTYPE_FLAG_MULTIPLE_ALLOWED,",0
    /* Check input */,0
    g_assert(block_type < WTAP_BLOCK_END_OF_LIST)_,0
    /* Don't re-register. */,0
    g_assert(blocktype_list[block_type] == NULL)_,0
    /* Sanity check */,0
    g_assert(blocktype->name)_,0
    g_assert(blocktype->description)_,0
    g_assert(blocktype->create)_,0
    blocktype->block_type = block_type_,0
     * Initialize the set of supported options.,0
     * All blocks that support options at all support OPT_COMMENT.,0
"    blocktype->options = g_array_sized_new(FALSE, TRUE, sizeof (wtap_opttype_t), OPT_COMMENT + 1)_",0
    if (OPT_COMMENT + 1 > blocktype->options->len),0
"        g_array_set_size(blocktype->options, OPT_COMMENT + 1)_",0
"    g_array_insert_val(blocktype->options, OPT_COMMENT, opt_comment)_",0
    blocktype_list[block_type] = blocktype_,0
"int wtap_opttype_register_custom_block_type(const char* name, const char* description, wtap_block_create_func create,",0
"                                            wtap_mand_free_func free_mand, wtap_mand_copy_func copy_mand)",0
    int block_type_,0
    /* Ensure valid data/functions for required fields */,0
    g_assert(name)_,0
    g_assert(description)_,0
    g_assert(create)_,0
"    /* This shouldn't happen, so flag it for fixing */",0
    g_assert(num_custom_blocks < MAX_WTAP_BLOCK_CUSTOM)_,0
    block_type = WTAP_BLOCK_END_OF_LIST+num_custom_blocks_,0
    custom_blocktype_list[num_custom_blocks].name = name_,0
    custom_blocktype_list[num_custom_blocks].description = description_,0
    custom_blocktype_list[num_custom_blocks].create = create_,0
    custom_blocktype_list[num_custom_blocks].free_mand = free_mand_,0
    custom_blocktype_list[num_custom_blocks].copy_mand = copy_mand_,0
    blocktype_list[block_type] = &custom_blocktype_list[num_custom_blocks]_,0
    num_custom_blocks++_,0
    return block_type_,0
"static void wtap_opttype_option_register(wtap_blocktype_t *blocktype, int opttype, wtap_opttype_t *option)",0
    if ((guint)opttype + 1 > blocktype->options->len),0
"        g_array_set_size(blocktype->options, opttype + 1)_",0
"    g_array_insert_val(blocktype->options, opttype, *option)_",0
void* wtap_block_get_mandatory_data(wtap_block_t block),0
    return block->mandatory_data_,0
static wtap_optval_t *,0
"wtap_block_get_option(wtap_block_t block, guint option_id)",0
    guint i_,0
    wtap_option_t *opt_,0
    for (i = 0_ i < block->options->len_ i++) {,0
"        opt = &g_array_index(block->options, wtap_option_t, i)_",0
        if (opt->option_id == option_id),0
            return &opt->value_,0
"wtap_block_get_nth_option(wtap_block_t block, guint option_id, guint idx)",0
    guint opt_idx_,0
    opt_idx = 0_,0
        if (opt->option_id == option_id) {,0
            if (opt_idx == idx),0
                return &opt->value_,0
            opt_idx++_,0
wtap_block_t wtap_block_create(wtap_block_type_t block_type),0
    wtap_block_t block_,0
    if (block_type >= (WTAP_BLOCK_END_OF_LIST+num_custom_blocks)),0
"    block = g_new(struct wtap_block, 1)_",0
    block->info = blocktype_list[block_type]_,0
"    block->options = g_array_new(FALSE, FALSE, sizeof(wtap_option_t))_",0
    block->info->create(block)_,0
    return block_,0
static void wtap_block_free_options(wtap_block_t block),0
    wtap_opttype_t *opttype_,0
"        opttype = &g_array_index(block->info->options, wtap_opttype_t, opt->option_id)_",0
        switch (opttype->data_type) {,0
        case WTAP_OPTTYPE_STRING:,0
            g_free(opt->value.stringval)_,0
        case WTAP_OPTTYPE_CUSTOM:,0
            opttype->free_func(opt->value.customval.data)_,0
            g_free(opt->value.customval.data)_,0
void wtap_block_free(wtap_block_t block),0
    if (block != NULL),0
        if (block->info->free_mand != NULL),0
            block->info->free_mand(block)_,0
        g_free(block->mandatory_data)_,0
        wtap_block_free_options(block)_,0
        if (block->options != NULL),0
"            g_array_free(block->options, TRUE)_",0
        g_free(block)_,0
void wtap_block_array_free(GArray* block_array),0
    guint block_,0
    if (block_array == NULL),0
    for (block = 0_ block < block_array->len_ block++) {,0
"        wtap_block_free(g_array_index(block_array, wtap_block_t, block))_",0
"    g_array_free(block_array, TRUE)_",0
 * Make a copy of a block.,0
"wtap_block_copy(wtap_block_t dest_block, wtap_block_t src_block)",0
    wtap_option_t *src_opt_,0
     * Copy the mandatory data.,0
    if (dest_block->info->copy_mand != NULL),0
"        dest_block->info->copy_mand(dest_block, src_block)_",0
"    /* Copy the options.  For now, don't remove any options that are in destination",0
     * but not source.,0
    for (i = 0_ i < src_block->options->len_ i++),0
"        src_opt = &g_array_index(src_block->options, wtap_option_t, i)_",0
"        opttype = &g_array_index(src_block->info->options, wtap_opttype_t, src_opt->option_id)_",0
        switch(opttype->data_type) {,0
        case WTAP_OPTTYPE_UINT8:,0
"            wtap_block_add_uint8_option(dest_block, src_opt->option_id, src_opt->value.uint8val)_",0
        case WTAP_OPTTYPE_UINT64:,0
"            wtap_block_add_uint64_option(dest_block, src_opt->option_id, src_opt->value.uint64val)_",0
        case WTAP_OPTTYPE_IPv4:,0
"            wtap_block_add_ipv4_option(dest_block, src_opt->option_id, src_opt->value.ipv4val)_",0
        case WTAP_OPTTYPE_IPv6:,0
"            wtap_block_add_ipv6_option(dest_block, src_opt->option_id, &src_opt->value.ipv6val)_",0
"            wtap_block_add_string_option(dest_block, src_opt->option_id, src_opt->value.stringval, strlen(src_opt->value.stringval))_",0
"            wtap_block_add_custom_option(dest_block, src_opt->option_id, src_opt->value.customval.data, src_opt->value.customval.size)_",0
"void wtap_block_foreach_option(wtap_block_t block, wtap_block_foreach_func func, void* user_data)",0
"        func(block, opt->option_id, opttype->data_type, &opt->value, user_data)_",0
wtap_opttype_return_val,0
"wtap_block_num_options_of_type(wtap_block_t block, guint option_id, guint *countp)",0
    guint n_options_,0
    if (option_id >= block->info->options->len) {,0
        /* There's no option for this block with that option ID */,0
        return WTAP_OPTTYPE_NO_SUCH_OPTION_,0
"    opttype = &g_array_index(block->info->options, wtap_opttype_t, option_id)_",0
     * Can there be more than one instance of this option?,0
    if (!(opttype->flags & WTAP_OPTTYPE_FLAG_MULTIPLE_ALLOWED)) {,0
         * No_ this is only for use with options with multiple,0
         * instances.,0
        return WTAP_OPTTYPE_NUMBER_MISMATCH_,0
    n_options = 0_,0
"        opt = g_array_index(block->options, wtap_option_t*, i)_",0
            n_options++_,0
    *countp = n_options_,0
    return WTAP_OPTTYPE_SUCCESS_,0
static wtap_opttype_return_val,0
"wtap_block_add_option_common(wtap_block_t block, guint option_id, wtap_opttype_e type, wtap_option_t **optp)",0
     * Is this an option of the specified data type?,0
    if (opttype->data_type != type) {,0
         * No.,0
        return WTAP_OPTTYPE_TYPE_MISMATCH_,0
         * No. Is there already an instance of this option?,0
"        if (wtap_block_get_option(block, option_id) != NULL) {",0
            /*,0
             * Yes. Fail.,0
            return WTAP_OPTTYPE_ALREADY_EXISTS_,0
     * Add an instance.,0
    i = block->options->len_,0
"    g_array_set_size(block->options, i + 1)_",0
"    opt = &g_array_index(block->options, wtap_option_t, i)_",0
    opt->option_id = option_id_,0
    *optp = opt_,0
"wtap_block_get_option_common(wtap_block_t block, guint option_id, wtap_opttype_e type, wtap_optval_t **optvalp)",0
    wtap_optval_t *optval_,0
    if (opttype->flags & WTAP_OPTTYPE_FLAG_MULTIPLE_ALLOWED) {,0
"         * Yes.  You can't ask for ""the"" value.",0
"    optval = wtap_block_get_option(block, option_id)_",0
    if (optval == NULL) {,0
        /* Didn't find the option */,0
        return WTAP_OPTTYPE_NOT_FOUND_,0
    *optvalp = optval_,0
"wtap_block_get_nth_option_common(wtap_block_t block, guint option_id, wtap_opttype_e type, guint idx, wtap_optval_t **optvalp)",0
"    optval = wtap_block_get_nth_option(block, option_id, idx)_",0
"wtap_block_add_uint8_option(wtap_block_t block, guint option_id, guint8 value)",0
    wtap_opttype_return_val ret_,0
"    ret = wtap_block_add_option_common(block, option_id, WTAP_OPTTYPE_UINT8, &opt)_",0
    if (ret != WTAP_OPTTYPE_SUCCESS),0
        return ret_,0
    opt->value.uint8val = value_,0
"wtap_block_set_uint8_option_value(wtap_block_t block, guint option_id, guint8 value)",0
"    ret = wtap_block_get_option_common(block, option_id, WTAP_OPTTYPE_UINT8, &optval)_",0
    optval->uint8val = value_,0
"wtap_block_get_uint8_option_value(wtap_block_t block, guint option_id, guint8* value)",0
    *value = optval->uint8val_,0
"wtap_block_add_uint64_option(wtap_block_t block, guint option_id, guint64 value)",0
"    ret = wtap_block_add_option_common(block, option_id, WTAP_OPTTYPE_UINT64, &opt)_",0
    opt->value.uint64val = value_,0
"wtap_block_set_uint64_option_value(wtap_block_t block, guint option_id, guint64 value)",0
"    ret = wtap_block_get_option_common(block, option_id, WTAP_OPTTYPE_UINT64, &optval)_",0
    optval->uint64val = value_,0
"wtap_block_get_uint64_option_value(wtap_block_t block, guint option_id, guint64 *value)",0
    *value = optval->uint64val_,0
"wtap_block_add_ipv4_option(wtap_block_t block, guint option_id, guint32 value)",0
"    ret = wtap_block_add_option_common(block, option_id, WTAP_OPTTYPE_IPv4, &opt)_",0
    opt->value.ipv4val = value_,0
"wtap_block_set_ipv4_option_value(wtap_block_t block, guint option_id, guint32 value)",0
"    ret = wtap_block_get_option_common(block, option_id, WTAP_OPTTYPE_IPv4, &optval)_",0
    optval->ipv4val = value_,0
"wtap_block_get_ipv4_option_value(wtap_block_t block, guint option_id, guint32* value)",0
    *value = optval->ipv4val_,0
"wtap_block_add_ipv6_option(wtap_block_t block, guint option_id, struct e_in6_addr *value)",0
"    ret = wtap_block_add_option_common(block, option_id, WTAP_OPTTYPE_IPv6, &opt)_",0
    opt->value.ipv6val = *value_,0
"wtap_block_set_ipv6_option_value(wtap_block_t block, guint option_id, struct e_in6_addr *value)",0
"    ret = wtap_block_get_option_common(block, option_id, WTAP_OPTTYPE_IPv6, &optval)_",0
    optval->ipv6val = *value_,0
"wtap_block_get_ipv6_option_value(wtap_block_t block, guint option_id, struct e_in6_addr* value)",0
    *value = optval->ipv6val_,0
"wtap_block_add_string_option(wtap_block_t block, guint option_id, const char *value, gsize value_length)",0
"    ret = wtap_block_add_option_common(block, option_id, WTAP_OPTTYPE_STRING, &opt)_",0
"    opt->value.stringval = g_strndup(value, value_length)_",0
"wtap_block_add_string_option_vformat(wtap_block_t block, guint option_id, const char *format, va_list va)",0
"    opt->value.stringval = g_strdup_vprintf(format, va)_",0
"wtap_block_add_string_option_format(wtap_block_t block, guint option_id, const char *format, ...)",0
    va_list va_,0
"    va_start(va, format)_",0
    va_end(va)_,0
"wtap_block_set_string_option_value(wtap_block_t block, guint option_id, const char *value, size_t value_length)",0
"    ret = wtap_block_get_option_common(block, option_id, WTAP_OPTTYPE_STRING, &optval)_",0
    if (ret != WTAP_OPTTYPE_SUCCESS) {,0
        if (ret == WTAP_OPTTYPE_NOT_FOUND) {,0
"             * There's no instance to set, so just try to create a new one",0
             * with the value.,0
"            return wtap_block_add_string_option(block, option_id, value, value_length)_",0
        /* Otherwise fail. */,0
    g_free(optval->stringval)_,0
"    optval->stringval = g_strndup(value, value_length)_",0
"wtap_block_set_nth_string_option_value(wtap_block_t block, guint option_id, guint idx, const char *value, size_t value_length)",0
"    ret = wtap_block_get_nth_option_common(block, option_id, WTAP_OPTTYPE_STRING, idx, &optval)_",0
"wtap_block_set_string_option_value_format(wtap_block_t block, guint option_id, const char *format, ...)",0
             * with the formatted string.,0
"            va_start(va, format)_",0
"            ret = wtap_block_add_string_option_vformat(block, option_id, format, va)_",0
            va_end(va)_,0
            return ret_,0
"    optval->stringval = g_strdup_vprintf(format, va)_",0
"wtap_block_get_string_option_value(wtap_block_t block, guint option_id, char** value)",0
    *value = optval->stringval_,0
"wtap_block_get_nth_string_option_value(wtap_block_t block, guint option_id, guint idx, char** value)",0
"wtap_block_add_custom_option(wtap_block_t block, guint option_id, void *value, size_t value_size)",0
"    ret = wtap_block_add_option_common(block, option_id, WTAP_OPTTYPE_CUSTOM, &opt)_",0
    opt->value.customval.size = (guint)value_size_,0
"    opt->value.customval.data = g_memdup(value, (guint)value_size)_",0
"wtap_block_get_custom_option_value(wtap_block_t block, guint option_id, void** value)",0
"    ret = wtap_block_get_option_common(block, option_id, WTAP_OPTTYPE_CUSTOM, &optval)_",0
    *value = optval->customval.data_,0
"wtap_block_set_custom_option_value(wtap_block_t block, guint option_id, void *value)",0
    void *prev_value_,0
    prev_value = optval->customval.data_,0
"     * XXX - a custom value can be a structure that points to other data,",0
     * but we're doing a shallow copy here.,0
"    optval->customval.data = g_memdup(value, optval->customval.size)_",0
"    /* Free after memory is duplicated in case structure was manipulated with a ""get then set"" */",0
    g_free(prev_value)_,0
static void shb_create(wtap_block_t block),0
"    wtapng_mandatory_section_t* section_mand = g_new(wtapng_mandatory_section_t, 1)_",0
    section_mand->section_length = -1_,0
    block->mandatory_data = section_mand_,0
"static void shb_copy_mand(wtap_block_t dest_block, wtap_block_t src_block)",0
"    memcpy(dest_block->mandatory_data, src_block->mandatory_data, sizeof(wtapng_mandatory_section_t))_",0
static void nrb_create(wtap_block_t block),0
    block->mandatory_data = NULL_,0
static void isb_create(wtap_block_t block),0
"    block->mandatory_data = g_new0(wtapng_if_stats_mandatory_t, 1)_",0
"static void isb_copy_mand(wtap_block_t dest_block, wtap_block_t src_block)",0
"    memcpy(dest_block->mandatory_data, src_block->mandatory_data, sizeof(wtapng_if_stats_mandatory_t))_",0
static void idb_filter_free(void* data),0
    wtapng_if_descr_filter_t* filter = (wtapng_if_descr_filter_t*)data_,0
    g_free(filter->if_filter_str)_,0
    g_free(filter->if_filter_bpf_bytes)_,0
static void idb_create(wtap_block_t block),0
"    block->mandatory_data = g_new0(wtapng_if_descr_mandatory_t, 1)_",0
static void idb_free_mand(wtap_block_t block),0
    guint j_,0
    wtap_block_t if_stats_,0
    wtapng_if_descr_mandatory_t* mand = (wtapng_if_descr_mandatory_t*)block->mandatory_data_,0
    for(j = 0_ j < mand->num_stat_entries_ j++) {,0
"        if_stats = g_array_index(mand->interface_statistics, wtap_block_t, j)_",0
        wtap_block_free(if_stats)_,0
    if (mand->interface_statistics),0
"        g_array_free(mand->interface_statistics, TRUE)_",0
"static void idb_copy_mand(wtap_block_t dest_block, wtap_block_t src_block)",0
"    wtap_block_t src_if_stats, dest_if_stats_",0
"    wtapng_if_descr_mandatory_t *src_mand = (wtapng_if_descr_mandatory_t*)src_block->mandatory_data,",0
                                *dest_mand = (wtapng_if_descr_mandatory_t*)dest_block->mandatory_data_,0
    /* Need special consideration for copying of the interface_statistics member */,0
    if (dest_mand->num_stat_entries != 0),0
"        g_array_free(dest_mand->interface_statistics, TRUE)_",0
"    memcpy(dest_mand, src_mand, sizeof(wtapng_if_descr_mandatory_t))_",0
    if (src_mand->num_stat_entries != 0),0
"        dest_mand->interface_statistics = g_array_new(FALSE, FALSE, sizeof(wtap_block_t))_",0
        for (j = 0_ j < src_mand->num_stat_entries_ j++),0
"            src_if_stats = g_array_index(src_mand->interface_statistics, wtap_block_t, j)_",0
            dest_if_stats = wtap_block_create(WTAP_BLOCK_IF_STATS)_,0
"            wtap_block_copy(dest_if_stats, src_if_stats)_",0
"            dest_mand->interface_statistics = g_array_append_val(dest_mand->interface_statistics, dest_if_stats)_",0
void wtap_opttypes_initialize(void),0
    static wtap_blocktype_t shb_block = {,0
"        WTAP_BLOCK_NG_SECTION,  /* block_type */",0
"        ""SHB"",                  /* name */",0
"        ""Section Header Block"", /* description */",0
"        shb_create,             /* create */",0
"        NULL,                   /* free_mand */",0
"        shb_copy_mand,          /* copy_mand */",0
        NULL                    /* options */,0
    static wtap_opttype_t shb_hardware = {,0
"        ""hardware"",",0
"        ""SHB Hardware"",",0
"        WTAP_OPTTYPE_STRING,",0
"        0,",0
    static wtap_opttype_t shb_os = {,0
"        ""os"",",0
"        ""SHB Operating System"",",0
    static wtap_opttype_t shb_userappl = {,0
"        ""user_appl"",",0
"        ""SHB User Application"",",0
    static wtap_blocktype_t idb_block = {,0
"        WTAP_BLOCK_IF_DESCR,           /* block_type */",0
"        ""IDB"",                         /* name */",0
"        ""Interface Description Block"", /* description */",0
"        idb_create,                    /* create */",0
"        idb_free_mand,                 /* free_mand */",0
"        idb_copy_mand,                 /* copy_mand */",0
        NULL                           /* options */,0
    static wtap_opttype_t if_name = {,0
"        ""name"",",0
"        ""IDB Name"",",0
    static wtap_opttype_t if_description = {,0
"        ""description"",",0
"        ""IDB Description"",",0
    static wtap_opttype_t if_speed = {,0
"        ""speed"",",0
"        ""IDB Speed"",",0
"        WTAP_OPTTYPE_UINT64,",0
    static wtap_opttype_t if_tsresol = {,0
"        ""tsresol"",",0
"        ""IDB Time Stamp Resolution"",",0
"        WTAP_OPTTYPE_UINT8, /* XXX - signed? */",0
    static wtap_opttype_t if_filter = {,0
"        ""filter"",",0
"        ""IDB Filter"",",0
"        WTAP_OPTTYPE_CUSTOM,",0
        idb_filter_free,0
    static wtap_opttype_t if_os = {,0
"        ""IDB Operating System"",",0
    static wtap_opttype_t if_fcslen = {,0
"        ""fcslen"",",0
"        ""IDB FCS Length"",",0
"        WTAP_OPTTYPE_UINT8,",0
    static wtap_blocktype_t nrb_block = {,0
"        WTAP_BLOCK_NG_NRB,       /* block_type */",0
"        ""NRB"",                   /* name */",0
"        ""Name Resolution Block"", /* description */",0
"        nrb_create,              /* create */",0
"        NULL,                    /* free_mand */",0
"        NULL,                    /* copy_mand */",0
        NULL                     /* options */,0
    static wtap_opttype_t ns_dnsname = {,0
"        ""dnsname"",",0
"        ""NRB DNS server name"",",0
    static wtap_opttype_t ns_dnsIP4addr = {,0
"        ""dnsIP4addr"",",0
"        ""NRB DNS server IPv4 address"",",0
"        WTAP_OPTTYPE_IPv4,",0
    static wtap_opttype_t ns_dnsIP6addr = {,0
"        ""dnsIP6addr"",",0
"        ""NRB DNS server IPv6 address"",",0
"        WTAP_OPTTYPE_IPv6,",0
    static wtap_blocktype_t isb_block = {,0
"        WTAP_BLOCK_IF_STATS,          /* block_type */",0
"        ""ISB"",                        /* name */",0
"        ""Interface Statistics Block"", /* description */",0
"        isb_create,                   /* create */",0
"        NULL,                         /* free_mand */",0
"        isb_copy_mand,                /* copy_mand */",0
        NULL                          /* options */,0
    static wtap_opttype_t isb_starttime = {,0
"        ""starttime"",",0
"        ""ISB Start Time"",",0
    static wtap_opttype_t isb_endtime = {,0
"        ""endtime"",",0
"        ""ISB End Time"",",0
    static wtap_opttype_t isb_ifrecv = {,0
"        ""ifrecv"",",0
"        ""ISB Received Packets"",",0
    static wtap_opttype_t isb_ifdrop = {,0
"        ""ifdrop"",",0
"        ""ISB Dropped Packets"",",0
    static wtap_opttype_t isb_filteraccept = {,0
"        ""filteraccept"",",0
"        ""ISB Packets Accepted By Filter"",",0
    static wtap_opttype_t isb_osdrop = {,0
"        ""osdrop"",",0
"        ""ISB Packets Dropped By The OS"",",0
    static wtap_opttype_t isb_usrdeliv = {,0
"        ""usrdeliv"",",0
"        ""ISB Packets Delivered To The User"",",0
    /* Initialize the custom block array.  This is for future proofing,0
"       ""outside registered"" block types (for NULL checking) */",0
"    memset(blocktype_list, 0, MAX_WTAP_BLOCK_TYPE_VALUE*sizeof(wtap_blocktype_t*))_",0
    num_custom_blocks = 0_,0
     * Registser the SHB and the options that can appear in it.,0
"    wtap_opttype_block_register(WTAP_BLOCK_NG_SECTION, &shb_block)_",0
"    wtap_opttype_option_register(&shb_block, OPT_SHB_HARDWARE, &shb_hardware)_",0
"    wtap_opttype_option_register(&shb_block, OPT_SHB_OS, &shb_os)_",0
"    wtap_opttype_option_register(&shb_block, OPT_SHB_USERAPPL, &shb_userappl)_",0
     * Register the IDB and the options that can appear in it.,0
"    wtap_opttype_block_register(WTAP_BLOCK_IF_DESCR, &idb_block)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_NAME, &if_name)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_DESCR, &if_description)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_SPEED, &if_speed)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_TSRESOL, &if_tsresol)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_FILTER, &if_filter)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_OS, &if_os)_",0
"    wtap_opttype_option_register(&idb_block, OPT_IDB_FCSLEN, &if_fcslen)_",0
     * Register the NRB and the options that can appear in it.,0
"    wtap_opttype_block_register(WTAP_BLOCK_NG_NRB, &nrb_block)_",0
"    wtap_opttype_option_register(&nrb_block, OPT_NS_DNSNAME, &ns_dnsname)_",0
"    wtap_opttype_option_register(&nrb_block, OPT_NS_DNSIP4ADDR, &ns_dnsIP4addr)_",0
"    wtap_opttype_option_register(&nrb_block, OPT_NS_DNSIP6ADDR, &ns_dnsIP6addr)_",0
     * Register the ISB and the options that can appear in it.,0
"    wtap_opttype_block_register(WTAP_BLOCK_IF_STATS, &isb_block)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_STARTTIME, &isb_starttime)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_ENDTIME, &isb_endtime)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_IFRECV, &isb_ifrecv)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_IFDROP, &isb_ifdrop)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_FILTERACCEPT, &isb_filteraccept)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_OSDROP, &isb_osdrop)_",0
"    wtap_opttype_option_register(&isb_block, OPT_ISB_USRDELIV, &isb_usrdeliv)_",0
"    proto_item *len, *type, *segs_",0
"        addr = (const struct e_in6_addr *)tvb_get_ptr(tvb, offset, IPv6_ADDR_SIZE)_",0
"    {&docsis_dpd_subc_assign_range,",0
"    {&docsis_dpd_subc_assign_index,",0
                                      (?:,0
"			{ ""Storm dir"",	""aprs.storm.dir"",",0
"		{ &hf_aprs_storm_spd,",0
"			{ ""Storm sws"",	""aprs.storm.sws"",",0
"			{ ""Storm pwg"",	""aprs.storm.pwg"",",0
"		{ &hf_aprs_storm_cp,",0
"			{ ""Storm rhw"",	""aprs.storm.rhw"",",0
"			{ ""Storm rtsw"",	""aprs.storm.rtsw"",",0
"			{ ""Storm rwg"",	""aprs.storm.rwg"",",0
"		{ ""Subject node name"", ""lat.subject_node_name"", FT_UINT_STRING,",1
"		{ ""Subject port name"", ""lat.subject_port_name"", FT_UINT_STRING,",1
Run 'make all' inside the pidl folder to generate all the dissectors and place,1
"		bSuccess = ReadFile(read_pipe, chBuf, READ_BUFFER, &dwRead, NULL)_",0
"	memcpy(&buffer[bytes_written], ""\0"", 1)_",1
    argv = (gchar **) g_malloc0(sizeof(gchar *) * (argc + 2))_,1
"      FT_UINT8, BASE_DEC, NULL, 0x0,",0
"      FT_UINT8, BASE_DEC, VALS (on_off_vals), 0x0,",0
"    {&hf_docsis_tcm_enabled,",0
	if (!init) {,1
        lrelease $i,0
		if (pref_lapd_sctp_payload_protocol_identifier == 0),0
"	prefs_register_uint_preference(lapd_module, ""sctp_payload_protocol_identifier"",",0
		if (lapd_sctp_payload_protocol_identifier != 0) ,0
        g_assert(fields)_,0
"  {0, NULL},",0
"  {0, ""0.9375 us with 192 samples""},",0
	packet-ocd.c \,0
          THROW (ReportedBoundsError)_,0
static const value_string ecos_flags[] = {,0
"        col_set_writable(pinfo->cinfo, COL_INFO, TRUE)_",0
"            print_escaped_json(pdata->fh, fi->hfinfo->abbrev)_",0
"gboolean check_jsonfilter(const char *jsonfilter, const char *str)",0
"            if(check_protocolfilter(pdata->filter, fi->hfinfo->abbrev)) {",0
    }  /* switch(tlvtype) */,0
        if (type == S7COMM_UD_TYPE_NCREQ && subfunc == S7COMM_NCPRG_FUNCREQUESTDOWNLOAD) {,0
"            proto_tree_add_item(data_tree, hf_s7comm_data_blockcontrol_filename, tvb, offset, dlength, ENC_ASCII|ENC_NA)_",0
        if (pdata->filter != NULL) {,0
#define PNFS_SCSI_EXT_READ_DATA			   1,0
"static const true_false_string tfs_short_long_timeout = { ""Short Timeout"", ""Long Timeout"" }_",0
"        /*update_id =*/ zbee_parse_uint(tree, hf_zbee_zdp_update_id, tvb, &offset, 1, NULL)_",0
"	     (g_ascii_strncasecmp(conv_data->request_method, ""HEAD"", 4) == 0)) &&",1
			path_len = strlen(request_uri) - strlen(query_str)_,1
/* file_util.c,0
" * (Originally part of the Wiretap Library, now part of the Wireshark",0
 *  utility library),0
 * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>,0
 * File wrapper functions to replace the file functions from GLib like,0
 * g_open().,0
" * With MSVC, code using the C support library from one version of MSVC",0
 * cannot use file descriptors or FILE *'s returned from code using,0
 * the C support library from another version of MSVC.,0
" * We therefore provide our own versions of the routines to open files,",0
 * so that they're built to use the same C support library as our code,0
 * that reads them.,0
 * (If both were built to use the Universal CRT:,0
 *    http://blogs.msdn.com/b/vcblog/archive/2015/03/03/introducing-the-universal-crt.aspx,0
 * this would not be a problem.),0
" * DO NOT USE THESE FUNCTIONS DIRECTLY, USE ws_open() AND ALIKE FUNCTIONS",0
 * FROM file_util.h INSTEAD!!!,0
 * The following code is stripped down code copied from the GLib file,0
 * glib/gstdio.h - stripped down because this is used only on Windows,0
 * and we use only wide char functions.,0
" * In addition, we have our own ws_stdio_stat64(), which uses",0
" * _wstati64(), so that we can get file sizes for files > 4 GB in size.",0
 * XXX - is there any reason why we supply our own versions of routines,0
" * that *don't* return file descriptors, other than ws_stdio_stat64()?",0
 * Is there an issue with UTF-16 support in _wmkdir() with some versions,0
" * of the C runtime, so that if GLib is built to use that version, it",0
 * won't handle UTF-16 paths?,0
"#error ""This is only for Windows""",0
#include <wchar.h>,0
#include <tchar.h>,0
"#include ""file_util.h""",0
static gchar *program_path = NULL_,0
static gchar *system_path = NULL_,0
static gchar *npcap_path = NULL_,0
 * g_open:,0
 * @filename: a pathname in the GLib file name encoding (UTF-8 on Windows),0
 * @flags: as in open(),0
 * @mode: as in open(),0
 * A wrapper for the POSIX open() function. The open() function is,0
 * used to convert a pathname into a file descriptor. Note that on,0
 * POSIX systems file descriptors are implemented by the operating,0
" * system. On Windows, it's the C library that implements open() and",0
 * file descriptors. The actual Windows API for opening files is,0
 * something different.,0
 * See the C library manual for more details about open().,0
" * Returns: a new file descriptor, or -1 if an error occurred. The",0
 * return value can be used exactly like the return value from open().,0
 * Since: 2.6,0
"ws_stdio_open (const gchar *filename,",0
"        int          flags,",0
        int          mode),0
"      wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL)_",0
      int retval_,0
      int save_errno_,0
      if (wfilename == NULL),0
          errno = EINVAL_,0
          return -1_,0
"      retval = _wopen (wfilename, flags, mode)_",0
      save_errno = errno_,0
      g_free (wfilename)_,0
      errno = save_errno_,0
      return retval_,0
 * g_rename:,0
 * @oldfilename: a pathname in the GLib file name encoding (UTF-8 on Windows),0
 * @newfilename: a pathname in the GLib file name encoding,0
 * A wrapper for the POSIX rename() function. The rename() function,0
" * renames a file, moving it between directories if required.",0
 * See your C library manual for more details about how rename() works,0
 * on your system. Note in particular that on Win9x it is not possible,0
 * to rename a file if a file with the new name already exists. Also,0
 * it is not possible in general on Windows to rename an open file.,0
" * Returns: 0 if the renaming succeeded, -1 if an error occurred",0
"ws_stdio_rename (const gchar *oldfilename,",0
          const gchar *newfilename),0
"      wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL)_",0
      wchar_t *wnewfilename_,0
      int save_errno = 0_,0
      if (woldfilename == NULL),0
"      wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL)_",0
      if (wnewfilename == NULL),0
          g_free (woldfilename)_,0
"      if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))",0
        retval = 0_,0
          retval = -1_,0
          switch (GetLastError ()),0
"#define CASE(a,b) case ERROR_##a: save_errno = b_ break",0
"            CASE (FILE_NOT_FOUND, ENOENT)_",0
"            CASE (PATH_NOT_FOUND, ENOENT)_",0
"            CASE (ACCESS_DENIED, EACCES)_",0
"            CASE (NOT_SAME_DEVICE, EXDEV)_",0
"            CASE (LOCK_VIOLATION, EACCES)_",0
"            CASE (SHARING_VIOLATION, EACCES)_",0
"            CASE (FILE_EXISTS, EEXIST)_",0
"            CASE (ALREADY_EXISTS, EEXIST)_",0
#undef CASE,0
            default: save_errno = EIO_,0
      g_free (woldfilename)_,0
      g_free (wnewfilename)_,0
 * g_mkdir:,0
 * @mode: permissions to use for the newly created directory,0
 * A wrapper for the POSIX mkdir() function. The mkdir() function,0
 * attempts to create a directory with the given name and permissions.,0
 * See the C library manual for more details about mkdir().,0
" * Returns: 0 if the directory was successfully created, -1 if an error",0
 *    occurred,0
"ws_stdio_mkdir (const gchar *filename,",0
         int          mode),0
      retval = _wmkdir (wfilename)_,0
 * g_stat:,0
" * @buf: a pointer to a <structname>stat</structname> struct, which",0
 *    will be filled with the file information,0
 * A wrapper for the POSIX stat() function. The stat() function,0
 * returns information about a file.,0
 * See the C library manual for more details about stat().,0
" * Returns: 0 if the information was successfully retrieved, -1 if an error",0
"ws_stdio_stat64 (const gchar *filename,",0
        ws_statb64 *buf),0
      size_t len_,0
      len = wcslen (wfilename)_,0
      while (len > 0 && G_IS_DIR_SEPARATOR (wfilename[len-1])),0
        len--_,0
      if (len > 0 &&,0
          (!g_path_is_absolute (filename) || len > (size_t) (g_path_skip_root (filename) - filename))),0
        wfilename[len] = '\0'_,0
"      retval = _wstati64 (wfilename, buf)_",0
 * g_unlink:,0
 * A wrapper for the POSIX unlink() function. The unlink() function,0
 * deletes a name from the filesystem. If this was the last link to the,0
" * file and no processes have it opened, the diskspace occupied by the",0
 * file is freed.,0
 * See your C library manual for more details about unlink(). Note,0
" * that on Windows, it is in general not possible to delete files that",0
" * are open to some process, or mapped into memory.",0
" * Returns: 0 if the name was successfully deleted, -1 if an error",0
ws_stdio_unlink (const gchar *filename),0
      retval = _wunlink (wfilename)_,0
 * g_remove:,0
 * A wrapper for the POSIX remove() function. The remove() function,0
 * deletes a name from the filesystem.,0
 * See your C library manual for more details about how remove() works,0
" * on your system. On Unix, remove() removes also directories, as it",0
" * calls unlink() for files and rmdir() for directories. On Windows,",0
" * although remove() in the C library only works for files, this",0
" * function tries first remove() and then if that fails rmdir(), and",0
" * thus works for both files and directories. Note however, that on",0
" * Windows, it is in general not possible to remove a file that is",0
" * open to some process, or mapped into memory.",0
 * If this function fails on Windows you can't infer too much from the,0
 * errno value. rmdir() is tried regardless of what caused remove() to,0
 * fail. Any errno value set by remove() will be overwritten by that,0
 * set by rmdir().,0
" * Returns: 0 if the file was successfully removed, -1 if an error",0
ws_stdio_remove (const gchar *filename),0
      retval = _wremove (wfilename)_,0
      if (retval == -1),0
        retval = _wrmdir (wfilename)_,0
 * g_fopen:,0
 * @mode: a string describing the mode in which the file should be,0
 *   opened,0
 * A wrapper for the POSIX fopen() function. The fopen() function opens,0
 * a file and associates a new stream with it.,0
 * See the C library manual for more details about fopen().,0
 * Returns: A <type>FILE</type> pointer if the file was successfully,0
" *    opened, or %NULL if an error occurred",0
FILE *,0
"ws_stdio_fopen (const gchar *filename,",0
         const gchar *mode),0
      wchar_t *wmode_,0
      FILE *retval_,0
"      wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL)_",0
      if (wmode == NULL),0
          g_free (wfilename)_,0
"      retval = _wfopen (wfilename, wmode)_",0
      g_free (wmode)_,0
 * g_freopen:,0
" * @stream: an existing stream which will be reused, or %NULL",0
 * A wrapper for the POSIX freopen() function. The freopen() function,0
 * opens a file and associates it with an existing stream.,0
 * See the C library manual for more details about freopen().,0
" *    opened, or %NULL if an error occurred.",0
"ws_stdio_freopen (const gchar *filename,",0
"           const gchar *mode,",0
           FILE        *stream),0
"      retval = _wfreopen (wfilename, wmode, stream)_",0
/* DLL loading */,0
init_dll_load_paths(),0
      TCHAR path_w[MAX_PATH]_,0
      if (program_path && system_path && npcap_path),0
      /* XXX - Duplicate code in filesystem.c:init_progfile_dir */,0
"      if (GetModuleFileName(NULL, path_w, MAX_PATH) == 0 || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {",0
      if (!program_path) {,0
            gchar *app_path_,0
"            app_path = g_utf16_to_utf8(path_w, -1, NULL, NULL, NULL)_",0
            /* We could use PathRemoveFileSpec here but we'd have to link to Shlwapi.dll */,0
            program_path = g_path_get_dirname(app_path)_,0
            g_free(app_path)_,0
"      if (GetSystemDirectory(path_w, MAX_PATH) == 0) {",0
      if (!system_path) {,0
"            system_path = g_utf16_to_utf8(path_w, -1, NULL, NULL, NULL)_",0
"      _tcscat_s(path_w, MAX_PATH, _T(""\\Npcap""))_",0
      if (!npcap_path) {,0
"            npcap_path = g_utf16_to_utf8(path_w, -1, NULL, NULL, NULL)_",0
      return FALSE_,0
ws_init_dll_search_path(),0
      gboolean dll_dir_set = FALSE_,0
      wchar_t *program_path_w_,0
      TCHAR npcap_path_w[MAX_PATH]_,0
      typedef BOOL (WINAPI *SetDllDirectoryHandler)(LPCTSTR)_,0
      SetDllDirectoryHandler PSetDllDirectory_,0
"      PSetDllDirectory = (SetDllDirectoryHandler) GetProcAddress(GetModuleHandle(_T(""kernel32.dll"")), ""SetDllDirectoryW"")_",0
      if (PSetDllDirectory) {,0
"            if (GetSystemDirectory(npcap_path_w, MAX_PATH) == 0) {",0
"                  dll_dir_set = PSetDllDirectory(_T(""""))_",0
"                  _tcscat_s(npcap_path_w, MAX_PATH, _T(""\\Npcap""))_",0
                  dll_dir_set = PSetDllDirectory(npcap_path_w)_,0
      if (!dll_dir_set && init_dll_load_paths()) {,0
"            program_path_w = g_utf8_to_utf16(program_path, -1, NULL, NULL, NULL)_",0
            SetCurrentDirectory(program_path_w)_,0
            g_free(program_path_w)_,0
      return dll_dir_set_,0
 * Internally g_module_open uses LoadLibrary on Windows and returns an,0
 * HMODULE cast to a GModule *. However there's no guarantee that this,0
" * will always be the case, so we call LoadLibrary and g_module_open",0
 * separately.,0
void *,0
ws_load_library(const gchar *library_name),0
      gchar   *full_path_,0
      wchar_t *full_path_w_,0
      HMODULE  dll_h_,0
      if (!init_dll_load_paths() || !library_name),0
      /* First try the program directory */,0
"      full_path = g_module_build_path(program_path, library_name)_",0
"      full_path_w = g_utf8_to_utf16(full_path, -1, NULL, NULL, NULL)_",0
      if (full_path && full_path_w) {,0
            dll_h = LoadLibraryW(full_path_w)_,0
            if (dll_h) {,0
                  g_free(full_path)_,0
                  g_free(full_path_w)_,0
                  return dll_h_,0
      /* Next try the system directory */,0
"      full_path = g_module_build_path(system_path, library_name)_",0
GModule *,0
"ws_module_open(gchar *module_name, GModuleFlags flags)",0
      GModule *mod_,0
      if (!init_dll_load_paths() || !module_name),0
"      full_path = g_module_build_path(program_path, module_name)_",0
      if (full_path) {,0
"            mod = g_module_open(full_path, flags)_",0
            if (mod) {,0
                  return mod_,0
"      full_path = g_module_build_path(system_path, module_name)_",0
      /* At last try the Npcap directory */,0
"      full_path = g_module_build_path(npcap_path, module_name)_",0
"/** Create or open a ""Wireshark is running"" mutex.",0
"#define WIRESHARK_IS_RUNNING_UUID ""9CA78EEA-EA4D-4490-9240-FC01FCEF464B""",0
static SECURITY_ATTRIBUTES *sec_attributes__,0
void create_app_running_mutex() {,0
      SECURITY_ATTRIBUTES *sa = NULL_,0
"      if (!sec_attributes_) sec_attributes_ = g_new0(SECURITY_ATTRIBUTES, 1)_",0
      sec_attributes_->nLength = sizeof(SECURITY_ATTRIBUTES)_,0
"      sec_attributes_->lpSecurityDescriptor = g_new0(SECURITY_DESCRIPTOR, 1)_",0
      sec_attributes_->bInheritHandle = TRUE_,0
"      if (InitializeSecurityDescriptor(sec_attributes_->lpSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION)) {",0
"            if (SetSecurityDescriptorDacl(sec_attributes_->lpSecurityDescriptor, TRUE, NULL, FALSE)) {",0
                  sa = sec_attributes__,0
      if (!sa) {,0
            g_free(sec_attributes_->lpSecurityDescriptor)_,0
            g_free(sec_attributes_)_,0
            sec_attributes_ = NULL_,0
"      CreateMutex(sa, FALSE, _T(""Wireshark-is-running-{"") _T(WIRESHARK_IS_RUNNING_UUID) _T(""}""))_",0
"      CreateMutex(sa, FALSE, _T(""Global\\Wireshark-is-running-{"") _T(WIRESHARK_IS_RUNNING_UUID) _T(""}""))_",0
 * c-basic-offset: 6,0
 * vi: set shiftwidth=6 tabstop=8 expandtab:,0
 * :indentSize=6:tabSize=8:noTabs=true:,0
//VN related defines,0
"    ti = proto_tree_add_uint_format(juniper_subtree,",0
"  ti = proto_tree_add_text(tree, tvb, offset, 20,",0
"              proto_tree_add_ipv4(juniper_subtree, hf_juniper_vn_host_ip, tvb,",0
"              proto_tree_add_text(juniper_subtree, tvb, offset, tlv_len,",0
"              proto_tree_add_text(juniper_subtree, tvb, 0, 0, ""Incorrect format"")_",0
"    &ett_juniper_vn_flags,",0
        /* WTAP_ENCAP_IP_OVER_IB_PCAP */,0
"static void dissect_juniper_vn_flags(proto_tree *tree, tvbuff_t* tvb, gint offset, gint tlv_len _U_)",0
		&hf_lsarpc_lsa_PolicyAccessMask_LSA_POLICY_VIEW_LOCAL_INFORMATION,0
    codec_register_plugin_types()_ /* Types known to libwscodecs */,0
"	plugin = (tap_plugin *)wmem_alloc(NULL, sizeof(tap_plugin))_",1
  epan_register_plugin_types()_ /* Types known to libwireshark */,1
	if (!tap_plugins),1
"	td=(tap_dissector_t *)wmem_alloc(NULL, sizeof(tap_dissector_t))_",1
"	tl=(volatile tap_listener_t *)wmem_alloc0(NULL, sizeof(tap_listener_t))_",1
"WS_DLL_PUBLIC gchar *register_tap_listener(const char *tapname, void *tapdata,",1
	DISSECTOR_ASSERT(transfer_conv)_,0
  map of nearby packets.,1
            goto dissect_zbee_aps_interpan_,0
"    memset(&default_filter, 0, sizeof(default_filter))_",0
    wdh->bytes_dumped += sizeof bh_,0
"            col_set_writable(pinfo->cinfo, COL_PROTOCOL, TRUE)_",0
    if (wimaxasncp_dict == NULL),1
"    tap_queue_packet(dns_tap, pinfo, dns_stats)_",0
